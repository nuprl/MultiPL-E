language: go_test.go
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzetti_1_test.go:92:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Split(word,\
    \ \"-\")[0])\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    for\
    \ _, v := range vowels {\n        if strings.Contains(word, v) {\n           \
    \ vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n        return \"\
    \"\n    }\n    vowelsCount -= len(word) - len(strings.Split(word, \"-\")[1])\n\
    \    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    for _, v := range\
    \ vowels {\n        if strings.Contains(word, v) {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount > 0 {\n        return \"\"\n    }\n    return\
    \ word\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw6l1mqpg_test.go:18:12: undefined: strings

    /tmp/tmpw6l1mqpg_test.go:25:36: undefined: strings

    /tmp/tmpw6l1mqpg_test.go:30:12: undefined: strings

    /tmp/tmpw6l1mqpg_test.go:37:36: undefined: strings

    /tmp/tmpw6l1mqpg_test.go:42:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range word {\n \
    \       if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n      \
    \      vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n        for\
    \ _, v := range word {\n            if v == 'a' || v == 'e' || v == 'i' || v ==\
    \ 'o' || v == 'u' {\n                return word\n            }\n        }\n \
    \   }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvpnaw8uc_test.go:16:5: vowels declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range word {\n \
    \       if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n      \
    \      vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n        vowelsCount\
    \ -= 1\n    }\n    if vowelsCount < 0 {\n        vowelsCount += 1\n    }\n   \
    \ vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpqhevex9a_test.go:59: expected 'u', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpqhevex9a_test.go:59: expected\
    \ 'u', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n    \
    \    tmpqhevex9a_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpqhevex9a_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpqhevex9a_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n     \
    \   tmpqhevex9a_test.go:59: expected 'o', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpqhevex9a_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpqhevex9a_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpqhevex9a_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpqhevex9a_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpqhevex9a_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpqhevex9a_test.go:59: expected 'o', got 'a'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string\n    vowels = append(vowels, \"a\"\
    , \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\"\
    , \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels\
    \ = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpff1kxik1_test.go:47:39: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range word {\n \
    \       if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n      \
    \      vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 2\n    i := len(word) - 1\n    for {\n     \
    \   if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u' {\n            vowelsCount++\n        }\n        if i == 0 {\n\
    \            break\n        }\n        i--\n    }\n    if vowelsCount < 2 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    i := len(word) - 1\n  \
    \  for {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            vowelsCount++\n        }\n        if\
    \ i == 0 {\n            break\n        }\n        i--\n    }\n    if vowelsCount\
    \ < 2 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    i := len(word)\
    \ - 1\n    for {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n        }\n\
    \        if i == 0 {\n            break\n        }\n        i--\n    }\n    if\
    \ vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    i :=\
    \ len(word) - 1\n    for {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n  \
    \      }\n        if i == 0 {\n            break\n        }\n        i--\n   \
    \ }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount -=\
    \ 2\n    i := len(word) - 1\n    for {\n        if word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n\
    \        }\n        if i == 0 {\n            break\n        }\n        i--\n \
    \   }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount -=\
    \ 2\n    i := len(word) - 1\n    for {\n        if word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i]\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpodmxfx6h_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            if vowelsCount > 0 {\n             \
    \   vowelsCount--\n                return word[i]\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqa4zm8ve_test.go:32:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n\
    \    vowelsCount += 2\n    lastVowel := strings.LastIndex(word, vowels[vowelsCount])\n\
    \    if lastVowel == -1 {\n        return \"\"\n    }\n    return word[lastVowel+len(vowels[vowelsCount])]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4o9ojzcc_test.go:18:12: undefined: strings

    /tmp/tmp4o9ojzcc_test.go:28:18: undefined: strings

    /tmp/tmp4o9ojzcc_test.go:32:12: cannot use word[lastVowel + len(vowels[vowelsCount])]
    (value of type byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjdwb9inx_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    for _, char := range word {\n        if char\
    \ == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n     \
    \       vowel_count++\n        }\n    }\n    if vowel_count > 0 {\n        for\
    \ _, char := range word {\n            if char == 'a' || char == 'e' || char ==\
    \ 'i' || char == 'o' || char == 'u' {\n                vowel_count--\n       \
    \     }\n        }\n    }\n    if vowel_count < 0 {\n        return \"\"\n   \
    \ }\n    vowel_count := 0\n    vowel_count := 0\n    for _, char := range word\
    \ {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char\
    \ == 'u' {\n            vowel_count++\n        }\n    }\n    if vowel_count >\
    \ 0 {\n        for _, char := range word {\n            if char == 'a' || char\
    \ == 'e' || char == 'i' || char == 'o' || char == 'u' {\n                vowel_count--\n\
    \            }\n        }\n    }\n    if vowel_count < 0 {\n        return \"\"\
    \n    }\n    vowel_count := 0\n    vowel_count := 0\n    for _, char := range\
    \ word {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o'\
    \ || char == 'u' {\n            vowel_count++\n        }\n    }\n    if vowel_count\
    \ > 0 {\n        for _, char := range word {\n            if char == 'a' || char\
    \ == 'e' || char == 'i' || char == 'o' || char == 'u' {\n                vowel_count--\n\
    \            }\n        }\n    }\n    if vowel_count < 0 {\n        return \"\"\
    \n    }\n    vowel_count := 0\n    vowel_count := 0\n    for _, char := range\
    \ word {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o'\
    \ || char == 'u' {\n            vowel_count++\n        }\n    }\n    if vowel_count\
    \ > 0 {\n        for _, char := range word {\n            if char == 'a' || char\
    \ == 'e' || char == 'i' || char == 'o' || char == 'u' {\n                vowel_count--\n\
    \            }\n        }\n    }\n    if vowel_count < 0 {\n        return \"\"\
    \n    }\n    vowel_count := 0\n    vowel_count := 0\n    for _, char := range\
    \ word {\n        if char == 'a' || char == 'e' || char == 'i' || \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5i29a_tn_test.go:88:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string\n    vowels = append(vowels, \"a\"\
    , \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\"\
    , \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels\
    \ = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdzoslid__test.go:47:39: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            if vowelsCount > 0 {\n                vowelsCount--\n       \
    \         return word[i]\n            }\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpml0ltx6p_test.go:31:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n        if vowelsCount >= len(vowels) {\n            return word[i]\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp244t63mq_test.go:23:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels {\n\
    \        if strings.Contains(word, v) {\n            vowelsCount++\n        }\n\
    \    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxx1j7ae6_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfu1cepfr_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowels\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkp_wrw38_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzetti_1_test.go:92:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowelsCount %= len(vowels)\n    vowelsCount += 1\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowelsCount %= len(vowels)\n    vowelsCount += 1\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowelsCount %= len(vowels)\n    vowelsCount += 1\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowelsCount %= len(vowels)\n    vowelsCount += 1\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowelsCount %= len(vowels)\n    vowelsCount += 1\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowelsCount %= len(vowels)\n    vowelsCount += 1\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowelsCount %= len(vowels)\n    vowelsCount += 1\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowelsCount %= len(vowels)\n    vowelsCount += 1\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowelsCount %= len(vowels)\n    vowelsCount += 1\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 1\n    vowels\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_mh3k_h6_test.go:86:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    i := len(word) - 1\n    \n    for i >= 0 {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            i -= vowelsLen\n        } else {\n            i -= 1\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpjcorf1dm_test.go:58: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpjcorf1dm_test.go:58: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpjcorf1dm_test.go:58: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpjcorf1dm_test.go:58: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpjcorf1dm_test.go:58:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpjcorf1dm_test.go:58: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels {\n\
    \        if strings.Contains(word, v) {\n            vowelsCount++\n        }\n\
    \    }\n    if vowelsCount > 0 {\n        vowelsCount -= 1\n    }\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount += 1\n    vowelsCount += 2\n    vowelsCount +=\
    \ 3\n    vowelsCount += 4\n    vowelsCount += 5\n    vowelsCount += 6\n    vowelsCount\
    \ += 7\n    vowelsCount += 8\n    vowelsCount += 9\n    vowelsCount += 10\n  \
    \  vowelsCount += 11\n    vowelsCount += 12\n    vowelsCount += 13\n    vowelsCount\
    \ += 14\n    vowelsCount += 15\n    vowelsCount += 16\n    vowelsCount += 17\n\
    \    vowelsCount += 18\n    vowelsCount += 19\n    vowelsCount += 20\n    vowelsCount\
    \ += 21\n    vowelsCount += 22\n    vowelsCount += 23\n    vowelsCount += 24\n\
    \    vowelsCount += 25\n    vowelsCount += 26\n    vowelsCount += 27\n    vowelsCount\
    \ += 28\n    vowelsCount += 29\n    vowelsCount += 30\n    vowelsCount += 31\n\
    \    vowelsCount += 32\n    vowelsCount += 33\n    vowelsCount += 34\n    vowelsCount\
    \ += 35\n    vowelsCount += 36\n    vowelsCount += 37\n    vowelsCount += 38\n\
    \    vowelsCount += 39\n    vowelsCount += 40\n    vowelsCount += 41\n    vowelsCount\
    \ += 42\n    vowelsCount += 43\n    vowelsCount += 44\n    vowelsCount += 45\n\
    \    vowelsCount += 46\n    vowelsCount += 47\n    vowelsCount += 48\n    vowelsCount\
    \ += 49\n    vowelsCount += 50\n    vowelsCount += 51\n    vowelsCount += 52\n\
    \    vowelsCount += 53\n    vowelsCount += 54\n    vowelsCount += 55\n    vowelsCount\
    \ += 56\n    vowelsCount += 57\n    vowelsCount += 58\n    vowelsCount += 59\n\
    \    vowelsCount \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpamut8c88_test.go:92:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string = []string{\"a\", \"e\", \"i\", \"\
    o\", \"u\"}\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}...)\n    vowels = append(vowels, []string{\"a\", \"e\", \"i\", \"\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqqtoepwh_test.go:40:53: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbzrqf4tk_test.go:80:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Split(word,\
    \ \"_\"))\n    if vowelsCount < 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ /= 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)\
    \ - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount > len(vowels)-1 {\n   \
    \     vowelsCount = len(vowels) - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels) - 1\n    }\n    vowelsCount\
    \ /= 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)\
    \ - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount > len(vowels)-1 {\n   \
    \     vowelsCount = len(vowels) - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels) - 1\n    }\n    vowelsCount\
    \ /= 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)\
    \ - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount > len(vowels)-1 {\n   \
    \     vowelsCount = len(vowels) - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels) - 1\n    }\n    vowelsCount\
    \ /= 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)\
    \ - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount > len(vowels)-1 {\n   \
    \     vowelsCount = len(vowels) - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels) - 1\n    }\n    vowelsCount\
    \ /= 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)\
    \ - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount > len(vowels)-1 {\n   \
    \     vowelsCount = len(vowels) - 1\n    }\n    vowelsCount /= 2\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels) - 1\n    }\n    vowel\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmh54v42g_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0smpeju9_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    lastConsonant := false\n\
    \    for _, v := range vowels {\n        if strings.Contains(word, v) {\n    \
    \        vowelsCount++\n            lastConsonant = true\n        }\n    }\n \
    \   if lastConsonant {\n        return \"\"\n    }\n    lastConsonant = false\n\
    \    for _, v := range vowels {\n        if strings.Contains(word, v) {\n    \
    \        vowelsCount++\n            lastConsonant = true\n        }\n    }\n \
    \   if lastConsonant {\n        return \"\"\n    }\n    lastConsonant = false\n\
    \    for _, v := range vowels {\n        if strings.Contains(word, v) {\n    \
    \        vowelsCount++\n            lastConsonant = true\n        }\n    }\n \
    \   if lastConsonant {\n        return \"\"\n    }\n    lastConsonant = false\n\
    \    for _, v := range vowels {\n        if strings.Contains(word, v) {\n    \
    \        vowelsCount++\n            lastConsonant = true\n        }\n    }\n \
    \   if lastConsonant {\n        return \"\"\n    }\n    lastConsonant = false\n\
    \    for _, v := range vowels {\n        if strings.Contains(word, v) {\n    \
    \        vowelsCount++\n            lastConsonant = true\n        }\n    }\n \
    \   if lastConsonant {\n        return \"\"\n    }\n    lastConsonant = false\n\
    \    for _, v := range vowels {\n        if strings.Contains(word, v) {\n    \
    \        vowelsCount++\n            lastConsonant = true\n        }\n    }\n \
    \   if lastConsonant {\n        return \"\"\n    }\n    lastConsonant = false\n\
    \    for _, v := range vowels {\n        if strings.Contains(word, v) {\n    \
    \        vowelsCount++\n            lastConsonant = true\n        }\n    }\n \
    \   if lastConsonant {\n        return \"\"\n    }\n    lastConsonant = false\n\
    \    for _, v := range vowels {\n        if strings.Contains(word, v) {\n    \
    \        vowelsCount++\n            lastConsonant = true\n        }\n    }\n \
    \   if lastConsonant {\n        return \"\"\n    }\n    lastConsonant = false\n\
    \    for _, v := range vowels {\n        if strings.Contains(word, v) {\n    \
    \        vowelsCount++\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc86o_t3u_test.go:111:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzetti_1_test.go:92:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string\n    vowels = append(vowels, \"a\"\
    , \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\"\
    , \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels\
    \ = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdzoslid__test.go:47:39: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    vowelsCount += len(vowels)\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == \"a\" || word[i]\
    \ == \"e\" || word[i] == \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n   \
    \         vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9s9qx69o_test.go:20:23: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmp9s9qx69o_test.go:20:41: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmp9s9qx69o_test.go:20:59: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmp9s9qx69o_test.go:20:77: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmp9s9qx69o_test.go:20:95: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzetti_1_test.go:92:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count += len(word) - len(word[:len(word)-1])\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == vowel[vowel_count] {\n           \
    \ vowel_count++\n        }\n    }\n    if vowel_count == 0 {\n        return \"\
    \"\n    }\n    return word[len(word)-vowel_count]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_j8blbrt_test.go:19:23: invalid operation: word[i] == vowel[vowel_count]
    (mismatched types byte and rune)

    /tmp/tmp_j8blbrt_test.go:26:12: cannot use word[len(word) - vowel_count] (value
    of type byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount += len(word) - len(strings.Split(word,\
    \ \"_\"))\n    vowelsCount -= len(strings.Split(word, \"-\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \".\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"!\"))\n    vowelsCount -= len(strings.Split(word, \"?\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \";\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \":\"))\n    vowelsCount -= len(strings.Split(word, \"/\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"\\\\\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"|\"))\n    vowelsCount -= len(strings.Split(word, \"%\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"$\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"&\"))\n    vowelsCount -= len(strings.Split(word, \"*\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"(\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \")\"))\n    vowelsCount -= len(strings.Split(word, \"+\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"=\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"<\"))\n    vowelsCount -= len(strings.Split(word, \">\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"?\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"!\"))\n    vowelsCount -= len(strings.Split(word, \".\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"-\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"/\"))\n    vowelsCount -= len(strings.Split(word, \"\\\\\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"|\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"%\"))\n    vowelsCount -= len(strings.Split(word, \"$\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"&\"))\n    vowelsCount -= len(\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7sfudl4t_test.go:59:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpj7u916_5_test.go:57: expected 'u', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpj7u916_5_test.go:57: expected\
    \ 'u', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n    \
    \    tmpj7u916_5_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpj7u916_5_test.go:57: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpj7u916_5_test.go:57: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpj7u916_5_test.go:57: expected 'a', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpj7u916_5_test.go:57: expected 'o', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpj7u916_5_test.go:57: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpj7u916_5_test.go:57: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpj7u916_5_test.go:57: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpj7u916_5_test.go:57:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpj7u916_5_test.go:57: expected 'o', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfu1cepfr_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"a\", \"A\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"e\", \"E\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"i\", \"I\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"o\", \"O\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"u\", \"U\", -1))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n\
    \    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels) - 1\n\
    \    }\n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgio2dddo_test.go:18:12: undefined: strings

    /tmp/tmpgio2dddo_test.go:25:36: undefined: strings

    /tmp/tmpgio2dddo_test.go:26:36: undefined: strings

    /tmp/tmpgio2dddo_test.go:27:36: undefined: strings

    /tmp/tmpgio2dddo_test.go:28:36: undefined: strings

    /tmp/tmpgio2dddo_test.go:29:36: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0smpeju9_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptuxg7i0__test.go:76:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Split(word,\
    \ \"e\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"i\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"o\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"u\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"a\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"e\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"i\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"o\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"u\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"a\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"e\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"i\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"o\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"u\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"a\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"e\"))\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3mb4xu6t_test.go:86:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphxp7507d_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for i := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(word[i],\
    \ \"a\") {\n            vowelsCount--\n        }\n        if strings.Contains(word[i],\
    \ \"e\") {\n            vowelsCount--\n        }\n        if strings.Contains(word[i],\
    \ \"i\") {\n            vowelsCount--\n        }\n        if strings.Contains(word[i],\
    \ \"o\") {\n            vowelsCount--\n        }\n        if strings.Contains(word[i],\
    \ \"u\") {\n            vowelsCount--\n        }\n        if vowelsCount < 0 {\n\
    \            return \"\"\n        }\n    }\n    return word[len(word)-1]\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl0494axi_test.go:19:12: undefined: strings

    /tmp/tmpl0494axi_test.go:28:12: undefined: strings

    /tmp/tmpl0494axi_test.go:31:12: undefined: strings

    /tmp/tmpl0494axi_test.go:34:12: undefined: strings

    /tmp/tmpl0494axi_test.go:37:12: undefined: strings

    /tmp/tmpl0494axi_test.go:40:12: undefined: strings

    /tmp/tmpl0494axi_test.go:47:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074864
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr_t9t1jc_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo87z6xrj_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsMap := make(map[string]bool)\n    for _, v := range vowels\
    \ {\n        vowelsMap[v] = true\n    }\n    \n    vowelsMap := make(map[string]bool)\n\
    \    for _, v := range vowels {\n        vowelsMap[v] = true\n    }\n    \n  \
    \  vowelsMap := make(map[string]bool)\n    for _, v := range vowels {\n      \
    \  vowelsMap[v] = true\n    }\n    \n    vowelsMap := make(map[string]bool)\n\
    \    for _, v := range vowels {\n        vowelsMap[v] = true\n    }\n    \n  \
    \  vowelsMap := make(map[string]bool)\n    for _, v := range vowels {\n      \
    \  vowelsMap[v] = true\n    }\n    \n    vowelsMap := make(map[string]bool)\n\
    \    for _, v := range vowels {\n        vowelsMap[v] = true\n    }\n    \n  \
    \  vowelsMap := make(map[string]bool)\n    for _, v := range vowels {\n      \
    \  vowelsMap[v] = true\n    }\n    \n    vowelsMap := make(map[string]bool)\n\
    \    for _, v := range vowels {\n        vowelsMap[v] = true\n    }\n    \n  \
    \  vowelsMap := make(map[string]bool)\n    for _, v := range vowels {\n      \
    \  vowelsMap[v] = true\n    }\n    \n    vowelsMap := make(map[string]bool)\n\
    \    for _, v := range vowels {\n        vowelsMap[v] = true\n    }\n    \n  \
    \  vowelsMap := make(map[string]bool)\n    for _, v := range vowels {\n      \
    \  vowelsMap[v] = true\n    }\n    \n    vowelsMap := make(map[string]bool)\n\
    \    for _, v := range vowels {\n        vowelsMap[v] = true\n    }\n    \n  \
    \  vowelsMap := make(map[string]bool)\n    for _, v := range vowels {\n      \
    \  vowelsMap[v] = true\n    }\n    \n    vowelsMap := make(map[string]bool)\n\
    \    for _, v := range vowels {\n        vowelsMap[v] = true\n    }\n    \n  \
    \  vowelsMap := make(map[string]bool)\n    for _, v := \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf_wq9uyy_test.go:93:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == \"a\" || word[i] == \"e\" || word[i]\
    \ == \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n\
    \    vowelsCount -= len(vowels)\n    vowelsCount -= len(vowels)\n    vowelsCount\
    \ -= len(vowels)\n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphg6yh88__test.go:73:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowel_count := 0\n    vowel_count += len(vowel)\n    for i := len(word) -\
    \ 1; i >= 0; i-- {\n        if word[i] == \"a\" || word[i] == \"e\" || word[i]\
    \ == \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n            vowel_count--\n\
    \        }\n        if vowel_count == 0 {\n            return word\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpistk826__test.go:19:23: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpistk826__test.go:19:41: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpistk826__test.go:19:59: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpistk826__test.go:19:77: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpistk826__test.go:19:95: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n   \
    \ vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount\
    \ /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n   \
    \ vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount\
    \ += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n   \
    \ vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount\
    \ /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n   \
    \ vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount\
    \ += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n   \
    \ vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount\
    \ /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n   \
    \ vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount\
    \ += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n   \
    \ vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount\
    \ /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n   \
    \ vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount\
    \ += 2\n    vowelsCount /= 2\n    vowelsCount += 2\n    vowelsCount /= 2\n   \
    \ vowelsCount += 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ocwyf3c_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_found := false\n    vowel_start := 0\n    vowel_end := len(word)\
    \ - 1\n    vowel_found := false\n    for i := 0; i < len(word); i++ {\n      \
    \  if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u' {\n            vowel_found = true\n            vowel_start =\
    \ i\n        }\n        if word[i] == word[i+1] {\n            vowel_found = true\n\
    \            vowel_end = i\n        }\n        if vowel_found {\n            vowel_count++\n\
    \        }\n    }\n    if vowel_count == 0 {\n        return \"\"\n    }\n   \
    \ if vowel_count == 1 {\n        return word[vowel_start]\n    }\n    if vowel_count\
    \ == 2 {\n        return word[vowel_start]\n    }\n    if vowel_count == 3 {\n\
    \        return word[vowel_start]\n    }\n    if vowel_count == 4 {\n        return\
    \ word[vowel_start]\n    }\n    if vowel_count == 5 {\n        return word[vowel_start]\n\
    \    }\n    if vowel_count == 6 {\n        return word[vowel_start]\n    }\n \
    \   if vowel_count == 7 {\n        return word[vowel_start]\n    }\n    if vowel_count\
    \ == 8 {\n        return word[vowel_start]\n    }\n    if vowel_count == 9 {\n\
    \        return word[vowel_start]\n    }\n    if vowel_count == 10 {\n       \
    \ return word[vowel_start]\n    }\n    if vowel_count == 11 {\n        return\
    \ word[vowel_start]\n    }\n    if vowel_count == 12 {\n        return word[vowel_start]\n\
    \    }\n    if vowel_count == 13 {\n        return word[vowel_start]\n    }\n\
    \    if vowel_count == 14 {\n        return word[vowel_start]\n    }\n    if vowel_count\
    \ == 15 {\n        return word[vowel_start]\n    }\n    if vowel_count == 16 {\n\
    \        return word[vowel_start]\n    }\n    if vowel_count == 17 {\n       \
    \ return word[vowel_start]\n    }\n    if vowel_count == 18 {\n        return\
    \ word[vowel_start]\n    }\n    if vowel_count == 19 {\n        return word[vowel_start]\n\
    \    }\n    if vowel_count == 20 {\n        return word[vowel_start]\n    }\n\
    \    if vowel_count == 21 {\n        return word[vowel_start]\n    }\n    if vowel_count\
    \ == 22\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr6xijd_f_test.go:101:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n        if vowelsCount > len(vowels) {\n            return \"\"\n     \
    \   }\n    }\n    return word[len(word)-1]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpncwp0uwv_test.go:26:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string\n    vowels = append(vowels, \"a\"\
    , \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\"\
    , \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels\
    \ = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpff1kxik1_test.go:47:39: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= len(word) - len(word[:len(word)-1])\n\
    \    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    for _, v := range\
    \ vowels {\n        if word == v {\n            return v\n        }\n    }\n \
    \   return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpqvbyh4a9_test.go:62: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpqvbyh4a9_test.go:62: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpqvbyh4a9_test.go:62: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpqvbyh4a9_test.go:62: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpqvbyh4a9_test.go:62:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpqvbyh4a9_test.go:62: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074867
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    i\
    \ := len(word) - 1\n    for {\n        if i == 0 {\n            break\n      \
    \  }\n        if strings.Contains(word[i], vowels[vowelsCount]) {\n          \
    \  vowelsCount++\n        }\n        i--\n    }\n    return word[i]\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpodz892we_test.go:18:12: undefined: strings

    /tmp/tmpodz892we_test.go:36:12: undefined: strings

    /tmp/tmpodz892we_test.go:41:12: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    for i := len(word) - 1; i >= 0; i-- {\n    \
    \    if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u' {\n            if vowelsCount > 0 {\n                vowelsCount--\n\
    \            }\n            if vowelsCount == 0 {\n                return word[i]\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy09d3iof_test.go:34:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string\n    vowels = append(vowels, \"a\"\
    , \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\"\
    , \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels\
    \ = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdzoslid__test.go:47:39: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppqfx09_5_test.go:82:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowel_count := 0\n    vowel_found := false\n    vowel_count := 0\n    vowel_found\
    \ := false\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            vowel_found = true\n            vowel_count++\n        }\n    }\n\
    \    if vowel_count == 0 {\n        return \"\"\n    }\n    if vowel_found ==\
    \ false {\n        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            if vowel_count == 1 {\n            \
    \    return word[i]\n            }\n            if vowel_count == 2 {\n      \
    \          return word[i]\n            }\n            if vowel_count == 3 {\n\
    \                return word[i]\n            }\n            if vowel_count ==\
    \ 4 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 5 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 6 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 7 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 8 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 9 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 10 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 11 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 12 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 13 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 14 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 15 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 16 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 17 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 18 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 19 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 20 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 21 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 22 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 23 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 24 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 25 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 26 {\n                return word[i]\n            }\n            if vowel_count\
    \ == 27 {\n                return word[i]\n            }\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmuncdbu0_test.go:115:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpek8bvgc2_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfu1cepfr_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += (len(word) - len(strings.Split(word, \"_\"\
    ))) / 2\n    vowelsCount %= len(vowels)\n    return vowels[vowelsCount]\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_kyv3_g2_test.go:18:12: undefined: strings

    /tmp/tmp_kyv3_g2_test.go:28:37: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range word {\n \
    \       if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n      \
    \      vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n        for\
    \ _, v := range word {\n            if v == 'a' || v == 'e' || v == 'i' || v ==\
    \ 'o' || v == 'u' {\n                return v\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpccya3njy_test.go:16:5: vowels declared but not used

    /tmp/tmpccya3njy_test.go:26:24: cannot use v (variable of type rune) as type string
    in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        return word\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpj733diym_test.go:54: expected 'u', got 'yogurt'\n    ---\
    \ FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpj733diym_test.go:54:\
    \ expected 'u', got 'full'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n\
    \        tmpj733diym_test.go:54: expected '', got 'easy'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpj733diym_test.go:54: expected '', got 'eAsy'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpj733diym_test.go:54: expected\
    \ '', got 'ali'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n   \
    \     tmpj733diym_test.go:54: expected 'a', got 'bad'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpj733diym_test.go:54: expected 'o', got 'most'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpj733diym_test.go:54: expected\
    \ '', got 'ab'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n    \
    \    tmpj733diym_test.go:54: expected '', got 'ba'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpj733diym_test.go:54: expected '', got 'quick'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpj733diym_test.go:54:\
    \ expected 'i', got 'anime'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpj733diym_test.go:54: expected '', got 'Asia'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpj733diym_test.go:54:\
    \ expected 'o', got 'Above'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowel string = \"\"\n    var vowel_count int = 0\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowel = word[i]\n            vowel_count++\n        }\n    }\n    if vowel_count\
    \ == 0 {\n        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            if vowel_count > 1 {\n             \
    \   return vowel\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp973ld9bl_test.go:19:21: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // code here\n    vowel := \"\"\n    vowel_count := 0\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowel = word[i]\n            vowel_count++\n        }\n    }\n    if vowel_count\
    \ == 0 {\n        return \"\"\n    }\n    vowel_count -= 1\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            if vowel_count <= 0 {\n\
    \                return word\n            }\n            vowel_count--\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpam6t677__test.go:20:21: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcbflmw1d_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0smpeju9_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzetti_1_test.go:92:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string\n    vowels = append(vowels, \"a\"\
    , \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\"\
    , \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels\
    \ = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpff1kxik1_test.go:47:39: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_8jljp7x_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    i := len(word) - 1\n    vowel := \"\"\n    \n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == vowels[vowelsLen] {\n            vowel\
    \ = word[i]\n            break\n        }\n    }\n    return vowel\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb3ii06sn_test.go:21:5: i declared but not used

    /tmp/tmpb3ii06sn_test.go:25:23: invalid operation: word[i] == vowels[vowelsLen]
    (mismatched types byte and string)

    /tmp/tmpb3ii06sn_test.go:26:21: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n\
    \    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= 2\n\
    \    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\
    \n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxv5wobsx_test.go:106:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiffi0dyj_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n        if vowelsCount >= len(vowels) {\n            return \"\"\n    \
    \    }\n    }\n    return word[len(word)-1]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprm0lxtvv_test.go:26:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string = []string{\"a\", \"e\", \"i\", \"\
    o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i]\
    \ == \"a\" || word[i] == \"e\" || word[i] == \"i\" || word[i] == \"o\" || word[i]\
    \ == \"u\" {\n            return word[i]\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5mwryc7f_test.go:15:9: vowels declared but not used

    /tmp/tmp5mwryc7f_test.go:18:23: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmp5mwryc7f_test.go:18:41: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmp5mwryc7f_test.go:18:59: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmp5mwryc7f_test.go:18:77: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmp5mwryc7f_test.go:18:95: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmp5mwryc7f_test.go:19:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n        if vowelsCount >= len(vowels) {\n            return \"\"\n    \
    \    }\n    }\n    return word[len(word)-1]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprm0lxtvv_test.go:26:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    i := len(word) - 1\n    \n    for i >= 0 {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            i -= 1\n            continue\n        }\n        \n        if\
    \ word[i] == 'y' {\n            i -= 2\n            continue\n        }\n    \
    \    \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n     \
    \   }\n        \n        if word[i] == 'y' {\n            i -= 2\n           \
    \ continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n \
    \           continue\n        }\n        \n        if word[i] == 'y' {\n     \
    \       i -= 2\n            continue\n        }\n        \n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            i -= 1\n            continue\n        }\n        \n        if\
    \ word[i] == 'y' {\n            i -= 2\n            continue\n        }\n    \
    \    \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n     \
    \   }\n        \n        if word[i] == 'y' {\n            i -= 2\n           \
    \ continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n \
    \           continue\n        }\n        \n        if word[i] == 'y' {\n     \
    \       i -= 2\n            continue\n        }\n        \n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            i -= 1\n            continue\n        }\n        \n        if\
    \ word[i] == 'y' {\n            i -= 2\n            continue\n        }\n    \
    \    \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n     \
    \   }\n        \n        if word[i] == 'y' {\n            i -= 2\n           \
    \ continue\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkrouspnx_test.go:102:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074867
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word[len(word)-1:] == v {\n            return v\n        }\n \
    \   }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpn4k3mqtg_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpn4k3mqtg_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpn4k3mqtg_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpn4k3mqtg_test.go:51: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpn4k3mqtg_test.go:51: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpn4k3mqtg_test.go:51: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpn4k3mqtg_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpn4k3mqtg_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpn4k3mqtg_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowelsCount--\n        }\n        if vowelsCount < 0 {\n    \
    \        return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvftcfax9_test.go:32:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074868
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen\
    \ += 2\n    vowelsLen += 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_8jljp7x_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount += 1\n  \
    \      }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for i := len(word) - 2; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowelsCount += 1\n        }\n    }\n    if vowelsCount < 2 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount += 1\n  \
    \      }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for i := len(word) - 2; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowelsCount += 1\n        }\n    }\n    if vowelsCount < 2 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount += 1\n  \
    \      }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for i := len(word) - 2; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowelsCount += 1\n        }\n    }\n    if vowelsCount < 2 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp59viadg8_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074867
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > len(word) {\n        return \"\"\n    }\n \
    \   vowelsCount -= len(vowels)\n    for i := len(word) - vowelsCount; i >= 0;\
    \ i-- {\n        if strings.Contains(word, vowels[i]) {\n            return word[i]\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplqna942s_test.go:19:12: undefined: strings

    /tmp/tmplqna942s_test.go:28:12: undefined: strings

    /tmp/tmplqna942s_test.go:29:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjdwb9inx_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string\n    vowels = append(vowels, \"a\"\
    , \"e\", \"i\", \"o\", \"u\")\n    for i := len(word) - 1; i >= 0; i-- {\n   \
    \     if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"i\" || word[i] ==\
    \ \"o\" || word[i] == \"u\" {\n            return word[i]\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg7oe6e3f_test.go:18:23: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpg7oe6e3f_test.go:18:41: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpg7oe6e3f_test.go:18:59: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpg7oe6e3f_test.go:18:77: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpg7oe6e3f_test.go:18:95: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmpg7oe6e3f_test.go:19:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    i := len(word) - 1\n    \n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            i -= vowelsLen\n        } else {\n \
    \           i -= 2\n        }\n    }\n    return word\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy_65xc20_test.go:21:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range word {\n \
    \       if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n      \
    \      vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n        for\
    \ _, v := range word {\n            if v == 'a' || v == 'e' || v == 'i' || v ==\
    \ 'o' || v == 'u' {\n                return v\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpccya3njy_test.go:16:5: vowels declared but not used

    /tmp/tmpccya3njy_test.go:26:24: cannot use v (variable of type rune) as type string
    in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowel := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowel_count := 0\n    vowel_index := len(word) - 2\n\
    \    for _, v := range vowel {\n        if word[vowel_index] == v {\n        \
    \    vowel_count++\n        }\n        vowel_index--\n    }\n    if vowel_count\
    \ == 0 {\n        return \"\"\n    }\n    if vowel_count == 1 {\n        return\
    \ word[vowel_index]\n    }\n    if vowel_count == 2 {\n        return word[vowel_index+1]\n\
    \    }\n    if vowel_count == 3 {\n        return word[vowel_index+2]\n    }\n\
    \    if vowel_count == 4 {\n        return word[vowel_index+3]\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9wnxqhw9_test.go:20:33: invalid operation: word[vowel_index] == v (mismatched
    types byte and string)

    /tmp/tmp9wnxqhw9_test.go:29:16: cannot use word[vowel_index] (value of type byte)
    as type string in return statement

    /tmp/tmp9wnxqhw9_test.go:32:16: cannot use word[vowel_index + 1] (value of type
    byte) as type string in return statement

    /tmp/tmp9wnxqhw9_test.go:35:16: cannot use word[vowel_index + 2] (value of type
    byte) as type string in return statement

    /tmp/tmp9wnxqhw9_test.go:38:16: cannot use word[vowel_index + 3] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptjcujqr2_test.go:19:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount += 1\n  \
    \      }\n        if vowelsCount > len(vowels) {\n            return \"\"\n  \
    \      }\n    }\n    return word[len(word)-1]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq9ok63qa_test.go:26:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowel\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsro3xjf8_test.go:86:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowel string = \"\"\n    for i := len(word) - 1; i\
    \ >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u' {\n            vowel = word[i]\n          \
    \  break\n        }\n    }\n    return vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkrb_167r_test.go:18:21: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Split(word,\
    \ \"a\")[0])\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ /= 2\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)\
    \ - 1\n    }\n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw06ootg6_test.go:18:12: undefined: strings

    /tmp/tmpw06ootg6_test.go:25:36: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels []string\n    vowels = append(vowels, \"a\"\
    , \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\"\
    , \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels\
    \ = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n   \
    \ vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels,\
    \ \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels, \"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\", \"I\", \"O\"\
    , \"U\")\n    vowels = append(vowels, \"a\", \"e\", \"i\", \"o\", \"u\")\n   \
    \ vowels = append(vowels, \"A\", \"E\", \"I\", \"O\", \"U\")\n    vowels = append(vowels,\
    \ \"a\", \"e\", \"i\", \"o\", \"u\")\n    vowels = append(vowels, \"A\", \"E\"\
    , \"I\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpff1kxik1_test.go:47:39: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"a\", \"A\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"e\", \"E\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"i\", \"I\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"o\", \"O\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"u\", \"U\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"A\", \"a\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"E\", \"e\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"I\", \"i\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"O\", \"o\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"U\", \"u\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"a\", \"A\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"e\", \"E\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"i\", \"I\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"o\", \"O\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"u\", \"U\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"A\", \"a\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"E\", \"e\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"I\", \"i\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"O\", \"o\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"U\", \"u\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"a\", \"A\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"e\", \"E\", -1))\n    vowelsCount -= len(word) - len(strings.Replace(word,\
    \ \"i\", \"I\", -1))\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2wq3xp2q_test.go:49:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    vowelsCount += len(vowels)\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n        return \"\
    \"\n    }\n    vowelsCount = 0\n    for i := len(word) - 1; i >= 0; i-- {\n  \
    \      if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            vowelsCount++\n        }\n    }\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount--\n\
    \        }\n    }\n    if vowelsCount < 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n \
    \       return \"\"\n    }\n    return word\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpq1kmy0rv_test.go:82: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpq1kmy0rv_test.go:82: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpq1kmy0rv_test.go:82: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpq1kmy0rv_test.go:82: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpq1kmy0rv_test.go:82:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpq1kmy0rv_test.go:82: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074871
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // write your code here\n    vowel := []rune{'a', 'e',\
    \ 'i', 'o', 'u'}\n    vowel_count := 0\n    vowel_count += len(word) - len(word[:len(word)-1])\n\
    \    for _, v := range vowel {\n        if word[len(word)-1:] == v {\n       \
    \     vowel_count += 1\n        }\n    }\n    if vowel_count > 0 {\n        return\
    \ word[len(word)-1:]\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsoz_1zrv_test.go:20:34: invalid operation: word[len(word) - 1:] == v (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // code here\n    vowel := \"\"\n    vowel_count := 0\n\
    \    vowel_count := 0\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowel = word[i]\n            vowel_count++\n        }\n    }\n\
    \    if vowel_count > 0 {\n        for i := len(word) - 1; i >= 0; i-- {\n   \
    \         if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u' {\n                vowel = word[i]\n                vowel_count++\n\
    \            }\n        }\n    }\n    return vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4isd12zn_test.go:18:17: no new variables on left side of :=

    /tmp/tmp4isd12zn_test.go:21:21: cannot use word[i] (value of type byte) as type
    string in assignment

    /tmp/tmp4isd12zn_test.go:28:25: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        vowelsCount -= len(vowels)\n \
    \   }\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= len(vowels)\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= len(vowels)\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= len(vowels)\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /=\
    \ len(vowels)\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= len(vowels)\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= len(vowels)\n    if vowelsCount\
    \ == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /=\
    \ len(vowels)\n    if \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3n3n_f9c_test.go:102:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // code here\n    vowels := []string{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmproeatp66_test.go:88:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Split(word,\
    \ \"e\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"i\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"o\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"u\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"a\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"e\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"i\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"o\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"u\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"a\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"e\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"i\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"o\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ -= len(strings.Split(word, \"u\"))\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    vowelsCount -= len(strings.Split(word, \"a\"))\n    if vowelsCount\
    \ < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount -= len(strings.Split(word,\
    \ \"e\"))\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3mb4xu6t_test.go:86:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2puompaw_test.go:106:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    if\
    \ vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpqg8djr1m_test.go:60: expected 'u', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpqg8djr1m_test.go:60: expected\
    \ 'u', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n    \
    \    tmpqg8djr1m_test.go:60: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpqg8djr1m_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpqg8djr1m_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n     \
    \   tmpqg8djr1m_test.go:60: expected 'o', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpqg8djr1m_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpqg8djr1m_test.go:60: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpqg8djr1m_test.go:60: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpqg8djr1m_test.go:60: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpqg8djr1m_test.go:60:\
    \ expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpqg8djr1m_test.go:60: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiffi0dyj_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word[len(word)-1:] == v {\n            return v\n        }\n \
    \   }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpn4k3mqtg_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpn4k3mqtg_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpn4k3mqtg_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpn4k3mqtg_test.go:51: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpn4k3mqtg_test.go:51: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpn4k3mqtg_test.go:51: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpn4k3mqtg_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpn4k3mqtg_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpn4k3mqtg_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzetti_1_test.go:92:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowel_count := 0\n    vowel_count := 0\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"i\"\
    \ || word[i] == \"o\" || word[i] == \"u\" {\n            vowel_count++\n     \
    \   }\n    }\n    if vowel_count > 0 {\n        for i := len(word) - 1; i >= 0;\
    \ i-- {\n            if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"\
    i\" || word[i] == \"o\" || word[i] == \"u\" {\n                return word[i]\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdnjpu49t_test.go:17:17: no new variables on left side of :=

    /tmp/tmpdnjpu49t_test.go:19:23: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpdnjpu49t_test.go:19:41: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpdnjpu49t_test.go:19:59: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpdnjpu49t_test.go:19:77: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpdnjpu49t_test.go:19:95: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmpdnjpu49t_test.go:25:27: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpdnjpu49t_test.go:25:45: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpdnjpu49t_test.go:25:63: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpdnjpu49t_test.go:25:81: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpdnjpu49t_test.go:25:81: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount %=\
    \ len(vowels)\n    vowelsCount += 2\n    if vowelsCount == 0 {\n        return\
    \ \"\"\n    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp081mja6l_test.go:103:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074870
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount %= len(vowels)\n    vowelsCount += 2\n    vowelsCount\
    \ %= len(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppqfx09_5_test.go:82:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074865
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := \"aeiouAEIOU\"\n    vowelLen := len(vowel)\n\
    \    vowelPos := 0\n    vowelPos := strings.LastIndex(word, vowel)\n    if vowelPos\
    \ == -1 {\n        return \"\"\n    }\n    vowelPos += len(vowel)\n    vowelPos\
    \ := strings.LastIndex(word[vowelPos:], vowel)\n    if vowelPos == -1 {\n    \
    \    return \"\"\n    }\n    vowelPos += len(vowel)\n    vowelPos := strings.LastIndex(word[vowelPos:],\
    \ vowel)\n    if vowelPos == -1 {\n        return \"\"\n    }\n    vowelPos +=\
    \ len(vowel)\n    vowelPos := strings.LastIndex(word[vowelPos:], vowel)\n    if\
    \ vowelPos == -1 {\n        return \"\"\n    }\n    vowelPos += len(vowel)\n \
    \   vowelPos := strings.LastIndex(word[vowelPos:], vowel)\n    if vowelPos ==\
    \ -1 {\n        return \"\"\n    }\n    vowelPos += len(vowel)\n    vowelPos :=\
    \ strings.LastIndex(word[vowelPos:], vowel)\n    if vowelPos == -1 {\n       \
    \ return \"\"\n    }\n    vowelPos += len(vowel)\n    vowelPos := strings.LastIndex(word[vowelPos:],\
    \ vowel)\n    if vowelPos == -1 {\n        return \"\"\n    }\n    vowelPos +=\
    \ len(vowel)\n    vowelPos := strings.LastIndex(word[vowelPos:], vowel)\n    if\
    \ vowelPos == -1 {\n        return \"\"\n    }\n    vowelPos += len(vowel)\n \
    \   vowelPos := strings.LastIndex(word[vowelPos:], vowel)\n    if vowelPos ==\
    \ -1 {\n        return \"\"\n    }\n    vowelPos += len(vowel)\n    vowelPos :=\
    \ strings.LastIndex(word[vowelPos:], vowel)\n    if vowelPos == -1 {\n       \
    \ return \"\"\n    }\n    vowelPos += len(vowel)\n    vowelPos := strings.LastIndex(word[vowelPos:],\
    \ vowel)\n    if vowelPos == -1 {\n        return \"\"\n    }\n    vowelPos +=\
    \ len(vowel)\n    vowelPos := strings.LastIndex(word[vowelPos:], vowel)\n    if\
    \ vowelPos == -1 {\n        return \"\"\n    }\n    vowelPos += len(vowel)\n \
    \   vowelPos := strings.LastIndex(word[vowelPos:], vowel)\n    if vowelPos ==\
    \ -1 {\n        return \"\"\n    }\n    vowelPos += len(vowel)\n    vowelPos :=\
    \ strings.LastIndex(word[vowelPos:], vowel)\n    if vowelPos == -1 {\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4t71sejm_test.go:85:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjdwb9inx_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowel_count := 0\n    for _, v := range vowel {\n        if strings.Contains(word,\
    \ v) {\n            vowel_count++\n        }\n    }\n    if vowel_count < 2 {\n\
    \        return \"\"\n    }\n    vowel_count -= 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count += 2\n    vowel_count %= len(vowel)\n    vowel_count += 2\n \
    \   vowel_count %= len(vowel)\n    vowel_count += 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count += 2\n    vowel_count %= len(vowel)\n    vowel_count += 2\n \
    \   vowel_count %= len(vowel)\n    vowel_count += 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count += 2\n    vowel_count %= len(vowel)\n    vowel_count += 2\n \
    \   vowel_count %= len(vowel)\n    vowel_count += 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count += 2\n    vowel_count %= len(vowel)\n    vowel_count += 2\n \
    \   vowel_count %= len(vowel)\n    vowel_count += 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count += 2\n    vowel_count %= len(vowel)\n    vowel_count += 2\n \
    \   vowel_count %= len(vowel)\n    vowel_count += 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count += 2\n    vowel_count %= len(vowel)\n    vowel_count += 2\n \
    \   vowel_count %= len(vowel)\n    vowel_count += 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count += 2\n    vowel_count %= len(vowel)\n    vowel_count += 2\n \
    \   vowel_count %= len(vowel)\n    vowel_count += 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count += 2\n    vowel_count %= len(vowel)\n    vowel_count += 2\n \
    \   vowel_count %= len(vowel)\n    vowel_count += 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count += 2\n    vowel_count %= len(vowel)\n    vowel_count += 2\n \
    \   vowel_count %= len(vowel)\n    vowel_count += 2\n    vowel_count %= len(vowel)\n\
    \    vowel_count \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfi_lwmqa_test.go:82:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n        if vowelsCount > len(vowels) {\n            return \"\"\n     \
    \   }\n    }\n    return word[len(word)-1]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpncwp0uwv_test.go:26:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // write your code here\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -=\
    \ 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps5mx6yqd_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzetti_1_test.go:92:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowel := \"\"\n    vowels := []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen\
    \ -= 1\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         if vowel == \"\" {\n                vowel = word[i]\n            } else\
    \ {\n                if vowels[vowelsLen-len(vowel)-1] <= word[i] {\n        \
    \            vowel = word[i]\n                }\n            }\n        }\n  \
    \  }\n    return vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvr3njn79_test.go:23:25: cannot use word[i] (value of type byte) as type
    string in assignment

    /tmp/tmpvr3njn79_test.go:25:54: invalid operation: vowels[vowelsLen - len(vowel)
    - 1] <= word[i] (mismatched types string and byte)

    /tmp/tmpvr3njn79_test.go:26:29: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfu1cepfr_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n\
    \    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcxwoubfj_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   return word\n    }\n    vowelsCount = 0\n    for _, v := range vowels {\n\
    \        if word[len(word)-1] == v {\n            vowelsCount++\n        }\n \
    \   }\n    if vowelsCount > 0 {\n        return word\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxhcgaqql_test.go:27:33: invalid operation: word[len(word) - 1] == v (mismatched
    types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq_73mwye_test.go:82:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowel := []rune{'a', 'e', 'i',\
    \ 'o', 'u'}\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n\
    \    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1qp1bkep_test.go:88:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo87z6xrj_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ = 0\n    for i := len(word) - 2; i >= 0; i-- {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word) - 2; i >= 0; i-- {\n\
    \        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            vowelsCount++\n        }\n    }\n    if vowelsCount\
    \ < 2 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    for i := len(word) - 2; i >= 0; i-- {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word) - 2; i >= 0; i-- {\n\
    \        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            vowelsCount++\n        }\n    }\n    if vowelsCount\
    \ < 2 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowels\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg62li1_1_test.go:78:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ = 0\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n        return\
    \ \"\"\n    }\n    vowelsCount = 0\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            vowelsCount++\n        }\n    }\n    if vowelsCount\
    \ < 2 {\n        return \"\"\n    }\n    vowelsCount = 0\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ = 0\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n        return\
    \ \"\"\n    }\n    vowelsCount = 0\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            vowelsCount++\n        }\n    }\n    if vowelsCount\
    \ < 2 {\n        return \"\"\n    }\n    vowelsCount = 0\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmuyxxi65_test.go:81:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074871
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n   \
    \ vowel_count := 0\n    vowel_count := 0\n    vowel_count := 0\n    vowel_count\
    \ := \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo87z6xrj_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0smpeju9_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount <= 1 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount--\n        }\n    }\n    if vowelsCount <= 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for _, v := range\
    \ vowels {\n        if strings.Contains(word, v) {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n   \
    \ vowelsCount -= len(vowels)\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount--\n        }\n    }\n    if vowelsCount <= 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for _, v := range\
    \ vowels {\n        if strings.Contains(word, v) {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n   \
    \ vowelsCount -= len(vowels)\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount--\n        }\n    }\n    if vowelsCount <= 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for _, v := range\
    \ vowels {\n        if strings.Contains(word, v) {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n   \
    \ vowelsCount -= len(vowels)\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount--\n        }\n    }\n    if vowelsCount <= 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for _, v := range\
    \ vowels {\n        if strings.Contains(word, v) {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n   \
    \ vowelsCount -= len(vowels)\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount--\n        }\n    }\n    if vowelsCount <= 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(vowels)\n    for _, v := range\
    \ vowels {\n        if strings.Contains(word, v) {\n            vowelsCount++\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwmv3h3yf_test.go:111:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    i := len(word) - 1\n    \n    vowel := \"\"\n    \n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            if i ==\
    \ 0 {\n                vowel = word[i]\n                break\n            }\n\
    \            if word[i-1] == 'a' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1]\
    \ == 'o' || word[i-1] == 'u' {\n                vowel = word[i]\n            \
    \    break\n            }\n            if word[i-2] == 'a' || word[i-2] == 'e'\
    \ || word[i-2] == 'i' || word[i-2] == 'o' || word[i-2] == 'u' {\n            \
    \    vowel = word[i]\n                break\n            }\n            if word[i-3]\
    \ == 'a' || word[i-3] == 'e' || word[i-3] == 'i' || word[i-3] == 'o' || word[i-3]\
    \ == 'u' {\n                vowel = word[i]\n                break\n         \
    \   }\n            if word[i-4] == 'a' || word[i-4] == 'e' || word[i-4] == 'i'\
    \ || word[i-4] == 'o' || word[i-4] == 'u' {\n                vowel = word[i]\n\
    \                break\n            }\n            if word[i-5] == 'a' || word[i-5]\
    \ == 'e' || word[i-5] == 'i' || word[i-5] == 'o' || word[i-5] == 'u' {\n     \
    \           vowel = word[i]\n                break\n            }\n          \
    \  if word[i-6] == 'a' || word[i-6] == 'e' || word[i-6] == 'i' || word[i-6] ==\
    \ 'o' || word[i-6] == 'u' {\n                vowel = word[i]\n               \
    \ break\n            }\n            if word[i-7] == 'a' || word[i-7] == 'e' ||\
    \ word[i-7] == 'i' || word[i-7] == 'o' || word[i-7] == 'u' {\n               \
    \ vowel = word[i]\n                break\n            }\n            if word[i-8]\
    \ == 'a' || word[i-8] == 'e' || word[i-8] == 'i' || word[i-8] == 'o' || word[i-8]\
    \ == 'u' {\n                vowel = word[i]\n                break\n         \
    \   }\n            if word[i-9] == 'a' || word[i-9] == 'e' || word[i-9] == 'i'\
    \ || word[i-9] == 'o' || word[i-9] == 'u' {\n                vowel = word[i]\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbxny1fg5_test.go:65:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_found := false\n    for _, v := range word {\n        if v ==\
    \ 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n            vowel_count++\n\
    \        } else {\n            if vowel_count == 0 {\n                vowel_found\
    \ = true\n            }\n            vowel_count = 0\n        }\n    }\n    if\
    \ vowel_count == 0 {\n        return \"\"\n    }\n    if vowel_found {\n     \
    \   for _, v := range word {\n            if v == 'a' || v == 'e' || v == 'i'\
    \ || v == 'o' || v == 'u' {\n                return v\n            }\n       \
    \ }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt5nottyr_test.go:15:5: vowel declared but not used

    /tmp/tmpt5nottyr_test.go:34:24: cannot use v (variable of type rune) as type string
    in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvzetti_1_test.go:92:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr_t9t1jc_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count := 0\n    for _, c := range word {\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            vowel_count++\n\
    \        }\n    }\n    if vowel_count > 0 {\n        for _, c := range word {\n\
    \            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \               vowel_count--\n            }\n        }\n    }\n    if vowel_count\
    \ < 0 {\n        return \"\"\n    }\n    vowel_count := 0\n    for _, c := range\
    \ word {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ {\n            vowel_count++\n        }\n    }\n    if vowel_count > 0 {\n \
    \       for _, c := range word {\n            if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' {\n                vowel_count--\n            }\n\
    \        }\n    }\n    if vowel_count < 0 {\n        return \"\"\n    }\n    vowel_count\
    \ := 0\n    for _, c := range word {\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' {\n            vowel_count++\n        }\n    }\n\
    \    if vowel_count > 0 {\n        for _, c := range word {\n            if c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n                vowel_count--\n\
    \            }\n        }\n    }\n    if vowel_count < 0 {\n        return \"\"\
    \n    }\n    vowel_count := 0\n    for _, c := range word {\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            vowel_count++\n\
    \        }\n    }\n    if vowel_count > 0 {\n        for _, c := range word {\n\
    \            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \               vowel_count--\n            }\n        }\n    }\n    if vowel_count\
    \ < 0 {\n        return \"\"\n    }\n    vowel_count := 0\n    for _, c := range\
    \ word {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ {\n            vowel_count++\n        }\n    }\n    if vowel_count > 0 {\n \
    \       for _, \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplxlikjr5_test.go:88:13: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word[len(word)-1:] == v {\n            return v\n        }\n \
    \   }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpn4k3mqtg_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpn4k3mqtg_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpn4k3mqtg_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpn4k3mqtg_test.go:51: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpn4k3mqtg_test.go:51: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpn4k3mqtg_test.go:51: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpn4k3mqtg_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpn4k3mqtg_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpn4k3mqtg_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2puompaw_test.go:106:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074869
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ietxki2_test.go:67:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := \"aeiouAEIOU\"\n    vowel_count := 0\n    vowel_count\
    \ := len(word)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count\
    \ -= len(vowel)\n    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\n\
    \    vowel_count -= len(vowel)\n    vowel_count -= len(vowel)\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp06em_g4f_test.go:72:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range word {\n \
    \       if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n      \
    \      vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n        for\
    \ i := len(word) - 1; i >= 0; i-- {\n            if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \     return word\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4jqygcc0_test.go:16:5: vowels declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(word) - len(strings.Split(word,\
    \ \"_\"))\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    return vowels[vowelsCount]\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6xfr787y_test.go:18:12: undefined: strings

    /tmp/tmp6xfr787y_test.go:25:36: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == \"a\" || word[i] == \"e\" || word[i]\
    \ == \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n   \
    \ vowelsCount -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n\
    \    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_9obaba4_test.go:19:23: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmp_9obaba4_test.go:19:41: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmp_9obaba4_test.go:19:59: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmp_9obaba4_test.go:19:77: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmp_9obaba4_test.go:19:95: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfu1cepfr_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiffi0dyj_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074866
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjdwb9inx_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        for i := len(word) - 1; i >= 0;\
    \ i-- {\n            if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u' {\n                return word[i]\n       \
    \     }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_c6ywqc6_test.go:26:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppjru6z6d_test.go:82:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8o_sxa0_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount -= len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmqb32521_test.go:107:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074872
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpijfo6q2j_test.go:79:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen\
    \ /= 2\n    vowelsLen /= 2\n    vowelsLen /= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0smpeju9_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         vowel_count++\n        }\n    }\n    if vowel_count > 0 {\n        for\
    \ i := len(word) - 1; i >= 0; i-- {\n            if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \     return word[i]\n            }\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8_c31lqh_test.go:15:5: vowel declared but not used

    /tmp/tmp8_c31lqh_test.go:25:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074872
