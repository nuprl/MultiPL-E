language: go_test.go
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += \"1\"\n    } else {\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpw1z5r4ga_test.go:44: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpw1z5r4ga_test.go:44:\
    \ expected 'db100000db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpw1z5r4ga_test.go:44: expected 'db1100111db', got '01'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpw1z5r4ga_test.go:44:\
    \ expected 'db1111db', got '01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    case 2:\n        result = \"10\"\n    case 3:\n\
    \        result = \"11\"\n    case 4:\n        result = \"100\"\n    case 5:\n\
    \        result = \"101\"\n    case 6:\n        result = \"110\"\n    case 7:\n\
    \        result = \"111\"\n    case 8:\n        result = \"1000\"\n    case 9:\n\
    \        result = \"1001\"\n    case 10:\n        result = \"1010\"\n    case\
    \ 11:\n        result = \"1011\"\n    case 12:\n        result = \"1100\"\n  \
    \  case 13:\n        result = \"1101\"\n    case 14:\n        result = \"1110\"\
    \n    case 15:\n        result = \"1111\"\n    default:\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary (0.00s)\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmprvolp0eb_test.go:71:\
    \ expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmprvolp0eb_test.go:71: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmprvolp0eb_test.go:71:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmprvolp0eb_test.go:71: expected 'db1111db', got 'db1111'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal < 0 {\n        fmt.Println(\"Negative numbers are not allowed\")\n \
    \   }\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary\
    \ += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        binary += \"0\"\
    \n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpmg1_63up_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpmg1_63up_test.go:45:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpmg1_63up_test.go:45: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpmg1_63up_test.go:45:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    \n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4zzh_yrm_test.go:17:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += \"1\"\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp7hubgnpq_test.go:42: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7hubgnpq_test.go:42: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp7hubgnpq_test.go:42: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp7hubgnpq_test.go:42: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n   \
    \ result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjwqdwh_i_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074546
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"0\"\n        temp = temp / 2\n    }\n    result += \"db\"\
    \n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptbh7enn0_test.go:42: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptbh7enn0_test.go:42:\
    \ expected 'db100000db', got '000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptbh7enn0_test.go:42: expected 'db1100111db', got '0000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptbh7enn0_test.go:42:\
    \ expected 'db1111db', got '0000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimalToBinary := make([]int, 10)\n    decimalToBinary[0] = 1\n\
    \    decimalToBinary[1] = 1\n    decimalToBinary[2] = 1\n    decimalToBinary[3]\
    \ = 1\n    decimalToBinary[4] = 1\n    decimalToBinary[5] = 1\n    decimalToBinary[6]\
    \ = 1\n    decimalToBinary[7] = 1\n    decimalToBinary[8] = 1\n    decimalToBinary[9]\
    \ = 1\n    decimalToBinary[10] = 1\n\n    for i := 0; i < 10; i++ {\n        decimalToBinary[i]\
    \ = decimalToBinary[i] - decimalToBinary[decimal%10]\n        decimal = decimal\
    \ / 10\n    }\n\n    for i := 0; i < 10; i++ {\n        if decimalToBinary[i]\
    \ == 1 {\n            result += \"1\"\n        } else {\n            result +=\
    \ \"0\"\n        }\n    }\n\n    result += \"db\"\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [10] with length 10 [recovered]\n\tpanic: runtime error: index out\
    \ of range [10] with length 10\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(0x56397b?)\n\t/tmp/tmprd2edvuz_test.go:27\
    \ +0x1b\ncommand-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmprd2edvuz_test.go:53\
    \ +0x42\ntesting.tRunner(0xc0000da1a0, 0x527f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += \"1\"\n    }\n    if decimal >\
    \ 0 {\n        result += \"0\"\n    }\n    if decimal > 0 {\n        result +=\
    \ \"b\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpubofl2ef_test.go:48: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpubofl2ef_test.go:48: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpubofl2ef_test.go:48: expected 'db1100111db', got '10b'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpubofl2ef_test.go:48: expected\
    \ 'db1111db', got '10b'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    if decimal < 0 {\n        fmt.Println(\"Negative numbers are not\
    \ allowed\")\n    }\n    if decimal > 0 {\n        result += \"1\"\n    }\n  \
    \  for i := 0; i < decimal; i++ {\n        result += \"0\"\n    }\n    result\
    \ += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptq9txl51_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptq9txl51_test.go:45:\
    \ expected 'db100000db', got '100000000000000000000000000000000db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptq9txl51_test.go:45: expected\
    \ 'db1100111db', got '10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptq9txl51_test.go:45:\
    \ expected 'db1111db', got '1000000000000000db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimalToBinary := decimalToBinaryHelper(decimal)\n    for i :=\
    \ 0; i < len(decimalToBinary); i++ {\n        binary += decimalToBinary[i]\n \
    \   }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rq3m4kl_test.go:16:24: undefined: decimalToBinaryHelper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal /= 2\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"1\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpa_s497dp_test.go:40: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa_s497dp_test.go:40:\
    \ expected 'db100000db', got '00000000000000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpa_s497dp_test.go:40: expected 'db1100111db', got '0000000000000000000000000000000000000000000000000001'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa_s497dp_test.go:40:\
    \ expected 'db1111db', got '00000001'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal < 2 {\n        result += \"0\"\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp69whmfe1_test.go:42: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp69whmfe1_test.go:42:\
    \ expected 'db100000db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp69whmfe1_test.go:42: expected 'db1100111db', got '00'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp69whmfe1_test.go:42:\
    \ expected 'db1111db', got '00'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    var remainder int\n    var i int\n    var temp int\n\n  \
    \  for i = 0; i <= decimal; i++ {\n        remainder = decimal % 2\n        decimal\
    \ = decimal / 2\n        temp = remainder\n        result = fmt.Sprintf(\"%c\"\
    , temp)\n    }\n\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpv1l4cqfd_test.go:46: expected 'db0db', got '\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpv1l4cqfd_test.go:46:\
    \ expected 'db100000db', got '\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpv1l4cqfd_test.go:46: expected 'db1100111db', got '\0'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpv1l4cqfd_test.go:46:\
    \ expected 'db1111db', got '\x01'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"b\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpuhfagsj__test.go:44: expected 'db0db', got 'b'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpuhfagsj__test.go:44:\
    \ expected 'db100000db', got 'b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpuhfagsj__test.go:44: expected 'db1100111db', got '10b'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpuhfagsj__test.go:44:\
    \ expected 'db1111db', got '10b'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    i := 0\n    for i < len(decimal) {\n\
    \        if decimal[i] > 0 {\n            result += \"1\"\n        } else {\n\
    \            result += \"0\"\n        }\n        i++\n    }\n    return \"db\"\
    \ + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4j141k0q_test.go:18:17: invalid argument: decimal (variable of type int)
    for len

    /tmp/tmp4j141k0q_test.go:19:19: invalid operation: cannot index decimal (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal -= 1\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6pk5uqs1_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6pk5uqs1_test.go:44:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6pk5uqs1_test.go:44: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6pk5uqs1_test.go:44:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Write your code here\n    result := \"\"\n    temp := decimal\n    for temp\
    \ > 0 {\n        result += \"1\"\n        temp--\n    }\n    result += \"db\"\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp0v25gjwy_test.go:42: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp0v25gjwy_test.go:42:\
    \ expected 'db100000db', got '11111111111111111111111111111111db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp0v25gjwy_test.go:42: expected\
    \ 'db1100111db', got '1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp0v25gjwy_test.go:42:\
    \ expected 'db1111db', got '111111111111111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"db\"\n    result += \"0\"\
    \n    for i := 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n        \
    \    result += fmt.Sprintf(\"%d\", decimal%2)\n        } else {\n            result\
    \ += fmt.Sprintf(\"%d\", decimal%2)\n        }\n        decimal = decimal/2\n\
    \    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp_g4f04gm_test.go:47: expected 'db100000db', got 'db00000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp_g4f04gm_test.go:47:\
    \ expected 'db1100111db', got 'db011100db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmp_g4f04gm_test.go:47: expected 'db1111db', got 'db0111db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal % 2 == 0 {\n        result += \"1\"\n    } else {\n   \
    \     result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpk3kmdp92_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpk3kmdp92_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpk3kmdp92_test.go:44: expected 'db1100111db', got '10'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk3kmdp92_test.go:44:\
    \ expected 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binary\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprsuskbi__test.go:101:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074546
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \   }\n    for i := 0; i < decimal; i++ {\n        binary += \"0\"\n    }\n  \
    \  return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n \
    \ candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp773t9sgs_test.go:42: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp773t9sgs_test.go:42:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp773t9sgs_test.go:42: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp773t9sgs_test.go:42:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    result += \"db\"\n    for i := 0; i < decimal; i++ {\n  \
    \      result += \"0\"\n    }\n    for i := decimal - 1; i >= 0; i-- {\n     \
    \   result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpldefbw6j_test.go:42: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpldefbw6j_test.go:42:\
    \ expected 'db100000db', got 'db0000000000000000000000000000000011111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpldefbw6j_test.go:42:\
    \ expected 'db1100111db', got 'db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpldefbw6j_test.go:42:\
    \ expected 'db1111db', got 'db000000000000000111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    decimalToBinary := decimal / 2\n    decimal = decimal % 2\n   \
    \ for i := 0; i < decimalToBinary; i++ {\n        binaryString += \"0\"\n    }\n\
    \    binaryString += string(decimal)\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpqqudpnzh_test.go:21:21: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074548
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \   }\n    for i := 0; i < decimal; i++ {\n        result += \"0\"\n    }\n  \
    \  result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpbf3qa0x8_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpbf3qa0x8_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpbf3qa0x8_test.go:43: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpbf3qa0x8_test.go:43:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074548
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    \n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp88n1t0_u_test.go:36: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp88n1t0_u_test.go:36: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp88n1t0_u_test.go:36: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp88n1t0_u_test.go:36: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    case 2:\n        result = \"10\"\n    case 3:\n\
    \        result = \"11\"\n    case 4:\n        result = \"100\"\n    case 5:\n\
    \        result = \"101\"\n    case 6:\n        result = \"110\"\n    case 7:\n\
    \        result = \"111\"\n    case 8:\n        result = \"1000\"\n    case 9:\n\
    \        result = \"1001\"\n    case 10:\n        result = \"1010\"\n    case\
    \ 11:\n        result = \"1011\"\n    case 12:\n        result = \"1100\"\n  \
    \  case 13:\n        result = \"1101\"\n    case 14:\n        result = \"1110\"\
    \n    case 15:\n        result = \"1111\"\n    default:\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary (0.00s)\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmprvolp0eb_test.go:71:\
    \ expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmprvolp0eb_test.go:71: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmprvolp0eb_test.go:71:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmprvolp0eb_test.go:71: expected 'db1111db', got 'db1111'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    case 2:\n        result = \"10\"\n    case 3:\n\
    \        result = \"11\"\n    case 4:\n        result = \"100\"\n    case 5:\n\
    \        result = \"101\"\n    case 6:\n        result = \"110\"\n    case 7:\n\
    \        result = \"111\"\n    case 8:\n        result = \"1000\"\n    case 9:\n\
    \        result = \"1001\"\n    case 10:\n        result = \"1010\"\n    case\
    \ 11:\n        result = \"1011\"\n    case 12:\n        result = \"1100\"\n  \
    \  case 13:\n        result = \"1101\"\n    case 14:\n        result = \"1110\"\
    \n    case 15:\n        result = \"1111\"\n    default:\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary (0.00s)\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmprvolp0eb_test.go:71:\
    \ expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmprvolp0eb_test.go:71: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmprvolp0eb_test.go:71:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmprvolp0eb_test.go:71: expected 'db1111db', got 'db1111'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Write your code here\n    \n    result := \"\"\n    \n    if decimal < 2 {\n\
    \        return fmt.Sprintf(\"%d\", decimal)\n    }\n    \n    decimal /= 2\n\
    \    \n    for i := 0; i < len(decimal); i++ {\n        if decimal > 0 {\n   \
    \         result += fmt.Sprintf(\"%d\", decimal%2)\n        }\n        decimal\
    \ /= 2\n    }\n    \n    result += \"db\"\n    \n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfm3n31wy_test.go:25:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp--\n    }\n    for temp > 0 {\n        result += \"1\"\n        temp--\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyuw_9302_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpyuw_9302_test.go:44: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"0\"\n        temp--\n    }\n    for temp > 0 {\n        result\
    \ += \"1\"\n        temp--\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpzu1udvkh_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzu1udvkh_test.go:45:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzu1udvkh_test.go:45: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzu1udvkh_test.go:45:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \   } else {\n        result += \"0\"\n    }\n    decimal /= 2\n    for i := 0;\
    \ i < decimal; i++ {\n        result += \"0\"\n    }\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp53qdrllt_test.go:45: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp53qdrllt_test.go:45:\
    \ expected 'db100000db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp53qdrllt_test.go:45: expected 'db1100111db', got '1'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp53qdrllt_test.go:45:\
    \ expected 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    for i := 0; i <\
    \ decimal; i++ {\n        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"\
    %d\", decimal/2)\n        } else {\n            result += fmt.Sprintf(\"%d\",\
    \ decimal%2)\n        }\n    }\n    result += \"db\"\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpgoqhftj6_test.go:45: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpgoqhftj6_test.go:45:\
    \ expected 'db100000db', got '01616161616161616161616161616161616161616161616161616161616161616db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpgoqhftj6_test.go:45:\
    \ expected 'db1100111db', got '01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpgoqhftj6_test.go:45:\
    \ expected 'db1111db', got '0111111111111111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        \nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdjnzckbk_test.go:112:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    i := 0\n    for i < len(decimal) {\n\
    \        result += \"0\"\n    }\n    for i < len(decimal) {\n        result +=\
    \ \"1\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn63raqg2_test.go:18:17: invalid argument: decimal (variable of type int)
    for len

    /tmp/tmpn63raqg2_test.go:21:17: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"0\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"0\"\n    binary\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy2n4izsl_test.go:101:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpdb20m4os_test.go:43:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpdb20m4os_test.go:43: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \       decimal -= 1\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\" + binary\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiffvyuqn_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiffvyuqn_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiffvyuqn_test.go:43: expected 'db1100111db', got '1db1'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiffvyuqn_test.go:43:\
    \ expected 'db1111db', got '1db1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074550
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    i := 0\n    switch decimal {\n    case 0:\n        result = \"\
    0\"\n    case 1:\n        result = \"1\"\n    case 2:\n        result = \"10\"\
    \n    case 3:\n        result = \"11\"\n    case 4:\n        result = \"100\"\n\
    \    case 5:\n        result = \"101\"\n    case 6:\n        result = \"110\"\n\
    \    case 7:\n        result = \"111\"\n    case 8:\n        result = \"1000\"\
    \n    case 9:\n        result = \"1001\"\n    case 10:\n        result = \"1010\"\
    \n    case 11:\n        result = \"1011\"\n    case 12:\n        result = \"1100\"\
    \n    case 13:\n        result = \"1101\"\n    case 14:\n        result = \"1110\"\
    \n    case 15:\n        result = \"1111\"\n    }\n    result += \"db\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuu4mno3k_test.go:16:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    result += \"1\"\
    \n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result +=\
    \ \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptx7xmuca_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    switch decimal {\n    case 0:\n    \
    \    result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n     \
    \   fmt.Println(\"Invalid input\")\n    }\n    return \"db\" + result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpk0efht_s_test.go:44:\
    \ expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpk0efht_s_test.go:44: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpk0efht_s_test.go:44:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpk0efht_s_test.go:44: expected 'db1111db', got 'db'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    base := 10\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    for i := decimal; i > 0; i-- {\n        result += \"1\"\
    \n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6vmd4a3h_test.go:16:5: base declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpe7afey5r_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpe7afey5r_test.go:44:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpe7afey5r_test.go:44: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpe7afey5r_test.go:44:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    binaryString += \"0\"\n    for i := 0; i < decimal; i++ {\n   \
    \     if decimal % 2 == 0 {\n            binaryString += \"1\"\n        } else\
    \ {\n            binaryString += \"0\"\n        }\n        decimal = decimal /\
    \ 2\n    }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyyvqsqna_test.go:44: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyyvqsqna_test.go:44:\
    \ expected 'db100000db', got '01111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpyyvqsqna_test.go:44: expected 'db1100111db', got '000011db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyyvqsqna_test.go:44:\
    \ expected 'db1111db', got '0000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal / 2\n    result += \"db\"\n    for i := 0; i <\
    \ temp; i++ {\n        result += fmt.Sprintf(\"%d\", decimal%2)\n        decimal\
    \ /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpi81p4_wo_test.go:41: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpi81p4_wo_test.go:41:\
    \ expected 'db100000db', got 'db0000010000000000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpi81p4_wo_test.go:41: expected 'db1100111db', got 'db111001100000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpi81p4_wo_test.go:41:\
    \ expected 'db1111db', got 'db1111000'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimalToBinary := make([]int, 10)\n    decimalToBinary[0] = 1\n\
    \    decimalToBinary[1] = 1\n    decimalToBinary[2] = 1\n    decimalToBinary[3]\
    \ = 1\n    decimalToBinary[4] = 1\n    decimalToBinary[5] = 1\n    decimalToBinary[6]\
    \ = 1\n    decimalToBinary[7] = 1\n    decimalToBinary[8] = 1\n    decimalToBinary[9]\
    \ = 1\n    decimalToBinary[10] = 1\n    decimalToBinary[11] = 1\n    decimalToBinary[12]\
    \ = 1\n    decimalToBinary[13] = 1\n    decimalToBinary[14] = 1\n    decimalToBinary[15]\
    \ = 1\n    decimalToBinary[16] = 1\n    decimalToBinary[17] = 1\n    decimalToBinary[18]\
    \ = 1\n    decimalToBinary[19] = 1\n    decimalToBinary[20] = 1\n    decimalToBinary[21]\
    \ = 1\n    decimalToBinary[22] = 1\n    decimalToBinary[23] = 1\n    decimalToBinary[24]\
    \ = 1\n    decimalToBinary[25] = 1\n    decimalToBinary[26] = 1\n    decimalToBinary[27]\
    \ = 1\n    decimalToBinary[28] = 1\n    decimalToBinary[29] = 1\n    decimalToBinary[30]\
    \ = 1\n    decimalToBinary[31] = 1\n    decimalToBinary[32] = 1\n    decimalToBinary[33]\
    \ = 1\n    decimalToBinary[34] = 1\n    decimalToBinary[35] = 1\n    decimalToBinary[36]\
    \ = 1\n    decimalToBinary[37] = 1\n    decimalToBinary[38] = 1\n    decimalToBinary[39]\
    \ = 1\n    decimalToBinary[40] = 1\n    decimalToBinary[41] = 1\n    decimalToBinary[42]\
    \ = 1\n    decimalToBinary[43] = 1\n    decimalToBinary[44] = 1\n    decimalToBinary[45]\
    \ = 1\n    decimalToBinary[46] = 1\n    decimalToBinary[47] = 1\n    decimalToBinary[48]\
    \ = 1\n    decimalToBinary[49] = 1\n    decimalToBinary[50] = 1\n    decimalToBinary[51]\
    \ = 1\n    decimalToBinary[52] = 1\n    decimalToBinary[53] = 1\n    decimalToBinary[54]\
    \ = 1\n    decimalToBinary[55] = 1\n    decimalToBinary[56] = 1\n    decimalToBinary[57]\
    \ = 1\n    decimalToBinary[58] = 1\n    decimalToBinary[59] = 1\n    decimalToBinary[60]\
    \ = 1\n    decimalToBinary[61] = 1\n    decimalToBinary[62] = 1\n    decimalToBinary\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9az9xygi_test.go:81:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimalToBinary := make([]int, 10)\n    decimalToBinary[0] = 1\n\
    \    decimalToBinary[1] = 1\n    decimalToBinary[2] = 2\n    decimalToBinary[3]\
    \ = 3\n    decimalToBinary[4] = 4\n    decimalToBinary[5] = 5\n    decimalToBinary[6]\
    \ = 6\n    decimalToBinary[7] = 7\n    decimalToBinary[8] = 8\n    decimalToBinary[9]\
    \ = 9\n    decimalToBinary[10] = 10\n    decimalToBinary[11] = 10\n    decimalToBinary[12]\
    \ = 10\n    decimalToBinary[13] = 10\n    decimalToBinary[14] = 10\n    decimalToBinary[15]\
    \ = 10\n    decimalToBinary[16] = 10\n    decimalToBinary[17] = 10\n    decimalToBinary[18]\
    \ = 10\n    decimalToBinary[19] = 10\n    decimalToBinary[20] = 10\n    decimalToBinary[21]\
    \ = 10\n    decimalToBinary[22] = 10\n    decimalToBinary[23] = 10\n    decimalToBinary[24]\
    \ = 10\n    decimalToBinary[25] = 10\n    decimalToBinary[26] = 10\n    decimalToBinary[27]\
    \ = 10\n    decimalToBinary[28] = 10\n    decimalToBinary[29] = 10\n    decimalToBinary[30]\
    \ = 10\n    decimalToBinary[31] = 10\n    decimalToBinary[32] = 10\n    decimalToBinary[33]\
    \ = 10\n    decimalToBinary[34] = 10\n    decimalToBinary[35] = 10\n    decimalToBinary[36]\
    \ = 10\n    decimalToBinary[37] = 10\n    decimalToBinary[38] = 10\n    decimalToBinary[39]\
    \ = 10\n    decimalToBinary[40] = 10\n    decimalToBinary[41] = 10\n    decimalToBinary[42]\
    \ = 10\n    decimalToBinary[43] = 10\n    decimalToBinary[44] = 10\n    decimalToBinary[45]\
    \ = 10\n    decimalToBinary[46] = 10\n    decimalToBinary[47] = 10\n    decimalToBinary[48]\
    \ = 10\n    decimalToBinary[49] = 10\n    decimalToBinary[50] = 10\n    decimalToBinary[51]\
    \ = 10\n    decimalToBinary[52] = 10\n    decimalToBinary[53] = 10\n    decimalToBinary[54]\
    \ = 10\n    decimalToBinary[55] = 10\n    decimalToBinary[56] = 10\n    decimalToBinary[57\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdv95n08v_test.go:74:23: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    for i := 0; i <\
    \ decimal; i++ {\n        result += \"1\"\n    }\n    result += \"db\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpe3nhjw4h_test.go:41: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpe3nhjw4h_test.go:41:\
    \ expected 'db100000db', got '011111111111111111111111111111111db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpe3nhjw4h_test.go:41: expected\
    \ 'db1100111db', got '01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpe3nhjw4h_test.go:41:\
    \ expected 'db1111db', got '0111111111111111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal % 2 == 0 {\n        result += \"1\"\n    } else {\n   \
    \     result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpk3kmdp92_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpk3kmdp92_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpk3kmdp92_test.go:44: expected 'db1100111db', got '10'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk3kmdp92_test.go:44:\
    \ expected 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for i := 0; i < len(decimal); i++ {\n        if decimal%2\
    \ == 0 {\n            binary += \"1\"\n        } else {\n            binary +=\
    \ \"0\"\n        }\n        decimal /= 2\n    }\n    return binary + \"db\"\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi4war7ga_test.go:16:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074551
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += \"1\"\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp7hubgnpq_test.go:42: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7hubgnpq_test.go:42: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp7hubgnpq_test.go:42: expected 'db1100111db', got '1'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp7hubgnpq_test.go:42: expected\
    \ 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"db\"\n    result += \"0\"\
    \n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result +=\
    \ \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpitha7es__test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \   }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"0\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"0\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"0\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    result += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"\
    0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"0\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"0\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"0\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    result += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"\
    0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"0\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"0\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"0\"\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmgjxjf4t_test.go:135:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal < 0 {\n        fmt.Println(\"Negative numbers are not allowed\")\n \
    \       return \"\"\n    }\n    binary := make([]byte, 32)\n    i := 0\n    for\
    \ decimal>0 {\n        binary[i] = byte(decimal%2)\n        decimal = decimal/2\n\
    \        i++\n    }\n    binary[i] = '0'\n    binary[len(binary)-1] = '1'\n  \
    \  return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfxarsej7_test.go:47: expected 'db0db', got '0\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\01'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpfxarsej7_test.go:47: expected 'db100000db', got '\0\0\0\0\
    \0\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\01'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfxarsej7_test.go:47: expected 'db1100111db', got '\x01\x01\
    \x01\0\0\x01\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\01'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpfxarsej7_test.go:47: expected\
    \ 'db1111db', got '\x01\x01\x01\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\01'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074552
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    case 2:\n        result = \"10\"\n    case 3:\n\
    \        result = \"11\"\n    case 4:\n        result = \"100\"\n    case 5:\n\
    \        result = \"101\"\n    case 6:\n        result = \"110\"\n    case 7:\n\
    \        result = \"111\"\n    case 8:\n        result = \"1000\"\n    case 9:\n\
    \        result = \"1001\"\n    case 10:\n        result = \"1010\"\n    case\
    \ 11:\n        result = \"1011\"\n    case 12:\n        result = \"1100\"\n  \
    \  case 13:\n        result = \"1101\"\n    case 14:\n        result = \"1110\"\
    \n    case 15:\n        result = \"1111\"\n    case 16:\n        result = \"10000\"\
    \n    case 17:\n        result = \"10001\"\n    case 18:\n        result = \"\
    10010\"\n    case 19:\n        result = \"10011\"\n    case 20:\n        result\
    \ = \"10100\"\n    case 21:\n        result = \"10101\"\n    case 22:\n      \
    \  result = \"10110\"\n    case 23:\n        result = \"10111\"\n    case 24:\n\
    \        result = \"11000\"\n    case 25:\n        result = \"11001\"\n    case\
    \ 26:\n        result = \"11010\"\n    case 27:\n        result = \"11011\"\n\
    \    case 28:\n        result = \"11100\"\n    case 29:\n        result = \"11101\"\
    \n    case 30:\n        result = \"11110\"\n    case 31:\n        result = \"\
    11111\"\n    case 32:\n        result = \"100001\"\n    case 33:\n        result\
    \ = \"100002\"\n    case 34:\n        result = \"100003\"\n    case 35:\n    \
    \    result = \"100004\"\n    case 36:\n        result = \"100005\"\n    case\
    \ 37:\n        result = \"100006\"\n    case 38:\n        result = \"100007\"\n\
    \    case 39:\n        result = \"100008\"\n    case 40:\n        result = \"\
    100009\"\n    case 41:\n        result = \"100010\"\n    case 42:\n        result\
    \ = \"100011\"\n    case 43:\n        result = \"100012\"\n    case 44:\n    \
    \    result = \"100013\"\n    case 45:\n        result = \"100014\"\n    case\
    \ 46:\n        result = \"100015\"\n    case 47:\n        result = \"100016\"\n\
    \    case 48:\n        result = \"100017\"\n    case 49:\n        result = \"\
    100018\"\n    case 50:\n        result = \"100019\"\n    case 51:\n        result\
    \ = \"100020\"\n    case 52:\n        result = \"100021\"\n    case 53:\n    \
    \    result = \"100022\"\n    case 54:\n        result = \"100023\"\n    case\
    \ 55:\n        result = \"1000\nfunc TestDecimal_To_Binary(t *testing.T) {\n \
    \ candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5pbq247_test.go:128:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074551
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpf30y4xe5_test.go:44:\
    \ expected 'db0db', got '0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpf30y4xe5_test.go:44: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpf30y4xe5_test.go:44:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpf30y4xe5_test.go:44: expected 'db1111db', got 'db'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074552
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    \n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp88n1t0_u_test.go:36: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp88n1t0_u_test.go:36: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp88n1t0_u_test.go:36: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp88n1t0_u_test.go:36: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    result += \"db\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpewg6zmxh_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074551
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpe7afey5r_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpe7afey5r_test.go:44:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpe7afey5r_test.go:44: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpe7afey5r_test.go:44:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    i := 0\n    for ; i < decimal; i++ {\n\
    \        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \        } else {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n    \
    \    }\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnl67aimu_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnl67aimu_test.go:45:\
    \ expected 'db100000db', got '\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpnl67aimu_test.go:45: expected 'db1100111db', got '\x01\x01\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnl67aimu_test.go:45:\
    \ expected 'db1111db', got '\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\
    \x01\x01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074552
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    if decimal < 2 {\n        return result\n    }\n    decimal /=\
    \ 2\n    for i := 0; i < len(decimal); i++ {\n        if decimal > 0 {\n     \
    \       result += fmt.Sprintf(\"%d\", decimal%2)\n            decimal = decimal\
    \ / 2\n        } else {\n            result += fmt.Sprintf(\"%d\", decimal%2)\n\
    \        }\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3smcjrht_test.go:20:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074551
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal < 0 {\n        fmt.Println(\"Negative numbers not allowed\")\n    }\n\
    \    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary +=\
    \ \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        binary += \"0\"\n\
    \    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpp728omx9_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpp728omx9_test.go:45:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpp728omx9_test.go:45: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpp728omx9_test.go:45:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074552
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"0\"\n    }\n    if decimal == 1 {\n       \
    \ return \"1\"\n    }\n    if decimal == 2 {\n        return \"10\"\n    }\n \
    \   if decimal == 3 {\n        return \"11\"\n    }\n    if decimal == 4 {\n \
    \       return \"100\"\n    }\n    if decimal == 5 {\n        return \"101\"\n\
    \    }\n    if decimal == 6 {\n        return \"110\"\n    }\n    if decimal ==\
    \ 7 {\n        return \"111\"\n    }\n    if decimal == 8 {\n        return \"\
    1000\"\n    }\n    if decimal == 9 {\n        return \"1001\"\n    }\n    if decimal\
    \ == 10 {\n        return \"1010\"\n    }\n    if decimal == 11 {\n        return\
    \ \"1011\"\n    }\n    if decimal == 12 {\n        return \"1100\"\n    }\n  \
    \  if decimal == 13 {\n        return \"1101\"\n    }\n    if decimal == 14 {\n\
    \        return \"1110\"\n    }\n    if decimal == 15 {\n        return \"1111\"\
    \n    }\n    if decimal == 16 {\n        return \"10000\"\n    }\n    if decimal\
    \ == 17 {\n        return \"10001\"\n    }\n    if decimal == 18 {\n        return\
    \ \"10010\"\n    }\n    if decimal == 19 {\n        return \"10011\"\n    }\n\
    \    if decimal == 20 {\n        return \"10100\"\n    }\n    if decimal == 21\
    \ {\n        return \"10101\"\n    }\n    if decimal == 22 {\n        return \"\
    10110\"\n    }\n    if decimal == 23 {\n        return \"10111\"\n    }\n    if\
    \ decimal == 24 {\n        return \"11000\"\n    }\n    if decimal == 25 {\n \
    \       return \"11001\"\n    }\n    if decimal == 26 {\n        return \"11010\"\
    \n    }\n    if decimal == 27 {\n        return \"11011\"\n    }\n    if decimal\
    \ == 28 {\n        return \"11100\"\n    }\n    if decimal == 29 {\n        return\
    \ \"11101\"\n    }\n    if decimal == 30 {\n        return \"11110\"\n    }\n\
    \    if decimal == 31 {\n        return \"11111\"\n    }\n    if decimal == 32\
    \ {\n        return \"100000\"\n    }\n    if decimal == 33 {\n        return\
    \ \"100001\"\n    }\n    if decimal == 34 {\n        return \"100010\"\n    }\n\
    \    if decimal == 35 {\n        return \"100011\"\n    }\n    if decimal == 36\
    \ {\n        return \"100100\"\n    }\n    if decimal == 37 {\n        return\
    \ \"100101\"\n    }\n    if decimal == 38 {\n        return \"100110\"\n    }\n\
    \    if decimal == 39 {\n        return \"100111\"\n    }\n    if decimal == 40\
    \  {\n        return \"101000\"\n    }\n    if decimal == 41 {\n        return\
    \ \"101001\"\n    }\n    if decimal == 42 {\n        return \"101010\"\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfeff4svc_test.go:144:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074551
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \   }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"\
    1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"\
    1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeztbz97u_test.go:135:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074551
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"1\"\n        temp--\n    }\n    result += \"db\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmphxonspac_test.go:42: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmphxonspac_test.go:42:\
    \ expected 'db100000db', got '11111111111111111111111111111111db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmphxonspac_test.go:42: expected\
    \ 'db1100111db', got '1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmphxonspac_test.go:42:\
    \ expected 'db1111db', got '111111111111111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074552
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal < 0 {\n        fmt.Println(\"Negative numbers are not allowed\")\n \
    \   }\n    binary := make([]byte, 32)\n    decimalToBinary := make([]byte, 32)\n\
    \    decimalToBinary[0] = '1'\n    decimalToBinary[1] = '0'\n    decimalToBinary[2]\
    \ = '0'\n    decimalToBinary[3] = '0'\n    decimalToBinary[4] = '0'\n    decimalToBinary[5]\
    \ = '0'\n    decimalToBinary[6] = '0'\n    decimalToBinary[7] = '0'\n    decimalToBinary[8]\
    \ = '0'\n    decimalToBinary[9] = '0'\n    decimalToBinary[10] = '0'\n    decimalToBinary[11]\
    \ = '0'\n    decimalToBinary[12] = '0'\n    decimalToBinary[13] = '0'\n    decimalToBinary[14]\
    \ = '0'\n    decimalToBinary[15] = '0'\n    decimalToBinary[16] = '0'\n    decimalToBinary[17]\
    \ = '0'\n    decimalToBinary[18] = '0'\n    decimalToBinary[19] = '0'\n    decimalToBinary[20]\
    \ = '0'\n    decimalToBinary[21] = '0'\n    decimalToBinary[22] = '0'\n    decimalToBinary[23]\
    \ = '0'\n    decimalToBinary[24] = '0'\n    decimalToBinary[25] = '0'\n    decimalToBinary[26]\
    \ = '0'\n    decimalToBinary[27] = '0'\n    decimalToBinary[28] = '0'\n    decimalToBinary[29]\
    \ = '0'\n    decimalToBinary[30] = '0'\n    decimalToBinary[31] = '0'\n    decimalToBinary[32]\
    \ = '0'\n    decimalToBinary[33] = '0'\n    decimalToBinary[34] = '0'\n    decimalToBinary[35]\
    \ = '0'\n    decimalToBinary[36] = '0'\n    decimalToBinary[37] = '0'\n    decimalToBinary[38]\
    \ = '0'\n    decimalToBinary[39] = '0'\n    decimalToBinary[40] = '0'\n    decimalToBinary[41]\
    \ = '0'\n    decimalToBinary[42] = '0'\n    decimalToBinary[43] = '0'\n    decimalToBinary[44]\
    \ = '0'\n    decimalToBinary[45] = '0'\n    decimalToBinary[46] = '0'\n    decimalToBinary[47]\
    \ = '0'\n    decimalToBinary[48] = '0'\n    decimalToBinary[49] = '0'\n    decimalToBinary[50]\
    \ = '0'\n    decimalToBinary[51] = '0'\n    decimalToBinary[52] = '0'\n    decimalToBinary[53]\
    \ = '0'\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkc6o74cf_test.go:74:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074551
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    switch decimal {\n    case 0:\n        binaryString = \"0\"\n \
    \   case 1:\n        binaryString = \"1\"\n    case -1:\n        binaryString\
    \ = \"-1\"\n    }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8dzf28y4_test.go:43: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8dzf28y4_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp8dzf28y4_test.go:43: expected 'db1100111db', got 'db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8dzf28y4_test.go:43:\
    \ expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimalToBinary := make([]int, 10)\n    decimalToBinary[0] = 1\n\
    \    decimalToBinary[1] = 1\n    decimalToBinary[2] = 1\n    decimalToBinary[3]\
    \ = 1\n    decimalToBinary[4] = 1\n    decimalToBinary[5] = 1\n    decimalToBinary[6]\
    \ = 1\n    decimalToBinary[7] = 1\n    decimalToBinary[8] = 1\n    decimalToBinary[9]\
    \ = 1\n    decimalToBinary[10] = 1\n    decimalToBinary[11] = 1\n    decimalToBinary[12]\
    \ = 1\n    decimalToBinary[13] = 1\n    decimalToBinary[14] = 1\n    decimalToBinary[15]\
    \ = 1\n    decimalToBinary[16] = 1\n    decimalToBinary[17] = 1\n    decimalToBinary[18]\
    \ = 1\n    decimalToBinary[19] = 1\n    decimalToBinary[20] = 1\n    decimalToBinary[21]\
    \ = 1\n    decimalToBinary[22] = 1\n    decimalToBinary[23] = 1\n    decimalToBinary[24]\
    \ = 1\n    decimalToBinary[25] = 1\n    decimalToBinary[26] = 1\n    decimalToBinary[27]\
    \ = 1\n    decimalToBinary[28] = 1\n    decimalToBinary[29] = 1\n    decimalToBinary[30]\
    \ = 1\n    decimalToBinary[31] = 1\n    decimalToBinary[32] = 1\n    decimalToBinary[33]\
    \ = 1\n    decimalToBinary[34] = 1\n    decimalToBinary[35] = 1\n    decimalToBinary[36]\
    \ = 1\n    decimalToBinary[37] = 1\n    decimalToBinary[38] = 1\n    decimalToBinary[39]\
    \ = 1\n    decimalToBinary[40] = 1\n    decimalToBinary[41] = 1\n    decimalToBinary[42]\
    \ = 1\n    decimalToBinary[43] = 1\n    decimalToBinary[44] = 1\n    decimalToBinary[45]\
    \ = 1\n    decimalToBinary[46] = 1\n    decimalToBinary[47] = 1\n    decimalToBinary[48]\
    \ = 1\n    decimalToBinary[49] = 1\n    decimalToBinary[50] = 1\n    decimalToBinary[51]\
    \ = 1\n    decimalToBinary[52] = 1\n    decimalToBinary[53] = 1\n    decimalToBinary[54]\
    \ = 1\n    decimalToBinary[55] = 1\n    decimalToBinary[56] = 1\n    decimalToBinary[57]\
    \ = 1\n    decimalToBinary[58] = 1\n    decimalToBinary[59] = 1\n    decimalToBinary[60]\
    \ = 1\n    decimalToBinary[61] = 1\n    decimalToBinary[62] = 1\n    decimalToBinary\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9az9xygi_test.go:81:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    i := 0\n    for i < len(decimal) {\n\
    \        if decimal[i] > 0 {\n            result += \"1\"\n        } else {\n\
    \            result += \"0\"\n        }\n        i++\n    }\n    return \"db\"\
    \ + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvs5qx2zi_test.go:18:17: invalid argument: decimal (variable of type int)
    for len

    /tmp/tmpvs5qx2zi_test.go:19:19: invalid operation: cannot index decimal (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    decimalToBinary := decimal\n    for decimalToBinary > 0 {\n   \
    \     binaryString += fmt.Sprintf(\"%v\", decimalToBinary%2)\n        decimalToBinary\
    \ = decimalToBinary/2\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpntd7oydy_test.go:40: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpntd7oydy_test.go:40: expected\
    \ 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpntd7oydy_test.go:40: expected 'db1100111db', got '1110011'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpntd7oydy_test.go:40:\
    \ expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    if decimal < 0 {\n        fmt.Println(\"Negative numbers are not\
    \ allowed\")\n    }\n    if decimal > 0 {\n        result += \"1\"\n    }\n  \
    \  for i := 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n           \
    \ result += fmt.Sprintf(\"%d\", decimal%2)\n        } else {\n            result\
    \ += fmt.Sprintf(\"%d\", decimal%2)\n        }\n        decimal /= 2\n    }\n\
    \    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptnd4bp0h_test.go:50: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptnd4bp0h_test.go:50:\
    \ expected 'db100000db', got '10000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptnd4bp0h_test.go:50: expected 'db1100111db', got '111100db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptnd4bp0h_test.go:50:\
    \ expected 'db1111db', got '1111db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp = temp / 2\n    }\n    result += \"db\"\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp30_9sqrl_test.go:41: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp30_9sqrl_test.go:41:\
    \ expected 'db100000db', got '000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp30_9sqrl_test.go:41: expected 'db1100111db', got '0000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp30_9sqrl_test.go:41:\
    \ expected 'db1111db', got '0000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Write your code here\n    result := \"\"\n    switch decimal {\n    case 0:\n\
    \        result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n \
    \       fmt.Println(\"Invalid input\")\n    }\n    return \"db\" + result\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpqjcem37w_test.go:44:\
    \ expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpqjcem37w_test.go:44: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpqjcem37w_test.go:44:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpqjcem37w_test.go:44: expected 'db1111db', got 'db'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    switch decimal {\n    case 0:\n    \
    \    result = \"0\"\n    case 1:\n        result = \"1\"\n    case 2:\n      \
    \  result = \"10\"\n    case 3:\n        result = \"11\"\n    case 4:\n      \
    \  result = \"100\"\n    case 5:\n        result = \"101\"\n    case 6:\n    \
    \    result = \"110\"\n    case 7:\n        result = \"111\"\n    case 8:\n  \
    \      result = \"1000\"\n    case 9:\n        result = \"1001\"\n    case 10:\n\
    \        result = \"1010\"\n    case 11:\n        result = \"1011\"\n    case\
    \ 12:\n        result = \"1100\"\n    case 13:\n        result = \"1101\"\n  \
    \  case 14:\n        result = \"1110\"\n    case 15:\n        result = \"1111\"\
    \n    default:\n        fmt.Println(\"Invalid input\")\n    }\n    return \"db\"\
    \ + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary (0.00s)\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpmhb15sr6_test.go:72:\
    \ expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpmhb15sr6_test.go:72: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpmhb15sr6_test.go:72:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpmhb15sr6_test.go:72: expected 'db1111db', got 'db1111'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal % 2\n    decimal /= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += fmt.Sprintf(\"%d\", temp)\n        temp = temp * 2\n\
    \    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpdmy8fb_h_test.go:42: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpdmy8fb_h_test.go:42:\
    \ expected 'db100000db', got '0000000000000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpdmy8fb_h_test.go:42: expected 'db1100111db', got '124816326412825651210242048409681921638432768655361310722621445242881048576209715241943048388608167772163355443267108864134217728268435456536870912107374182421474836484294967296858993459217179869184343597383686871947673613743895347227487790694454975581388810995116277762199023255552439804651110487960930222081759218604441635184372088832703687441776641407374883553282814749767106565629499534213121125899906842624db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpdmy8fb_h_test.go:42:\
    \ expected 'db1111db', got '1248163264db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal\n    temp /= 2\n   \
    \ for temp > 0 {\n        result += fmt.Sprintf(\"%c\", temp%2)\n        temp\
    \ /= 2\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpu3sqldcn_test.go:42: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpu3sqldcn_test.go:42:\
    \ expected 'db100000db', got 'db\0\0\0\0\x01'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpu3sqldcn_test.go:42: expected 'db1100111db', got 'db\x01\
    \x01\0\0\x01\x01'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n \
    \       tmpu3sqldcn_test.go:42: expected 'db1111db', got 'db\x01\x01\x01'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    result += \"1\"\
    \n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result +=\
    \ \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptx7xmuca_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \       decimal--\n    }\n    for i := 0; i < decimal; i++ {\n        binary +=\
    \ \"0\"\n    }\n    return binary + \"db\" + binary\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8dg3mvtf_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8dg3mvtf_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp8dg3mvtf_test.go:43: expected 'db1100111db', got '1db1'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8dg3mvtf_test.go:43:\
    \ expected 'db1111db', got '1db1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal /= 2\n    for ; decimal > 0; decimal-- {\n        result\
    \ += \"1\"\n    }\n    result += \"0\"\n    result += \"db\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp0uz3tojb_test.go:41: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp0uz3tojb_test.go:41:\
    \ expected 'db100000db', got '11111111111111110db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp0uz3tojb_test.go:41: expected 'db1100111db', got '1111111111111111111111111111111111111111111111111110db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp0uz3tojb_test.go:41:\
    \ expected 'db1111db', got '11111110db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \       decimal -= 1\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpa32z1u8y_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa32z1u8y_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpa32z1u8y_test.go:43: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa32z1u8y_test.go:43:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal % 2 == 0 {\n        result += \"1\"\n    } else {\n   \
    \     result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpk3kmdp92_test.go:44: expected 'db0db', got '1'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpk3kmdp92_test.go:44:\
    \ expected 'db100000db', got '1'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpk3kmdp92_test.go:44: expected 'db1100111db', got '10'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk3kmdp92_test.go:44:\
    \ expected 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"0\"\n    }\n    binary := make([]byte, 32)\n\
    \    binary[0] = '1'\n    binary[1] = '0'\n    binary[2] = '0'\n    binary[3]\
    \ = '0'\n    binary[4] = '0'\n    binary[5] = '0'\n    binary[6] = '0'\n    binary[7]\
    \ = '0'\n    binary[8] = '0'\n    binary[9] = '0'\n    binary[10] = '0'\n    binary[11]\
    \ = '0'\n    binary[12] = '0'\n    binary[13] = '0'\n    binary[14] = '0'\n  \
    \  binary[15] = '0'\n    binary[16] = '0'\n    binary[17] = '0'\n    binary[18]\
    \ = '0'\n    binary[19] = '0'\n    binary[20] = '0'\n    binary[21] = '0'\n  \
    \  binary[22] = '0'\n    binary[23] = '0'\n    binary[24] = '0'\n    binary[25]\
    \ = '0'\n    binary[26] = '0'\n    binary[27] = '0'\n    binary[28] = '0'\n  \
    \  binary[29] = '0'\n    binary[30] = '0'\n    binary[31] = '1'\n    binary[32]\
    \ = '0'\n    binary[33] = '0'\n    binary[34] = '0'\n    binary[35] = '0'\n  \
    \  binary[36] = '0'\n    binary[37] = '0'\n    binary[38] = '0'\n    binary[39]\
    \ = '0'\n    binary[40] = '0'\n    binary[41] = '0'\n    binary[42] = '0'\n  \
    \  binary[43] = '0'\n    binary[44] = '0'\n    binary[45] = '0'\n    binary[46]\
    \ = '0'\n    binary[47] = '0'\n    binary[48] = '0'\n    binary[49] = '0'\n  \
    \  binary[50] = '0'\n    binary[51] = '0'\n    binary[52] = '0'\n    binary[53]\
    \ = '0'\n    binary[54] = '0'\n    binary[55] = '0'\n    binary[56] = '0'\n  \
    \  binary[57] = '0'\n    binary[58] = '0'\n    binary[59] = '0'\n    binary[60]\
    \ = '0'\n    binary[61] = '0'\n    binary[62] = '0'\n    binary[63] = '0'\n  \
    \  binary[64] = '0'\n    binary[65] = '0'\n    binary[66] = '0'\n    binary[67]\
    \ = '0'\n    binary[68] = '0'\n    binary[69] = '0'\n    binary[70] = '0'\n  \
    \  binary[71] = '0'\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm9ujzh8t_test.go:92:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074552
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal\n    for i := 0; i <\
    \ len(strconv.Itoa(temp)); i++ {\n        result += \"0\"\n    }\n    temp = temp\
    \ / 2\n    for i := 0; i < len(strconv.Itoa(temp)); i++ {\n        result += \"\
    1\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6uf3_ikf_test.go:18:25: undefined: strconv

    /tmp/tmp6uf3_ikf_test.go:22:25: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpdb20m4os_test.go:43:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpdb20m4os_test.go:43: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    switch decimal {\n    case 0:\n    \
    \    result = \"0\"\n    case 1:\n        result = \"1\"\n    }\n    return result\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpk0nq8mt6_test.go:42: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpk0nq8mt6_test.go:42:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpk0nq8mt6_test.go:42: expected 'db1100111db', got 'db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk0nq8mt6_test.go:42:\
    \ expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074554
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"0\"\n    }\n    binary := \"\"\n    decimal\
    \ %= 2\n    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n\
    \    for i := 0; i < decimal; i++ {\n        binary += \"0\"\n    }\n    return\
    \ binary + \"db\" + decimal_to_binary(decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpu41pdld2_test.go:46: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpu41pdld2_test.go:46:\
    \ expected 'db100000db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpu41pdld2_test.go:46: expected 'db1100111db', got '1db0'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpu41pdld2_test.go:46:\
    \ expected 'db1111db', got '1db0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074554
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal -= 1\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6pk5uqs1_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6pk5uqs1_test.go:44:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6pk5uqs1_test.go:44: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6pk5uqs1_test.go:44:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \       decimal -= 1\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpa32z1u8y_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa32z1u8y_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpa32z1u8y_test.go:43: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa32z1u8y_test.go:43:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \   }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"\
    1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"\
    1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeztbz97u_test.go:135:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074551
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    i := 0\n    for i < decimal {\n    \
    \    if decimal%2 == 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \        } else {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n    \
    \    }\n        decimal /= 2\n        i++\n    }\n    result += \"db\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpep6kaa7m_test.go:47: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpep6kaa7m_test.go:47:\
    \ expected 'db100000db', got '\0\0\0\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpep6kaa7m_test.go:47: expected 'db1100111db', got '\x01\x01\
    \x01\0\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n       \
    \ tmpep6kaa7m_test.go:47: expected 'db1111db', got '\x01\x01\x01db'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074554
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    result += \"1\"\
    \n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result +=\
    \ \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptx7xmuca_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Printf(\"%v\", decimal)\n\
    \    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n \
    \ candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "3210315--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptzqk0crs_test.go:43: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptzqk0crs_test.go:43:\
    \ expected 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptzqk0crs_test.go:43: expected 'db1100111db', got ''\n  \
    \  --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptzqk0crs_test.go:43:\
    \ expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074554
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"1\"\n        temp--\n    }\n    return \"db\" + result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpc7ueldol_test.go:41: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpc7ueldol_test.go:41:\
    \ expected 'db100000db', got 'db11111111111111111111111111111111'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpc7ueldol_test.go:41: expected\
    \ 'db1100111db', got 'db1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpc7ueldol_test.go:41:\
    \ expected 'db1111db', got 'db111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    switch decimal {\n    case 0:\n        binaryString = \"0\"\n \
    \   case 1:\n        binaryString = \"1\"\n    default:\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp8i8ha4hb_test.go:43:\
    \ expected 'db0db', got '0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp8i8ha4hb_test.go:43: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp8i8ha4hb_test.go:43:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmp8i8ha4hb_test.go:43: expected 'db1111db', got 'db'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074555
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    i := 0\n    for {\n        if decimal < 2 {\n            break\n\
    \        }\n        decimal /= 2\n        result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \        i++\n    }\n    result += \"db\"\n    for i := 0; i < len(result); i++\
    \ {\n        if result[i] == '0' {\n            result[i] = '1'\n        } else\
    \ {\n            result[i] = '0'\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2av3ao02_test.go:28:13: cannot assign to result[i] (value of type byte)

    /tmp/tmp2av3ao02_test.go:30:13: cannot assign to result[i] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074554
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp--\n    }\n    for temp > 0 {\n        result += \"1\"\n        temp--\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyuw_9302_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpyuw_9302_test.go:44: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal -= 1\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6pk5uqs1_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6pk5uqs1_test.go:44:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6pk5uqs1_test.go:44: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6pk5uqs1_test.go:44:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \       decimal -= 1\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\" + binary\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiffvyuqn_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiffvyuqn_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpiffvyuqn_test.go:43: expected 'db1100111db', got '1db1'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiffvyuqn_test.go:43:\
    \ expected 'db1111db', got '1db1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz5etizy2_test.go:113:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Write your code here\n    result := \"\"\n    i := 0\n    for i < decimal {\n\
    \        if decimal % 2 == 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \        }\n        decimal /= 2\n        i++\n    }\n    if decimal > 0 {\n \
    \       result += fmt.Sprintf(\"%c\", decimal%2)\n    }\n    result += \"db\"\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp1kx8qwzw_test.go:48: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp1kx8qwzw_test.go:48:\
    \ expected 'db100000db', got '\0\0\0\0\0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp1kx8qwzw_test.go:48: expected 'db1100111db', got '\0\0\x01\
    db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp1kx8qwzw_test.go:48:\
    \ expected 'db1111db', got '\x01db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    if decimal < 0 {\n        result += \"0\"\
    \n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyshcjvx3_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyshcjvx3_test.go:44:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpyshcjvx3_test.go:44: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyshcjvx3_test.go:44:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    case 2:\n        result = \"10\"\n    case 3:\n\
    \        result = \"11\"\n    case 4:\n        result = \"100\"\n    case 5:\n\
    \        result = \"101\"\n    case 6:\n        result = \"110\"\n    case 7:\n\
    \        result = \"111\"\n    case 8:\n        result = \"1000\"\n    case 9:\n\
    \        result = \"1001\"\n    case 10:\n        result = \"1010\"\n    case\
    \ 11:\n        result = \"1011\"\n    case 12:\n        result = \"1100\"\n  \
    \  case 13:\n        result = \"1101\"\n    case 14:\n        result = \"1110\"\
    \n    case 15:\n        result = \"1111\"\n    default:\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary (0.00s)\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmprvolp0eb_test.go:71:\
    \ expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmprvolp0eb_test.go:71: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmprvolp0eb_test.go:71:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmprvolp0eb_test.go:71: expected 'db1111db', got 'db1111'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    switch decimal {\n    case 0:\n        binaryString = \"0\"\n \
    \   case 1:\n        binaryString = \"1\"\n    default:\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnfj6zxux_test.go:43:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpnfj6zxux_test.go:43: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnfj6zxux_test.go:43: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpnfj6zxux_test.go:43: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074555
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    i := 0\n    for ; i < len(decimal);\
    \ i++ {\n        if decimal%2 == 0 {\n            result += fmt.Sprintf(\"%c\"\
    , decimal%2)\n        }\n        decimal /= 2\n    }\n    result += \"db\"\n \
    \   return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmposk69l9i_test.go:18:19: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n   \
    \ result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjwqdwh_i_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074546
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    if decimal < 2 {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    for i := 0; i < decimal; i++ {\n        result += \"0\"\n    }\n    for i\
    \ := decimal; i > 0; i-- {\n        result += \"1\"\n    }\n    return \"db\"\
    \ + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\n--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpar4uznhw_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpar4uznhw_test.go:44:\
    \ expected 'db100000db', got 'db0000000000000000000000000000000011111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpar4uznhw_test.go:44:\
    \ expected 'db1100111db', got 'db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpar4uznhw_test.go:44:\
    \ expected 'db1111db', got 'db000000000000000111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074556
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    var remainder int\n    var i int\n    for i = 0; i < 8; i++\
    \ {\n        remainder = decimal % 2\n        decimal = decimal / 2\n        if\
    \ remainder == 0 {\n            result = \"0\" + result\n        } else {\n  \
    \          result = \"1\" + result\n        }\n    }\n    return \"db\" + result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpe64b99ld_test.go:46: expected 'db0db', got 'db00000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpe64b99ld_test.go:46:\
    \ expected 'db100000db', got 'db00100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpe64b99ld_test.go:46: expected 'db1100111db', got 'db01100111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpe64b99ld_test.go:46:\
    \ expected 'db1111db', got 'db00001111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074556
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal < 0 || decimal > 100 {\n        fmt.Println(\"Invalid input\")\n   \
    \ }\n    binary := \"\"\n    decimal %= 10\n    for i := 0; i < len(decimal);\
    \ i++ {\n        binary += string(decimal%2)\n        decimal /= 10\n    }\n \
    \   binary += \"db\"\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxgia0zfi_test.go:20:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binary\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprsuskbi__test.go:101:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074546
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    if decimal < 2 {\n        return fmt.Sprintf(\"%d\", decimal)\n\
    \    }\n    decimal /= 2\n    for i := 0; i < len(decimal_to_binary_test); i++\
    \ {\n        if decimal >= decimal_to_binary_test[i] {\n            result +=\
    \ decimal_to_binary_test[i]\n            decimal -= decimal_to_binary_test[i]\n\
    \        }\n    }\n    return result + \"db\" + decimal_to_binary(decimal)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3tliik3_test.go:20:25: undefined: decimal_to_binary_test

    /tmp/tmph3tliik3_test.go:21:23: undefined: decimal_to_binary_test

    /tmp/tmph3tliik3_test.go:22:23: undefined: decimal_to_binary_test

    /tmp/tmph3tliik3_test.go:23:24: undefined: decimal_to_binary_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    for i := 0; i <\
    \ decimal; i++ {\n        result += \"1\"\n    }\n    result += \"db\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpe3nhjw4h_test.go:41: expected 'db0db', got '0db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpe3nhjw4h_test.go:41:\
    \ expected 'db100000db', got '011111111111111111111111111111111db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpe3nhjw4h_test.go:41: expected\
    \ 'db1100111db', got '01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpe3nhjw4h_test.go:41:\
    \ expected 'db1111db', got '0111111111111111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"0\"\n    }\n    binary := make([]byte, 32)\n\
    \    i := 0\n    for decimal&1 == 1 {\n        binary[i] = '1'\n        decimal\
    \ = decimal >> 1\n        i++\n    }\n    for decimal&1 == 0 {\n        binary[i]\
    \ = '0'\n        decimal = decimal >> 1\n        i++\n    }\n    return string(binary)\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmpc1pks06p_test.go:26\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmpc1pks06p_test.go:43\
    \ +0x414\ntesting.tRunner(0xc0000da340, 0x527f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074556
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    result += \"0\"\
    \n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result +=\
    \ \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpai3w7fqg_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal\n    for temp > 0 {\n\
    \        result += \"1\"\n        temp--\n    }\n    return \"db\" + result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpc7ueldol_test.go:41: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpc7ueldol_test.go:41:\
    \ expected 'db100000db', got 'db11111111111111111111111111111111'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpc7ueldol_test.go:41: expected\
    \ 'db1100111db', got 'db1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpc7ueldol_test.go:41:\
    \ expected 'db1111db', got 'db111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    switch decimal {\n    case 0:\n    \
    \    result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n     \
    \   fmt.Println(\"Invalid input\")\n    }\n    return \"db\" + result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpk0efht_s_test.go:44:\
    \ expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpk0efht_s_test.go:44: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpk0efht_s_test.go:44:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpk0efht_s_test.go:44: expected 'db1111db', got 'db'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \       decimal -= 1\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpa32z1u8y_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa32z1u8y_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpa32z1u8y_test.go:43: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa32z1u8y_test.go:43:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    if decimal < 2 {\n        return fmt.Sprintf(\"%d\", decimal)\n\
    \    }\n    decimal /= 2\n    for i := 0; i < len(decimal_to_binary_test); i++\
    \ {\n        if decimal >= decimal_to_binary_test[i].decimals {\n            result\
    \ += decimal_to_binary_test[i].binary\n            decimal -= decimal_to_binary_test[i].decimals\n\
    \        } else {\n            result += decimal_to_binary_test[i].decimal_to_binary\n\
    \        }\n    }\n    return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyzoyyrv3_test.go:20:25: undefined: decimal_to_binary_test

    /tmp/tmpyzoyyrv3_test.go:21:23: undefined: decimal_to_binary_test

    /tmp/tmpyzoyyrv3_test.go:22:23: undefined: decimal_to_binary_test

    /tmp/tmpyzoyyrv3_test.go:23:24: undefined: decimal_to_binary_test

    /tmp/tmpyzoyyrv3_test.go:25:23: undefined: decimal_to_binary_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \   }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        binary += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        binary += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    binary += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        binary\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"\
    0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        binary += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        binary += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    binary += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        binary\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"\
    0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        binary += \"0\"\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnpff2dii_test.go:135:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    if decimal < 2 {\n        return fmt.Sprintf(\"%d\", decimal)\n\
    \    }\n    decimal /= 2\n    for i := 0; i < len(decimal); i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"1\"\n    result += \"db\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9fkc0cth_test.go:20:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074556
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    if decimal < 2 {\n        return fmt.Sprintf(\"%d\", decimal)\n\
    \    }\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal /= 2\n    result +=\
    \ \"b\"\n    decimal /= 2\n    result += \"b\"\n    decimal \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi0v38pui_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"db\"\n    result += \"0\"\
    \n    for i := 0; i < decimal; i++ {\n        if decimal % 2 == 0 {\n        \
    \    result += fmt.Sprintf(\"%d\", decimal)\n        } else {\n            result\
    \ += fmt.Sprintf(\"%d\", decimal/2)\n        }\n    }\n    result += \"db\"\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpk8cc5m3t_test.go:46: expected 'db100000db', got 'db03232323232323232323232323232323232323232323232323232323232323232db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpk8cc5m3t_test.go:46:\
    \ expected 'db1100111db', got 'db051515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk8cc5m3t_test.go:46:\
    \ expected 'db1111db', got 'db0777777777777777db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074556
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpdb20m4os_test.go:43:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpdb20m4os_test.go:43: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    result += \"0\"\
    \n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result +=\
    \ \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpai3w7fqg_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    decimal %= \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz5etizy2_test.go:113:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp--\n    }\n    temp = decimal\n    for temp > 0 {\n        result\
    \ += \"1\"\n        temp--\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpih_pu0yq_test.go:45: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpih_pu0yq_test.go:45: expected\
    \ 'db100000db', got '0000000000000000000000000000000011111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpih_pu0yq_test.go:45:\
    \ expected 'db1100111db', got '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpih_pu0yq_test.go:45:\
    \ expected 'db1111db', got '000000000000000111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074556
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for i := 0; i < len(decimal); i++ {\n        if decimal%2\
    \ == 0 {\n            binary += \"1\"\n        } else {\n            binary +=\
    \ \"0\"\n        }\n        decimal /= 2\n    }\n    return \"db\" + binary +\
    \ \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ahvt413_test.go:16:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074556
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    i := 0\n    for ; i < len(decimal); i++ {\n        if decimal%2\
    \ == 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n        } else\
    \ {\n            result += fmt.Sprintf(\"%c\", '0')\n        }\n        decimal\
    \ /= 2\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp0hcb663_test.go:17:19: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074556
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    binaryString += \"0\"\n    for i := 0; i < decimal; i++ {\n   \
    \     binaryString += \"1\"\n    }\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3v0yhj6n_test.go:39: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp3v0yhj6n_test.go:39:\
    \ expected 'db100000db', got '011111111111111111111111111111111'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp3v0yhj6n_test.go:39: expected\
    \ 'db1100111db', got '01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp3v0yhj6n_test.go:39:\
    \ expected 'db1111db', got '0111111111111111'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp = temp / 2\n    }\n    result += \"db\"\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp30_9sqrl_test.go:41: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp30_9sqrl_test.go:41:\
    \ expected 'db100000db', got '000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp30_9sqrl_test.go:41: expected 'db1100111db', got '0000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp30_9sqrl_test.go:41:\
    \ expected 'db1111db', got '0000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal); i++ {\n       \
    \ if decimal >= 2 {\n            result += fmt.Sprintf(\"%d\", decimal%2)\n  \
    \          decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    0%d\", decimal%2)\n            decimal = 0\n        }\n    }\n    return \"db\"\
    \ + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdncy285w_test.go:17:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074556
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    decimalToBinary := decimal / 2\n    decimalToBinary = decimalToBinary\
    \ % 2\n    binaryString = fmt.Sprintf(\"%c\", decimalToBinary)\n    decimalToBinary\
    \ = decimal - decimalToBinary\n    binaryString = binaryString + fmt.Sprintf(\"\
    %c\", decimalToBinary)\n    return binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpqzn_opjo_test.go:40: expected 'db0db', got '\0\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpqzn_opjo_test.go:40:\
    \ expected 'db100000db', got '\0 '\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpqzn_opjo_test.go:40: expected 'db1100111db', got '\x01f'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpqzn_opjo_test.go:40:\
    \ expected 'db1111db', got '\x01\x0E'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \       decimal--\n    }\n    for i := 0; i < decimal; i++ {\n        binary +=\
    \ \"0\"\n    }\n    return binary + \"db\" + binary\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8dg3mvtf_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8dg3mvtf_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp8dg3mvtf_test.go:43: expected 'db1100111db', got '1db1'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8dg3mvtf_test.go:43:\
    \ expected 'db1111db', got '1db1'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"0\"\n    }\n    binary := \"\"\n    decimal\
    \ %= 2\n    for i := 0; i < len(decimal); i++ {\n        if decimal > 0 {\n  \
    \          binary += \"1\"\n            decimal -= 1\n        } else {\n     \
    \       binary += \"0\"\n        }\n    }\n    return \"db\" + binary + \"0\"\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_no0it_k_test.go:20:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    result += \"1\"\
    \n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result +=\
    \ \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk66zhfbg_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074556
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    base := 2\n    for i := 0; i < decimal; i++ {\n        result +=\
    \ \"0\"\n    }\n    for i := decimal; i > 0; i-- {\n        result += \"1\"\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmhutvgxu_test.go:16:5: base declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binaryString += \"0\"\n    binaryString += \"1\"\n    binaryString\
    \ += \"0\"\n    binaryString += \"1\"\n    binaryString += \"0\"\n    binaryString\
    \ += \"1\"\n    binary\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprsuskbi__test.go:101:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074546
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    result += \"0\"\
    \n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result +=\
    \ \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpai3w7fqg_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp--\n    }\n    for temp > 0 {\n        result += \"1\"\n        temp--\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyuw_9302_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpyuw_9302_test.go:44: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074549
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"0\"\n    }\n    result := \"\"\n    decimal\
    \ /= 2\n    for i := 0; i < len(decimal); i++ {\n        if decimal % 2 == 0 {\n\
    \            result += fmt.Sprintf(\"%c\", '0')\n        } else {\n          \
    \  result += fmt.Sprintf(\"%c\", '1')\n        }\n        decimal /= 2\n    }\n\
    \    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_ycz26gv_test.go:20:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpdb20m4os_test.go:43:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpdb20m4os_test.go:43: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"1\"\n\
    \        temp--\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp7riauwzb_test.go:41: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7riauwzb_test.go:41:\
    \ expected 'db100000db', got '11111111111111111111111111111111db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp7riauwzb_test.go:41: expected\
    \ 'db1100111db', got '1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp7riauwzb_test.go:41:\
    \ expected 'db1111db', got '111111111111111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074558
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    base := 2\n    for i := 0; i < decimal; i++ {\n        result +=\
    \ \"0\"\n    }\n    for i := decimal; i > 0; i-- {\n        result += \"1\"\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmhutvgxu_test.go:16:5: base declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpdb20m4os_test.go:43:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpdb20m4os_test.go:43: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpdb20m4os_test.go:43:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpdb20m4os_test.go:43: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal /= 2\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"1\"\n    result += \"db\"\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptlezakcu_test.go:41: expected 'db0db', got '1db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptlezakcu_test.go:41:\
    \ expected 'db100000db', got '00000000000000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptlezakcu_test.go:41: expected 'db1100111db', got '0000000000000000000000000000000000000000000000000001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptlezakcu_test.go:41:\
    \ expected 'db1111db', got '00000001db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074558
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"0\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    \        result += \"1\"\n        decimal /= 2\n    }\n    if decimal > 0 {\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb_4w5i3c_test.go:135:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimalToBinary := make([]int, 10)\n    decimalToBinary[0] = 1\n\
    \    decimalToBinary[1] = 1\n    decimalToBinary[2] = 2\n    decimalToBinary[3]\
    \ = 3\n    decimalToBinary[4] = 4\n    decimalToBinary[5] = 5\n    decimalToBinary[6]\
    \ = 6\n    decimalToBinary[7] = 7\n    decimalToBinary[8] = 8\n    decimalToBinary[9]\
    \ = 9\n    decimalToBinary[10] = 1\n    decimalToBinary[11] = 1\n    decimalToBinary[12]\
    \ = 2\n    decimalToBinary[13] = 3\n    decimalToBinary[14] = 4\n    decimalToBinary[15]\
    \ = 5\n    decimalToBinary[16] = 6\n    decimalToBinary[17] = 7\n    decimalToBinary[18]\
    \ = 8\n    decimalToBinary[19] = 9\n    decimalToBinary[20] = 1\n    decimalToBinary[21]\
    \ = 1\n    decimalToBinary[22] = 2\n    decimalToBinary[23] = 3\n    decimalToBinary[24]\
    \ = 4\n    decimalToBinary[25] = 5\n    decimalToBinary[26] = 6\n    decimalToBinary[27]\
    \ = 7\n    decimalToBinary[28] = 8\n    decimalToBinary[29] = 9\n    decimalToBinary[30]\
    \ = 1\n    decimalToBinary[31] = 1\n    decimalToBinary[32] = 2\n    decimalToBinary[33]\
    \ = 3\n    decimalToBinary[34] = 4\n    decimalToBinary[35] = 5\n    decimalToBinary[36]\
    \ = 6\n    decimalToBinary[37] = 7\n    decimalToBinary[38] = 8\n    decimalToBinary[39]\
    \ = 9\n    decimalToBinary[40] = 1\n    decimalToBinary[41] = 1\n    decimalToBinary[42]\
    \ = 2\n    decimalToBinary[43] = 3\n    decimalToBinary[44] = 4\n    decimalToBinary[45]\
    \ = 5\n    decimalToBinary[46] = 6\n    decimalToBinary[47] = 7\n    decimalToBinary[48]\
    \ = 8\n    decimalToBinary[49] = 9\n    decimalToBinary[50] = 1\n    decimalToBinary[51]\
    \ = 1\n    decimalToBinary[52] = 2\n    decimalToBinary[53] = 3\n    decimalToBinary[54]\
    \ = 4\n    decimalToBinary[55] = 5\n    decimalToBinary[56] = 6\n    decimalToBinary[57]\
    \ = 7\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_tvhk6ob_test.go:76:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp--\n    }\n    for temp > 0 {\n        result += \"1\"\n        temp--\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyuw_9302_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpyuw_9302_test.go:44: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string = \"\"\n    \n    // Your code here\n    \n    return binary\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpsv_776k0_test.go:38: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpsv_776k0_test.go:38: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpsv_776k0_test.go:38: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpsv_776k0_test.go:38: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074558
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp--\n    }\n    for temp > 0 {\n        result += \"1\"\n        temp--\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyuw_9302_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpyuw_9302_test.go:44: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    var remainder int\n    var i int\n\n    // The remainder\
    \ is calculated by dividing the decimal number by the base (2) and\n    // then\
    \ multiplying by 10 and adding it to the remainder. For example, if\n    // the\
    \ decimal number is 5 and the base is 2, then the remainder is 5.\n    remainder\
    \ = decimal / 2\n\n    // The remainder is then divided by 10 and added to the\
    \ remainder for the next digit.\n    for i = 0; i < len(strconv.Itoa(remainder));\
    \ i++ {\n        remainder *= 10\n        remainder += remainder % 2\n    }\n\n\
    \    // The remainder is then divided by 10 and added to the remainder for the\
    \ next digit.\n    for i = 0; i < len(strconv.Itoa(remainder)); i++ {\n      \
    \  remainder *= 10\n        remainder += remainder % 2\n    }\n\n    // The remainder\
    \ is then divided by 10 and added to the remainder for the next digit.\n    for\
    \ i = 0; i < len(strconv.Itoa(remainder)); i++ {\n        remainder *= 10\n  \
    \      remainder += remainder % 2\n    }\n\n    // The remainder is then divided\
    \ by 10 and added to the remainder for the next digit.\n    for i = 0; i < len(strconv.Itoa(remainder));\
    \ i++ {\n        remainder *= 10\n        remainder += remainder % 2\n    }\n\n\
    \    // The remainder is then divided by 10 and added to the remainder for the\
    \ next digit.\n    for i = 0; i < len(strconv.Itoa(remainder)); i++ {\n      \
    \  remainder *= 10\n        remainder += remainder % 2\n    }\n\n    // The remainder\
    \ is then divided by 10 and added to the remainder for the next digit.\n    for\
    \ i = 0; i < len(strconv.Itoa(remainder)); i++ {\n        remainder *= 10\n  \
    \      remainder += remainder % 2\n    }\n\n    // The remainder is then divided\
    \ by 10 and added to the remainder for the next digit.\n    for i = 0; i < len(strconv.Itoa(remainder));\
    \ i++ {\n        remainder *= 10\n        remainder += remainder % 2\n    }\n\n\
    \    // The remainder is then divided by 10 and added to the remainder for the\
    \ next digit.\n    for i = 0; i < len(strconv.Itoa(remainder)); i++ {\n      \
    \  remainder *= 10\n        remainder += remainder % 2\n    }\n\n    // The remainder\
    \ is then divided by 10 and added to the remainder for the next digit.\n    for\
    \ i = 0; i < len(strconv.Itoa(remainder)); i++ {\n        remainder\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2xc38lr5_test.go:75:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    switch decimal {\n    case 0:\n    \
    \    result = \"0\"\n    case 1:\n        result = \"1\"\n    default:\n     \
    \   fmt.Println(\"Error\")\n    }\n    return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Error\nError\nError\n--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpy31almdp_test.go:44: expected\
    \ 'db0db', got '0db'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpy31almdp_test.go:44: expected 'db100000db', got 'db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpy31almdp_test.go:44: expected\
    \ 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpy31almdp_test.go:44: expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074558
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"1\"\n \
    \       decimal /= 2\n    }\n    if decimal > 0 {\n        result += \"0\"\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp07pykggn_test.go:135:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074557
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    result += fmt.Sprintf(\"%c\", decimal)\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfovdn1_8_test.go:40: expected 'db0db', got '\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpfovdn1_8_test.go:40:\
    \ expected 'db100000db', got '\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfovdn1_8_test.go:40: expected 'db1100111db', got '\0\x01\
    '\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpfovdn1_8_test.go:40:\
    \ expected 'db1111db', got '\0\x01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074558
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    base := 2\n    for i := 0; i < decimal; i++ {\n        if decimal\
    \ % base == 0 {\n            result += fmt.Sprintf(\"%c\", decimal % base)\n \
    \       } else {\n            result += fmt.Sprintf(\"%c\", 0)\n        }\n  \
    \      decimal /= base\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpc1gfqb3n_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpc1gfqb3n_test.go:44:\
    \ expected 'db100000db', got 'db\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpc1gfqb3n_test.go:44: expected 'db1100111db', got 'db\0\0\
    \0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpc1gfqb3n_test.go:44:\
    \ expected 'db1111db', got 'db\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074559
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%d\", decimal%2)\n\
    \            decimal /= 2\n        } else {\n            result += fmt.Sprintf(\"\
    %d\", decimal%2)\n            decimal *= 2\n        }\n    }\n    return \"db\"\
    \ + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp27gfgro_test.go:18:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074558
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpdb20m4os_test.go:43:\
    \ expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db100000db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpdb20m4os_test.go:43: expected\
    \ 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n\
    \        tmpdb20m4os_test.go:43: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \   }\n    for i := 0; i < decimal; i++ {\n        binary += \"0\"\n    }\n  \
    \  return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n \
    \ candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp773t9sgs_test.go:42: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp773t9sgs_test.go:42:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp773t9sgs_test.go:42: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp773t9sgs_test.go:42:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimalToBinary := make([]int, 10)\n    decimalToBinary[0] = 1\n\
    \    decimalToBinary[1] = 1\n    decimalToBinary[2] = 1\n    decimalToBinary[3]\
    \ = 1\n    decimalToBinary[4] = 1\n    decimalToBinary[5] = 1\n    decimalToBinary[6]\
    \ = 1\n    decimalToBinary[7] = 1\n    decimalToBinary[8] = 1\n    decimalToBinary[9]\
    \ = 1\n    decimalToBinary[10] = 1\n    decimalToBinary[11] = 1\n    decimalToBinary[12]\
    \ = 1\n    decimalToBinary[13] = 1\n    decimalToBinary[14] = 1\n    decimalToBinary[15]\
    \ = 1\n    decimalToBinary[16] = 1\n    decimalToBinary[17] = 1\n    decimalToBinary[18]\
    \ = 1\n    decimalToBinary[19] = 1\n    decimalToBinary[20] = 1\n    decimalToBinary[21]\
    \ = 1\n    decimalToBinary[22] = 1\n    decimalToBinary[23] = 1\n    decimalToBinary[24]\
    \ = 1\n    decimalToBinary[25] = 1\n    decimalToBinary[26] = 1\n    decimalToBinary[27]\
    \ = 1\n    decimalToBinary[28] = 1\n    decimalToBinary[29] = 1\n    decimalToBinary[30]\
    \ = 1\n    decimalToBinary[31] = 1\n    decimalToBinary[32] = 1\n    decimalToBinary[33]\
    \ = 1\n    decimalToBinary[34] = 1\n    decimalToBinary[35] = 1\n    decimalToBinary[36]\
    \ = 1\n    decimalToBinary[37] = 1\n    decimalToBinary[38] = 1\n    decimalToBinary[39]\
    \ = 1\n    decimalToBinary[40] = 1\n    decimalToBinary[41] = 1\n    decimalToBinary[42]\
    \ = 1\n    decimalToBinary[43] = 1\n    decimalToBinary[44] = 1\n    decimalToBinary[45]\
    \ = 1\n    decimalToBinary[46] = 1\n    decimalToBinary[47] = 1\n    decimalToBinary[48]\
    \ = 1\n    decimalToBinary[49] = 1\n    decimalToBinary[50] = 1\n    decimalToBinary[51]\
    \ = 1\n    decimalToBinary[52] = 1\n    decimalToBinary[53] = 1\n    decimalToBinary[54]\
    \ = 1\n    decimalToBinary[55] = 1\n    decimalToBinary[56] = 1\n    decimalToBinary[57]\
    \ = 1\n    decimalToBinary[58] = 1\n    decimalToBinary[59] = 1\n    decimalToBinary[60]\
    \ = 1\n    decimalToBinary[61] = 1\n    decimalToBinary[62] = 1\n    decimalToBinary\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9az9xygi_test.go:81:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal\n    for i := 0; i <\
    \ len(result); i++ {\n        if temp%2 == 0 {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n        temp /= 2\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2q52awtm_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp2q52awtm_test.go:45:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp2q52awtm_test.go:45: expected 'db1100111db', got 'db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp2q52awtm_test.go:45:\
    \ expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    result += \"db\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpewg6zmxh_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074551
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    decimalToBinary := decimal\n    for decimalToBinary > 0 {\n   \
    \     binaryString += fmt.Sprintf(\"%v\", decimalToBinary%2)\n        decimalToBinary\
    \ /= 2\n    }\n    return binaryString + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpcn5zu153_test.go:40: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpcn5zu153_test.go:40:\
    \ expected 'db100000db', got '000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpcn5zu153_test.go:40: expected 'db1100111db', got '1110011db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpcn5zu153_test.go:40:\
    \ expected 'db1111db', got '1111db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string = \"\"\n    for i := 0; i < 8; i++ {\n        if decimal >= 2\
    \ {\n            binary += \"1\"\n            decimal -= 2\n        } else {\n\
    \            binary += \"0\"\n        }\n    }\n    return binary + \"db\" + binary\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9niau048_test.go:43: expected 'db0db', got '00000000db00000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9niau048_test.go:43:\
    \ expected 'db100000db', got '11111111db11111111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp9niau048_test.go:43: expected 'db1100111db', got '11111111db11111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9niau048_test.go:43:\
    \ expected 'db1111db', got '11111110db11111110'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimalToBinary := make([]int, 10)\n    decimalToBinary[0] = 1\n\
    \    decimalToBinary[1] = 1\n    decimalToBinary[2] = 1\n    decimalToBinary[3]\
    \ = 1\n    decimalToBinary[4] = 1\n    decimalToBinary[5] = 1\n    decimalToBinary[6]\
    \ = 1\n    decimalToBinary[7] = 1\n    decimalToBinary[8] = 1\n    decimalToBinary[9]\
    \ = 1\n    decimalToBinary[10] = 1\n    decimalToBinary[11] = 1\n    decimalToBinary[12]\
    \ = 1\n    decimalToBinary[13] = 1\n    decimalToBinary[14] = 1\n    decimalToBinary[15]\
    \ = 1\n    decimalToBinary[16] = 1\n    decimalToBinary[17] = 1\n    decimalToBinary[18]\
    \ = 1\n    decimalToBinary[19] = 1\n    decimalToBinary[20] = 1\n    decimalToBinary[21]\
    \ = 1\n    decimalToBinary[22] = 1\n    decimalToBinary[23] = 1\n    decimalToBinary[24]\
    \ = 1\n    decimalToBinary[25] = 1\n    decimalToBinary[26] = 1\n    decimalToBinary[27]\
    \ = 1\n    decimalToBinary[28] = 1\n    decimalToBinary[29] = 1\n    decimalToBinary[30]\
    \ = 1\n    decimalToBinary[31] = 1\n    decimalToBinary[32] = 1\n    decimalToBinary[33]\
    \ = 1\n    decimalToBinary[34] = 1\n    decimalToBinary[35] = 1\n    decimalToBinary[36]\
    \ = 1\n    decimalToBinary[37] = 1\n    decimalToBinary[38] = 1\n    decimalToBinary[39]\
    \ = 1\n    decimalToBinary[40] = 1\n    decimalToBinary[41] = 1\n    decimalToBinary[42]\
    \ = 1\n    decimalToBinary[43] = 1\n    decimalToBinary[44] = 1\n    decimalToBinary[45]\
    \ = 1\n    decimalToBinary[46] = 1\n    decimalToBinary[47] = 1\n    decimalToBinary[48]\
    \ = 1\n    decimalToBinary[49] = 1\n    decimalToBinary[50] = 1\n    decimalToBinary[51]\
    \ = 1\n    decimalToBinary[52] = 1\n    decimalToBinary[53] = 1\n    decimalToBinary[54]\
    \ = 1\n    decimalToBinary[55] = 1\n    decimalToBinary[56] = 1\n    decimalToBinary[57]\
    \ = 1\n    decimalToBinary[58] = 1\n    decimalToBinary[59] = 1\n    decimalToBinary[60]\
    \ = 1\n    decimalToBinary[61] = 1\n    decimalToBinary[62] = 1\n    decimalToBinary\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9az9xygi_test.go:81:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    result += fmt.Sprintf(\"%c\", decimal%2)\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpy3xv6_f6_test.go:40: expected 'db0db', got '\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpy3xv6_f6_test.go:40:\
    \ expected 'db100000db', got '\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpy3xv6_f6_test.go:40: expected 'db1100111db', got '\0\x01\
    '\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpy3xv6_f6_test.go:40:\
    \ expected 'db1111db', got '\0\x01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    if decimal < 0 {\n        result += \"0\"\
    \n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyshcjvx3_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyshcjvx3_test.go:44:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpyshcjvx3_test.go:44: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyshcjvx3_test.go:44:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimalToBinary := make([]int, 10)\n    decimalToBinary[0] = 1\n\
    \    decimalToBinary[1] = 1\n    decimalToBinary[2] = 1\n    decimalToBinary[3]\
    \ = 1\n    decimalToBinary[4] = 1\n    decimalToBinary[5] = 1\n    decimalToBinary[6]\
    \ = 1\n    decimalToBinary[7] = 1\n    decimalToBinary[8] = 1\n    decimalToBinary[9]\
    \ = 1\n    decimalToBinary[10] = 1\n\n    for i := 0; i < 10; i++ {\n        decimalToBinary[i]\
    \ = decimalToBinary[(i+1)%10]\n    }\n\n    for i := 0; i < decimal; i++ {\n \
    \       result += \"1\"\n    }\n\n    for i := decimal; i < 10; i++ {\n      \
    \  result += \"0\"\n    }\n\n    result += \"db\"\n    return result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [10] with length 10 [recovered]\n\tpanic: runtime error: index out\
    \ of range [10] with length 10\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(0x56397b?)\n\t/tmp/tmpu09zbo8d_test.go:27\
    \ +0x1b\ncommand-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmpu09zbo8d_test.go:52\
    \ +0x42\ntesting.tRunner(0xc0000da340, 0x527f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal < 2 {\n        result += \"0\"\n    }\n    return result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp69whmfe1_test.go:42: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp69whmfe1_test.go:42:\
    \ expected 'db100000db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp69whmfe1_test.go:42: expected 'db1100111db', got '00'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp69whmfe1_test.go:42:\
    \ expected 'db1111db', got '00'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    result += fmt.Sprintf(\"%c\", decimal%2)\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpy3xv6_f6_test.go:40: expected 'db0db', got '\0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpy3xv6_f6_test.go:40:\
    \ expected 'db100000db', got '\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpy3xv6_f6_test.go:40: expected 'db1100111db', got '\0\x01\
    '\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpy3xv6_f6_test.go:40:\
    \ expected 'db1111db', got '\0\x01'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    var remainder int\n    var i int\n\n    // The remainder\
    \ is calculated from the decimal number by dividing it by 2.\n    // The remainder\
    \ is then added to the decimal number by multiplying it by 2.\n    // The remainder\
    \ is then divided by 2 again, until it reaches 0.\n    // The remainder is then\
    \ added to the decimal number by dividing it by 2.\n    // The remainder is then\
    \ multiplied by 2 again, until it reaches 0.\n    // The remainder is then added\
    \ to the decimal number by dividing it by 2.\n    // The remainder is then multiplied\
    \ by 2 again, until it reaches 0.\n    // The remainder is then added to the decimal\
    \ number by dividing it by 2.\n    // The remainder is then multiplied by 2 again,\
    \ until it reaches 0.\n    // The remainder is then added to the decimal number\
    \ by dividing it by 2.\n    // The remainder is then multiplied by 2 again, until\
    \ it reaches 0.\n    // The remainder is then added to the decimal number by dividing\
    \ it by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder is then added to the decimal number by dividing it\
    \ by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder is then added to the decimal number by dividing it\
    \ by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder is then added to the decimal number by dividing it\
    \ by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder is then added to the decimal number by dividing it\
    \ by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder is then added to the decimal number by dividing it\
    \ by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder is then added to the decimal number by dividing it\
    \ by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder is then added to the decimal number by dividing it\
    \ by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder is then added to the decimal number by dividing it\
    \ by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder is then added to the decimal number by dividing it\
    \ by 2.\n    // The remainder is then multiplied by 2 again, until it reaches\
    \ 0.\n    // The remainder \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwirfz8vf_test.go:51:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074558
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp--\n    }\n    for temp > 0 {\n        result += \"1\"\n        temp--\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyuw_9302_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpyuw_9302_test.go:44: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    for i := 0; i < 8; i++ {\n        if decimal\
    \ >= 2 {\n            decimal /= 2\n            result += \"1\"\n        } else\
    \ {\n            result += \"0\"\n        }\n    }\n    return \"db\" + result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpl0u3o5kp_test.go:44: expected 'db0db', got 'db00000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpl0u3o5kp_test.go:44:\
    \ expected 'db100000db', got 'db00000000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpl0u3o5kp_test.go:44: expected 'db1100111db', got 'db00000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpl0u3o5kp_test.go:44:\
    \ expected 'db1111db', got 'db00000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += decimal_to_binary(decimal/2)\n\
    \    }\n    if decimal > 0 {\n        result += \"1\"\n    }\n    if decimal >\
    \ 0 {\n        result += decimal_to_binary(decimal/2)\n    }\n    if decimal >\
    \ 0 {\n        result += \"0\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfhd0ofht_test.go:48: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpfhd0ofht_test.go:48: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpfhd0ofht_test.go:48: expected 'db1100111db', got '10'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpfhd0ofht_test.go:48: expected\
    \ 'db1111db', got '10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    result += \"1\"\
    \n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result +=\
    \ \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n  \
    \  result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"\
    0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result\
    \ += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"1\"\n  \
    \  result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result += \"\
    1\"\n    result += \"0\"\n    result += \"1\"\n    result += \"0\"\n    result\
    \ += \"1\"\n    result += \"0\"\n    result += \"1\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptx7xmuca_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal % 2\n    decimal /=\
    \ 2\n    for i := 0; i < decimal; i++ {\n        result += fmt.Sprintf(\"%d\"\
    , temp)\n        temp = temp / 2\n    }\n    return result + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp1h41dcsx_test.go:42: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp1h41dcsx_test.go:42:\
    \ expected 'db100000db', got '0000000000000000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp1h41dcsx_test.go:42: expected 'db1100111db', got '100000000000000000000000000000000000000000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp1h41dcsx_test.go:42:\
    \ expected 'db1111db', got '1000000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074559
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    i := 0\n    for ; i < len(decimal); i++ {\n        if decimal%2\
    \ == 0 {\n            result += fmt.Sprintf(\"%d\", decimal%2)\n        } else\
    \ {\n            result += \"0\"\n        }\n        decimal /= 2\n    }\n   \
    \ if decimal > 0 {\n        result += \"1\"\n    }\n    return \"db\" + result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp80zcomyx_test.go:17:19: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    result += \"0\"\n    result += \"0\"\
    \n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result +=\
    \ \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpai3w7fqg_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \   }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        binary += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        binary += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    binary += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        binary\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"\
    0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        binary += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        binary += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    binary += \"0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        binary\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"\
    0\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        binary += \"0\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        binary += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        binary += \"0\"\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnpff2dii_test.go:135:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074555
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"0\"\n    }\n    binary := make([]byte, 32)\n\
    \    i := 0\n    for decimal&1 == 0 {\n        binary[i] = '0'\n        decimal\
    \ = decimal >> 1\n        i++\n    }\n    for decimal&1 == 1 {\n        binary[i]\
    \ = '1'\n        decimal = decimal >> 1\n        i++\n    }\n    binary[i] = 'b'\n\
    \    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpzb6g8uqk_test.go:50: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzb6g8uqk_test.go:50:\
    \ expected 'db100000db', got '000001b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzb6g8uqk_test.go:50:\
    \ expected 'db1100111db', got '111b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n     \
    \   tmpzb6g8uqk_test.go:50: expected 'db1111db', got '1111b\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\n\
    FAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp5s3_lyr7_test.go:41: expected 'db0db', got 'db0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp5s3_lyr7_test.go:41:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp5s3_lyr7_test.go:41: expected 'db1100111db', got 'db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5s3_lyr7_test.go:41:\
    \ expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    decimalString := fmt.Sprintf(\"%d\", decimal)\n    for i := 0;\
    \ i < len(decimalString); i++ {\n        if decimalString[i] == '1' {\n      \
    \      binaryString += \"1\"\n        } else {\n            binaryString += \"\
    0\"\n        }\n    }\n    return \"db\" + binaryString\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnehrqhnc_test.go:43: expected 'db0db', got 'db0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnehrqhnc_test.go:43:\
    \ expected 'db100000db', got 'db00'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpnehrqhnc_test.go:43: expected 'db1100111db', got 'db100'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnehrqhnc_test.go:43:\
    \ expected 'db1111db', got 'db10'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal < 0 {\n        fmt.Println(\"Negative numbers are not allowed\")\n \
    \   }\n    binary := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary\
    \ += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        binary += \"0\"\
    \n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpmg1_63up_test.go:45: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpmg1_63up_test.go:45:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpmg1_63up_test.go:45: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpmg1_63up_test.go:45:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074547
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        binary += \"1\"\n \
    \       decimal -= 1\n    }\n    for i := 0; i < decimal; i++ {\n        binary\
    \ += \"0\"\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpa32z1u8y_test.go:43: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa32z1u8y_test.go:43:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpa32z1u8y_test.go:43: expected 'db1100111db', got '1db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa32z1u8y_test.go:43:\
    \ expected 'db1111db', got '1db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074553
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal < 0 {\n        fmt.Println(\"Negative numbers not allowed\")\n    }\n\
    \    binary := make([]byte, 32)\n    i := 0\n    for decimal == 0 {\n        binary[i]\
    \ = '0'\n        i++\n        decimal = decimal >> 1\n    }\n    for decimal ==\
    \ 1 {\n        binary[i] = '1'\n        i++\n        decimal = decimal >> 1\n\
    \    }\n    binary[i] = 'b'\n    return string(binary)\n}\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: runtime error: index out\
    \ of range [32] with length 32 [recovered]\n\tpanic: runtime error: index out\
    \ of range [32] with length 32\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(0x563a1b?)\n\t/tmp/tmpg6ko7jv2_test.go:21\
    \ +0xff\ncommand-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmpg6ko7jv2_test.go:40\
    \ +0x42\ntesting.tRunner(0xc0000cc4e0, 0x527fa8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    for i := 0; i < decimal; i++ {\n        result\
    \ += \"0\"\n    }\n    result += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpe7afey5r_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpe7afey5r_test.go:44:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpe7afey5r_test.go:44: expected 'db1100111db', got '10db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpe7afey5r_test.go:44:\
    \ expected 'db1111db', got '10db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074550
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    temp := decimal\n    for i := 0; i <\
    \ len(strconv.Itoa(temp)); i++ {\n        result += \"0\"\n    }\n    result +=\
    \ \"1\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjiij17lo_test.go:18:25: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal\n    for temp > 0 {\n        result += \"0\"\n\
    \        temp--\n    }\n    for temp > 0 {\n        result += \"1\"\n        temp--\n\
    \    }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyuw_9302_test.go:44: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db100000db', got 'db00000000000000000000000000000000'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpyuw_9302_test.go:44: expected\
    \ 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyuw_9302_test.go:44:\
    \ expected 'db1111db', got 'db000000000000000'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimalToBinary := make([]int, 10)\n    decimalToBinary[0] = 1\n\
    \    decimalToBinary[1] = 1\n    decimalToBinary[2] = 1\n    decimalToBinary[3]\
    \ = 1\n    decimalToBinary[4] = 1\n    decimalToBinary[5] = 1\n    decimalToBinary[6]\
    \ = 1\n    decimalToBinary[7] = 1\n    decimalToBinary[8] = 1\n    decimalToBinary[9]\
    \ = 1\n    decimalToBinary[10] = 1\n    decimalToBinary[11] = 1\n    decimalToBinary[12]\
    \ = 1\n    decimalToBinary[13] = 1\n    decimalToBinary[14] = 1\n    decimalToBinary[15]\
    \ = 1\n    decimalToBinary[16] = 1\n    decimalToBinary[17] = 1\n    decimalToBinary[18]\
    \ = 1\n    decimalToBinary[19] = 1\n    decimalToBinary[20] = 1\n    decimalToBinary[21]\
    \ = 1\n    decimalToBinary[22] = 1\n    decimalToBinary[23] = 1\n    decimalToBinary[24]\
    \ = 1\n    decimalToBinary[25] = 1\n    decimalToBinary[26] = 1\n    decimalToBinary[27]\
    \ = 1\n    decimalToBinary[28] = 1\n    decimalToBinary[29] = 1\n    decimalToBinary[30]\
    \ = 1\n    decimalToBinary[31] = 1\n    decimalToBinary[32] = 1\n    decimalToBinary[33]\
    \ = 1\n    decimalToBinary[34] = 1\n    decimalToBinary[35] = 1\n    decimalToBinary[36]\
    \ = 1\n    decimalToBinary[37] = 1\n    decimalToBinary[38] = 1\n    decimalToBinary[39]\
    \ = 1\n    decimalToBinary[40] = 1\n    decimalToBinary[41] = 1\n    decimalToBinary[42]\
    \ = 1\n    decimalToBinary[43] = 1\n    decimalToBinary[44] = 1\n    decimalToBinary[45]\
    \ = 1\n    decimalToBinary[46] = 1\n    decimalToBinary[47] = 1\n    decimalToBinary[48]\
    \ = 1\n    decimalToBinary[49] = 1\n    decimalToBinary[50] = 1\n    decimalToBinary[51]\
    \ = 1\n    decimalToBinary[52] = 1\n    decimalToBinary[53] = 1\n    decimalToBinary[54]\
    \ = 1\n    decimalToBinary[55] = 1\n    decimalToBinary[56] = 1\n    decimalToBinary[57]\
    \ = 1\n    decimalToBinary[58] = 1\n    decimalToBinary[59] = 1\n    decimalToBinary[60]\
    \ = 1\n    decimalToBinary[61] = 1\n    decimalToBinary[62] = 1\n    decimalToBinary\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9az9xygi_test.go:81:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074549
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    temp := decimal % 2\n    decimal /= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += fmt.Sprintf(\"%c\", temp%2)\n        temp /= 2\n  \
    \  }\n    return \"db\" + result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopnvu27x_test.go:41: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpopnvu27x_test.go:41:\
    \ expected 'db100000db', got 'db\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpopnvu27x_test.go:41: expected\
    \ 'db1100111db', got 'db\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
    \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpopnvu27x_test.go:41: expected 'db1111db', got 'db\x01\0\0\
    \0\0\0\0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    switch decimal {\n    case 0:\n        result = \"0\"\n    case\
    \ 1:\n        result = \"1\"\n    default:\n        fmt.Printf(\"Error: decimal\
    \ number %d is not 0 or 1\\n\", decimal)\n    }\n    return \"db\" + result\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Error: decimal number 32 is not 0 or 1\nError: decimal number 103 is not\
    \ 0 or 1\nError: decimal number 15 is not 0 or 1\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp6puo12x2_test.go:43:\
    \ expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp6puo12x2_test.go:43: expected 'db100000db', got 'db'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp6puo12x2_test.go:43:\
    \ expected 'db1100111db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmp6puo12x2_test.go:43: expected 'db1111db', got 'db'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074560
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \   } else {\n        result += \"0\"\n    }\n    decimal /= 2\n    for i := 0;\
    \ i < decimal; i++ {\n        result += \"0\"\n    }\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp53qdrllt_test.go:45: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp53qdrllt_test.go:45:\
    \ expected 'db100000db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp53qdrllt_test.go:45: expected 'db1100111db', got '1'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp53qdrllt_test.go:45:\
    \ expected 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074550
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal /= 2\n    for i := 0; i < decimal;\
    \ i++ {\n        result += \"1\"\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpwlimq88u_test.go:40: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpwlimq88u_test.go:40: expected\
    \ 'db100000db', got '1111111111111111'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpwlimq88u_test.go:40: expected 'db1100111db', got '111111111111111111111111111111111111111111111111111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpwlimq88u_test.go:40:\
    \ expected 'db1111db', got '1111111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074560
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"\
    1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"\
    1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n\
    \    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal\
    \ /= 2\n    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n\
    \    if decimal > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if\
    \ decimal > 0 {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0\
    \ {\n        result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n    \
    \    result += \"1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result\
    \ += \"1\"\n    }\n    decimal /= 2\n    if decimal > 0 {\n        result += \"\
    1\"\n    }\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n\
    \    }\n    decimal /= 2\n    if decimal > 0 {\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqzb6ghms_test.go:135:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    if decimal > 0 {\n\
    \        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal >\
    \ 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal %= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n    }\n    decimal /= 2\n    if decimal\
    \ > 0 {\n        result += string(decimal)\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppxvge6k2_test.go:129:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074559
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    result := \"\"\n    decimal %= 2\n    for i := 0; i < len(decimal);\
    \ i++ {\n        if decimal > 0 {\n            result += fmt.Sprintf(\"%c\", decimal%2)\n\
    \        }\n        decimal /= 2\n    }\n    return \"db\" + result\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxzht2ok4_test.go:18:25: invalid argument: decimal (variable of type int)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074560
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    binary += \"0\"\n    for i := 0; i < decimal; i++ {\n   \
    \     binary += \"1\"\n    }\n    binary += \"b\"\n    return binary\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2dzrc997_test.go:40: expected 'db0db', got '0b'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp2dzrc997_test.go:40:\
    \ expected 'db100000db', got '011111111111111111111111111111111b'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp2dzrc997_test.go:40: expected\
    \ 'db1100111db', got '01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111b'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp2dzrc997_test.go:40:\
    \ expected 'db1111db', got '0111111111111111b'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074560
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n   \
    \ result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n  \
    \  result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"\
    0\"\n    result += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result\
    \ += \"0\"\n    result += \"0\"\n    result += \"0\"\n    result \nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25soik4a_test.go:118:6: expected ''('', found TestDecimal_To_Binary

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074559
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binaryString\
    \ := \"\"\n    decimalString := fmt.Sprintf(\"%d\", decimal)\n    decimalLen :=\
    \ len(decimalString)\n    binaryLen := decimalLen / 2\n    for i := 0; i < binaryLen;\
    \ i++ {\n        binaryString += fmt.Sprintf(\"%d\", decimal%2)\n        decimal\
    \ = decimal/2\n    }\n    binaryString += fmt.Sprintf(\"%d\", decimal%2)\n   \
    \ return binaryString\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp7706ganq_test.go:43: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7706ganq_test.go:43:\
    \ expected 'db100000db', got '00'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp7706ganq_test.go:43: expected 'db1100111db', got '11'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp7706ganq_test.go:43:\
    \ expected 'db1111db', got '11'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074560
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    result += \"db\"\n    result += fmt.Sprintf(\"%b\", decimal)\n\
    \    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptpjl9roj_test.go:37: expected 'db0db', got 'db0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptpjl9roj_test.go:37:\
    \ expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmptpjl9roj_test.go:37: expected 'db1100111db', got 'db1100111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptpjl9roj_test.go:37:\
    \ expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074560
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    result\
    \ := \"\"\n    decimal %= 2\n    if decimal > 0 {\n        result += \"1\"\n \
    \   } else {\n        result += \"0\"\n    }\n    decimal /= 2\n    for i := 0;\
    \ i < decimal; i++ {\n        result += \"0\"\n    }\n    return result\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp53qdrllt_test.go:45: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp53qdrllt_test.go:45:\
    \ expected 'db100000db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp53qdrllt_test.go:45: expected 'db1100111db', got '1'\n \
    \   --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp53qdrllt_test.go:45:\
    \ expected 'db1111db', got '1'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074550
