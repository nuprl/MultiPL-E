language: go_test.go
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp99o38hk4_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp99o38hk4_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q\
    \ {\n        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n\
    \    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n      \
    \  return false\n    }\n    if sum > w {\n        return true\n    }\n    if sum\
    \ == w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkp4hernq_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpkp4hernq_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpkp4hernq_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpkp4hernq_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    \n    // Write your test here\n  \
    \  \n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppe38tg9t_test.go:41: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmppe38tg9t_test.go:41:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmppe38tg9t_test.go:41: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpnghzvgru_test.go:39:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    sum := 0\n    for _, v := range q\
    \ {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    max := 0\n    for _, v := range q {\n        if v > max {\n            max\
    \ = v\n        }\n    }\n    if sum == max {\n        return true\n    }\n   \
    \ return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp4rtij1g__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp4rtij1g__test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max > w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpu3w8gvmn_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpu3w8gvmn_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if q[len(q)-1]\
    \ != 0 {\n        return false\n    }\n    max := 0\n    for _, v := range q {\n\
    \        max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n\
    \        return true\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpqpeyl_m__test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpqpeyl_m__test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpqpeyl_m__test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprf277zeg_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpq5pkf_l7_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpq5pkf_l7_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if w ==\
    \ 0 {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n        return\
    \ will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == 0 {\n        return will_it_fly(q[1:],\
    \ w)\n    }\n    if q[len(q)-1] == w {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if q[0] == w {\n        return will_it_fly(q[1:], w)\n    }\n\
    \    if q[len(q)-1] == w+q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n\
    \    }\n    if q[0] == w+q[0] {\n        return will_it_fly(q[1:], w)\n    }\n\
    \    if q[len(q)-1] == w+q[0]+q[1] {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if q[0] == w+q[0]+q[1] {\n        return will_it_fly(q[1:], w)\n\
    \    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2] {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if q[0] == w+q[0]+q[1]+q[2] {\n        return will_it_fly(q[1:],\
    \ w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2]+q[3] {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    if q[0] == w+q[0]+q[1]+q[2]+q[3] {\n        return will_it_fly(q[1:],\
    \ w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2]+q[3]+q[4] {\n        return\
    \ will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == w+q[0]+q[1]+q[2]+q[3]+q[4]\
    \ {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2]+q[3]+q[4]+q[5]\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == w+q[0]+q[1]+q[2]+q[3]+q[4]+q[5]\
    \ {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2]+q[3]+q[4]+q[5]+q[6]\
    \ {\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjh5wjf_c_test.go:71:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu85ibi4k_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppu6nvmza_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppu6nvmza_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpqhgfm160_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpqhgfm160_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpqhgfm160_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu85ibi4k_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    sum := 0\n    for _, v := range q\
    \ {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    max := 0\n    for _, v := range q {\n        if v > max {\n            max\
    \ = v\n        }\n    }\n    if sum == max {\n        return true\n    }\n   \
    \ return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp4rtij1g__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp4rtij1g__test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpeu6zp288_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpeu6zp288_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpeu6zp288_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpeu6zp288_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max%w == 0 {\n        return false\n    }\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1h71b_ea_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1h71b_ea_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q\
    \ {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    for _, v := range q {\n        if v != 0 {\n            if v != q[len(q)-1]\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpsmkwepwi_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    if q == nil || w == 0 {\n  \
    \      return false\n    }\n    max := 0\n    for _, v := range q {\n        max\
    \ += v\n    }\n    if max > w {\n        return false\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n     \
    \   return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpjjvqfjhf_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpjjvqfjhf_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    for _, v := range q {\n        if v > max {\n            return false\n \
    \       }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpb72u81qd_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpb72u81qd_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpb72u81qd_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpb72u81qd_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // TODO: write your function here\n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpl5dzvcwz_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpl5dzvcwz_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpl5dzvcwz_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n  \
    \      return false\n    }\n    if sum == w {\n        return true\n    }\n  \
    \  if sum > w {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpz93k07yo_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpz93k07yo_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpz93k07yo_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpeqj8wt0r_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpeqj8wt0r_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpeqj8wt0r_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpeqj8wt0r_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    \n    // Your code here\n    \n  \
    \  // Your code here\n    \n    // Your code here\n    \n    // Your code here\n\
    \    \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg9lone12_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max < w {\n  \
    \      return false\n    }\n    max -= w\n    i := 0\n    for _, v := range q\
    \ {\n        if v != q[i] {\n            return false\n        }\n        i++\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp2t8nxpe0_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp2t8nxpe0_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp2t8nxpe0_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp2t8nxpe0_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpq5pkf_l7_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpq5pkf_l7_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpqy6y0f9n_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppu6nvmza_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppu6nvmza_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpent3t_ez_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpent3t_ez_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpent3t_ez_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    return will_it_fly(q, max)\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpwzi2a_aw_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpwzi2a_aw_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpwzi2a_aw_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpwzi2a_aw_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    \n    \n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpp8l0a590_test.go:40: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpp8l0a590_test.go:40:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpp8l0a590_test.go:40: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpp8vfqh6m_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpp8vfqh6m_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpp8vfqh6m_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpp8vfqh6m_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpvytwrbzg_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpvytwrbzg_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpvytwrbzg_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    // If the list is balanced,\
    \ then its sum is less than or equal to w.\n    // If not, then its sum is greater\
    \ than or equal to w.\n    // If it's balanced, then its sum is less than or equal\
    \ to w.\n    // If it's unbalanced, then its sum is greater than or equal to w.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp504p3rp4_test.go:152:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpjyg84eqw_test.go:49: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpjyg84eqw_test.go:49:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu85ibi4k_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    max := 0\n    for _, v := range q {\n        max += v\n  \
    \  }\n    if max == w {\n        return true\n    }\n    if max < w {\n      \
    \  return false\n    }\n    max -= w\n    i := 0\n    for _, v := range q {\n\
    \        if v != q[i-1] {\n            return false\n        }\n        i++\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 34 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.will_it_fly(...)\n\t/tmp/tmpazjc0bsm_test.go:33\n\
    command-line-arguments_test.TestWill_It_Fly(0x0?)\n\t/tmp/tmpazjc0bsm_test.go:51\
    \ +0x59f\ntesting.tRunner(0xc000199040, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpqy6y0f9n_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if will_it_fly(q[1:],\
    \ w) {\n        return true\n    }\n    if will_it_fly(q[:len(q)-1], w) {\n  \
    \      return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpvtsobikq_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpvtsobikq_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpvtsobikq_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    sum := 0\n    for _, v := range q\
    \ {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    max := 0\n    for _, v := range q {\n        if v > max {\n            max\
    \ = v\n        }\n    }\n    return sum == max\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp3u5_asr2_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp3u5_asr2_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    for i := 0; i < len(q); i++ {\n        if q[i] != i+1 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp09hji9it_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__1 (0.00s)\n        tmp09hji9it_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__2\
    \ (0.00s)\n        tmp09hji9it_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp09hji9it_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp09hji9it_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpvytwrbzg_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpvytwrbzg_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpvytwrbzg_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpnghzvgru_test.go:39:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    for _, v := range q {\n        if v != 0 {\n            if v != max-1 {\n\
    \                return false\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmphwbypuby_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmphwbypuby_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmphwbypuby_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    if q == nil || w == 0 {\n  \
    \      return false\n    }\n    if q == nil || w == 0 {\n        return false\n\
    \    }\n    if q == nil || w == 0 {\n        return false\n    }\n    if q ==\
    \ nil || w == 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n\
    \        return false\n    }\n    if q == nil || w == 0 {\n        return false\n\
    \    }\n    if q == nil || w == 0 {\n        return false\n    }\n    if q ==\
    \ nil || w == 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n\
    \        return false\n    }\n    if q == nil || w == 0 {\n        return false\n\
    \    }\n    if q == nil || w == 0 {\n        return false\n    }\n    if q ==\
    \ nil || w == 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n\
    \        return false\n    }\n    if q == nil || w == 0 {\n        return false\n\
    \    }\n    if q == nil || w == 0 {\n        return false\n    }\n    if q ==\
    \ nil || w == 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n\
    \        return false\n    }\n    if q == nil || w == 0 {\n        return false\n\
    \    }\n    if q == nil || w == 0 {\n        return false\n    }\n    if q ==\
    \ nil || w == 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n\
    \        return false\n    }\n    if q == nil || w == 0 {\n        return false\n\
    \    }\n    if q == nil || w == 0 {\n        return false\n    }\n    if q ==\
    \ nil || w == 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n\
    \        return false\n    }\n    if q == nil || w == 0 {\n        return false\n\
    \    }\n    if q == nil || w == 0 {\n        return false\n    }\n    if q ==\
    \ nil || w == 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n\
    \        return false\n    }\n    if q == nil || w == 0 {\n        return false\n\
    \    }\n    if q == nil || w == 0 {\n        return false\n    }\n    if q ==\
    \ nil || w == 0 {\n        return false\n    }\n    if q == nil || w == 0 {\n\
    \        return false\n    }\n    if q == nil || w == 0 {\n        return false\n\
    \    }\n    if q == nil || w == 0 {\n        return false\n    }\n    if q ==\
    \ nil || w == 0 {\n        return false\n    }\n    if q == \nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpinl3ik2d_test.go:126:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    if q == nil || w < 0 {\n   \
    \     return false\n    }\n    if len(q) == 0 {\n        return true\n    }\n\
    \    if q[len(q)-1] == 0 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n\
    \    if q[0] == 0 {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1]\
    \ == w {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == w\
    \ {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == w+q[0]\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == w+q[0]\
    \ {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == w+q[0]+q[1]\
    \ {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2]\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == w+q[0]+q[1]+q[2]\
    \ {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2]+q[3]\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == w+q[0]+q[1]+q[2]+q[3]\
    \ {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2]+q[3]+q[4]\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == w+q[0]+q[1]+q[2]+q[3]+q[4]\
    \ {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2]+q[3]+q[4]+q[5]\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[0] == w+q[0]+q[1]+q[2]+q[3]+q[4]+q[5]\
    \ {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] == w+q[0]+q[1]+q[2]+q[3]+\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_9v5x0le_test.go:72:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max > w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpih0nb56x_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpih0nb56x_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n  \
    \      return false\n    }\n    if sum == w {\n        return true\n    }\n  \
    \  if sum > w {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpz93k07yo_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpz93k07yo_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpz93k07yo_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if will_it_fly(q[1:],\
    \ w) {\n        return true\n    }\n    if q[0] != 0 {\n        return false\n\
    \    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpbshqjexh_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpbshqjexh_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpbshqjexh_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q\
    \ {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpb0g8j2lx_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpb0g8j2lx_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpb0g8j2lx_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkbwh0cti_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[1:],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpnpglp6et_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpnpglp6et_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpqy6y0f9n_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    if max\
    \ <= w {\n        return true\n    }\n    sum := 0\n    for _, v := range q {\n\
    \        sum += v\n    }\n    if sum < w {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmparznat4r_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmparznat4r_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmparznat4r_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // TODO: Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp0_w2bw61_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp0_w2bw61_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp0_w2bw61_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppu6nvmza_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppu6nvmza_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        if v > max {\n            max = v\n  \
    \      }\n    }\n    if max <= w {\n        return true\n    }\n    sum := 0\n\
    \    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n      \
    \  return false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpubi6uoq7_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpubi6uoq7_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpubi6uoq7_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // TODO: Write your code here\n    \n    return true\n}\n\
    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9tq9w2zd_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp9tq9w2zd_test.go:39:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp9tq9w2zd_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmphypinlz5_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmphypinlz5_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmphypinlz5_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max > w {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range\
    \ [:-1]\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512620, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.will_it_fly({0xc0001d2628?, 0xc000190dd0?,\
    \ 0x0?}, 0x0?)\n\t/tmp/tmpyn6rwxpu_test.go:27 +0x75\ncommand-line-arguments_test.will_it_fly({0xc0001d2628?,\
    \ 0x0?, 0xc0001d25f0?}, 0x40ccc5?)\n\t/tmp/tmpyn6rwxpu_test.go:27 +0x45\ncommand-line-arguments_test.will_it_fly({0xc0001d2628?,\
    \ 0x5d2f90?, 0x5e2ea0?}, 0x2ae1393da418?)\n\t/tmp/tmpyn6rwxpu_test.go:27 +0x45\n\
    command-line-arguments_test.will_it_fly({0xc0001d2628?, 0x5d2f90?, 0x55ade1?},\
    \ 0xf?)\n\t/tmp/tmpyn6rwxpu_test.go:27 +0x45\ncommand-line-arguments_test.TestWill_It_Fly(0x0?)\n\
    \t/tmp/tmpyn6rwxpu_test.go:37 +0x7a\ntesting.tRunner(0xc000199380, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprf277zeg_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpp8vfqh6m_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpp8vfqh6m_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpp8vfqh6m_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpp8vfqh6m_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if q[len(q)-1]\
    \ < w {\n        return false\n    }\n    max := q[0]\n    for i := 1; i < len(q);\
    \ i++ {\n        if q[i] > max {\n            max = q[i]\n        }\n    }\n \
    \   return max == w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpe70x5i9b_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpe70x5i9b_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    \n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n\
    \    if sum < w {\n        return true\n    }\n    \n    return sum == w\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpan4mxucf_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpan4mxucf_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpan4mxucf_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    if sum == max {\n        return true\n    }\n\
    \    if sum > max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp9v1bak9z_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkilc3sch_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpkilc3sch_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkilc3sch_test.go:49: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    max := 0\n    for _, v := range q {\n        if v > max {\n            max\
    \ = v\n        }\n    }\n    return sum == max\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpj95zwq31_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpj95zwq31_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    if q == nil || w == 0 {\n        return\
    \ false\n    }\n    max := 0\n    for _, v := range q {\n        max += v\n  \
    \  }\n    if max < w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpqim1m56f_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpqim1m56f_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpqim1m56f_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqim1m56f_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == 0 {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpj0xg5z0__test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpj0xg5z0__test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpj0xg5z0__test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpj0xg5z0__test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppu6nvmza_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppu6nvmza_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    if max == w {\n        return true\n    }\n    if max < w {\n        return\
    \ false\n    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n  \
    \  }\n    if sum < max {\n        return false\n    }\n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpt477mhfo_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpt477mhfo_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpt477mhfo_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if len(q)\
    \ == 1 {\n        return q[0] == w\n    }\n    if q[0] != w {\n        return\
    \ false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpb6qngd1o_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpb6qngd1o_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpeqj8wt0r_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpeqj8wt0r_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpeqj8wt0r_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpeqj8wt0r_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    sum := 0\n    for _, v := range q\
    \ {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    max := sum - w\n    if max < 0 {\n        return false\n    }\n    for _,\
    \ v := range q {\n        if v != max {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpfi16x6i9_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpfi16x6i9_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpfi16x6i9_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    for _, v := range q {\n        if v != 0 {\n            if v != q[len(q)-1]\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpju2v2tu3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    // The maximum possible\
    \ weight is w.\n    if w == 0 {\n        return true\n    }\n    \n    // The\
    \ maximum possible weight is w.\n    if w == 1 {\n        return true\n    }\n\
    \    \n    // The maximum possible weight is w.\n    if w == 2 {\n        return\
    \ true\n    }\n    \n    // The maximum possible weight is w.\n    if w == 3 {\n\
    \        return true\n    }\n    \n    // The maximum possible weight is w.\n\
    \    if w == 4 {\n        return true\n    }\n    \n    // The maximum possible\
    \ weight is w.\n    if w == 5 {\n        return true\n    }\n    \n    // The\
    \ maximum possible weight is w.\n    if w == 6 {\n        return true\n    }\n\
    \    \n    // The maximum possible weight is w.\n    if w == 7 {\n        return\
    \ true\n    }\n    \n    // The maximum possible weight is w.\n    if w == 8 {\n\
    \        return true\n    }\n    \n    // The maximum possible weight is w.\n\
    \    if w == 9 {\n        return true\n    }\n    \n    // The maximum possible\
    \ weight is w.\n    if w == 10 {\n        return true\n    }\n    \n    // The\
    \ maximum possible weight is w.\n    if w == 11 {\n        return true\n    }\n\
    \    \n    // The maximum possible weight is w.\n    if w == 12 {\n        return\
    \ true\n    }\n    \n    // The maximum possible weight is w.\n    if w == 13\
    \ {\n        return true\n    }\n    \n    // The maximum possible weight is w.\n\
    \    if w == 14 {\n        return true\n    }\n    \n    // The maximum possible\
    \ weight is w.\n    if w == 15 {\n        return true\n    }\n    \n    // The\
    \ maximum possible weight is w.\n    if w == 16 {\n        return true\n    }\n\
    \    \n    // The maximum possible weight is w.\n    if w == 17 {\n        return\
    \ true\n    }\n    \n    // The maximum possible weight is w.\n    if w == 18\
    \ {\n        return true\n    }\n    \n    // The maximum possible weight is w.\n\
    \    if w == 19 {\n        return true\n    }\n    \n    // The maximum possible\
    \ weight is w.\n    if w == 20 {\n        return true\n    }\n    \n    // The\
    \ maximum possible weight is w.\n    if w == 21 {\n        return true\n    }\n\
    \    \n    // The maximum possible weight is w.\n    if w == 22 {\n        return\
    \ true\n    }\n    \n    // The maximum possible weight is w.\n    if w == 23\
    \ {\n        return true\n    }\n    \n    // The maximum possible weight is \n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7pran36w_test.go:139:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // TODO: Write your function here\n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppdk6boxm_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmppdk6boxm_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmppdk6boxm_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max > w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpu3w8gvmn_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpu3w8gvmn_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    if max == w {\n        return true\n    }\n    if max > w {\n        return\
    \ false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpln207w1y_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpln207w1y_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpln207w1y_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    for _, v := range q {\n        if v > max {\n            return false\n \
    \       }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpb72u81qd_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpb72u81qd_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpb72u81qd_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpb72u81qd_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // TODO: Write the function here.\n    return false\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpgxz4o17__test.go:38: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpgxz4o17__test.go:38:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpgxz4o17__test.go:38: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    \n    // Your code here\n    \n  \
    \  // Your code here\n    \n    // Your code here\n    \n    // Your code here\n\
    \    \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg9lone12_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max > w {\n        return false\n    }\n    for i := 0; i < len(q); i++\
    \ {\n        if q[i] > max {\n            return false\n        }\n    }\n   \
    \ return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkb63g1r3_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpkb63g1r3_test.go:53:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpq5pkf_l7_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpq5pkf_l7_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    max := 0\n    for _, v := range q {\n        if v > max {\n            max\
    \ = v\n        }\n    }\n    if sum == max {\n        return true\n    }\n   \
    \ return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpts5kev8n_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpts5kev8n_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max > w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpih0nb56x_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpih0nb56x_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpp8vfqh6m_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpp8vfqh6m_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpp8vfqh6m_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpp8vfqh6m_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q\
    \ {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpnh8tpyva_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpnh8tpyva_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    if w == 0 {\n        return\
    \ true\n    }\n    if q == nil {\n        return false\n    }\n    if q == []int\
    \ {\n        return true\n    }\n    if q[len(q)-1] != len(q)/2 {\n        return\
    \ false\n    }\n    if q[0] == 0 {\n        return true\n    }\n    if q[len(q)-1]\
    \ == 0 {\n        return true\n    }\n    if q[len(q)-1] < w {\n        return\
    \ false\n    }\n    if q[0] < w {\n        return false\n    }\n    return will_it_fly(q[1:],\
    \ w-q)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2ded86lu_test.go:24:9: expected operand, found ''return''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprf277zeg_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp99o38hk4_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp99o38hk4_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max == w {\n \
    \       return true\n    }\n    if max > w {\n        return false\n    }\n  \
    \  max -= w\n    i := 0\n    for j := len(q) - 1; j >= 0; j-- {\n        if q[j]\
    \ != q[j+1] {\n            i++\n            if i == max {\n                return\
    \ true\n            }\n        }\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\npanic: runtime error: index out of range\
    \ [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3]\
    \ with length 3\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.will_it_fly(...)\n\t/tmp/tmpfi14tv8y_test.go:32\n\
    command-line-arguments_test.TestWill_It_Fly(0x0?)\n\t/tmp/tmpfi14tv8y_test.go:49\
    \ +0x565\ntesting.tRunner(0xc000198ea0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q\
    \ {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp64mx4zz0_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp64mx4zz0_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp64mx4zz0_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp64mx4zz0_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if len(q)\
    \ == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1] {\n \
    \       return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpvtrd4o8w_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpqy6y0f9n_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppu6nvmza_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppu6nvmza_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp99o38hk4_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp99o38hk4_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max < w {\n  \
    \      return false\n    }\n    max -= w\n    for i := 0; i < len(q); i++ {\n\
    \        if q[i] != q[len(q)-1-i] {\n            return false\n        }\n   \
    \ }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpzp6ohli4_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpzp6ohli4_test.go:53:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // base case\n    if len(q)\
    \ == 0 {\n        return true\n    }\n    \n    // recursive case\n    if will_it_fly(q[1:],\
    \ w) {\n        return true\n    }\n    \n    // base case\n    if w == 0 {\n\
    \        return false\n    }\n    \n    // recursive case\n    if q[0] != 0 {\n\
    \        return false\n    }\n    \n    // base case\n    if q[len(q)-1] == 0\
    \ {\n        return false\n    }\n    \n    // recursive case\n    if q[len(q)-1]\
    \ != 0 {\n        return false\n    }\n    \n    // base case\n    if q[len(q)-1]\
    \ == q[0] {\n        return false\n    }\n    \n    // recursive case\n    if\
    \ q[len(q)-1] != q[0] {\n        return false\n    }\n    \n    // base case\n\
    \    if q[len(q)-1] == q[len(q)-1] {\n        return will_it_fly(q[1:], w-1)\n\
    \    }\n    \n    // recursive case\n    if q[len(q)-1] != q[len(q)-1] {\n   \
    \     return false\n    }\n    \n    // base case\n    if q[len(q)-1] == q[len(q)-1]\
    \ {\n        return will_it_fly(q[1:], w-1)\n    }\n    \n    // recursive case\n\
    \    if q[len(q)-1] != q[len(q)-1] {\n        return false\n    }\n    \n    //\
    \ base case\n    if q[len(q)-1] == q[len(q)-1] {\n        return will_it_fly(q[1:],\
    \ w-1)\n    }\n    \n    // recursive case\n    if q[len(q)-1] != q[len(q)-1]\
    \ {\n        return false\n    }\n    \n    // base case\n    if q[len(q)-1] ==\
    \ q[len(q)-1] {\n        return will_it_fly(q[1:], w-1)\n    }\n    \n    // recursive\
    \ case\n    if q[len(q)-1] != q[len(q)-1] {\n        return false\n    }\n   \
    \ \n    // base case\n    if q[len(q)-1] == q[len(q)-1] {\n        return will_it_fly(q[1:],\
    \ w-1)\n    }\n    \n    // recursive case\n    if q[len(q)-1] != q[len(q)-1]\
    \ {\n        return false\n    }\n    \n    // base case\n    if q[len(q)-1] ==\
    \ q[len(q)-1] {\n        return will_it_fly(q[1:], w-1)\n    }\n    \n    // recursive\
    \ case\n    if q[len(q)-1] != q[len(q)-1] {\n        return false\n    }\n   \
    \ \n    // base case\n    if q[len(q)-1] == q[len(q)-1] {\n        return will_it_fly(q[1:\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpolcn9mwh_test.go:121:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpnghzvgru_test.go:39:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    if sum == w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpnf59o9v1_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpnf59o9v1_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpnf59o9v1_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpnghzvgru_test.go:39:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    \n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpuo_l5rx3_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpuo_l5rx3_test.go:39:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpuo_l5rx3_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpeqj8wt0r_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpeqj8wt0r_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpeqj8wt0r_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpeqj8wt0r_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max <= w {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmptabijs9m_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmptabijs9m_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max < w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpp8vfqh6m_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpp8vfqh6m_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpp8vfqh6m_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpp8vfqh6m_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp99o38hk4_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp99o38hk4_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppu6nvmza_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppu6nvmza_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu85ibi4k_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpqy6y0f9n_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    if max > w {\n        return true\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    if sum > max {\n        return true\n    }\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpv3hkxooh_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpv3hkxooh_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpv3hkxooh_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpv3hkxooh_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // \nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu85ibi4k_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max > w {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range\
    \ [:-1]\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x512620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.will_it_fly({0xc0000c3628?, 0xc0000f5110?,\
    \ 0x0?}, 0x0?)\n\t/tmp/tmpeej4elho_test.go:27 +0x75\ncommand-line-arguments_test.will_it_fly({0xc0000c3628?,\
    \ 0x0?, 0xc0000c35f0?}, 0x40ccc5?)\n\t/tmp/tmpeej4elho_test.go:27 +0x45\ncommand-line-arguments_test.will_it_fly({0xc0000c3628?,\
    \ 0x5d2f90?, 0x5e2ea0?}, 0x2ae789decb98?)\n\t/tmp/tmpeej4elho_test.go:27 +0x45\n\
    command-line-arguments_test.will_it_fly({0xc0000c3628?, 0x5d2f90?, 0x55ade1?},\
    \ 0xf?)\n\t/tmp/tmpeej4elho_test.go:27 +0x45\ncommand-line-arguments_test.TestWill_It_Fly(0x0?)\n\
    \t/tmp/tmpeej4elho_test.go:37 +0x7a\ntesting.tRunner(0xc000003d40, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkilc3sch_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpkilc3sch_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkilc3sch_test.go:49: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    if max\
    \ < w {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n\
    \        sum += v\n    }\n    if sum < w {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp223emm64_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp223emm64_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp223emm64_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max == 0 {\n        return false\n    }\n    if max < w {\n        return\
    \ false\n    }\n    return will_it_fly(q, max) || will_it_fly(q[:len(q)-1], max)\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpai145_u__test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpai145_u__test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpai145_u__test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpai145_u__test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp99o38hk4_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp99o38hk4_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q\
    \ {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp64mx4zz0_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp64mx4zz0_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp64mx4zz0_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp64mx4zz0_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // TODO: Write the code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpinn18jim_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpinn18jim_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpinn18jim_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpvytwrbzg_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpvytwrbzg_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpvytwrbzg_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range q\
    \ {\n        if v > max {\n            max = v\n        }\n    }\n    sum := 0\n\
    \    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n      \
    \  return false\n    }\n    if sum == w {\n        return true\n    }\n    if\
    \ sum > w {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkt746tyz_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpkt746tyz_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkt746tyz_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max%w == 0 {\n        return false\n    }\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp1h71b_ea_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp1h71b_ea_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max == w {\n        return true\n    }\n\
    \    if max > w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpih0nb56x_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpih0nb56x_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpqhgfm160_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpqhgfm160_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpqhgfm160_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprf277zeg_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppu6nvmza_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppu6nvmza_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if q[len(q)-1]\
    \ != len(q)/2 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpri4ov2it_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpri4ov2it_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpri4ov2it_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpqy6y0f9n_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpqy6y0f9n_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max < w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n        if sum > w {\n            return false\n        }\n    }\n   \
    \ return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpf2a02_0q_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpf2a02_0q_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpf2a02_0q_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    if max < 0 {\n        return true\n    }\n   \
    \ sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < 0\
    \ || sum > max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpucr5m_pw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpucr5m_pw_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        if v > max {\n            max = v\n  \
    \      }\n    }\n    if max == 0 {\n        return true\n    }\n    sum := 0\n\
    \    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n      \
    \  return false\n    }\n    max /= 2\n    if sum > w {\n        return false\n\
    \    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpo6irk9_c_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpo6irk9_c_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpa6wwmzau_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpa6wwmzau_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpa6wwmzau_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    if sum == w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpnf59o9v1_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpnf59o9v1_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpnf59o9v1_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    return true\n}\n\
    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpdy9s52wx_test.go:40: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpdy9s52wx_test.go:40:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpdy9s52wx_test.go:40: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Your code here\n    \n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpuo_l5rx3_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpuo_l5rx3_test.go:39:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpuo_l5rx3_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprf277zeg_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpjyg84eqw_test.go:49: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpjyg84eqw_test.go:49:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    if sum == w {\n        return true\n    }\n    if sum > w {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpj7c211ke_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpj7c211ke_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpj7c211ke_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        if v > max {\n            max = v\n  \
    \      }\n    }\n    if max < w {\n        return false\n    }\n    sum := 0\n\
    \    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n      \
    \  return false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpbxp51b8e_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpbxp51b8e_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpbxp51b8e_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // TODO: Write the function here\n    return false\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpka7o4nd2_test.go:38: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpka7o4nd2_test.go:38:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpka7o4nd2_test.go:38: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpqhgfm160_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpqhgfm160_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpqhgfm160_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppu6nvmza_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppu6nvmza_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    return false\n}\n\
    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp7cby6ij0_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp7cby6ij0_test.go:40:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp7cby6ij0_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    \n    // Base case\n    if\
    \ len(q) == 0 {\n        return true\n    }\n    \n    // Recursive case\n   \
    \ if q[len(q)-1] == 0 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n\
    \    \n    // If q[len(q)-1] is not 0, then q is balanced\n    if w == 0 {\n \
    \       return true\n    }\n    \n    // If q[len(q)-1] is not 0, then q is unbalanced\n\
    \    if q[len(q)-1] > w {\n        return false\n    }\n    \n    // If q[len(q)-1]\
    \ is 0, then q is balanced\n    if q[len(q)-1] == w {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    \n    // If q[len(q)-1] is 0, then q is unbalanced\n    if q[len(q)-1]\
    \ < w {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    \n    // If q[len(q)-1]\
    \ is less than w, then q is unbalanced\n    if q[len(q)-1] == w {\n        return\
    \ will_it_fly(q[:len(q)-1], w)\n    }\n    \n    // If q[len(q)-1] is more than\
    \ w, then q is balanced\n    if q[len(q)-1] > w {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    \n    // If q[len(q)-1] is more than w, then q is unbalanced\n\
    \    if q[len(q)-1] == w {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n\
    \    \n    // If q[len(q)-1] is more than w, then q is balanced\n    if q[len(q)-1]\
    \ < w {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    \n    // If q[len(q)-1]\
    \ is less than w, then q is balanced\n    if q[len(q)-1] == w {\n        return\
    \ will_it_fly(q[:len(q)-1], w)\n    }\n    \n    // If q[len(q)-1] is less than\
    \ w, then q is unbalanced\n    if q[len(q)-1] > w {\n        return will_it_fly(q[:len(q)-1],\
    \ w)\n    }\n    \n    // If q[len(q)-1] is more than w, then q is balanced\n\
    \    if q[len(q)-1] == w {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n\
    \    \n    // If q[len(q)-1] is more than w, then q is unbalanced\n    if q[len(q)-1]\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe6zjbz48_test.go:85:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    if sum == w {\n        return true\n    }\n    if sum > w {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpj7c211ke_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpj7c211ke_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpj7c211ke_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    if q[len(q)-1]\
    \ < w {\n        return false\n    }\n    if will_it_fly(q[:len(q)-1], w) && will_it_fly(q[len(q)-1:],\
    \ w) {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0388\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.will_it_fly({0xc0401dfe58?,\
    \ 0x0?, 0x3?}, 0x1?)\n\t/tmp/tmpf2cg2a_x_test.go:15 +0xfa fp=0xc0201e0398 sp=0xc0201e0390\
    \ pc=0x4ef75a\ncommand-line-arguments_test.will_it_fly({0xc0401dfe58, 0x1, 0x3},\
    \ 0x1)\n\t/tmp/tmpf2cg2a_x_test.go:22 +0x5c fp=0xc0201e03d0 sp=0xc0201e0398 pc=0x4ef6bc\n\
    command-line-arguments_test.will_it_fly({0xc0401dfe58, 0x1, 0x3}, 0x1)\n\t/tmp/tmpf2cg2a_x_test.go:22\
    \ +0xa6 fp=0xc0201e0408 sp=0xc0201e03d0 pc=0x4ef706\ncommand-line-arguments_test.will_it_fly({0xc0401dfe58,\
    \ 0x1, 0x3}, 0x1)\n\t/tmp/tmpf2cg2a_x_test.go:22 +0xa6 fp=0xc0201e0440 sp=0xc0201e0408\
    \ pc=0x4ef706\ncommand-line-arguments_test.will_it_fly({0xc0401dfe58, 0x1, 0x3},\
    \ 0x1)\n\t/tmp/tmpf2cg2a_x_test.go:22 +0xa6 fp=0xc0201e0478 sp=0xc0201e0440 pc=0x4ef706\n\
    command-line-arguments_test.will_it_fly({0xc0401dfe58, 0x1, 0x3}, 0x1)\n\t/tmp/tmpf2cg2a_x_test.go:22\
    \ +0xa6 fp=0xc0201e04b0 sp=0xc0201e0478 pc=0x4ef706\ncommand-line-arguments_test.will_it_fly({0xc0401dfe58,\
    \ 0x1, 0x3}, 0x1)\n\t/tmp/tmpf2cg2a_x_test.go:22 +0xa6 fp=0xc0201e04e8 sp=0xc0201e04b0\
    \ pc=0x4ef706\ncommand-line-arguments_test.will_it_fly({0xc0401dfe58, 0x1, 0x3},\
    \ 0x1)\n\t/tmp/tmpf2cg2a_x_test.go:22 +0xa6 fp=0xc0201e0520 sp=0xc0201e04e8 pc=0x4ef706\n\
    command-line-arguments_test.will_it_fly({0xc0401dfe58, 0x1, 0x3}, 0x1)\n\t/tmp/tmpf2cg2a_x_test.go:22\
    \ +0xa6 fp=0xc0201e0558 sp=0xc0201e0520 pc=0x4ef706\ncommand-line-arguments_test.will_it_fly({0xc0401dfe58,\
    \ 0x1, 0x3}, 0x1)\n\t/tmp/tmpf2cg2a_x_test.go:22 +0xa6 fp=0xc0201e0590 sp=0xc0201e0558\
    \ pc=0x4ef706\ncommand-line-arguments_test.will_it_fly({0xc0401dfe58, 0x1, 0x3},\
    \ 0x1)\n\t"
  timestamp: 1660075309
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpq5pkf_l7_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpq5pkf_l7_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max < w {\n        return false\n    }\n\
    \    for _, v := range q {\n        if v != 0 {\n            if v > max {\n  \
    \              return false\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpt8n3ltr9_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpt8n3ltr9_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpt8n3ltr9_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpt8n3ltr9_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    sum :=\
    \ 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n  \
    \      return false\n    }\n    if sum == w {\n        return true\n    }\n  \
    \  if sum > w {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpxrgrhwne_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpxrgrhwne_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpxrgrhwne_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmt9yaojd_test.go:163:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpnghzvgru_test.go:39:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpnghzvgru_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpjyg84eqw_test.go:49: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpjyg84eqw_test.go:49:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n    }\n    if sum > w {\n        return false\n    }\n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp8v4gd2mt_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp8v4gd2mt_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n    }\n    if sum < max {\n        return false\n    }\n    return will_it_fly(q[1:],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpnpglp6et_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpnpglp6et_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n    max :=\
    \ 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w {\n  \
    \      return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum\
    \ += v\n        if sum > w {\n            return false\n        }\n    }\n   \
    \ return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpsc9n1m15_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpsc9n1m15_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpcolodoew_test.go:38:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpcolodoew_test.go:38: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    // return true if q will\
    \ fly, false otherwise\n    \n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmph0m5nuy1_test.go:41: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmph0m5nuy1_test.go:41:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmph0m5nuy1_test.go:41: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns True if the object q will fly, and False otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// #\
    \ it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3\
    \ is less than the maximum possible weight, and it's balanced.\n// # 3 is less\
    \ than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int,\
    \ w int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexv9v28d_test.go:271:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
