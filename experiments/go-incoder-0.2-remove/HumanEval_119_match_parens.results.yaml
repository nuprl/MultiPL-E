language: go_test.go
name: HumanEval_119_match_parens
results:
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0] = lst[0]\n    stack2[0] = lst[0]\n    i := 1\n    for i < len(lst)\
    \ {\n        if lst[i] == \"(\" {\n            stack1[i] = lst[i]\n          \
    \  stack2[i] = lst[i]\n            i++\n        } else if lst[i] == \")\" {\n\
    \            stack1[i] = lst[i]\n            stack2[i] = lst[i]\n            i++\n\
    \        } else {\n            stack1[i] = lst[i]\n            stack2[i] = lst[i]\n\
    \            i++\n        }\n    }\n    stack1[i] = \"\"\n    stack2[i] = \"\"\
    \n    result := \"\"\n    i := 0\n    for i < len(stack1) {\n        if stack1[i]\
    \ == \"\" {\n            result += \"(\"\n        } else {\n            result\
    \ += stack1[i]\n        }\n        i++\n    }\n    for i < len(stack2) {\n   \
    \     if stack2[i] == \"\" {\n            result += \"(\"\n        } else {\n\
    \            result += stack2[i]\n        }\n        i++\n    }\n    if result\
    \ == \"()\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n \
    \   }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp46gu1qzk_test.go:44:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack := make([]string, len(lst))\n    stack[0] = lst[0]\n    stack[1] = lst[1]\n\
    \    i := 2\n    for i < len(lst) {\n        if lst[i] == \"(\" {\n          \
    \  stack[i] = lst[i]\n            i++\n        } else if lst[i] == \")\" {\n \
    \           stack[i] = lst[i]\n            i++\n            if stack[i - 1] ==\
    \ \"(\" && stack[i - 2] == \")\" {\n                stack[i] = \"(\"\n       \
    \         i++\n            }\n        } else if stack[i - 1] == \"(\" && stack[i\
    \ - 2] == \")\" {\n            stack[i] = \"(\"\n            i++\n        }\n\
    \    }\n    if stack[i - 1] == \"(\" && stack[i - 2] == \")\" {\n        return\
    \ \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqs67nwkt_test.go:72: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpqs67nwkt_test.go:72: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpqs67nwkt_test.go:72: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpqs67nwkt_test.go:72: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpqs67nwkt_test.go:72: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   result := \"Yes\"\n    for _, str := range lst {\n        if str == \"(\"\
    \ || str == \")\" {\n            result += \"Yes\"\n        } else {\n       \
    \     result += \"No\"\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppr8qtauf_test.go:56: expected 'Yes', got 'YesNoYes'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmppr8qtauf_test.go:56:\
    \ expected 'No', got 'YesYesYes'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmppr8qtauf_test.go:56: expected 'No', got 'YesNoNo'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmppr8qtauf_test.go:56: expected 'Yes', got 'YesNoNo'\n   \
    \ --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmppr8qtauf_test.go:56:\
    \ expected 'Yes', got 'YesNoNo'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmppr8qtauf_test.go:56: expected 'No', got 'YesNoNo'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmppr8qtauf_test.go:56: expected 'Yes', got 'YesNoNo'\n   \
    \ --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmppr8qtauf_test.go:56:\
    \ expected 'No', got 'YesNoNo'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmppr8qtauf_test.go:56: expected 'No', got 'YesNoNo'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmppr8qtauf_test.go:56: expected 'No', got 'YesNoNo'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmppr8qtauf_test.go:56:\
    \ expected 'Yes', got 'YesYesYes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmppr8qtauf_test.go:56: expected 'Yes', got 'YesYesYes'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n    for\
    \ i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == \"(\" {\n       \
    \     stack[i] = \")\"\n            result += stack[i]\n            stack = stack[:len(stack)-1]\n\
    \        } else if stack[i] == \")\" {\n            stack[i] = \"(\"\n       \
    \     result += stack[i]\n            stack = stack[:len(stack)-1]\n        }\
    \ else {\n            result += stack[i]\n        }\n    }\n    if result != \"\
    \" {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqtnr5j4s_test.go:66: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpqtnr5j4s_test.go:66: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpqtnr5j4s_test.go:66: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpqtnr5j4s_test.go:66: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpqtnr5j4s_test.go:66: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqtnr5j4s_test.go:66: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    result := \"\"\n\
    \    for i := 0; i < len(lst); i++ {\n        stack[i] = i\n    }\n    for len(stack)\
    \ > 0 {\n        i := stack[len(stack)-1]\n        if lst[i] == \"(\" {\n    \
    \        stack[len(stack)] = i\n            result += \"(\"\n        } else if\
    \ lst[i] == \")\" {\n            stack[len(stack)] = i\n            result +=\
    \ \")\"\n        } else {\n            return result\n        }\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range\
    \ [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens(...)\n\t/tmp/tmpe6hhedps_test.go:29\n\
    command-line-arguments_test.TestMatch_Parens(0x0?)\n\t/tmp/tmpe6hhedps_test.go:45\
    \ +0xdfc\ntesting.tRunner(0xc000103380, 0x528f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074116
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n\
    \    for i := len(stack) - 1; i >= 0; i-- {\n        switch stack[i] {\n     \
    \   case \"(\":\n            stack[i] = \")\"\n            if result == \"No\"\
    \ {\n                result = \"Yes\"\n            }\n        case \"(\":\n  \
    \          stack[i] = \")\"\n            if result == \"Yes\" {\n            \
    \    result = \"No\"\n            }\n        default:\n            if result ==\
    \ \"No\" {\n                result = \"Yes\"\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgacxu6pi_test.go:30:14:\
    \ duplicate case \"(\" (constant of type string) in expression switch\n\t/tmp/tmpgacxu6pi_test.go:25:14:\
    \ previous case\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   if len(lst) == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string,\
    \ len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0], stack2[0]\
    \ = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[0], lst[0]\n    for i := 1;\
    \ i < len(lst); i++ {\n        if stack1[i] == \")\" {\n            stack1[i]\
    \ = \"(\"\n            stack2[i] = lst[i]\n        } else {\n            stack1[i]\
    \ = stack1[i-1]\n            stack2[i] = stack2[i-1]\n        }\n    }\n    if\
    \ stack1[len(stack1)-1] != \")\" {\n        return \"No\"\n    }\n    if stack2[len(stack2)-1]\
    \ != \")\" {\n        return \"No\"\n    }\n    stack1[len(stack1)-1] = \"(\"\n\
    \    stack2[len(stack2)-1] = \"(\"\n    result := \"Yes\"\n    for i := 0; i <\
    \ len(stack1); i++ {\n        if stack1[i] != stack2[i] {\n            result\
    \ = \"No\"\n            break\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpndco5j_g_test.go:79: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpndco5j_g_test.go:79: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpndco5j_g_test.go:79: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpndco5j_g_test.go:79: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpndco5j_g_test.go:79: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpndco5j_g_test.go:79: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack := make([]string, len(lst))\n    stack[0] = lst[0]\n    stack[1] = lst[1]\n\
    \    i := 2\n    for i < len(lst) {\n        if stack[i] == \"\" {\n         \
    \   stack[i] = lst[i]\n            continue\n        }\n        if stack[i-1]\
    \ == \"\" {\n            stack[i] = stack[i] + stack[i]\n            stack[i]\
    \ = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:len(stack[i])-1]\n\
    \            stack[i] = stack[i][:len(stack[i])-1]\n            stack[i] = stack[i][:\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpojb45ej9_test.go:72:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074115
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == \"(\" {\n         \
    \   stack[i] = s\n            i++\n        } else if s == \")\" {\n          \
    \  i -= 1\n            if i == -1 {\n                return \"No\"\n         \
    \   }\n            stack[i] = s\n        } else if i == -1 {\n            return\
    \ \"No\"\n        }\n    }\n    for _, s := range stack {\n        result = result\
    \ + s\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5bq737q7_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp5bq737q7_test.go:65: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmp5bq737q7_test.go:65: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmp5bq737q7_test.go:65: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmp5bq737q7_test.go:65: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmp5bq737q7_test.go:65: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp5bq737q7_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps0_6jr53_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074115
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   s := lst[0]\n    for _, v := range lst[1:] {\n        if v != s {\n      \
    \      return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpz2rcigza_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpz2rcigza_test.go:54: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpz2rcigza_test.go:54: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpz2rcigza_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpz2rcigza_test.go:54: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpz2rcigza_test.go:54: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpz2rcigza_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpz2rcigza_test.go:54: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     result += \"(\" + s + \")\"\n    }\n    result += \"()\"\n    if result\
    \ == \"(())()\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmptwd7kjc3_test.go:53: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmptwd7kjc3_test.go:53: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmptwd7kjc3_test.go:53: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmptwd7kjc3_test.go:53: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmptwd7kjc3_test.go:53: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmptwd7kjc3_test.go:53: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, v := range lst {\n   \
    \     if v == \"(\" || v == \")\" {\n            result += v\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp2j3eykow_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp2j3eykow_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp2j3eykow_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp2j3eykow_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmp2j3eykow_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += \"(\"\n        } else\
    \ {\n            result += \"(\"\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"No\"\n    }\n    return \"Yes\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpjl6s49dl_test.go:57: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpjl6s49dl_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpjl6s49dl_test.go:57: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpjl6s49dl_test.go:57: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpjl6s49dl_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpjl6s49dl_test.go:57: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := 0; i\
    \ < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\
    \n        } else if lst[i] == \")\" {\n            stack[i] = \")\"\n        }\
    \ else {\n            return fmt.Sprintf(\"No\")\n        }\n    }\n    return\
    \ fmt.Sprintf(\"Yes\")\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpkk2qt_9d_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpkk2qt_9d_test.go:55: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpkk2qt_9d_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpkk2qt_9d_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpkk2qt_9d_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074116
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0] = lst[0]\n    stack2[0] = lst[0]\n    i := 1\n    for i < len(lst)\
    \ {\n        if lst[i] == \"(\" {\n            stack1[i] = lst[i]\n          \
    \  stack2[i] = lst[i]\n            i += 1\n        } else {\n            stack1[i]\
    \ = stack1[i-1]\n            stack2[i] = stack2[i-1]\n        }\n    }\n    stack1[i]\
    \ = \"\"\n    stack2[i] = \"\"\n    result := \"Yes\"\n    for i := 1; i < len(stack1);\
    \ i++ {\n        if stack1[i] == \"\" {\n            if stack2[i] == \"\" {\n\
    \                result = \"No\"\n                break\n            }\n     \
    \       if stack2[i] == \"(\" {\n                result = \"No\"\n           \
    \     break\n            }\n            if stack2[i] == \")\" {\n            \
    \    result = \"Yes\"\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074127
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n\
    \    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == \"(\" {\n\
    \            stack[i] = \")\"\n            result += \")\"\n            stack\
    \ = stack[:i]\n        } else if stack[i] == \")\" {\n            stack[i] = \"\
    (\"\n            result += \"(\"\n            stack = stack[:i]\n        }\n \
    \   }\n    if result == \"No\" {\n        result = \"Yes\"\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpxdlpeu_g_test.go:64: expected 'Yes', got 'No('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpxdlpeu_g_test.go:64:\
    \ expected 'No', got 'No(('\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpxdlpeu_g_test.go:64: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmpxdlpeu_g_test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpxdlpeu_g_test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n      \
    \  tmpxdlpeu_g_test.go:64: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpxdlpeu_g_test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpxdlpeu_g_test.go:64: expected\
    \ 'Yes', got 'No()'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n   \
    \     tmpxdlpeu_g_test.go:64: expected 'Yes', got 'No)('\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n        \
    \    stack[i] = s\n            i++\n        } else if s[i] == ')' {\n        \
    \    if len(stack) == 0 {\n                return \"No\"\n            }\n    \
    \        s := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n\
    \            stack[i] = s\n            result += s\n            i++\n        }\
    \ else {\n            result += s\n        }\n    }\n    if i == len(lst) {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range\
    \ [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5ca0, 0x2, 0x2?})\n\
    \t/tmp/tmpbj2yz2xl_test.go:22 +0x225\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmpbj2yz2xl_test.go:51 +0x99\ntesting.tRunner(0xc000192680, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   if len(lst) == 1 {\n        return lst[0]\n    }\n    s := lst[0]\n    for\
    \ _, v := range lst[1:] {\n        if v != s {\n            return \"No\"\n  \
    \      }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpc5xorslv_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpc5xorslv_test.go:57: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpc5xorslv_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpc5xorslv_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpc5xorslv_test.go:57: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpc5xorslv_test.go:57: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpc5xorslv_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpc5xorslv_test.go:57: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    result += \"(\"\n    for _, s\
    \ := range lst {\n        if s == \"(\" {\n            result += \"(\"\n     \
    \   } else if s == \")\" {\n            result += \")\"\n        } else {\n  \
    \          result += s\n        }\n    }\n    result += \")\"\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpjpl4lg5i_test.go:57: expected 'Yes', got '(()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpjpl4lg5i_test.go:57:\
    \ expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpjpl4lg5i_test.go:57: expected 'No', got '((()(())())()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpjpl4lg5i_test.go:57:\
    \ expected 'Yes', got '()())(()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpjpl4lg5i_test.go:57: expected 'Yes', got '((())))(()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpjpl4lg5i_test.go:57:\
    \ expected 'No', got '(()()))'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpjpl4lg5i_test.go:57: expected 'Yes', got '((()(()))())'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpjpl4lg5i_test.go:57: expected\
    \ 'No', got '(((((((()))'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpjpl4lg5i_test.go:57: expected 'No', got '()(()(()()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpjpl4lg5i_test.go:57: expected\
    \ 'No', got '()()()'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n  \
    \      tmpjpl4lg5i_test.go:57: expected 'Yes', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpjpl4lg5i_test.go:57: expected 'Yes', got '()()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            if stack[len(stack)-1] != \"\" {\n  \
    \              stack[len(stack)-1] += lst[i]\n            } else {\n         \
    \       stack[len(stack)] = lst[i]\n            }\n        }\n    }\n    if stack[len(stack)-1]\
    \ != \"\" {\n        result = \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range\
    \ [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5ca0, 0x2, 0x2?})\n\
    \t/tmp/tmpb2fdbecd_test.go:29 +0x1bc\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmpb2fdbecd_test.go:46 +0x99\ntesting.tRunner(0xc0001924e0, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    result += \"(\"\n    for _, v\
    \ := range lst {\n        if v == \"(\" {\n            result += \"(\"\n     \
    \   } else {\n            result += \")\"\n        }\n    }\n    result += \"\
    )\"\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp_qj2uo18_test.go:55: expected 'Yes', got '()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp_qj2uo18_test.go:55:\
    \ expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp_qj2uo18_test.go:55: expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp_qj2uo18_test.go:55: expected 'Yes', got '()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmp_qj2uo18_test.go:55:\
    \ expected 'Yes', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmp_qj2uo18_test.go:55: expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp_qj2uo18_test.go:55: expected 'Yes', got '()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp_qj2uo18_test.go:55:\
    \ expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmp_qj2uo18_test.go:55: expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp_qj2uo18_test.go:55: expected 'No', got '()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp_qj2uo18_test.go:55:\
    \ expected 'Yes', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp_qj2uo18_test.go:55: expected 'Yes', got '()()'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    result := \"No\"\n    stack1 := make([]string, len(lst))\n\
    \    stack2 := make([]string, len(lst))\n    i := 0\n    for _, s := range lst\
    \ {\n        if s == '(' {\n            stack1[i] = s\n            i++\n     \
    \   } else if s == ')' {\n            stack2[i] = s\n            i++\n       \
    \ } else {\n            if stack1[i] == stack2[i] {\n                stack1[i]\
    \ = s\n                i++\n            } else {\n                result = \"\
    No\"\n                break\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxwxlosz5_test.go:23:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpxwxlosz5_test.go:26:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   if len(lst) == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string,\
    \ len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0], stack2[0]\
    \ = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1], lst[1]\n    stack1[2],\
    \ stack2[2] = lst[2], lst[2]\n    stack1[3], stack2[3] = lst[3], lst[3]\n    stack1[4],\
    \ stack2[4] = lst[4], lst[4]\n    stack1[5], stack2[5] = lst[5], lst[5]\n    stack1[6],\
    \ stack2[6] = lst[6], lst[6]\n    stack1[7], stack2[7] = lst[7], lst[7]\n    stack1[8],\
    \ stack2[8] = lst[8], lst[8]\n    stack1[9], stack2[9] = lst[9], lst[9]\n    stack1[10],\
    \ stack2[10] = lst[10], lst[10]\n    stack1[11], stack2[11] = lst[11], lst[11]\n\
    \    stack1[12], stack2[12] = lst[12], lst[12]\n    stack1[13], stack2[13] = lst[13],\
    \ lst[13]\n    stack1[14], stack2[14] = lst[14], lst[14]\n    stack1[15], stack2[15]\
    \ = lst[15], lst[15]\n    stack1[16], stack2[16] = lst[16], lst[16]\n    stack1[17],\
    \ stack2[17] = lst[17], lst[17]\n    stack1[18], stack2[18] = lst[18], lst[18]\n\
    \    stack1[19], stack2[19] = lst[19], lst[19]\n    stack1[20], stack2[20] = lst[20],\
    \ lst[20]\n    stack1[21], stack2[21] = lst[21], lst[21]\n    stack1[22], stack2[22]\
    \ = lst[22], lst[22]\n    stack1[23], stack2[23] = lst[23], lst[23]\n    stack1[24],\
    \ stack2[24] = lst[24], lst[24]\n    stack1[25], stack2[25] = lst[25], lst[25]\n\
    \    stack1[26], stack2[26] = lst[26], lst[26]\n    stack1[27], stack2[27] = lst[27],\
    \ lst[27]\n    stack1[28], stack\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprsvcglwu_test.go:54:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0], stack2[0] = lst[0], lst[1]\n    stack1[1], stack2[1] = lst[1],\
    \ lst[0]\n    stack1[2], stack2[2] = lst[2], lst[1]\n    stack1[3], stack2[3]\
    \ = lst[3], lst[2]\n    stack1[4], stack2[4] = lst[4], lst[3]\n    stack1[5],\
    \ stack2[5] = lst[5], lst[4]\n    stack1[6], stack2[6] = lst[6], lst[5]\n    stack1[7],\
    \ stack2[7] = lst[7], lst[6]\n    stack1[8], stack2[8] = lst[8], lst[7]\n    stack1[9],\
    \ stack2[9] = lst[9], lst[8]\n    stack1[10], stack2[10] = lst[10], lst[9]\n \
    \   stack1[11], stack2[11] = lst[11], lst[10]\n    stack1[12], stack2[12] = lst[12],\
    \ lst[11]\n    stack1[13], stack2[13] = lst[13], lst[12]\n    stack1[14], stack2[14]\
    \ = lst[14], lst[13]\n    stack1[15], stack2[15] = lst[15], lst[14]\n    stack1[16],\
    \ stack2[16] = lst[16], lst[15]\n    stack1[17], stack2[17] = lst[17], lst[16]\n\
    \    stack1[18], stack2[18] = lst[18], lst[17]\n    stack1[19], stack2[19] = lst[19],\
    \ lst[18]\n    stack1[20], stack2[20] = lst[20], lst[19]\n    stack1[21], stack2[21]\
    \ = lst[21], lst[20]\n    stack1[22], stack2[22] = lst[22], lst[21]\n    stack1[23],\
    \ stack2[23] = lst[23], lst[22]\n    stack1[24], stack2[24] = lst[24], lst[23]\n\
    \    stack1[25], stack2[25] = lst[25], lst[24]\n    stack1[26], stack2[26] = lst[26],\
    \ lst[25]\n    stack1[27], stack2[27] = lst[27], lst[26]\n    stack1[28], stack2[28]\
    \ = lst[28], lst[27]\n    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx1h4l1a7_test.go:53:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += \"(\" + s + \")\"\n\
    \        } else {\n            result += s\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpd4dz4k02_test.go:53: expected 'Yes', got '()(())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpd4dz4k02_test.go:53:\
    \ expected 'No', got '())())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpd4dz4k02_test.go:53: expected 'No', got '(()(())())())'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpd4dz4k02_test.go:53: expected\
    \ 'Yes', got ')())(()()('\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpd4dz4k02_test.go:53: expected 'Yes', got '(())))(()())(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpd4dz4k02_test.go:53:\
    \ expected 'No', got '()())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpd4dz4k02_test.go:53: expected 'Yes', got '(()(()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpd4dz4k02_test.go:53: expected\
    \ 'No', got '((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpd4dz4k02_test.go:53: expected 'No', got ')(()(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpd4dz4k02_test.go:53: expected\
    \ 'No', got ')()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n    \
    \    tmpd4dz4k02_test.go:53: expected 'Yes', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpd4dz4k02_test.go:53: expected 'Yes', got '())(()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074118
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n           \
    \ stack[i] = s\n            i++\n        } else if s == ')' {\n            i -=\
    \ 1\n            if i == -1 {\n                return \"No\"\n            }\n\
    \            stack[i] = s\n        } else if s == '{' {\n            stack[i]\
    \ = s\n            i++\n        } else if s == '}' {\n            i -= 1\n   \
    \         if i == -1 {\n                return \"No\"\n            }\n       \
    \     stack[i] = s\n        } else {\n            stack[i] = s\n        }\n  \
    \  }\n    for _, s := range stack {\n        result = result + s\n    }\n    return\
    \ \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp03pg6fh7_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp03pg6fh7_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    /tmp/tmp03pg6fh7_test.go:31:24: invalid operation: s == ''{'' (mismatched types
    string and untyped rune)

    /tmp/tmp03pg6fh7_test.go:34:24: invalid operation: s == ''}'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += \"(\" + s + \")\"\n\
    \        } else {\n            result += \"(\" + s + \")\"\n        }\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'Yes', got '(()()())'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '())())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp37dykhcn_test.go:53: expected 'No', got '((()(()))(())()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'Yes', got '()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'Yes', got '((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmp37dykhcn_test.go:53: expected 'Yes', got '((()()(()))())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'No', got '()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmp37dykhcn_test.go:53: expected 'Yes', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'Yes', got '())(()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074118
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, str := range lst {\n        if str == \"(\" {\n     \
    \       stack[i] = str\n            i++\n        } else if str == \")\" {\n  \
    \          stack[i] = str\n            i++\n            if i == len(stack) {\n\
    \                result += \"(\" + strings.Join(stack[:i], \"\")\n           \
    \     break\n            }\n        } else {\n            result += \"(\" + str\
    \ + \")\"\n        }\n    }\n    if result == \"(\" + strings.Join(stack[:i],\
    \ \"\") + \")\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7rowwdsy_test.go:29:33: undefined: strings

    /tmp/tmp7rowwdsy_test.go:36:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    result := \"No\"\n    stack1 := make([]string, len(lst))\n\
    \    stack2 := make([]string, len(lst))\n    i := 0\n    for _, s := range lst\
    \ {\n        if s == \"(\" {\n            stack1[i] = s\n            i++\n   \
    \     } else if s == \")\" {\n            stack2[i] = s\n            i++\n   \
    \     } else {\n            if stack1[i] == \"\" {\n                stack1[i]\
    \ = s\n                i++\n            } else if stack2[i] == \"\" {\n      \
    \          stack2[i] = s\n                i++\n            } else {\n        \
    \        if stack1[i] != stack2[i] {\n                    result = \"No\"\n  \
    \                  break\n                }\n            }\n        }\n    }\n\
    \    if result == \"No\" {\n        result = \"Yes\"\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpo2xm4r3v_test.go:74: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpo2xm4r3v_test.go:74: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpo2xm4r3v_test.go:74: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpo2xm4r3v_test.go:74: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpo2xm4r3v_test.go:74: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpo2xm4r3v_test.go:74: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n      \
    \  result += \"(\" + s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '(()()())(()()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '())())())())'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'No', got '((()(()))(())()))((()(()))(())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'Yes', got '()()))((()()()()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '((()))))((()())(()((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '(())(()))(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '((()()(()))())((()()(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '((((()(((()))((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'No', got '()(())((()()()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '()()()()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '(()())(()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'Yes', got '())(()())(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, v := range lst {\n   \
    \     if v == \"(\" || v == \")\" {\n            result += v\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp2j3eykow_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp2j3eykow_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp2j3eykow_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp2j3eykow_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmp2j3eykow_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074117
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool,\
    \ len(lst))\n    stack1[0], stack2[0] = true, true\n    stack1[1], stack2[1] =\
    \ true, true\n    stack1[2], stack2[2] = true, true\n    stack1[3], stack2[3]\
    \ = true, true\n    stack1[4], stack2[4] = true, true\n    stack1[5], stack2[5]\
    \ = true, true\n    stack1[6], stack2[6] = true, true\n    stack1[7], stack2[7]\
    \ = true, true\n    stack1[8], stack2[8] = true, true\n    stack1[9], stack2[9]\
    \ = true, true\n    stack1[10], stack2[10] = true, true\n    stack1[11], stack2[11]\
    \ = true, true\n    stack1[12], stack2[12] = true, true\n    stack1[13], stack2[13]\
    \ = true, true\n    stack1[14], stack2[14] = true, true\n    stack1[15], stack2[15]\
    \ = true, true\n    stack1[16], stack2[16] = true, true\n    stack1[17], stack2[17]\
    \ = true, true\n    stack1[18], stack2[18] = true, true\n    stack1[19], stack2[19]\
    \ = true, true\n    stack1[20], stack2[20] = true, true\n    stack1[21], stack2[21]\
    \ = true, true\n    stack1[22], stack2[22] = true, true\n    stack1[23], stack2[23]\
    \ = true, true\n    stack1[24], stack2[24] = true, true\n    stack1[25], stack2[25]\
    \ = true, true\n    stack1[26], stack2[26] = true, true\n    stack1[27], stack2[27]\
    \ = true, true\n    stack1[28], stack2[28] = true, true\n    stack1[29], stack2[29]\
    \ = true, true\n    stack1[30], stack2[30] = true, true\n    stack1[31], stack2[31]\
    \ = true, true\n    stack1[32], stack2[32] = true, true\n    stack1[33], stack2[33]\
    \ = true, true\n    stack1[34], stack2[34] = true, true\n    stack1[35], stack2[35]\
    \ = true, true\n    stack1[36], stack2[36] = true, true\n    stack1[37], stack2[37]\
    \ = true, true\n    stack1[38], stack2[38] = true, true\n    stack1[39], stack2[39]\
    \ = true, true\n    stack1[40], stack2[40] = true, true\n    stack1[4\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_c52v8fx_test.go:61:13: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps0_6jr53_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074115
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if\
    \ i == -1 {\n            stack = stack[:len(stack)-1]\n        } else {\n    \
    \        stack[len(stack)-1]--\n            if stack[len(stack)-1] == -1 {\n \
    \               stack = stack[:len(stack)-1]\n            } else {\n         \
    \       result += lst[i]\n                stack[len(stack)-1]++\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqbtp51b__test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result = result + s\n       \
    \ }\n    }\n    if result == \"()\" {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpxgmfx9oz_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpxgmfx9oz_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpxgmfx9oz_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpxgmfx9oz_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpxgmfx9oz_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n        \
    \    stack[i] = lst[i]\n        } else if lst[i] == \")\" {\n            result\
    \ += \"(\" + stack[len(stack)-1] + \")\"\n            stack = stack[:len(stack)-1]\n\
    \        } else {\n            result += \"(\" + lst[i] + \")\"\n        }\n \
    \   }\n    if stack != nil {\n        return \"No\"\n    }\n    return \"Yes\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range\
    \ [1] with length 1\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x514620,\
    \ 0xc000162030})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514620, 0xc000162030})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens(...)\n\t/tmp/tmpap2fnu17_test.go:22\n\
    command-line-arguments_test.TestMatch_Parens(0xc000103380?)\n\t/tmp/tmpap2fnu17_test.go:54\
    \ +0x196d\ntesting.tRunner(0xc000103380, 0x529f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    result := \"No\"\n    for _, s := range lst {\n    \
    \    if s == \"(\" || s == \")\" {\n            continue\n        }\n        result\
    \ := \"Yes\"\n        break\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7nen23rp_test.go:23:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0] = lst[0]\n    stack2[0] = lst[1]\n    i := 2\n    for i < len(lst)\
    \ {\n        if lst[i] == \"(\" {\n            stack1[i] = lst[i]\n          \
    \  stack2[i] = lst[i+1]\n            i += 2\n        } else if lst[i] == \")\"\
    \ {\n            stack1[i] = lst[i]\n            stack2[i] = lst[i+1]\n      \
    \      i += 2\n        } else {\n            if stack1[i-1] == \")\" && stack2[i-1]\
    \ == \"(\" {\n                stack1[i] = stack1[i-1]\n                stack2[i]\
    \ = stack2[i-1]\n                i += 2\n            } else {\n              \
    \  if stack1[i-1] == \"(\" && stack2[i-1] == \")\" {\n                    stack1[i]\
    \ = stack1[i-1]\n                    stack2[i] = stack2[i-1]\n               \
    \     i += 2\n                } else {\n                    if stack1[i-1] ==\
    \ \")\" && stack2[i-1] == \"(\" {\n                        stack1[i] = stack1[i-1]\n\
    \                        stack2[i] = stack2[i-1]\n                        i +=\
    \ 2\n                    } else {\n                        if stack1[i-1] == \"\
    (\" && stack2[i-1] == \")\" {\n                            stack1[i] = stack1[i-1]\n\
    \                            stack2[i] = stack2[i-1]\n                       \
    \     i += 2\n                        } else {\n                            if\
    \ stack1[i-1] == \")\" && stack2[i-1] == \"(\" {\n                           \
    \     stack1[i] = stack1[i-1]\n                                stack2[i] = stack2[i-1]\n\
    \                                i += 2\n                            } else {\n\
    \                                if stack1[i-1] == \"(\" && stack2[i-1] == \"\
    )\" {\n                                    stack1[i] = stack1[i-1]\n         \
    \                           stack2[i] = stack2[i-1]\n                        \
    \            i += 2\n                                } else {\n              \
    \                      if stack1[i-1] == \"(\" && stack2[i-1] == \")\" {\n   \
    \                                     stack1[i] = stack1[i-1]\n              \
    \                          stack2[i] = stack2[i-1]\n                         \
    \               i += 2\n                                    } else {\n       \
    \                                 return \"No\"\n                            \
    \        }\n                                }\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    if stack1[i-1] == \")\" && stack2[i-1] == \"(\"\
    \ {\n        stack1[i] = stack1[i-1]\n        stack2[i] = stack2[i-1]\n      \
    \  i += 2\n    } else {\n        if stack1[i-1] == \"(\" && stack2[i-1] == \"\
    )\" {\n            stack1[i] = stack1[i-1]\n            stack2[i] = stack2[i-1]\n\
    \            i += 2\n        } else {\n            if stack1[i-1] == \"(\" &&\
    \ stack2[i-1] == \")\" {\n                stack1[i] = stack1[i-1]\n          \
    \      stack2[i] = stack2[i-1]\n                i += \nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2t8wjz4z_test.go:95:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            if\
    \ len(stack) == 0 {\n                result = \"No\"\n                break\n\
    \            }\n            stack = stack[:len(stack)-1]\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack[len(stack)-1] = \"(\"\n            } else\
    \ {\n                stack[len(stack)-1] = \")\"\n            }\n        } else\
    \ {\n            stack[i] = \")\"\n        }\n    }\n    if result == \"No\" {\n\
    \        result = \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5c80, 0x2, 0x2?})\n\
    \t/tmp/tmp7r6yifp3_test.go:29 +0x1bf\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmp7r6yifp3_test.go:52 +0x107\ntesting.tRunner(0xc000120340, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        }\n        if lst[i] == \")\" {\n         \
    \   if len(stack) == 0 {\n                result = \"No\"\n                break\n\
    \            }\n            stack = stack[:len(stack)-1]\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack[len(stack)-1] = \"(\"\n            }\n   \
    \         if stack[len(stack)-1] == \")\" {\n                stack[len(stack)-1]\
    \ = \"(\"\n            }\n        }\n    }\n    if result == \"No\" {\n      \
    \  result = \"Yes\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000162000})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc00011bc80, 0x2, 0x2?})\n\
    \t/tmp/tmpfblz3b4j_test.go:30 +0x1be\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmpfblz3b4j_test.go:52 +0x107\ntesting.tRunner(0xc000103520, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   if len(lst) == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string,\
    \ len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0], stack2[0]\
    \ = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1], lst[1]\n    stack1[2],\
    \ stack2[2] = lst[0], lst[1]\n    stack1[3], stack2[3] = lst[1], lst[0]\n    stack1[4],\
    \ stack2[4] = lst[0], lst[1]\n    stack1[5], stack2[5] = lst[1], lst[0]\n    stack1[6],\
    \ stack2[6] = lst[0], lst[1]\n    stack1[7], stack2[7] = lst[1], lst[0]\n    stack1[8],\
    \ stack2[8] = lst[0], lst[1]\n    stack1[9], stack2[9] = lst[1], lst[0]\n    stack1[10],\
    \ stack2[10] = lst[0], lst[1]\n    stack1[11], stack2[11] = lst[1], lst[0]\n \
    \   stack1[12], stack2[12] = lst[0], lst[1]\n    stack1[13], stack2[13] = lst[1],\
    \ lst[0]\n    stack1[14], stack2[14] = lst[0], lst[1]\n    stack1[15], stack2[15]\
    \ = lst[1], lst[0]\n    stack1[16], stack2[16] = lst[0], lst[1]\n    stack1[17],\
    \ stack2[17] = lst[1], lst[0]\n    stack1[18], stack2[18] = lst[0], lst[1]\n \
    \   stack1[19], stack2[19] = lst[1], lst[0]\n    stack1[20], stack2[20] = lst[0],\
    \ lst[1]\n    stack1[21], stack2[21] = lst[1], lst[0]\n    stack1[22], stack2[22]\
    \ = lst[0], lst[1]\n    stack1[23], stack2[23] = lst[1], lst[0]\n    stack1[24],\
    \ stack2[24] = lst[0], lst[1]\n    stack1[25], stack2[25] = lst[1], lst[0]\n \
    \   stack1[26], stack2[26] = lst[0], lst[1]\n    stack1[27], stack2[27] = lst[1],\
    \ lst[0]\n    stack1[28], stack2[28] = lst[0], lst[1]\n    stack1[29], stack2[29]\
    \ = lst[1], lst[0]\n    stack1[30], stack2[30] = lst[0], lst[1]\n    stack1[31],\
    \ stack2[31] = lst[1], lst[0]\n    stack1[32], stack2[32] = lst[0], lst[1]\n \
    \   stack1[33], stack2[33] = lst[1], lst\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb75_0n3p_test.go:60:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var i int\n    for i = 0; i <\
    \ len(lst); i++ {\n        if lst[i] == \"(\" {\n            result += \"(\"\n\
    \            i++\n            if i == len(lst) {\n                return \"No\"\
    \n            }\n        } else if lst[i] == \")\" {\n            result += \"\
    )\"\n            i++\n            if i == len(lst) {\n                return \"\
    No\"\n            }\n        } else {\n            result += lst[i]\n        }\n\
    \    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpuo96kf15_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpuo96kf15_test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n      \
    \  tmpuo96kf15_test.go:64: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmpuo96kf15_test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpuo96kf15_test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n      \
    \  tmpuo96kf15_test.go:64: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpuo96kf15_test.go:64: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n        \
    \    stack[i] = s\n            i++\n        } else if s[i] == ')' {\n        \
    \    result += \"(\" + stack[len(stack)-i-1] + \")\"\n            stack = stack[:len(stack)-i-1]\n\
    \            i -= 1\n        } else {\n            result += s[i]\n        }\n\
    \    }\n    if stack != nil {\n        return \"No\"\n    }\n    return \"Yes\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9lysx20v_test.go:30:13: invalid operation: result += s[i] (mismatched
    types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   if len(lst) == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string,\
    \ len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0] = lst[0]\n\
    \    stack2[0] = lst[0]\n    i := 1\n    for _, s := range lst[1:] {\n       \
    \ if s == '(' {\n            stack1[i] = s\n            i++\n        } else if\
    \ s == ')' {\n            stack2[i] = s\n            i++\n        } else {\n \
    \           if stack1[i-1] == '(' && stack2[i-1] == ')' {\n                stack1[i]\
    \ = s\n                i++\n            } else {\n                if stack1[i-1]\
    \ == ')' && stack2[i-1] == '(' {\n                    stack1[i] = s\n        \
    \            i++\n                } else {\n                    if stack1[i-1]\
    \ == '(' && stack2[i-1] == ')' {\n                        stack1[i] = s\n    \
    \                    i++\n                    } else {\n                     \
    \   if stack1[i-1] == ')' && stack2[i-1] == '(' {\n                          \
    \  stack1[i] = s\n                            i++\n                        } else\
    \ {\n                            if stack1[i-1] == '(' && stack2[i-1] == ')' {\n\
    \                                stack1[i] = s\n                             \
    \   i++\n                            } else {\n                              \
    \  if stack1[i-1] == '(' && stack2[i-1] == ')' {\n                           \
    \         stack1[i] = s\n                                    i++\n           \
    \                     } else {\n                                    if stack1[i-1]\
    \ == ')' && stack2[i-1] == '(' {\n                                        stack1[i]\
    \ = s\n                                        i++\n                         \
    \           } else {\n                                        if stack1[i-1] ==\
    \ '(' && stack2[i-1] == ')' {\n                                            stack1[i]\
    \ = s\n                                            i++\n                     \
    \                   } else {\n                                            if stack1[i-1]\
    \ == '(' && stack2[i-1] == ')' {\n                                           \
    \     stack1[i] = s\n                                                i++\n   \
    \                                         }\n                                \
    \        }\n                                    }\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                }\n            }\n        }\n    }\n    if stack1[i-1]\
    \ == '(' && stack2[i-1] == ')' {\n        return stack1[i]\n    } else {\n   \
    \     return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0lwvlfw2_test.go:30:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:33:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:37:31: invalid operation: stack1[i - 1] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:37:53: invalid operation: stack2[i - 1] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:41:35: invalid operation: stack1[i - 1] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:41:57: invalid operation: stack2[i - 1] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:45:39: invalid operation: stack1[i - 1] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:45:61: invalid operation: stack2[i - 1] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:49:43: invalid operation: stack1[i - 1] == '')'' (mismatched
    types string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:49:65: invalid operation: stack2[i - 1] == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmp0lwvlfw2_test.go:49:65: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"()\" {\n            result = result + \"()\"\n        } else if\
    \ s == \"()()\" {\n            result = result + \"()()\"\n        } else if s\
    \ == \"(())\" {\n            result = result + \"(())\"\n        } else if s ==\
    \ \"(()())\" {\n            result = result + \"(()())\"\n        } else if s\
    \ == \"(()(())\" {\n            result = result + \"(()(()))\"\n        } else\
    \ if s == \"()(())\" {\n            result = result + \"()(())\"\n        } else\
    \ if s == \"()(()())\" {\n            result = result + \"()(()())\"\n       \
    \ } else if s == \"()(()(())\" {\n            result = result + \"()(()(()))\"\
    \n        } else if s == \"()(()(()())\" {\n            result = result + \"()(()(()()))\"\
    \n        } else if s == \"()(()(()(()))\" {\n            result = result + \"\
    ()(()(()(())))\"\n        } else if s == \"()(()(()(()()))\" {\n            result\
    \ = result + \"()(()(()(()(())))\"\n        } else if s == \"()(()(()(()(())))\"\
    \ {\n            result = result + \"()(()(()(()(()(())))\"\n        } else if\
    \ s == \"()(()(()(()(()())))\" {\n            result = result + \"()(()(()(()(()(()())))\"\
    \n        } else if s == \"()(()(()(()(()(()())))\" {\n            result = result\
    \ + \"()(()(()(()(()(()(()())))\"\n        } else if s == \"()(()(()(()(()(()(()()())))\"\
    \ {\n            result = result + \"()(()(()(()(()(()(()(()()())))\"\n      \
    \  } else if s == \"()(()(()(()(()(()(()(()()()())))\" {\n            result =\
    \ result + \"()(()(()(()(()(()(()(()(()()()())))\"\n        } else if s == \"\
    ()(()(()(()(()(()(()(()(()()()())))\" {\n            result = result + \"()(()(()(()(()(()(()(()(()(()()()())))\"\
    \n        } else if s == \"()(()(()(()(()(()(()(()(()(()()()()())))\" {\n    \
    \        result = result + \"()(()(()(()(()(()(()(()(()(()(()(()()()()())))\"\n\
    \        } else if s == \"()(()(()(()(()(()(()(()(()(()(()(()(()()()()())))\"\
    \ {\n            result = result + \"()(()(()(()(()(()(()(()(()(()(()(()(()(()(()()()()())))\"\
    \n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo76qigfs_test.go:59:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     result += \"(\"\n        for i := 0; i < len(s); i++ {\n            if s[i]\
    \ == '(' {\n                result += \")\"\n            }\n            if s[i]\
    \ == ')' {\n                result += \"(\"\n            }\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"No\"\n    }\n    return \"Yes\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpirzeengy_test.go:60: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpirzeengy_test.go:60: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpirzeengy_test.go:60: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpirzeengy_test.go:60: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpirzeengy_test.go:60: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpirzeengy_test.go:60: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    result := \"No\"\n    for _, s := range lst {\n    \
    \    if s == \"(\" || s == \")\" {\n            result += \"Yes\"\n        }\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'NoYes'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpcmz9gl4r_test.go:51:\
    \ expected 'No', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpcmz9gl4r_test.go:51: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpcmz9gl4r_test.go:51: expected 'Yes', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'NoYesYes'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            stack[i] = lst[i]\n        }\n    }\n\
    \    for i := 0; i < len(stack); i++ {\n        if stack[i] == \"(\" {\n     \
    \       if result == \"Yes\" {\n                result = \"No\"\n            }\
    \ else {\n                result = \"Yes\"\n            }\n        } else if stack[i]\
    \ == \")\" {\n            if result == \"Yes\" {\n                result = \"\
    No\"\n            } else {\n                result = \"Yes\"\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpgki8kcd__test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpgki8kcd__test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n      \
    \  tmpgki8kcd__test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpgki8kcd__test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpgki8kcd__test.go:71: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074120
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0] = lst[0]\n    stack2[0] = lst[0]\n    i := 1\n    for i < len(lst)\
    \ {\n        if lst[i] == \"(\" {\n            stack1[i] = lst[i]\n          \
    \  stack2[i] = lst[i]\n            i++\n        } else if lst[i] == \")\" {\n\
    \            stack1[i] = lst[i]\n            stack2[i] = lst[i]\n            i++\n\
    \        } else if lst[i] == stack1[0] {\n            stack1[i] = lst[i]\n   \
    \         stack2[i] = lst[i]\n            i++\n        } else {\n            stack1[i]\
    \ = stack1[0]\n            stack2[i] = stack2[0]\n            i++\n        }\n\
    \    }\n    stack1[i] = stack1[0]\n    stack2[i] = stack2[0]\n    stack1 := append(stack1[:i],\
    \ stack1[i+1:]...)\n    stack2 := append(stack2[:i], stack2[i+1:]...)\n    if\
    \ stack1 == stack2 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmf2bnz4i_test.go:47:12: no new variables on left side of :=

    /tmp/tmpmf2bnz4i_test.go:48:12: no new variables on left side of :=

    /tmp/tmpmf2bnz4i_test.go:49:8: invalid operation: stack1 == stack2 (slice can
    only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n        \
    \    stack[i] = s\n            i++\n        } else if s[i] == ')' {\n        \
    \    result += \"(\" + stack[i] + \")\"\n            stack[i] = \"\"\n       \
    \     i++\n        } else {\n            result += \"(\" + s[i] + \")\"\n    \
    \    }\n    }\n    if i == len(lst) {\n        return result\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumpmoe2s_test.go:30:23: invalid operation: "(" + s[i] (mismatched types
    untyped string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    result := \"\"\n\
    \    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n         \
    \   stack[i] = 1\n        } else {\n            stack[i] = -1\n        }\n   \
    \ }\n    for i := 0; i < len(lst); i++ {\n        if stack[i] < 0 {\n        \
    \    result += \"(\" + lst[i]\n        } else {\n            result += \"(\" +\
    \ lst[i] + \")\"\n        }\n        if stack[i] == 1 {\n            stack[i]++\n\
    \        }\n        if stack[i] == -1 {\n            stack[i]--\n        }\n \
    \   }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmptra2qp00_test.go:67: expected 'Yes', got '(()(()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmptra2qp00_test.go:67:\
    \ expected 'No', got '()()'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmptra2qp00_test.go:67: expected 'No', got '((()(())(())())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmptra2qp00_test.go:67:\
    \ expected 'Yes', got '()())((()()('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmptra2qp00_test.go:67: expected 'Yes', got '((())))((()())(('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmptra2qp00_test.go:67:\
    \ expected 'No', got '(()(())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmptra2qp00_test.go:67: expected 'Yes', got '((()((()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmptra2qp00_test.go:67: expected\
    \ 'No', got '((((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmptra2qp00_test.go:67: expected 'No', got '()(()((()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmptra2qp00_test.go:67: expected\
    \ 'No', got '()(()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n  \
    \      tmptra2qp00_test.go:67: expected 'Yes', got '(()()'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmptra2qp00_test.go:67: expected 'Yes', got '()(()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074120
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool,\
    \ len(lst))\n    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool,\
    \ len(lst))\n    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool,\
    \ len(lst))\n    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool,\
    \ len(lst))\n    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool,\
    \ len(lst))\n    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool,\
    \ len(lst))\n    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool,\
    \ len(lst))\n    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool,\
    \ len(lst))\n    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool,\
    \ len(lst))\n    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool,\
    \ len(lst))\n    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool,\
    \ len(lst))\n    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool,\
    \ len(lst))\n    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool,\
    \ len(lst))\n    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool,\
    \ len(lst))\n    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool,\
    \ len(lst))\n    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool,\
    \ len(lst))\n    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool,\
    \ len(lst))\n    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool,\
    \ len(lst))\n    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool,\
    \ len(lst))\n    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool,\
    \ len(lst))\n    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvhcg16q2_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n        \
    \    stack[i] = s\n            i++\n        } else if s[i] == ')' {\n        \
    \    result += \"(\" + stack[i] + \")\"\n            stack[i] = \"\"\n       \
    \     i++\n        } else {\n            result += \"(\" + s + \")\"\n       \
    \ }\n    }\n    if i == len(lst) {\n        return result\n    }\n    return \"\
    No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range\
    \ [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens(...)\n\t/tmp/tmp2xosjqql_test.go:22\n\
    command-line-arguments_test.TestMatch_Parens(0xc0001124e0?)\n\t/tmp/tmp2xosjqql_test.go:46\
    \ +0x1e8a\ntesting.tRunner(0xc0001124e0, 0x529f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n    for\
    \ i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == \"(\" {\n       \
    \     stack[i] = \"\"\n            result += \"(\"\n            stack = append(stack,\
    \ \"\")\n        } else if stack[i] == \")\" {\n            stack[i] = \"\"\n\
    \            result += \")\"\n            stack = stack[:len(stack)-1]\n     \
    \   } else {\n            stack[i] = \"\"\n            result += stack[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp4ss72la7_test.go:64: expected 'Yes', got ')'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp4ss72la7_test.go:64: expected\
    \ 'No', got '))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n       \
    \ tmp4ss72la7_test.go:64: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp4ss72la7_test.go:64: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp4ss72la7_test.go:64: expected\
    \ 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp4ss72la7_test.go:64:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmp4ss72la7_test.go:64: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmp4ss72la7_test.go:64: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmp4ss72la7_test.go:64: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp4ss72la7_test.go:64:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmp4ss72la7_test.go:64: expected 'Yes', got ')('\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp4ss72la7_test.go:64: expected 'Yes', got '()'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    result := \"No\"\n    for _, s := range lst {\n    \
    \    if s == \"(\" || s == \")\" {\n            result += \"Yes\"\n        }\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'NoYes'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpcmz9gl4r_test.go:51:\
    \ expected 'No', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpcmz9gl4r_test.go:51: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpcmz9gl4r_test.go:51: expected 'Yes', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'NoYesYes'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool,\
    \ len(lst))\n    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool,\
    \ len(lst))\n    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool,\
    \ len(lst))\n    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool,\
    \ len(lst))\n    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool,\
    \ len(lst))\n    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool,\
    \ len(lst))\n    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool,\
    \ len(lst))\n    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool,\
    \ len(lst))\n    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool,\
    \ len(lst))\n    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool,\
    \ len(lst))\n    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool,\
    \ len(lst))\n    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool,\
    \ len(lst))\n    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool,\
    \ len(lst))\n    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool,\
    \ len(lst))\n    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool,\
    \ len(lst))\n    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool,\
    \ len(lst))\n    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool,\
    \ len(lst))\n    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool,\
    \ len(lst))\n    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool,\
    \ len(lst))\n    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool,\
    \ len(lst))\n    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvhcg16q2_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n           \
    \ stack[i] = s\n            i++\n        } else if s == ')' {\n            i -=\
    \ 1\n            if i == -1 {\n                return \"No\"\n            }\n\
    \            stack[i] = s\n        } else {\n            i++\n        }\n    }\n\
    \    for _, s := range stack {\n        result = result + s\n    }\n    return\
    \ \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgrbrp3ao_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpgrbrp3ao_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n         \
    \   stack1[i] = \"(\"\n            stack2[i] = \")\"\n        } else {\n     \
    \       stack1[i] = \")\"\n            stack2[i] = \"(\"\n        }\n    }\n \
    \   stack1Len := len(stack1)\n    stack2Len := len(stack2)\n    if stack1Len >\
    \ stack2Len {\n        return \"No\"\n    }\n    stack1Len -= stack2Len\n    stack2Len\
    \ -= stack1Len\n    stack1Len += 1\n    stack2Len += 1\n    stack1 := stack1[:stack1Len]\n\
    \    stack2 := stack2[:stack2Len]\n    stack1Len += stack2Len\n    stack2Len +=\
    \ stack1Len\n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n\
    \    stack1Len += stack2Len\n    stack2Len += stack1Len\n    stack1 := stack1[:stack1Len]\n\
    \    stack2 := stack2[:stack2Len]\n    stack1Len += stack2Len\n    stack2Len +=\
    \ stack1Len\n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n\
    \    stack1Len += stack2Len\n    stack2Len += stack1Len\n    stack1 := stack1[:stack1Len]\n\
    \    stack2 := stack2[:stack2Len]\n    stack1Len += stack2Len\n    stack2Len +=\
    \ stack1Len\n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n\
    \    stack1Len += stack2Len\n    stack2Len += stack1Len\n    stack1 := stack1[:stack1Len]\n\
    \    stack2 := stack2[:stack2Len]\n    stack1Len += stack2Len\n    stack2Len +=\
    \ stack1Len\n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n\
    \    stack1Len += stack2Len\n    stack2Len += stack1Len\n    stack1 := stack1[:stack1Len]\n\
    \    stack2 := stack2[:stack2Len]\n\nfunc TestMatch_Parens(t *testing.T) {\n \
    \ candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjsuutn7_test.go:76:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    for i := 0; i <\
    \ len(lst); i++ {\n        stack[i] = i\n    }\n    result := \"\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    for i := 0; i < len(lst); i++ {\n       \
    \ if stack[i] > len(lst)-1 {\n            result += \"(\"\n            stack[i]\
    \ = 0\n        } else {\n            result += \"(\"\n            stack[i]++\n\
    \        }\n    }\n    result += \")\"\n    result += \")\"\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpnxhjdqw0_test.go:63: expected 'Yes', got '(((())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpnxhjdqw0_test.go:63:\
    \ expected 'No', got '(((())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpnxhjdqw0_test.go:63: expected 'No', got '(((())'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpnxhjdqw0_test.go:63: expected 'Yes', got '(((())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpnxhjdqw0_test.go:63:\
    \ expected 'Yes', got '(((())'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpnxhjdqw0_test.go:63: expected 'No', got '(((())'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpnxhjdqw0_test.go:63: expected 'Yes', got '(((())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpnxhjdqw0_test.go:63:\
    \ expected 'No', got '(((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpnxhjdqw0_test.go:63: expected 'No', got '(((())'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnxhjdqw0_test.go:63: expected 'No', got '(((())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpnxhjdqw0_test.go:63:\
    \ expected 'Yes', got '(((())'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpnxhjdqw0_test.go:63: expected 'Yes', got '(((())'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else {\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack[len(stack)-1] = \")\"\n            } else\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpwyt5ovo4_test.go:59: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpwyt5ovo4_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpwyt5ovo4_test.go:59: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpwyt5ovo4_test.go:59: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpwyt5ovo4_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpwyt5ovo4_test.go:59: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    result := \"No\"\n    for _, item := range lst {\n \
    \       if item == \"(\" || item == \")\" {\n            result += \"Yes\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpv0zbuvcq_test.go:51: expected 'Yes', got 'NoYes'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpv0zbuvcq_test.go:51:\
    \ expected 'No', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpv0zbuvcq_test.go:51: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpv0zbuvcq_test.go:51: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpv0zbuvcq_test.go:51: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpv0zbuvcq_test.go:51: expected 'Yes', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpv0zbuvcq_test.go:51: expected 'Yes', got 'NoYesYes'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    result := \"No\"\n    for _, s := range lst {\n    \
    \    if s == \"(\" || s == \")\" {\n            continue\n        }\n        result\
    \ := \"Yes\"\n        break\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7nen23rp_test.go:23:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n      \
    \  result += \"(\" + s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '(()()())(()()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '())())())())'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'No', got '((()(()))(())()))((()(()))(())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'Yes', got '()()))((()()()()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '((()))))((()())(()((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '(())(()))(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '((()()(()))())((()()(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '((((()(((()))((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'No', got '()(())((()()()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '()()()()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '(()())(()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'Yes', got '())(()())(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    result := \"No\"\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n        \
    \    stack[i] = 1\n        } else if lst[i] == \")\" {\n            stack[i] =\
    \ 0\n        } else if stack[i] == 0 {\n            result = \"No\"\n        \
    \    break\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp893bfqvj_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp893bfqvj_test.go:57: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp893bfqvj_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp893bfqvj_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp893bfqvj_test.go:57: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp893bfqvj_test.go:57: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if result != \"\" {\n            result = result + \")\"\n        }\n  \
    \      result = result + s\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp_s2cb43g_test.go:52: expected 'Yes', got '()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp_s2cb43g_test.go:52:\
    \ expected 'No', got ')))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp_s2cb43g_test.go:52: expected 'No', got '(()(()))())())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp_s2cb43g_test.go:52:\
    \ expected 'Yes', got ')()))(()()('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp_s2cb43g_test.go:52: expected 'Yes', got '(()))))(()())(('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp_s2cb43g_test.go:52:\
    \ expected 'No', got '())())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmp_s2cb43g_test.go:52: expected 'Yes', got '(()()()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmp_s2cb43g_test.go:52: expected\
    \ 'No', got '(((()((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmp_s2cb43g_test.go:52: expected 'No', got ')(())(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp_s2cb43g_test.go:52: expected\
    \ 'No', got ')())('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n   \
    \     tmp_s2cb43g_test.go:52: expected 'Yes', got '())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp_s2cb43g_test.go:52: expected 'Yes', got '))('\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n        \
    \    stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else if stack[len(stack)-1] == \"\" {\n            stack\
    \ = append(stack, \"\")\n        }\n    }\n    if len(stack) == 0 {\n        return\
    \ \"No\"\n    }\n    for i := 0; i < len(stack); i++ {\n        if stack[i] ==\
    \ \"\" {\n            result += \"(\"\n        } else {\n            result +=\
    \ \"(\"\n        }\n    }\n    for i := 0; i < len(stack); i++ {\n        if stack[i]\
    \ == \"\" {\n            result += \")\"\n        } else {\n            result\
    \ += \")\"\n        }\n    }\n    if result == \"()\" {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5myf2n5k_test.go:76: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5myf2n5k_test.go:76: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5myf2n5k_test.go:76: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5myf2n5k_test.go:76: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp5myf2n5k_test.go:76: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp5myf2n5k_test.go:76: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   result := \"\"\n    stack := make([]string, len(lst))\n    for i := 0; i <\
    \ len(lst); i++ {\n        stack[i] = lst[i]\n    }\n    for i := len(stack) -\
    \ 1; i >= 0; i-- {\n        if stack[i] == \"(\" {\n            stack[i] = \"\
    (\"\n            result += stack[i]\n            stack = stack[:len(stack)-1]\n\
    \        } else if stack[i] == \")\" {\n            stack[i] = \")\"\n       \
    \     result += stack[i]\n            stack = stack[:len(stack)-1]\n        }\
    \ else {\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if result\
    \ != \"\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmphx09s6d2_test.go:69: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmphx09s6d2_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmphx09s6d2_test.go:69: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmphx09s6d2_test.go:69: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool,\
    \ len(lst))\n    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool,\
    \ len(lst))\n    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool,\
    \ len(lst))\n    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool,\
    \ len(lst))\n    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool,\
    \ len(lst))\n    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool,\
    \ len(lst))\n    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool,\
    \ len(lst))\n    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool,\
    \ len(lst))\n    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool,\
    \ len(lst))\n    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool,\
    \ len(lst))\n    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool,\
    \ len(lst))\n    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool,\
    \ len(lst))\n    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool,\
    \ len(lst))\n    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool,\
    \ len(lst))\n    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool,\
    \ len(lst))\n    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool,\
    \ len(lst))\n    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool,\
    \ len(lst))\n    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool,\
    \ len(lst))\n    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool,\
    \ len(lst))\n    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool,\
    \ len(lst))\n    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvhcg16q2_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    result += \"(\"\n    for _, s\
    \ := range lst {\n        result += s\n        result += \"(\"\n    }\n    result\
    \ += \")\"\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpaybvpozn_test.go:52: expected 'Yes', got '(()(()()'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpaybvpozn_test.go:52:\
    \ expected 'No', got '()()()'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpaybvpozn_test.go:52: expected 'No', got '((()(())(())())()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpaybvpozn_test.go:52:\
    \ expected 'Yes', got '()())((()()(()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpaybvpozn_test.go:52: expected 'Yes', got '((())))((()())((()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpaybvpozn_test.go:52:\
    \ expected 'No', got '(()(())()'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpaybvpozn_test.go:52: expected 'Yes', got '((()((()))()()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpaybvpozn_test.go:52:\
    \ expected 'No', got '((((((((())()'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpaybvpozn_test.go:52: expected 'No', got '()(()((()(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmpaybvpozn_test.go:52:\
    \ expected 'No', got '()(()(()'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmpaybvpozn_test.go:52: expected 'Yes', got '((()()'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpaybvpozn_test.go:52: expected 'Yes', got '()((()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var i int\n    for i = 0; i <\
    \ len(lst); i++ {\n        if lst[i] == \"(\" {\n            result += \"(\"\n\
    \            i++\n        }\n        if lst[i] == \")\" {\n            result\
    \ += \")\"\n            i++\n        }\n    }\n    if result == \"()\" {\n   \
    \     return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpft8ici4g_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpft8ici4g_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpft8ici4g_test.go:60: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpft8ici4g_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpft8ici4g_test.go:60: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if\
    \ i == -1 {\n            stack = stack[:len(stack)-1]\n        } else {\n    \
    \        stack[len(stack)-1]--\n        }\n        if stack[len(stack)-1] == -1\
    \ {\n            result += \"(\"\n            stack = stack[:len(stack)-1]\n \
    \       } else {\n            result += \"(\"\n        }\n    }\n    if result\
    \ == \"()\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n \
    \   }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph_lmurfu_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n      \
    \  result += \"(\" + s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '(()()())(()()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '())())())())'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'No', got '((()(()))(())()))((()(()))(())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'Yes', got '()()))((()()()()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '((()))))((()())(()((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '(())(()))(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '((()()(()))())((()()(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '((((()(((()))((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'No', got '()(())((()()()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '()()()()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '(()())(()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'Yes', got '())(()())(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack1[0], stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1]\
    \ = lst[1], lst[1]\n    stack1[2], stack2[2] = lst[2], lst[2]\n    stack1[3],\
    \ stack2[3] = lst[3], lst[3]\n    stack1[4], stack2[4] = lst[4], lst[4]\n    stack1[5],\
    \ stack2[5] = lst[5], lst[5]\n    stack1[6], stack2[6] = lst[6], lst[6]\n    stack1[7],\
    \ stack2[7] = lst[7], lst[7]\n    stack1[8], stack2[8] = lst[8], lst[8]\n    stack1[9],\
    \ stack2[9] = lst[9], lst[9]\n    stack1[10], stack2[10] = lst[10], lst[10]\n\
    \    stack1[11], stack2[11] = lst[11], lst[11]\n    stack1[12], stack2[12] = lst[12],\
    \ lst[12]\n    stack1[13], stack2[13] = lst[13], lst[13]\n    stack1[14], stack2[14]\
    \ = lst[14], lst[14]\n    stack1[15], stack2[15] = lst[15], lst[15]\n    stack1[16],\
    \ stack2[16] = lst[16], lst[16]\n    stack1[17], stack2[17] = lst[17], lst[17]\n\
    \    stack1[18], stack2[18] = lst[18], lst[18]\n    stack1[19], stack2[19] = lst[19],\
    \ lst[19]\n    stack1[20], stack2[20] = lst[20], lst[20]\n    stack1[21], stack2[21]\
    \ = lst[21], lst[21]\n    stack1[22], stack2[22] = lst[22], lst[22]\n    stack1[23],\
    \ stack2[23] = lst[23], lst[23]\n    stack1[24], stack2[24] = lst[24], lst[24]\n\
    \    stack1[25], stack2[25] = lst[25], lst[25]\n    stack1[26], stack2[26] = lst[26],\
    \ lst[26]\n    stack1[27], stack2[27] = lst[27], lst[27]\n    stack1[28], stack2[28]\
    \ = lst[28], lst[28]\n    stack1[29], stack2[29] = lst\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt1ty8mb0_test.go:50:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := 0; i\
    \ < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\
    \n        } else if lst[i] == \")\" {\n            if len(stack) == 0 {\n    \
    \            return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n\
    \            if stack[len(stack)-1] == \"(\" {\n                stack[len(stack)-1]\
    \ = \"(\"\n            } else {\n                stack[len(stack)-1] = \")\"\n\
    \            }\n        } else {\n            return \"No\"\n        }\n    }\n\
    \    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5c80, 0x2, 0x2?})\n\
    \t/tmp/tmp1w6nr328_test.go:27 +0x1a7\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmp1w6nr328_test.go:47 +0x107\ntesting.tRunner(0xc0001924e0, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    result := \"No\"\
    \n    i := 0\n    for _, str := range lst {\n        if str == \"(\" || str ==\
    \ \")\" {\n            stack[i] = 1\n        } else {\n            stack[i] =\
    \ 0\n        }\n        i++\n    }\n    for i := len(stack) - 1; i >= 0; i-- {\n\
    \        if stack[i] == 1 {\n            result = \"Yes\"\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpb0y0mvlv_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpb0y0mvlv_test.go:62: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpb0y0mvlv_test.go:62: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpb0y0mvlv_test.go:62: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    result := \"\"\n\
    \    i := 0\n    for _, s := range lst {\n        if s == '(' {\n            stack[i]\
    \ = 1\n            i++\n        } else if s == ')' {\n            stack[i] = -1\n\
    \            i++\n        } else if stack[i] == 1 {\n            result += s\n\
    \        }\n    }\n    if result != \"\" {\n        return \"Yes\"\n    }\n  \
    \  return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwrklg6r_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpkwrklg6r_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0], stack2[0] = lst[0], lst[1]\n    stack1[1], stack2[1] = lst[1],\
    \ lst[0]\n    stack1[2], stack2[2] = lst[2], lst[1]\n    stack1[3], stack2[3]\
    \ = lst[3], lst[2]\n    stack1[4], stack2[4] = lst[4], lst[3]\n    stack1[5],\
    \ stack2[5] = lst[5], lst[4]\n    stack1[6], stack2[6] = lst[6], lst[5]\n    stack1[7],\
    \ stack2[7] = lst[7], lst[6]\n    stack1[8], stack2[8] = lst[8], lst[7]\n    stack1[9],\
    \ stack2[9] = lst[9], lst[8]\n    stack1[10], stack2[10] = lst[10], lst[9]\n \
    \   stack1[11], stack2[11] = lst[11], lst[10]\n    stack1[12], stack2[12] = lst[12],\
    \ lst[11]\n    stack1[13], stack2[13] = lst[13], lst[12]\n    stack1[14], stack2[14]\
    \ = lst[14], lst[13]\n    stack1[15], stack2[15] = lst[15], lst[14]\n    stack1[16],\
    \ stack2[16] = lst[16], lst[15]\n    stack1[17], stack2[17] = lst[17], lst[16]\n\
    \    stack1[18], stack2[18] = lst[18], lst[17]\n    stack1[19], stack2[19] = lst[19],\
    \ lst[18]\n    stack1[20], stack2[20] = lst[20], lst[19]\n    stack1[21], stack2[21]\
    \ = lst[21], lst[20]\n    stack1[22], stack2[22] = lst[22], lst[21]\n    stack1[23],\
    \ stack2[23] = lst[23], lst[22]\n    stack1[24], stack2[24] = lst[24], lst[23]\n\
    \    stack1[25], stack2[25] = lst[25], lst[24]\n    stack1[26], stack2[26] = lst[26],\
    \ lst[25]\n    stack1[27], stack2[27] = lst[27], lst[26]\n    stack1[28], stack2[28]\
    \ = lst[28], lst[27]\n    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx1h4l1a7_test.go:53:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n        \
    \    stack[i] = s\n            i++\n        } else if s[i] == ')' {\n        \
    \    result += \"(\" + stack[i] + \")\"\n            stack[i] = \"\"\n       \
    \     i++\n        } else {\n            result += \"(\" + s[i] + \")\"\n    \
    \    }\n    }\n    if i == len(lst) {\n        return result\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumpmoe2s_test.go:30:23: invalid operation: "(" + s[i] (mismatched types
    untyped string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074120
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += \"(\"\n        } else\
    \ {\n            result += s\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpjlhxvayd_test.go:53: expected 'Yes', got '()(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpjlhxvayd_test.go:53:\
    \ expected 'No', got '(('\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpjlhxvayd_test.go:53: expected 'No', got '(()(())())())'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpjlhxvayd_test.go:53: expected\
    \ 'Yes', got ')())(()()('\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpjlhxvayd_test.go:53: expected 'Yes', got '(())))(()())(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpjlhxvayd_test.go:53:\
    \ expected 'No', got '()())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpjlhxvayd_test.go:53: expected 'Yes', got '(()(()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpjlhxvayd_test.go:53: expected\
    \ 'No', got '((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpjlhxvayd_test.go:53: expected 'No', got ')(()(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpjlhxvayd_test.go:53: expected\
    \ 'No', got ')()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n    \
    \    tmpjlhxvayd_test.go:53: expected 'Yes', got '(('\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpjlhxvayd_test.go:53: expected 'Yes', got '(('\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074122
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, v := range lst {\n   \
    \     if v == \"(\" || v == \")\" {\n            result += \"(\" + v + \")\"\n\
    \        } else {\n            result += \"(\" + v + \")\"\n        }\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpwubx8lrq_test.go:53: expected 'Yes', got '(()()())'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpwubx8lrq_test.go:53:\
    \ expected 'No', got '())())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpwubx8lrq_test.go:53: expected 'No', got '((()(()))(())()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpwubx8lrq_test.go:53:\
    \ expected 'Yes', got '()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpwubx8lrq_test.go:53: expected 'Yes', got '((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpwubx8lrq_test.go:53:\
    \ expected 'No', got '(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpwubx8lrq_test.go:53: expected 'Yes', got '((()()(()))())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpwubx8lrq_test.go:53:\
    \ expected 'No', got '((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpwubx8lrq_test.go:53: expected 'No', got '()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmpwubx8lrq_test.go:53:\
    \ expected 'No', got '()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmpwubx8lrq_test.go:53: expected 'Yes', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpwubx8lrq_test.go:53: expected 'Yes', got '())(()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    result += \"Yes\"\n    for _,\
    \ item := range lst {\n        if item == \"(\" {\n            result += \"Yes\"\
    \n        }\n        if item == \")\" {\n            result += \"Yes\"\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp_qp9uui__test.go:55: expected 'Yes', got 'YesYes'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp_qp9uui__test.go:55:\
    \ expected 'No', got 'YesYesYes'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp_qp9uui__test.go:55: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmp_qp9uui__test.go:55: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmp_qp9uui__test.go:55: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n      \
    \  tmp_qp9uui__test.go:55: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp_qp9uui__test.go:55: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp_qp9uui__test.go:55: expected\
    \ 'Yes', got 'YesYesYes'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp_qp9uui__test.go:55: expected 'Yes', got 'YesYesYes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        stack\
    \ = stack[:len(stack)-1]\n        if i == -1 {\n            result += \"(\"\n\
    \        } else {\n            result += \"(\"\n            for _, s := range\
    \ lst[i+1:] {\n                if s == '(' {\n                    stack = append(stack,\
    \ i)\n                } else {\n                    stack = append(stack, len(s))\n\
    \                }\n            }\n        }\n    }\n    return result\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjjf8u44x_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpjjf8u44x_test.go:35:25: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    var\
    \ i int\n    for i = 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n  \
    \          stack = append(stack, i)\n        }\n        if lst[i] == \")\" {\n\
    \            if len(stack) == 0 {\n                return \"No\"\n           \
    \ }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqpb5pnxh_test.go:18:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        stack\
    \ = stack[:len(stack)-1]\n        if i == -1 {\n            result += \"(\"\n\
    \        } else {\n            result += \"(\"\n            for _, s := range\
    \ lst[i+1:] {\n                if s == '(' {\n                    stack = append(stack,\
    \ i+1)\n                } else {\n                    stack = append(stack, len(s))\n\
    \                }\n            }\n            result += s\n        }\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdt1z5ug9_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpdt1z5ug9_test.go:35:25: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpdt1z5ug9_test.go:41:23: undefined: s

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   s := lst[0]\n    i := 0\n    for i < len(lst) {\n        if lst[i] == \"(\"\
    \ {\n            s += \")\"\n            i += 1\n        } else if lst[i] == \"\
    )\" {\n            s += \"(\"\n            i += 1\n        } else {\n        \
    \    s += lst[i]\n            i += 1\n        }\n    }\n    if s != lst[0] {\n\
    \        return \"No\"\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp6kgccnmm_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp6kgccnmm_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp6kgccnmm_test.go:65: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp6kgccnmm_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp6kgccnmm_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp6kgccnmm_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n    stack\
    \ = stack[:len(lst)]\n    for len(stack) > 0 {\n        i := len(stack) - 1\n\
    \        result += \"(\"\n        if stack[i] != \")\" {\n            result +=\
    \ \"(\"\n        }\n        stack = stack[:len(stack)-1]\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpsvoy82q7_test.go:59: expected 'Yes', got '((('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpsvoy82q7_test.go:59:\
    \ expected 'No', got '(('\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpsvoy82q7_test.go:59: expected 'No', got '(((('\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpsvoy82q7_test.go:59: expected 'Yes', got '(((('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpsvoy82q7_test.go:59:\
    \ expected 'Yes', got '(((('\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpsvoy82q7_test.go:59: expected 'No', got '(((('\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpsvoy82q7_test.go:59: expected 'Yes', got '(((('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpsvoy82q7_test.go:59:\
    \ expected 'No', got '(((('\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpsvoy82q7_test.go:59: expected 'No', got '(((('\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpsvoy82q7_test.go:59: expected 'No', got '(((('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpsvoy82q7_test.go:59:\
    \ expected 'Yes', got '((('\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpsvoy82q7_test.go:59: expected 'Yes', got '((('\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074123
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    result := \"No\"\n    for _, s := range lst {\n    \
    \    if s == \"(\" || s == \")\" {\n            continue\n        }\n        result\
    \ := \"Yes\"\n        break\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7nen23rp_test.go:23:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := 0; i\
    \ < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\
    \n        } else {\n            if stack[len(stack)-1] == \"(\" {\n          \
    \      stack[len(stack)-1] += \")\"\n            } else {\n                return\
    \ \"No\"\n            }\n        }\n    }\n    if stack[len(stack)-1] == \"(\"\
    \ {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpr2emvelt_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpr2emvelt_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpr2emvelt_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpr2emvelt_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpr2emvelt_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpr2emvelt_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if result != \"\" {\n            result += \"|\"\n        }\n        result\
    \ += \"(\" + s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpl58hi35v_test.go:52: expected 'Yes', got '(()()|())'\n \
    \   --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpl58hi35v_test.go:52:\
    \ expected 'No', got '())|())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpl58hi35v_test.go:52: expected 'No', got '((()(()))|(())()))'\n   \
    \ --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpl58hi35v_test.go:52:\
    \ expected 'Yes', got '()()))|((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpl58hi35v_test.go:52: expected 'Yes', got '((()))))|((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpl58hi35v_test.go:52:\
    \ expected 'No', got '(())|(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpl58hi35v_test.go:52: expected 'Yes', got '((()()|(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpl58hi35v_test.go:52:\
    \ expected 'No', got '((((()|(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpl58hi35v_test.go:52: expected 'No', got '()(())|((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmpl58hi35v_test.go:52:\
    \ expected 'No', got '()()|()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpl58hi35v_test.go:52: expected 'Yes', got '(()|())'\n   \
    \ --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmpl58hi35v_test.go:52:\
    \ expected 'Yes', got '())|(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0], stack2[0] = lst[0], lst[1]\n    i := 2\n    for i < len(lst) {\n\
    \        if stack1[i] == \")\" && stack2[i] == \"(\" {\n            stack1[i]\
    \ = \"\"\n            stack2[i] = \"\"\n            i++\n        } else if stack1[i]\
    \ == \"(\" && stack2[i] == \")\" {\n            stack1[i] = \"\"\n           \
    \ stack2[i] = \"\"\n            i++\n        } else if stack1[i] == \")\" && stack2[i]\
    \ == \"(\" {\n            stack1[i] = \"\"\n            stack2[i] = \"\"\n   \
    \         i++\n        } else if stack1[i] == \"(\" && stack2[i] == \")\" {\n\
    \            stack1[i] = \"\"\n            stack2[i] = \"\"\n            i++\n\
    \        } else if stack1[i] == \")\" && stack2[i] == \"(\" {\n            stack1[i]\
    \ = \"\"\n            stack2[i] = \"\"\n            i++\n        } else if stack1[i]\
    \ == \"(\" && stack2[i] == \")\" {\n            stack1[i] = \"\"\n           \
    \ stack2[i] = \"\"\n            i++\n        } else if stack1[i] == \")\" && stack2[i]\
    \ == \"(\" {\n            stack1[i] = \"\"\n            stack2[i] = \"\"\n   \
    \         i++\n        } else if stack1[i] == \")\" && stack2[i] == \"(\" {\n\
    \            stack1[i] = \"\"\n            stack2[i] = \"\"\n            i++\n\
    \        } else if stack1[i] == \"(\" && stack2[i] == \")\" {\n            stack1[i]\
    \ = \"\"\n            stack2[i] = \"\"\n            i++\n        } else if stack1[i]\
    \ == \")\" && stack2[i] == \"(\" {\n            stack1[i] = \"\"\n           \
    \ stack2[i] = \"\"\n            i++\n        } else if stack1[i] == \")\" && stack2[i]\
    \ == \"(\" {\n            stack1[i] = \"\"\n            stack2[i] = \"\"\n   \
    \         i++\n        } else if stack1[i] == \")\" && stack2[i] == \"(\" {\n\
    \            stack1[i] = \"\"\n            stack2[i] = \"\"\n            i++\n\
    \        } else if stack1[i] == \")\" && stack2[i] == \"(\" {\n            stack1[i]\
    \ = \"\"\n            stack2[i] = \"\"\n            i++\n        } else if stack1[i]\
    \ == \")\" && stack2[i] == \"(\" {\n            stack1[i] = \"\"\n           \
    \ stack2[i] = \"\"\n            i++\n        } else if stack1[i] == \")\" && stack2[i]\
    \ == \"(\" {\n            stack1[i] = \"\"\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy3l3gxfy_test.go:85:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074122
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack := make([]string, len(lst))\n    stack[0] = lst[0]\n    stack[1] = lst[1]\n\
    \    i := 2\n    for i < len(lst) {\n        if lst[i] == \"(\" {\n          \
    \  stack[i] = lst[i]\n            i++\n        } else if lst[i] == \")\" {\n \
    \           stack[i] = lst[i]\n            i++\n        } else if lst[i] == \"\
    (\" && stack[len(stack)-1] == \"(\" {\n            stack[i] = lst[i]\n       \
    \     i++\n        } else if lst[i] == \")\" && stack[len(stack)-1] == \"(\" {\n\
    \            stack[i] = lst[i]\n            i++\n        } else if lst[i] == \"\
    (\" && stack[len(stack)-1] == \")\" {\n            stack[i] = lst[i]\n       \
    \     i++\n        } else if lst[i] == \")\" && stack[len(stack)-1] == \")\" {\n\
    \            stack[i] = lst[i]\n            i++\n        } else {\n          \
    \  return \"No\"\n        }\n    }\n    if stack[len(stack)-1] == \"(\" {\n  \
    \      return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8n360bvh_test.go:79: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp8n360bvh_test.go:79: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp8n360bvh_test.go:79: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp8n360bvh_test.go:79: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp8n360bvh_test.go:79: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps0_6jr53_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074115
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if\
    \ i == -1 {\n            stack = stack[:len(stack)-1]\n        } else {\n    \
    \        stack[len(stack)-1]--\n        }\n        if stack[len(stack)-1] == -1\
    \ {\n            result += \"(\"\n            stack = stack[:len(stack)-1]\n \
    \       } else {\n            result += \"(\"\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdhz0efvg_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    for i := 0; i <\
    \ len(lst); i++ {\n        stack[i] = 0\n    }\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] == \"(\" {\n            stack[i]++\n        } else\
    \ if lst[i] == \")\" {\n            stack[i]--\n            if stack[i] == 0 {\n\
    \                return \"Yes\"\n            }\n        }\n    }\n    return \"\
    No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp08xfz9of_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp08xfz9of_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp08xfz9of_test.go:59: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp08xfz9of_test.go:59: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp08xfz9of_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp08xfz9of_test.go:59: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    result := \"\"\n\
    \    i := 0\n    for _, s := range lst {\n        if s == '(' {\n            stack[i]\
    \ = 1\n        } else if s == ')' {\n            stack[i] = 0\n        } else\
    \ if stack[i] != 0 {\n            return fmt.Sprintf(\"No\")\n        }\n    \
    \    i++\n    }\n    if i == len(lst) {\n        return fmt.Sprintf(\"Yes\")\n\
    \    }\n    return fmt.Sprintf(\"No\")\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkadwuttj_test.go:19:5: result declared but not used

    /tmp/tmpkadwuttj_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpkadwuttj_test.go:24:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            if\
    \ len(stack) == 0 {\n                result = \"Yes\"\n                break\n\
    \            }\n            stack = stack[:len(stack)-1]\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack[len(stack)-1] = \"(\"\n            } else\
    \ {\n                stack[len(stack)-1] = \")\"\n            }\n        } else\
    \ {\n            stack[i] = \")\"\n        }\n    }\n    return result\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5c80, 0x2, 0x2?})\n\
    \t/tmp/tmplifcz_db_test.go:29 +0x1d4\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmplifcz_db_test.go:49 +0x107\ntesting.tRunner(0xc0001a01a0, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            if\
    \ len(stack) == 0 {\n                result = \"Yes\"\n                break\n\
    \            }\n            stack = stack[:len(stack)-1]\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack[len(stack)-1] = \"(\"\n            } else\
    \ {\n                stack[len(stack)-1] = \")\"\n            }\n        } else\
    \ {\n            stack[i] = \"?\"\n        }\n    }\n    return result\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000fdc80, 0x2, 0x2?})\n\
    \t/tmp/tmppzdek67i_test.go:29 +0x1d4\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmppzdek67i_test.go:49 +0x107\ntesting.tRunner(0xc00019a680, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += \"(\" + s + \")\"\n\
    \        } else {\n            result += \"(\" + s + \")\"\n        }\n    }\n\
    \    if result == \"(\" + \")\" + \")\" {\n        return \"Yes\"\n    } else\
    \ {\n        return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpv87ypon2_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpv87ypon2_test.go:57: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpv87ypon2_test.go:57: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpv87ypon2_test.go:57: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpv87ypon2_test.go:57: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpv87ypon2_test.go:57: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n        \
    \    stack[i] = s\n            i++\n        } else if s[i] == ')' {\n        \
    \    result += \"(\" + stack[len(stack)-i-1] + \")\"\n            i -= len(stack[len(stack)-i-1])\n\
    \        } else {\n            result += \"(\" + s + \")\"\n        }\n    }\n\
    \    if i == 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range\
    \ [1] with length 1\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc000187ca0, 0x2, 0x2?})\n\
    \t/tmp/tmp7nxgve8h_test.go:22 +0x205\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmp7nxgve8h_test.go:45 +0x99\ntesting.tRunner(0xc000198ea0, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if result != \"\" {\n            result = result + \")\"\n        }\n  \
    \      result = result + s\n    }\n    if result != \"\" {\n        result = \"\
    (\" + result\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm2189gln_test.go:55: expected 'Yes', got '(()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpm2189gln_test.go:55:\
    \ expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpm2189gln_test.go:55: expected 'No', got '((()(()))())())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpm2189gln_test.go:55:\
    \ expected 'Yes', got '()()))(()()('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm2189gln_test.go:55: expected 'Yes', got '((()))))(()())(('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpm2189gln_test.go:55:\
    \ expected 'No', got '(())())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpm2189gln_test.go:55: expected 'Yes', got '((()()()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpm2189gln_test.go:55: expected\
    \ 'No', got '((((()((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpm2189gln_test.go:55: expected 'No', got '()(())(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm2189gln_test.go:55: expected\
    \ 'No', got '()())('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n  \
    \      tmpm2189gln_test.go:55: expected 'Yes', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpm2189gln_test.go:55: expected 'Yes', got '())('\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if\
    \ i == -1 {\n            stack = stack[:len(stack)-1]\n        } else {\n    \
    \        stack[len(stack)-1]--\n        }\n        if stack[len(stack)-1] == -1\
    \ {\n            result += \"(\"\n            stack = stack[:len(stack)-1]\n \
    \       } else {\n            result += \"(\"\n        }\n    }\n    for _, s\
    \ := range lst {\n        if s == '(' {\n            stack = append(stack, len(s))\n\
    \        } else {\n            stack = append(stack, -1)\n        }\n    }\n \
    \   for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        if i == -1\
    \ {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1]--\n\
    \        }\n        if stack[len(stack)-1] == -1 {\n            result += \"(\"\
    \n            stack = stack[:len(stack)-1]\n        } else {\n            result\
    \ += \"(\"\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx699blek_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpx699blek_test.go:42:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074123
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps0_6jr53_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074115
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := range\
    \ lst {\n        stack[i] = lst[i]\n    }\n    result := \"\"\n    i := 0\n  \
    \  for i < len(stack) {\n        if stack[i] == \"(\" {\n            i++\n   \
    \         if i == len(stack) {\n                return \"No\"\n            }\n\
    \            if stack[i] == \"(\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \")\" {\n            i++\n     \
    \       if i == len(stack) {\n                return \"No\"\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \"(\" {\n            i++\n     \
    \       if i == len(stack) {\n                return \"No\"\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \")\" {\n            i++\n     \
    \       if i == len(stack) {\n                return \"No\"\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \")\" {\n            i++\n     \
    \       if i == len(stack) {\n                return \"No\"\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \"(\" {\n            i++\n     \
    \       if i == len(stack) {\n                return \"No\"\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \")\" {\n            i++\n     \
    \       if i == len(stack) {\n                return \"No\"\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \")\" {\n            i++\n     \
    \       if i == len(stack) {\n                return \"No\"\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \")\" {\n            i++\n     \
    \       if i == len(stack) {\n                return \"No\"\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    return \"No\"\n                }\n    \
    \        }\n        }\n        if stack[i] == \")\" {\n            i++\n     \
    \       if i == len(stack) {\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp49i03b3c_test.go:136:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074124
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for i := 0; i < len(stack); i++ {\n        if stack[i] < 0 {\n   \
    \         continue\n        }\n        result += \"(\"\n        for j := 0; j\
    \ < i; j++ {\n            if stack[j] < 0 {\n                continue\n      \
    \      }\n            result += lst[stack[j]]\n        }\n        result += \"\
    )\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3jnh2ea0_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074125
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        stack\
    \ = stack[:len(stack)-1]\n        if i == -1 {\n            result += '('\n  \
    \      } else {\n            result += lst[i]\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5w5s04qw_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp5w5s04qw_test.go:31:13: invalid operation: result += ''('' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074125
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool,\
    \ len(lst))\n    stack3 := make([]bool, len(lst))\n    stack4 := make([]bool,\
    \ len(lst))\n    stack5 := make([]bool, len(lst))\n    stack6 := make([]bool,\
    \ len(lst))\n    stack7 := make([]bool, len(lst))\n    stack8 := make([]bool,\
    \ len(lst))\n    stack9 := make([]bool, len(lst))\n    stack10 := make([]bool,\
    \ len(lst))\n    stack11 := make([]bool, len(lst))\n    stack12 := make([]bool,\
    \ len(lst))\n    stack13 := make([]bool, len(lst))\n    stack14 := make([]bool,\
    \ len(lst))\n    stack15 := make([]bool, len(lst))\n    stack16 := make([]bool,\
    \ len(lst))\n    stack17 := make([]bool, len(lst))\n    stack18 := make([]bool,\
    \ len(lst))\n    stack19 := make([]bool, len(lst))\n    stack20 := make([]bool,\
    \ len(lst))\n    stack21 := make([]bool, len(lst))\n    stack22 := make([]bool,\
    \ len(lst))\n    stack23 := make([]bool, len(lst))\n    stack24 := make([]bool,\
    \ len(lst))\n    stack25 := make([]bool, len(lst))\n    stack26 := make([]bool,\
    \ len(lst))\n    stack27 := make([]bool, len(lst))\n    stack28 := make([]bool,\
    \ len(lst))\n    stack29 := make([]bool, len(lst))\n    stack30 := make([]bool,\
    \ len(lst))\n    stack31 := make([]bool, len(lst))\n    stack32 := make([]bool,\
    \ len(lst))\n    stack33 := make([]bool, len(lst))\n    stack34 := make([]bool,\
    \ len(lst))\n    stack35 := make([]bool, len(lst))\n    stack36 := make([]bool,\
    \ len(lst))\n    stack37 := make([]bool, len(lst))\n    stack38 := make([]bool,\
    \ len(lst))\n    stack39 := make([]bool, len(lst))\n    stack40 := make([]bool,\
    \ len(lst))\n    stack41 := make([]bool, len(lst))\n    stack42 := make([]bool,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvhcg16q2_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, str := range lst {\n        if str == \"(\" {\n            stack = append(stack,\
    \ len(str))\n        }\n        if str == \")\" {\n            stack = stack[:len(stack)-1]\n\
    \        }\n        if stack[len(stack)-1] == len(str) {\n            stack =\
    \ stack[:len(stack)-1]\n        }\n    }\n    if len(stack) > 0 {\n        result\
    \ = \"No\"\n    } else {\n        result = \"Yes\"\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x514620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x514620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens(...)\n\t/tmp/tmpx00yuq89_test.go:27\n\
    command-line-arguments_test.TestMatch_Parens(0xc0001924e0?)\n\t/tmp/tmpx00yuq89_test.go:46\
    \ +0x1dfe\ntesting.tRunner(0xc0001924e0, 0x529f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074125
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n        \
    \    stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            if stack[len(stack)-1] == \"\" {\n  \
    \              result += \"(\"\n            } else {\n                result +=\
    \ \"(\"\n            }\n            stack[len(stack)-1] = lst[i]\n        }\n\
    \    }\n    if stack[len(stack)-1] == \"\" {\n        result += \"(\"\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpk8sr62xo_test.go:64: expected 'Yes', got '('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpk8sr62xo_test.go:64: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpk8sr62xo_test.go:64:\
    \ expected 'No', got '(('\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpk8sr62xo_test.go:64: expected 'Yes', got '(('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpk8sr62xo_test.go:64: expected 'Yes', got '(('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpk8sr62xo_test.go:64: expected\
    \ 'No', got '(('\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n       \
    \ tmpk8sr62xo_test.go:64: expected 'Yes', got '(('\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpk8sr62xo_test.go:64: expected 'No', got '(('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpk8sr62xo_test.go:64: expected\
    \ 'No', got '(('\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n       \
    \ tmpk8sr62xo_test.go:64: expected 'No', got '(('\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpk8sr62xo_test.go:64: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpk8sr62xo_test.go:64: expected\
    \ 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074125
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"\" {\n            continue\n        }\n        result += \"(\"\
    \n        for i := 0; i < len(s); i++ {\n            if s[i] == '(' {\n      \
    \          result += \")\"\n                continue\n            }\n        \
    \    result += s[i]\n        }\n        result += \")\"\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpabv45sni_test.go:29:13: invalid operation: result += s[i] (mismatched
    types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074125
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            if\
    \ len(stack) == 0 {\n                result = \"Yes\"\n                break\n\
    \            }\n            stack = stack[:len(stack)-1]\n            if stack[len(stack)-1]\
    \ == \"(\" {\n                stack[len(stack)-1] = \"(\"\n            } else\
    \ {\n                stack[len(stack)-1] = \")\"\n            }\n        } else\
    \ {\n            stack[i] = \"?\"\n        }\n    }\n    return result\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000fdc80, 0x2, 0x2?})\n\
    \t/tmp/tmppzdek67i_test.go:29 +0x1d4\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmppzdek67i_test.go:49 +0x107\ntesting.tRunner(0xc00019a680, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += \"(\" + s + \")\"\n\
    \        } else {\n            result += s\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpd4dz4k02_test.go:53: expected 'Yes', got '()(())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpd4dz4k02_test.go:53:\
    \ expected 'No', got '())())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpd4dz4k02_test.go:53: expected 'No', got '(()(())())())'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpd4dz4k02_test.go:53: expected\
    \ 'Yes', got ')())(()()('\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpd4dz4k02_test.go:53: expected 'Yes', got '(())))(()())(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpd4dz4k02_test.go:53:\
    \ expected 'No', got '()())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpd4dz4k02_test.go:53: expected 'Yes', got '(()(()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpd4dz4k02_test.go:53: expected\
    \ 'No', got '((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpd4dz4k02_test.go:53: expected 'No', got ')(()(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpd4dz4k02_test.go:53: expected\
    \ 'No', got ')()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n    \
    \    tmpd4dz4k02_test.go:53: expected 'Yes', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpd4dz4k02_test.go:53: expected 'Yes', got '())(()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n        \
    \    stack[i] = s\n            i++\n        } else if s[i] == ')' {\n        \
    \    result += \"(\" + stack[i] + \")\"\n            stack[i] = \"\"\n       \
    \     i++\n        } else {\n            result += \"(\" + stack[i] + \")\"\n\
    \            stack[i] = \"\"\n        }\n    }\n    if i == len(lst) {\n     \
    \   return result\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range\
    \ [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5ca0, 0x2, 0x2?})\n\
    \t/tmp/tmp0kybj1hu_test.go:22 +0x268\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmp0kybj1hu_test.go:47 +0x99\ntesting.tRunner(0xc0001a0340, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074125
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    for i := 0; i <\
    \ len(lst); i++ {\n        stack[i] = i\n    }\n    result := \"\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuj9tt1xg_test.go:118:15: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if result != \"\" {\n            result = result + \")\"\n        }\n  \
    \      if s != \"\" {\n            result = result + \"(\" + s\n        }\n  \
    \  }\n    if result != \"\" {\n        result = \"Yes\"\n    } else {\n      \
    \  result = \"No\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpyf8hocye_test.go:59: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpyf8hocye_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpyf8hocye_test.go:59: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpyf8hocye_test.go:59: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpyf8hocye_test.go:59: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpyf8hocye_test.go:59: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074125
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n           \
    \ stack[i] = s\n            i++\n        } else if s == ')' {\n            if\
    \ len(stack) == 0 {\n                return \"No\"\n            }\n          \
    \  s := stack[len(stack)-1]\n            if result != \"\" {\n               \
    \ result += \"+\"\n            }\n            result += s\n            stack =\
    \ stack[:len(stack)-1]\n            i = 0\n        } else {\n            if len(stack)\
    \ == 0 {\n                return \"No\"\n            }\n            s := stack[len(stack)-1]\n\
    \            if result != \"\" {\n                result += \"+\"\n          \
    \  }\n            result += s\n            stack = stack[:len(stack)-1]\n    \
    \        i = 0\n        }\n    }\n    if result != \"\" {\n        result += \"\
    +\"\n    }\n    return result == \"Yes\" ? \"Yes\" : \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr7gf56tb_test.go:52:28: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += \"(\" + s + \")\"\n\
    \        } else {\n            result += \"(\" + s + \")\"\n        }\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'Yes', got '(()()())'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '())())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp37dykhcn_test.go:53: expected 'No', got '((()(()))(())()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'Yes', got '()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'Yes', got '((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmp37dykhcn_test.go:53: expected 'Yes', got '((()()(()))())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'No', got '()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmp37dykhcn_test.go:53: expected 'Yes', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'Yes', got '())(()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n        \
    \    stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            return fmt.Sprintf(\"No\")\n        }\n\
    \    }\n    for i := 0; i < len(stack); i++ {\n        if stack[i] == \"(\" {\n\
    \            result += stack[i]\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpgvbrcths_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpgvbrcths_test.go:61: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpgvbrcths_test.go:61:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpgvbrcths_test.go:61: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpgvbrcths_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpgvbrcths_test.go:61: expected\
    \ 'Yes', got '('\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n      \
    \  tmpgvbrcths_test.go:61: expected 'Yes', got '('\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074125
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n        \
    \    stack[i] = s\n            i++\n        } else if s[i] == ')' {\n        \
    \    if len(stack) == 0 {\n                return \"No\"\n            }\n    \
    \        result += \"(\" + stack[len(stack)-1] + \")\"\n            stack = stack[:len(stack)-1]\n\
    \            i -= 1\n        } else {\n            result += \"(\" + s + \")\"\
    \n        }\n    }\n    if len(stack) > 0 {\n        return \"No\"\n    }\n  \
    \  return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range\
    \ [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5ca0, 0x2, 0x2?})\n\
    \t/tmp/tmpsqu_guw7_test.go:22 +0x211\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmpsqu_guw7_test.go:49 +0x99\ntesting.tRunner(0xc0001a01a0, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074125
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    result := \"No\"\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n        \
    \    stack[i] = 1\n        } else if lst[i] == \")\" {\n            if stack[i]\
    \ > 0 {\n                stack[i]--\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmphlwjuc0w_test.go:59: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmphlwjuc0w_test.go:59: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmphlwjuc0w_test.go:59: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmphlwjuc0w_test.go:59: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"()\" {\n            result = \"Yes\"\n            break\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpf0_znwet_test.go:52: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpf0_znwet_test.go:52: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpf0_znwet_test.go:52:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpf0_znwet_test.go:52: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpf0_znwet_test.go:52: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpf0_znwet_test.go:52: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n      \
    \  tmpf0_znwet_test.go:52: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpf0_znwet_test.go:52: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpf0_znwet_test.go:52: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmpf0_znwet_test.go:52:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmpf0_znwet_test.go:52: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpf0_znwet_test.go:52: expected 'Yes', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0], stack2[0] = lst[0], lst[1]\n    stack1[1], stack2[1] = lst[1],\
    \ lst[0]\n    stack1[2], stack2[2] = lst[2], lst[1]\n    stack1[3], stack2[3]\
    \ = lst[3], lst[2]\n    stack1[4], stack2[4] = lst[4], lst[3]\n    stack1[5],\
    \ stack2[5] = lst[5], lst[4]\n    stack1[6], stack2[6] = lst[6], lst[5]\n    stack1[7],\
    \ stack2[7] = lst[7], lst[6]\n    stack1[8], stack2[8] = lst[8], lst[7]\n    stack1[9],\
    \ stack2[9] = lst[9], lst[8]\n    stack1[10], stack2[10] = lst[10], lst[9]\n \
    \   stack1[11], stack2[11] = lst[11], lst[10]\n    stack1[12], stack2[12] = lst[12],\
    \ lst[11]\n    stack1[13], stack2[13] = lst[13], lst[12]\n    stack1[14], stack2[14]\
    \ = lst[14], lst[13]\n    stack1[15], stack2[15] = lst[15], lst[14]\n    stack1[16],\
    \ stack2[16] = lst[16], lst[15]\n    stack1[17], stack2[17] = lst[17], lst[16]\n\
    \    stack1[18], stack2[18] = lst[18], lst[17]\n    stack1[19], stack2[19] = lst[19],\
    \ lst[18]\n    stack1[20], stack2[20] = lst[20], lst[19]\n    stack1[21], stack2[21]\
    \ = lst[21], lst[20]\n    stack1[22], stack2[22] = lst[22], lst[21]\n    stack1[23],\
    \ stack2[23] = lst[23], lst[22]\n    stack1[24], stack2[24] = lst[24], lst[23]\n\
    \    stack1[25], stack2[25] = lst[25], lst[24]\n    stack1[26], stack2[26] = lst[26],\
    \ lst[25]\n    stack1[27], stack2[27] = lst[27], lst[26]\n    stack1[28], stack2[28]\
    \ = lst[28], lst[27]\n    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx1h4l1a7_test.go:53:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"()\" {\n            result = \"Yes\"\n            break\n    \
    \    }\n        if s == \"(\" {\n            result = \"No\"\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpt4tsftnb_test.go:56: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpt4tsftnb_test.go:56: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpt4tsftnb_test.go:56:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpt4tsftnb_test.go:56: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpt4tsftnb_test.go:56: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpt4tsftnb_test.go:56: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n      \
    \  tmpt4tsftnb_test.go:56: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpt4tsftnb_test.go:56: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpt4tsftnb_test.go:56: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmpt4tsftnb_test.go:56:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmpt4tsftnb_test.go:56: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpt4tsftnb_test.go:56: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n      \
    \  result += \"(\" + s + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '(()()())(()()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '())())())())'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'No', got '((()(()))(())()))((()(()))(())()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'Yes', got '()()))((()()()()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '((()))))((()())(()((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '(())(()))(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '((()()(()))())((()()(()))())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '((((()(((()))((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'No', got '()(())((()()()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'No', got '()()()()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp_g9frvez_test.go:52: expected 'Yes', got '(()())(()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmp_g9frvez_test.go:52:\
    \ expected 'Yes', got '())(()())(()'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if result != \"\" {\n            result += \"|\"\n        }\n        result\
    \ += \"(\" + s + \")\"\n    }\n    if result != \"\" {\n        result = \"(\"\
    \ + result + \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp4vh_uy_d_test.go:55: expected 'Yes', got '((()()|()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp4vh_uy_d_test.go:55:\
    \ expected 'No', got '(())|()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp4vh_uy_d_test.go:55: expected 'No', got '(((()(()))|(())())))'\n \
    \   --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp4vh_uy_d_test.go:55:\
    \ expected 'Yes', got '(()()))|((()()())'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp4vh_uy_d_test.go:55: expected 'Yes', got '(((()))))|((()())(())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp4vh_uy_d_test.go:55:\
    \ expected 'No', got '((())|(())))'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp4vh_uy_d_test.go:55: expected 'Yes', got '(((()()|(()))()))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp4vh_uy_d_test.go:55:\
    \ expected 'No', got '(((((()|(((())))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp4vh_uy_d_test.go:55: expected 'No', got '(()(())|((()())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp4vh_uy_d_test.go:55:\
    \ expected 'No', got '(()()|()())'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp4vh_uy_d_test.go:55: expected 'Yes', got '((()|()))'\n \
    \   --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmp4vh_uy_d_test.go:55:\
    \ expected 'Yes', got '(())|(())'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074126
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for _, s := range lst {\n        if s == '(' {\n            stack\
    \ = append(stack, -1)\n        } else {\n            stack = append(stack, len(s))\n\
    \        }\n    }\n    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i]\
    \ < 0 {\n            continue\n        }\n        result += \"(\"\n        for\
    \ _, s := range lst {\n            if stack[i] > len(s) {\n                continue\n\
    \            }\n            if s[stack[i]] != ')' {\n                continue\n\
    \            }\n            result += \"(\"\n            stack[i] = -1\n     \
    \   }\n        result += \")\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2fjd9bk3_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp2fjd9bk3_test.go:28:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    for i := 0; i <\
    \ len(lst); i++ {\n        stack[i] = 0\n    }\n    result := \"\"\n    result\
    \ += \"(\"\n    for i := 0; i < len(lst); i++ {\n        if stack[i] > 0 {\n \
    \           result += \"(\"\n            stack[i] = 0\n        }\n        if lst[i]\
    \ == \"(\" {\n            stack[i]++\n        }\n        if lst[i] == \")\" {\n\
    \            stack[i]--\n        }\n        if stack[i] == 0 {\n            result\
    \ += lst[i]\n        }\n    }\n    result += \")\"\n    return result\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppf5z2t5d_test.go:67: expected 'Yes', got '(()()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmppf5z2t5d_test.go:67:\
    \ expected 'No', got '()'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmppf5z2t5d_test.go:67: expected 'No', got '((()(())())()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmppf5z2t5d_test.go:67:\
    \ expected 'Yes', got '()())(()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmppf5z2t5d_test.go:67: expected 'Yes', got '((())))(()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmppf5z2t5d_test.go:67:\
    \ expected 'No', got '(()()))'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmppf5z2t5d_test.go:67: expected 'Yes', got '((()(()))())'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmppf5z2t5d_test.go:67: expected\
    \ 'No', got '(((((((()))'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmppf5z2t5d_test.go:67: expected 'No', got '()(()(()()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmppf5z2t5d_test.go:67: expected\
    \ 'No', got '()()()'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n  \
    \      tmppf5z2t5d_test.go:67: expected 'Yes', got '()'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmppf5z2t5d_test.go:67: expected 'Yes', got '()'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n        \
    \    stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            stack[i] = \"\"\n        }\n    }\n \
    \   for i := 0; i < len(stack); i++ {\n        if stack[i] == \"\" {\n       \
    \     result += \"(\"\n        } else {\n            result += \"(\"\n       \
    \ }\n    }\n    for i := 0; i < len(stack); i++ {\n        if stack[i] == \"\"\
    \ {\n            result += \")\"\n        } else {\n            result += \")\"\
    \n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpz7q6b0u9_test.go:70: expected 'Yes', got '(())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpz7q6b0u9_test.go:70:\
    \ expected 'No', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpz7q6b0u9_test.go:70: expected 'No', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpz7q6b0u9_test.go:70: expected 'Yes', got '(())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpz7q6b0u9_test.go:70:\
    \ expected 'Yes', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n\
    \        tmpz7q6b0u9_test.go:70: expected 'No', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpz7q6b0u9_test.go:70: expected 'Yes', got '(())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpz7q6b0u9_test.go:70:\
    \ expected 'No', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpz7q6b0u9_test.go:70: expected 'No', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpz7q6b0u9_test.go:70: expected 'No', got '(())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpz7q6b0u9_test.go:70:\
    \ expected 'Yes', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpz7q6b0u9_test.go:70: expected 'Yes', got '(())'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps0_6jr53_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074115
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := range\
    \ lst {\n        stack[i] = lst[i]\n    }\n    result := \"\"\n    i := 0\n  \
    \  for i < len(stack) {\n        if stack[i] == \"(\" {\n            i++\n   \
    \         if i == len(stack) {\n                result += \"Yes\"\n          \
    \      break\n            }\n            if stack[i] == \"(\" {\n            \
    \    result += \"Yes\"\n                i++\n                continue\n      \
    \      }\n            if stack[i] == \")\" {\n                result += \"Yes\"\
    \n                i++\n                continue\n            }\n            result\
    \ += \"No\"\n            break\n        }\n        if stack[i] == \")\" {\n  \
    \          result += \"No\"\n            break\n        }\n        result += \"\
    No\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n \
    \ candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074139
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    s := \"\"\n    for _, v := range lst {\n        if v\
    \ == \"(\" || v == \")\" {\n            s += v\n        }\n    }\n    return s\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpw6bagcjl_test.go:51: expected 'Yes', got ')'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpw6bagcjl_test.go:51: expected\
    \ 'No', got '))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n       \
    \ tmpw6bagcjl_test.go:51: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpw6bagcjl_test.go:51: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpw6bagcjl_test.go:51: expected\
    \ 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpw6bagcjl_test.go:51:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpw6bagcjl_test.go:51: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpw6bagcjl_test.go:51: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpw6bagcjl_test.go:51: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmpw6bagcjl_test.go:51:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmpw6bagcjl_test.go:51: expected 'Yes', got '()'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpw6bagcjl_test.go:51: expected 'Yes', got ')('\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074126
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n           \
    \ stack[i] = s\n            i++\n        } else if s == ')' {\n            stack[i]\
    \ = s\n            i++\n            if i == len(stack) {\n                result\
    \ += \"(\" + strings.Join(stack[:i], \"\")\n                i = 0\n          \
    \  }\n        } else {\n            result += s\n        }\n    }\n    if i ==\
    \ len(stack) {\n        result += \"(\" + strings.Join(stack[:i], \"\")\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwq_er2x9_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpwq_er2x9_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    /tmp/tmpwq_er2x9_test.go:29:33: undefined: strings

    /tmp/tmpwq_er2x9_test.go:37:25: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool,\
    \ len(lst))\n    for i := 0; i < len(lst); i++ {\n        stack1[i] = false\n\
    \        stack2[i] = false\n    }\n    stack1[0] = true\n    stack2[0] = true\n\
    \    result := \"\"\n    for i := 0; i < len(lst); i++ {\n        if stack1[i]\
    \ {\n            stack1[i] = false\n            stack2[i] = true\n           \
    \ result += lst[i]\n        }\n        if stack2[i] {\n            stack2[i] =\
    \ false\n            stack1[i] = true\n            result += lst[i]\n        }\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpnkv4itto_test.go:66: expected 'Yes', got '()(()('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpnkv4itto_test.go:66:\
    \ expected 'No', got '))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpnkv4itto_test.go:66: expected 'No', got '(()(())(()(())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpnkv4itto_test.go:66:\
    \ expected 'Yes', got ')()))())'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpnkv4itto_test.go:66: expected 'Yes', got '(())))(())))'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpnkv4itto_test.go:66: expected\
    \ 'No', got '()()'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n     \
    \   tmpnkv4itto_test.go:66: expected 'Yes', got '(()((()('\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpnkv4itto_test.go:66: expected 'No', got '(((((((('\n   \
    \ --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n        tmpnkv4itto_test.go:66:\
    \ expected 'No', got ')(())(()'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n\
    \        tmpnkv4itto_test.go:66: expected 'No', got ')()('\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpnkv4itto_test.go:66: expected 'Yes', got '(('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpnkv4itto_test.go:66: expected\
    \ 'Yes', got '))'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := 0; i\
    \ < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\
    \n        } else if lst[i] == \")\" {\n            stack[i] = \")\"\n        }\
    \ else {\n            return fmt.Sprintf(\"No\")\n        }\n    }\n    return\
    \ fmt.Sprintf(\"Yes\")\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpkk2qt_9d_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpkk2qt_9d_test.go:55: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpkk2qt_9d_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpkk2qt_9d_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpkk2qt_9d_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074116
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for len(stack) > 0 {\n        i := stack[len(stack)-1]\n        stack\
    \ = stack[:len(stack)-1]\n        if i == -1 {\n            result += \"(\"\n\
    \        } else {\n            result += \"(\"\n            for _, s := range\
    \ lst[i+1:] {\n                if s == '(' {\n                    stack = append(stack,\
    \ -1)\n                } else {\n                    stack = append(stack, len(s))\n\
    \                }\n            }\n        }\n    }\n    return result\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw77_sciq_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpw77_sciq_test.go:35:25: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            stack[i] = lst[i]\n        }\n    }\n\
    \    for i := 0; i < len(stack); i++ {\n        if stack[i] == \"(\" {\n     \
    \       result += \")\"\n        } else if stack[i] == \")\" {\n            result\
    \ += \"(\"\n        } else {\n            result += \"(\" + stack[i]\n       \
    \ }\n    }\n    if result == \"No\" {\n        result = \"Yes\"\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpmrrldh_z_test.go:68: expected 'Yes', got 'No(()(('\n   \
    \ --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpmrrldh_z_test.go:68:\
    \ expected 'No', got 'No(('\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpmrrldh_z_test.go:68: expected 'No', got 'No((()(())(())())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpmrrldh_z_test.go:68:\
    \ expected 'Yes', got 'No()())((()()('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpmrrldh_z_test.go:68: expected 'Yes', got 'No((())))((()())(('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpmrrldh_z_test.go:68:\
    \ expected 'No', got 'No(()(())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpmrrldh_z_test.go:68: expected 'Yes', got 'No((()((()))()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmpmrrldh_z_test.go:68:\
    \ expected 'No', got 'No((((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpmrrldh_z_test.go:68: expected 'No', got 'No()(()((()('\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmpmrrldh_z_test.go:68:\
    \ expected 'No', got 'No()(()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmpmrrldh_z_test.go:68: expected 'Yes', got 'No)('\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpmrrldh_z_test.go:68: expected 'Yes', got 'No()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"()\" {\n            result += \"()\"\n        } else if s == \"\
    ()()\" {\n            result += \"()()\"\n        } else if s == \"(())\" {\n\
    \            result += \"(())\"\n        } else if s == \"(()())\" {\n       \
    \     result += \"(()())\"\n        } else if s == \"(()(())\" {\n           \
    \ result += \"(()(()))\"\n        } else if s == \"()(())\" {\n            result\
    \ += \"()(())\"\n        } else if s == \"()(()())\" {\n            result +=\
    \ \"()(()())\"\n        } else if s == \"()(()(())\" {\n            result +=\
    \ \"()(()(()))\"\n        } else if s == \"()(()(()())\" {\n            result\
    \ += \"()(()(()()))\"\n        } else if s == \"()(()(()(()))\" {\n          \
    \  result += \"()(()(()(())))\"\n        } else if s == \"()(()(()(()()))\" {\n\
    \            result += \"()(()(()(()(())))\"\n        } else if s == \"()(()(()(()(())))\"\
    \ {\n            result += \"()(()(()(()(()(())))\"\n        } else if s == \"\
    ()(()(()(()(()(())))\" {\n            result += \"()(()(()(()(()(()(())))\"\n\
    \        } else if s == \"()(()(()(()(()(()(())))\" {\n            result += \"\
    ()(()(()(()(()(()(()(())))\"\n        } else if s == \"()(()(()(()(()(()(()(())))\"\
    \ {\n            result += \"()(()(()(()(()(()(()(()(())))\"\n        } else if\
    \ s == \"()(()(()(()(()(()(()(()(())))\" {\n            result += \"()(()(()(()(()(()(()(()(()(())))\"\
    \n        } else if s == \"()(()(()(()(()(()(()(()(())))\" {\n            result\
    \ += \"()(()(()(()(()(()(()(()(()(()(())))\"\n        } else if s == \"()(()(()(()(()(()(()(()(()(())))\"\
    \ {\n            result += \"()(()(()(()(()(()(()(()(()(()(()(())))\"\n      \
    \  } else if s == \"()(()(()(()(()(()(()(()(()(()(())))\" {\n            result\
    \ += \"()(()(()(()(()(()(()(()(()(()(()(()(()(())))\"\n        } else if s ==\
    \ \"()(()(()(()(()(()(()(()(()(()(()(())))\" {\n            result += \"()(()(()(()(()(()(\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj6kgy3r2_test.go:59:23: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]bool, len(lst))\n    stack2 := make([]bool,\
    \ len(lst))\n    stack1[0], stack2[0] = true, true\n    stack1[1], stack2[1] =\
    \ true, true\n    stack1[2], stack2[2] = true, true\n    stack1[3], stack2[3]\
    \ = true, true\n    stack1[4], stack2[4] = true, true\n    stack1[5], stack2[5]\
    \ = true, true\n    stack1[6], stack2[6] = true, true\n    stack1[7], stack2[7]\
    \ = true, true\n    stack1[8], stack2[8] = true, true\n    stack1[9], stack2[9]\
    \ = true, true\n    stack1[10], stack2[10] = true, true\n    stack1[11], stack2[11]\
    \ = true, true\n    stack1[12], stack2[12] = true, true\n    stack1[13], stack2[13]\
    \ = true, true\n    stack1[14], stack2[14] = true, true\n    stack1[15], stack2[15]\
    \ = true, true\n    stack1[16], stack2[16] = true, true\n    stack1[17], stack2[17]\
    \ = true, true\n    stack1[18], stack2[18] = true, true\n    stack1[19], stack2[19]\
    \ = true, true\n    stack1[20], stack2[20] = true, true\n    stack1[21], stack2[21]\
    \ = true, true\n    stack1[22], stack2[22] = true, true\n    stack1[23], stack2[23]\
    \ = true, true\n    stack1[24], stack2[24] = true, true\n    stack1[25], stack2[25]\
    \ = true, true\n    stack1[26], stack2[26] = true, true\n    stack1[27], stack2[27]\
    \ = true, true\n    stack1[28], stack2[28] = true, true\n    stack1[29], stack2[29]\
    \ = true, true\n    stack1[30], stack2[30] = true, true\n    stack1[31], stack2[31]\
    \ = true, true\n    stack1[32], stack2[32] = true, true\n    stack1[33], stack2[33]\
    \ = true, true\n    stack1[34], stack2[34] = true, true\n    stack1[35], stack2[35]\
    \ = true, true\n    stack1[36], stack2[36] = true, true\n    stack1[37], stack2[37]\
    \ = true, true\n    stack1[38], stack2[38] = true, true\n    stack1[39], stack2[39]\
    \ = true, true\n    stack1[40], stack2[40] = true, true\n    stack1[4\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_c52v8fx_test.go:61:13: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps0_6jr53_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074115
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n           \
    \ stack[i] = s\n            i++\n        } else if s == ')' {\n            i -=\
    \ 1\n            if i == -1 {\n                return \"No\"\n            }\n\
    \            stack[i] = s\n        } else {\n            stack[i] = s\n      \
    \  }\n    }\n    for _, s := range stack {\n        result = result + s\n    }\n\
    \    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj82cy43d_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpj82cy43d_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var i int\n    for i = 0; i <\
    \ len(lst); i++ {\n        if lst[i] == \"(\" {\n            result += \"(\"\n\
    \            i++\n        } else if lst[i] == \")\" {\n            result += \"\
    )\"\n            i++\n        } else if lst[i] == \"(\" {\n            result\
    \ += \")\"\n            i++\n        } else {\n            result += lst[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpif8yqy8t_test.go:61: expected 'Yes', got '()()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpif8yqy8t_test.go:61:\
    \ expected 'No', got ')'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpif8yqy8t_test.go:61: expected 'No', got '(()(())())())'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpif8yqy8t_test.go:61: expected\
    \ 'Yes', got ')())(()()('\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpif8yqy8t_test.go:61: expected 'Yes', got '(())))(()())(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpif8yqy8t_test.go:61:\
    \ expected 'No', got '()())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpif8yqy8t_test.go:61: expected 'Yes', got '(()(()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpif8yqy8t_test.go:61: expected\
    \ 'No', got '((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpif8yqy8t_test.go:61: expected 'No', got ')(()(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpif8yqy8t_test.go:61: expected\
    \ 'No', got ')()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n    \
    \    tmpif8yqy8t_test.go:61: expected 'Yes', got '('\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpif8yqy8t_test.go:61: expected 'Yes', got ')'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   \n    stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    \n    for i, s := range lst {\n        if s == '(' {\n            stack1[i]\
    \ = s\n        } else {\n            stack2[i] = s\n        }\n    }\n    \n \
    \   stack1Len := len(stack1)\n    stack2Len := len(stack2)\n    \n    if stack1Len\
    \ > stack2Len {\n        return \"No\"\n    }\n    \n    stack1Len -= stack2Len\n\
    \    \n    if stack1Len == 0 {\n        return \"Yes\"\n    }\n    \n    stack1\
    \ := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n    \n    stack1Len\
    \ -= stack2Len\n    \n    if stack1Len == 0 {\n        return \"Yes\"\n    }\n\
    \    \n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n  \
    \  \n    stack1Len -= stack2Len\n    \n    if stack1Len == 0 {\n        return\
    \ \"Yes\"\n    }\n    \n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n\
    \    \n    stack1Len -= stack2Len\n    \n    if stack1Len == 0 {\n        return\
    \ \"Yes\"\n    }\n    \n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n\
    \    \n    stack1Len -= stack2Len\n    \n    if stack1Len == 0 {\n        return\
    \ \"Yes\"\n    }\n    \n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n\
    \    \n    stack1Len -= stack2Len\n    \n    if stack1Len == 0 {\n        return\
    \ \"Yes\"\n    }\n    \n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n\
    \    \n    stack1Len -= stack2Len\n    \n    if stack1Len == 0 {\n        return\
    \ \"Yes\"\n    }\n    \n    stack1 := stack1[:stack1Len]\n    stack2 := stack2[:stack2Len]\n\
    \    \n    stack1Len -= stack2Len\n    \n    if stack1Len == 0 {\n        return\
    \ \"Yes\"\n    }\n    \n    stack1 := stack1[:stack1Len]\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmponsgxj4a_test.go:111:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var i int\n    var j int\n  \
    \  var k int\n    var l int\n    var m int\n    var n int\n    var o int\n   \
    \ var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var\
    \ u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z\
    \ int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n\
    \    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n \
    \   var k int\n    var l int\n    var m int\n    var n int\n    var o int\n  \
    \  var p int\n    var q int\n    var r int\n    var s int\n    var t int\n   \
    \ var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var\
    \ z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e\
    \ int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n\
    \    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n \
    \   var p int\n    var q int\n    var r int\n    var s int\n    var t int\n  \
    \  var u int\n    var v int\n    var w int\n    var x int\n    var y int\n   \
    \ var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\
    \ e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j\
    \ int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n\
    \    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n \
    \   var u int\n    var v int\n    var w int\n    var x int\n    var y int\n  \
    \  var z int\n    var a int\n    var b int\n    var c int\n    var d int\n   \
    \ var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var\
    \ j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o\
    \ int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n\
    \    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n \
    \   var z int\n    var a int\n    var b int\n    var c int\n    var d int\n  \
    \  var e int\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2sd5o2ko_test.go:147:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074126
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for len(stack) > 0 {\n        n := stack[len(stack)-1]\n        if\
    \ n == -1 {\n            stack = stack[:len(stack)-1]\n        } else {\n    \
    \        stack = stack[:len(stack)-1]\n            result += \"(\"\n         \
    \   for i := 0; i < n; i++ {\n                result += lst[stack[len(stack)-1]+i]\n\
    \            }\n            result += \")\"\n        }\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdewd4osb_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    result := \"No\"\n    for _, s := range lst {\n    \
    \    if s == \"(\" || s == \")\" {\n            result += \"Yes\"\n        }\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'NoYes'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpcmz9gl4r_test.go:51:\
    \ expected 'No', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpcmz9gl4r_test.go:51: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpcmz9gl4r_test.go:51: expected 'Yes', got 'NoYesYes'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpcmz9gl4r_test.go:51: expected 'Yes', got 'NoYesYes'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if result != \"\" {\n            result = result + \")\"\n        }\n  \
    \      result = result + s\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp_s2cb43g_test.go:52: expected 'Yes', got '()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp_s2cb43g_test.go:52:\
    \ expected 'No', got ')))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp_s2cb43g_test.go:52: expected 'No', got '(()(()))())())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp_s2cb43g_test.go:52:\
    \ expected 'Yes', got ')()))(()()('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp_s2cb43g_test.go:52: expected 'Yes', got '(()))))(()())(('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp_s2cb43g_test.go:52:\
    \ expected 'No', got '())())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmp_s2cb43g_test.go:52: expected 'Yes', got '(()()()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmp_s2cb43g_test.go:52: expected\
    \ 'No', got '(((()((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmp_s2cb43g_test.go:52: expected 'No', got ')(())(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp_s2cb43g_test.go:52: expected\
    \ 'No', got ')())('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n   \
    \     tmp_s2cb43g_test.go:52: expected 'Yes', got '())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp_s2cb43g_test.go:52: expected 'Yes', got '))('\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074121
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   if len(lst) == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string,\
    \ len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0] = lst[0]\n\
    \    stack2[0] = lst[0]\n    i := 1\n    for i < len(lst) {\n        if lst[i]\
    \ == \"(\" {\n            stack1[i] = lst[i]\n            stack2[i] = lst[i]\n\
    \            i += 1\n        } else if lst[i] == \")\" {\n            stack1[i]\
    \ = lst[i]\n            stack2[i] = lst[i]\n            i += 1\n        } else\
    \ {\n            if stack1[i-1] == \")\" && stack2[i-1] == \"(\" {\n         \
    \       stack1[i] = \"(\"\n                stack2[i] = \")\"\n               \
    \ i += 1\n            }\n        }\n    }\n    if stack1[i-1] == \")\" && stack2[i-1]\
    \ == \"(\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n  \
    \  }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074140
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            if stack[len(stack)-1] == lst[i] {\n\
    \                stack[len(stack)-1] = lst[i]\n            } else {\n        \
    \        result = \"No\"\n                break\n            }\n        }\n  \
    \  }\n    if result == \"No\" {\n        result = \"Yes\"\n    }\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpulfwtmjt_test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpulfwtmjt_test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpulfwtmjt_test.go:64: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpulfwtmjt_test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpulfwtmjt_test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpulfwtmjt_test.go:64: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   if len(lst) == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string,\
    \ len(lst))\n    stack2 := make([]string, len(lst))\n    stack1[0], stack2[0]\
    \ = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[0], lst[0]\n    stack1[2],\
    \ stack2[2] = lst[0], lst[0]\n    stack1[3], stack2[3] = lst[0], lst[0]\n    stack1[4],\
    \ stack2[4] = lst[0], lst[0]\n    stack1[5], stack2[5] = lst[0], lst[0]\n    stack1[6],\
    \ stack2[6] = lst[0], lst[0]\n    stack1[7], stack2[7] = lst[0], lst[0]\n    stack1[8],\
    \ stack2[8] = lst[0], lst[0]\n    stack1[9], stack2[9] = lst[0], lst[0]\n    stack1[10],\
    \ stack2[10] = lst[0], lst[0]\n    stack1[11], stack2[11] = lst[0], lst[0]\n \
    \   stack1[12], stack2[12] = lst[0], lst[0]\n    stack1[13], stack2[13] = lst[0],\
    \ lst[0]\n    stack1[14], stack2[14] = lst[0], lst[0]\n    stack1[15], stack2[15]\
    \ = lst[0], lst[0]\n    stack1[16], stack2[16] = lst[0], lst[0]\n    stack1[17],\
    \ stack2[17] = lst[0], lst[0]\n    stack1[18], stack2[18] = lst[0], lst[0]\n \
    \   stack1[19], stack2[19] = lst[0], lst[0]\n    stack1[20], stack2[20] = lst[0],\
    \ lst[0]\n    stack1[21], stack2[21] = lst[0], lst[0]\n    stack1[22], stack2[22]\
    \ = lst[0], lst[0]\n    stack1[23], stack2[23] = lst[0], lst[0]\n    stack1[24],\
    \ stack2[24] = lst[0], lst[0]\n    stack1[25], stack2[25] = lst[0], lst[0]\n \
    \   stack1[26], stack2[26] = lst[0], lst[0]\n    stack1[27], stack2[27] = lst[0],\
    \ lst[0]\n    stack1[28], stack2[28] = lst[0], lst[0]\n    stack1[29], stack2[29]\
    \ = lst[0], lst[0]\n    stack1[30], stack2[30] = lst[0], lst[0]\n    stack1[31],\
    \ stack2[31] = lst[0], lst[0]\n    stack1[32], stack2[32] = lst[0], lst[0]\n \
    \   stack1[33], stack2[33] = lst[0], lst\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxpnb1ltk_test.go:60:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   if len(lst) == 1 {\n        return lst[0]\n    }\n    result := \"\"\n   \
    \ for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n            result\
    \ += \"(\"\n            i += 1 // skip the '('\n        }\n        if lst[i] ==\
    \ \")\" {\n            result += \")\"\n            i += 1 // skip the ')'\n \
    \       }\n    }\n    if result == \"()\" {\n        return \"Yes\"\n    }\n \
    \   return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpieyu6zvk_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpieyu6zvk_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpieyu6zvk_test.go:65: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpieyu6zvk_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpieyu6zvk_test.go:65: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack3 := make([]string, len(lst))\n    stack4 := make([]string,\
    \ len(lst))\n    stack5 := make([]string, len(lst))\n    stack6 := make([]string,\
    \ len(lst))\n    stack7 := make([]string, len(lst))\n    stack8 := make([]string,\
    \ len(lst))\n    stack9 := make([]string, len(lst))\n    stack10 := make([]string,\
    \ len(lst))\n    stack11 := make([]string, len(lst))\n    stack12 := make([]string,\
    \ len(lst))\n    stack13 := make([]string, len(lst))\n    stack14 := make([]string,\
    \ len(lst))\n    stack15 := make([]string, len(lst))\n    stack16 := make([]string,\
    \ len(lst))\n    stack17 := make([]string, len(lst))\n    stack18 := make([]string,\
    \ len(lst))\n    stack19 := make([]string, len(lst))\n    stack20 := make([]string,\
    \ len(lst))\n    stack21 := make([]string, len(lst))\n    stack22 := make([]string,\
    \ len(lst))\n    stack23 := make([]string, len(lst))\n    stack24 := make([]string,\
    \ len(lst))\n    stack25 := make([]string, len(lst))\n    stack26 := make([]string,\
    \ len(lst))\n    stack27 := make([]string, len(lst))\n    stack28 := make([]string,\
    \ len(lst))\n    stack29 := make([]string, len(lst))\n    stack30 := make([]string,\
    \ len(lst))\n    stack31 := make([]string, len(lst))\n    stack32 := make([]string,\
    \ len(lst))\n    stack33 := make([]string, len(lst))\n    stack34 := make([]string,\
    \ len(lst))\n    stack35 := make([]string, len(lst))\n    stack36 := make([]string,\
    \ len(lst))\n    stack37 := make([]string, len(lst))\n    stack38 := make([]string,\
    \ len(lst))\n    stack39 := make([]string, len(lst))\n    stack40 := make([]string,\
    \ len(lst))\n    stack41 := make([]string, len(lst))\n    stack42 := make([]string,\
    \ len(lst))\n    stack4\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps0_6jr53_test.go:61:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074115
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := 0; i\
    \ < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n    result := \"No\"\n\
    \    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == \"(\" {\n\
    \            stack[i] = \")\"\n            if stack[len(stack)-i-1] == \"(\" {\n\
    \                stack[len(stack)-i-1] = \")\"\n                stack = stack[:len(stack)-i-1]\n\
    \                result += \"Yes\"\n            } else {\n                result\
    \ += \"No\"\n            }\n        } else {\n            stack[i] = \"(\"\n \
    \           if stack[len(stack)-i-1] == \")\" {\n                stack[len(stack)-i-1]\
    \ = \"(\"\n                stack = stack[:len(stack)-i-1]\n                result\
    \ += \"Yes\"\n            } else {\n                result += \"No\"\n       \
    \     }\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range\
    \ [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5c80, 0x2, 0x2?})\n\
    \t/tmp/tmprgz32j8c_test.go:24 +0x2bb\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmprgz32j8c_test.go:55 +0x107\ntesting.tRunner(0xc0001a01a0, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result = result + s\n       \
    \ }\n    }\n    if result == \"()\" {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpxgmfx9oz_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpxgmfx9oz_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpxgmfx9oz_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpxgmfx9oz_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpxgmfx9oz_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  s := lst[0]\n    t := lst[1]\n    i := 0\n    j := len(s) - 1\n    k := len(t)\
    \ - 1\n    result := \"No\"\n    for i < len(s) && j < len(t) {\n        if s[i]\
    \ == '(' {\n            i++\n        }\n        if s[j] == ')' {\n           \
    \ j--\n        }\n        if i == j {\n            if s[i] == t[k] {\n       \
    \         i++\n                k--\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc0001d6000})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0001d2480?, 0x0?, 0x0?})\n\
    \t/tmp/tmp2wrny5mr_test.go:31 +0xf6\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmp2wrny5mr_test.go:55 +0x107\ntesting.tRunner(0xc000199040, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n           \
    \ stack[i] = s\n            i++\n        } else if s == ')' {\n            i -=\
    \ 1\n            if i == -1 {\n                return \"No\"\n            }\n\
    \            stack[i] = s\n        } else if i == 0 {\n            result = \"\
    Yes\"\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf7z30iig_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpf7z30iig_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     result += \"(\" + s + \")\"\n    }\n    result += \"()\"\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'Yes', got '(()()())()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'No', got '())())()'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp7dahvk4r_test.go:50: expected 'No', got '((()(()))(())()))()'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'Yes', got '()()))((()()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'Yes', got '((()))))((()())(()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'No', got '(())(()))()'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'Yes', got '((()()(()))())()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'No', got '((((()(((()))()'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'No', got '()(())((()()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'No', got '()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'Yes', got '(()())()'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'Yes', got '())(()()'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0], stack2[0] = lst[0], lst[0]\n    stack1[1], stack2[1] = lst[1],\
    \ lst[1]\n    stack1[2], stack2[2] = lst[2], lst[2]\n    stack1[3], stack2[3]\
    \ = lst[3], lst[3]\n    stack1[4], stack2[4] = lst[4], lst[4]\n    stack1[5],\
    \ stack2[5] = lst[5], lst[5]\n    stack1[6], stack2[6] = lst[6], lst[6]\n    stack1[7],\
    \ stack2[7] = lst[7], lst[7]\n    stack1[8], stack2[8] = lst[8], lst[8]\n    stack1[9],\
    \ stack2[9] = lst[9], lst[9]\n    stack1[10], stack2[10] = lst[10], lst[10]\n\
    \    stack1[11], stack2[11] = lst[11], lst[11]\n    stack1[12], stack2[12] = lst[12],\
    \ lst[12]\n    stack1[13], stack2[13] = lst[13], lst[13]\n    stack1[14], stack2[14]\
    \ = lst[14], lst[14]\n    stack1[15], stack2[15] = lst[15], lst[15]\n    stack1[16],\
    \ stack2[16] = lst[16], lst[16]\n    stack1[17], stack2[17] = lst[17], lst[17]\n\
    \    stack1[18], stack2[18] = lst[18], lst[18]\n    stack1[19], stack2[19] = lst[19],\
    \ lst[19]\n    stack1[20], stack2[20] = lst[20], lst[20]\n    stack1[21], stack2[21]\
    \ = lst[21], lst[21]\n    stack1[22], stack2[22] = lst[22], lst[22]\n    stack1[23],\
    \ stack2[23] = lst[23], lst[23]\n    stack1[24], stack2[24] = lst[24], lst[24]\n\
    \    stack1[25], stack2[25] = lst[25], lst[25]\n    stack1[26], stack2[26] = lst[26],\
    \ lst[26]\n    stack1[27], stack2[27] = lst[27], lst[27]\n    stack1[28], stack2[28]\
    \ = lst[28], lst[28]\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bxsfyc1_test.go:52:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := range\
    \ lst {\n        stack[i] = lst[i]\n    }\n    result := \"\"\n    i := 0\n  \
    \  for i < len(stack) {\n        switch stack[i] {\n        case \"(\":\n    \
    \        stack[i] = \")\"\n            i++\n        default:\n            result\
    \ += stack[i]\n            i++\n        }\n    }\n    if result != \"\" {\n  \
    \      return \"No\"\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpjl0c4gx8_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpjl0c4gx8_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpjl0c4gx8_test.go:64: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpjl0c4gx8_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpjl0c4gx8_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpjl0c4gx8_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0}\n    for\
    \ _, s := range lst {\n        if s == '(' {\n            stack = append(stack,\
    \ -1)\n        } else {\n            stack = append(stack, len(s))\n        }\n\
    \    }\n    for i := 0; i < len(stack); i++ {\n        if stack[i] < 0 {\n   \
    \         continue\n        }\n        if stack[i] == 0 {\n            result\
    \ += '('\n            stack[i] = -1\n        } else {\n            result += string(lst[stack[i]])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyg31yuxt_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpyg31yuxt_test.go:32:13: invalid operation: result += ''('' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := 0; i\
    \ < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n    result := \"\"\n  \
    \  i := 0\n    for i < len(stack) {\n        if stack[i] == \"(\" {\n        \
    \    i++\n            if i == len(stack) {\n                result = \"No\"\n\
    \                break\n            }\n            if stack[i] == \"(\" {\n  \
    \              i++\n                if i == len(stack) {\n                   \
    \ result = \"No\"\n                    break\n                }\n            \
    \    if stack[i] == \"(\" {\n                    i++\n                    if i\
    \ == len(stack) {\n                        result = \"Yes\"\n                \
    \        break\n                    }\n                }\n            }\n    \
    \    }\n        if stack[i] == \")\" {\n            i++\n            if i == len(stack)\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \           if stack[i] == \")\" {\n                i++\n                if i\
    \ == len(stack) {\n                    result = \"No\"\n                    break\n\
    \                }\n                if stack[i] == \")\" {\n                 \
    \   i++\n                    if i == len(stack) {\n                        result\
    \ = \"Yes\"\n                        break\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074141
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n      \
    \  result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result\
    \ += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result +=\
    \ \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result += \"\
    (\" + s + \")\"\n    }\n    for _, s := range lst {\n        result += \"(\" +\
    \ s + \")\"\n    }\n    for _, s := range lst {\n        result += \"(\" + s +\
    \ \")\"\n    }\n    for _, s := range lst {\n        result += \"(\" + s + \"\
    )\"\n    }\n    for _, s := range lst {\n        result += \"(\" + s + \")\"\n\
    \    }\n    for _, s := range lst {\n        result += \"(\" + s + \")\"\n   \
    \ }\n    for _, s := range lst {\n        result += \"(\" + s + \")\"\n    }\n\
    \    for _, s := range lst {\n        result += \"(\" + s + \")\"\n    }\n   \
    \ for _, s := range lst {\n        result += \"(\" + s + \")\"\n    }\n    for\
    \ _, s := range lst {\n        result += \"(\" + s + \")\"\n    }\n    for _,\
    \ s := range lst {\n        result += \"(\" + s + \")\"\n    }\n    for _, s :=\
    \ range lst {\n        result += \"(\" + s + \")\"\n    }\n    for _, s := range\
    \ lst {\n        result += \"(\" + s + \")\"\n    }\n    for _, s := range lst\
    \ {\n        result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n\
    \        result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n   \
    \     result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n      \
    \  result += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result\
    \ += \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result +=\
    \ \"(\" + s + \")\"\n    }\n    for _, s := range lst {\n        result += \"\
    (\" + s + \")\"\n    }\n    for _, s := range lst {\n        result += \"(\" +\
    \ s + \")\"\n    }\n    for _, s := range lst {\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppb27axgg_test.go:95:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    result := \"\"\n\
    \    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n         \
    \   stack[i] = 1\n        } else if s[i] == ')' {\n            stack[i] = 0\n\
    \        } else if stack[i] != 0 {\n            return result\n        }\n   \
    \     i++\n    }\n    return result == \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpugssajrs_test.go:31:12: cannot use result == "Yes" (untyped bool value)
    as string value in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0], stack2[0] = lst[0], lst[1]\n    stack1[1], stack2[1] = lst[1],\
    \ lst[0]\n    stack1[2], stack2[2] = lst[2], lst[1]\n    stack1[3], stack2[3]\
    \ = lst[3], lst[2]\n    stack1[4], stack2[4] = lst[4], lst[3]\n    stack1[5],\
    \ stack2[5] = lst[5], lst[4]\n    stack1[6], stack2[6] = lst[6], lst[5]\n    stack1[7],\
    \ stack2[7] = lst[7], lst[6]\n    stack1[8], stack2[8] = lst[8], lst[7]\n    stack1[9],\
    \ stack2[9] = lst[9], lst[8]\n    stack1[10], stack2[10] = lst[10], lst[9]\n \
    \   stack1[11], stack2[11] = lst[11], lst[10]\n    stack1[12], stack2[12] = lst[12],\
    \ lst[11]\n    stack1[13], stack2[13] = lst[13], lst[12]\n    stack1[14], stack2[14]\
    \ = lst[14], lst[13]\n    stack1[15], stack2[15] = lst[15], lst[14]\n    stack1[16],\
    \ stack2[16] = lst[16], lst[15]\n    stack1[17], stack2[17] = lst[17], lst[16]\n\
    \    stack1[18], stack2[18] = lst[18], lst[17]\n    stack1[19], stack2[19] = lst[19],\
    \ lst[18]\n    stack1[20], stack2[20] = lst[20], lst[19]\n    stack1[21], stack2[21]\
    \ = lst[21], lst[20]\n    stack1[22], stack2[22] = lst[22], lst[21]\n    stack1[23],\
    \ stack2[23] = lst[23], lst[22]\n    stack1[24], stack2[24] = lst[24], lst[23]\n\
    \    stack1[25], stack2[25] = lst[25], lst[24]\n    stack1[26], stack2[26] = lst[26],\
    \ lst[25]\n    stack1[27], stack2[27] = lst[27], lst[26]\n    stack1[28], stack2[28]\
    \ = lst[28], lst[27]\n    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx1h4l1a7_test.go:53:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074116
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            if stack[len(stack)-1] != \"\" {\n  \
    \              if stack[len(stack)-1] != lst[i] {\n                    result\
    \ = \"No\"\n                    break\n                }\n            } else {\n\
    \                result = \"Yes\"\n                break\n            }\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmp6c24f28f_test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp6c24f28f_test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n      \
    \  tmp6c24f28f_test.go:64: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp6c24f28f_test.go:64: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp6c24f28f_test.go:64: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmp6c24f28f_test.go:64: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp6c24f28f_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += \"(\" + s + \")\"\n\
    \        } else {\n            result += \"(\" + s + \")\"\n        }\n    }\n\
    \    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'Yes', got '(()()())'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '())())'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp37dykhcn_test.go:53: expected 'No', got '((()(()))(())()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'Yes', got '()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'Yes', got '((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmp37dykhcn_test.go:53: expected 'Yes', got '((()()(()))())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'No', got '()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp37dykhcn_test.go:53:\
    \ expected 'No', got '()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmp37dykhcn_test.go:53: expected 'Yes', got '(()())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp37dykhcn_test.go:53: expected 'Yes', got '())(()'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074118
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := 0; i\
    \ < len(lst); i++ {\n        if lst[i] == \"(\" {\n            stack[i] = \"(\"\
    \n        } else if lst[i] == \")\" {\n            if len(stack) == 0 {\n    \
    \            return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n\
    \            if stack[len(stack)-1] == \"(\" {\n                stack[len(stack)-1]\
    \ = \"(\"\n            } else {\n                stack[len(stack)-1] = \")\"\n\
    \            }\n        } else {\n            return \"No\"\n        }\n    }\n\
    \    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc0000f5c80, 0x2, 0x2?})\n\
    \t/tmp/tmp1w6nr328_test.go:27 +0x1a7\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmp1w6nr328_test.go:47 +0x107\ntesting.tRunner(0xc0001924e0, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074121
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s[i] == '(' {\n        \
    \    stack[i] = s\n            i++\n        } else if s[i] == ')' {\n        \
    \    i -= 1\n            if i == -1 {\n                return \"No\"\n       \
    \     }\n            result += stack[i]\n        }\n    }\n    return \"Yes\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range\
    \ [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens(...)\n\t/tmp/tmp0sxzk30r_test.go:22\n\
    command-line-arguments_test.TestMatch_Parens(0xc0001a0340?)\n\t/tmp/tmp0sxzk30r_test.go:43\
    \ +0x19ca\ntesting.tRunner(0xc0001a0340, 0x529f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n           \
    \ stack[i] = s\n            i++\n        } else if s == ')' {\n            i -=\
    \ 1\n            if i == -1 {\n                return \"No\"\n            }\n\
    \            stack[i] = s\n        } else if s == \"\" {\n            if i ==\
    \ 0 {\n                return \"Yes\"\n            }\n            stack[i] = s\n\
    \        }\n    }\n    for _, s := range stack {\n        result = result + s\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu5tcfylc_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpu5tcfylc_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n       \
    \     stack[i] = s\n            i++\n        } else if s == ')' {\n          \
    \  if stack[len(stack)-1] == '(' {\n                stack[i] = s\n           \
    \     i++\n            } else {\n                result = \"Yes\"\n          \
    \      break\n            }\n        } else {\n            result = \"No\"\n \
    \           break\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpps9dqp93_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpps9dqp93_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    /tmp/tmpps9dqp93_test.go:26:39: invalid operation: stack[len(stack) - 1] == ''(''
    (mismatched types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n           \
    \ stack[i] = s\n            i++\n        } else if s == ')' {\n            stack[i]\
    \ = s\n            i++\n            if i == len(stack) {\n                result\
    \ += \"(\" + strings.Join(stack[:i], \"\")\n                return result\n  \
    \          }\n        } else {\n            result += s\n        }\n    }\n  \
    \  return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9j64henm_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp9j64henm_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    /tmp/tmp9j64henm_test.go:29:33: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if result != \"\" {\n            result = result + \")\"\n        }\n  \
    \      result = result + s\n    }\n    if result != \"\" {\n        result = \"\
    (\" + result\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm2189gln_test.go:55: expected 'Yes', got '(()())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpm2189gln_test.go:55:\
    \ expected 'No', got '()))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpm2189gln_test.go:55: expected 'No', got '((()(()))())())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpm2189gln_test.go:55:\
    \ expected 'Yes', got '()()))(()()('\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm2189gln_test.go:55: expected 'Yes', got '((()))))(()())(('\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpm2189gln_test.go:55:\
    \ expected 'No', got '(())())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpm2189gln_test.go:55: expected 'Yes', got '((()()()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpm2189gln_test.go:55: expected\
    \ 'No', got '((((()((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmpm2189gln_test.go:55: expected 'No', got '()(())(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm2189gln_test.go:55: expected\
    \ 'No', got '()())('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n  \
    \      tmpm2189gln_test.go:55: expected 'Yes', got '(())'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpm2189gln_test.go:55: expected 'Yes', got '())('\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += \"(\"\n        } else\
    \ {\n            result += \"(\"\n            result += s\n            result\
    \ += \")\"\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmph67o3cho_test.go:55: expected 'Yes', got '(()()('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmph67o3cho_test.go:55:\
    \ expected 'No', got '(('\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmph67o3cho_test.go:55: expected 'No', got '((()(()))(())()))'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmph67o3cho_test.go:55:\
    \ expected 'Yes', got '()()))((()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmph67o3cho_test.go:55: expected 'Yes', got '((()))))((()())(()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmph67o3cho_test.go:55:\
    \ expected 'No', got '(())(()))'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmph67o3cho_test.go:55: expected 'Yes', got '((()()(()))())'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmph67o3cho_test.go:55:\
    \ expected 'No', got '((((()(((()))'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmph67o3cho_test.go:55: expected 'No', got '()(())((()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmph67o3cho_test.go:55:\
    \ expected 'No', got '()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmph67o3cho_test.go:55: expected 'Yes', got '(('\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmph67o3cho_test.go:55: expected 'Yes', got '(('\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    i := 0\n    for _, s := range lst {\n        if s == \"(\" || s == \"\
    )\" {\n            stack[i] = s\n            i++\n        } else {\n         \
    \   stack[i] = \"No\"\n        }\n    }\n    stack = stack[:i]\n    for _, s :=\
    \ range stack {\n        if s == \"Yes\" {\n            result = \"Yes\"\n   \
    \         break\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpeb_qf9dq_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpeb_qf9dq_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpeb_qf9dq_test.go:63: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpeb_qf9dq_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpeb_qf9dq_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpeb_qf9dq_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n        \
    \    stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            if stack[len(stack)-1] == \"\" {\n  \
    \              stack[len(stack)-1] = lst[i]\n            } else {\n          \
    \      stack[len(stack)-1] += lst[i]\n            }\n        }\n    }\n    for\
    \ i := 0; i < len(stack); i++ {\n        if stack[i] == \"(\" {\n            result\
    \ += \"(\"\n        } else if stack[i] == \")\" {\n            result += \")\"\
    \n        }\n    }\n    if result != \"\" {\n        return \"Yes\"\n    } else\
    \ {\n        return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpdeoghh9u_test.go:71: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpdeoghh9u_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpdeoghh9u_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpdeoghh9u_test.go:71: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []int{0, 1}\n   \
    \ for _, s := range lst {\n        if s == '(' {\n            stack[0]++\n   \
    \     } else if s == ')' {\n            stack[0]--\n            if stack[0] ==\
    \ 0 {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5h_q17x4_test.go:21:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmp5h_q17x4_test.go:23:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) < 2 {\n        return \"No\"\n    }\n  \
    \  stack1 := make([]string, len(lst))\n    stack2 := make([]string, len(lst))\n\
    \    stack1[0], stack2[0] = lst[0], lst[1]\n    stack1[1], stack2[1] = lst[1],\
    \ lst[0]\n    i := 2\n    for i < len(lst) {\n        if stack1[i] == \"(\" &&\
    \ stack2[i] == \"(\" {\n            stack1[i] = \"\"\n            stack2[i] =\
    \ \"\"\n            stack1[i+1], stack2[i+1] = lst[i+1], lst[i]\n            i\
    \ += 2\n        } else if stack1[i] == \")\" && stack2[i] == \")\" {\n       \
    \     stack1[i] = \"\"\n            stack2[i] = \"\"\n            stack1[i+1],\
    \ stack2[i+1] = lst[i+1], lst[i]\n            i += 2\n        } else if stack1[i]\
    \ == \")\" && stack2[i] == \"(\" {\n            stack1[i] = \"\"\n           \
    \ stack2[i] = \"\"\n            stack1[i+1], stack2[i+1] = lst[i+1], lst[i]\n\
    \            i += 2\n        } else if stack1[i] == \"(\" && stack2[i] == \")\"\
    \ {\n            stack1[i] = \"\"\n            stack2[i] = \"\"\n            stack1[i+1],\
    \ stack2[i+1] = lst[i+1], lst[i]\n            i += 2\n        } else {\n     \
    \       stack1[i] = \"\"\n            stack2[i] = \"\"\n            stack1[i+1],\
    \ stack2[i+1] = lst[i+1], lst[i]\n            i += 2\n        }\n    }\n    if\
    \ stack1[0] == \"\" && stack2[0] == \"\" {\n        return \"Yes\"\n    }\n  \
    \  return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpfxnghs5x_test.go:84: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpfxnghs5x_test.go:84: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpfxnghs5x_test.go:84: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpfxnghs5x_test.go:84: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpfxnghs5x_test.go:84: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpfxnghs5x_test.go:84: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   s := lst[0]\n    i := 1\n    for i < len(lst) {\n        if lst[i] == \"(\"\
    \ {\n            s += \")\"\n            i++\n        } else if lst[i] == \")\"\
    \ {\n            s += \"(\"\n            i++\n        } else {\n            s\
    \ += lst[i]\n            i++\n        }\n    }\n    return s\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp_ty3mr07_test.go:62: expected 'Yes', got '()(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp_ty3mr07_test.go:62:\
    \ expected 'No', got ')('\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp_ty3mr07_test.go:62: expected 'No', got '(()(())())())'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp_ty3mr07_test.go:62: expected\
    \ 'Yes', got ')())(()()('\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmp_ty3mr07_test.go:62: expected 'Yes', got '(())))(()())(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp_ty3mr07_test.go:62:\
    \ expected 'No', got '()())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmp_ty3mr07_test.go:62: expected 'Yes', got '(()(()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmp_ty3mr07_test.go:62: expected\
    \ 'No', got '((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmp_ty3mr07_test.go:62: expected 'No', got ')(()(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp_ty3mr07_test.go:62: expected\
    \ 'No', got ')()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n    \
    \    tmp_ty3mr07_test.go:62: expected 'Yes', got '(('\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp_ty3mr07_test.go:62: expected 'Yes', got '))'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    i := 0\n    for _, s := range lst {\n        if s == '(' {\n           \
    \ stack[i] = s\n            i++\n        } else if s == ')' {\n            i -=\
    \ 1\n            if i == -1 {\n                return \"No\"\n            }\n\
    \            stack[i] = s\n        } else if i == -1 {\n            return \"\
    Yes\"\n        }\n    }\n    for _, s := range stack {\n        result = result\
    \ + s\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe3oc_yl4_test.go:22:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpe3oc_yl4_test.go:25:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074119
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     result += \"(\" + s + \")\"\n    }\n    result += \"()\"\n    return result\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'Yes', got '(()()())()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'No', got '())())()'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp7dahvk4r_test.go:50: expected 'No', got '((()(()))(())()))()'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'Yes', got '()()))((()()()()'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'Yes', got '((()))))((()())(()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'No', got '(())(()))()'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'Yes', got '((()()(()))())()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'No', got '((((()(((()))()'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'No', got '()(())((()()()'\n\
    \    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'No', got '()()()()()'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmp7dahvk4r_test.go:50: expected 'Yes', got '(()())()'\n  \
    \  --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmp7dahvk4r_test.go:50:\
    \ expected 'Yes', got '())(()()'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    for i := 0; i\
    \ < len(lst); i++ {\n        stack[i] = lst[i]\n    }\n    result := \"\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph5iur637_test.go:119:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmph4ei2jt3_test.go:55: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmph4ei2jt3_test.go:55: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"()\" {\n            result += \"()\"\n        } else if s == \"\
    ()()\" {\n            result += \"()()\"\n        } else if s == \"(())\" {\n\
    \            result += \"(())\"\n        } else if s == \"(())()\" {\n       \
    \     result += \"(())()\"\n        } else if s == \"(()())\" {\n            result\
    \ += \"(()())\"\n        } else if s == \"(())()()\" {\n            result +=\
    \ \"(())()()\"\n        } else if s == \"(()())()()\" {\n            result +=\
    \ \"(())()()()\"\n        } else if s == \"(()())()()()\" {\n            result\
    \ += \"(())()()()()\"\n        } else if s == \"(()())()()()()\" {\n         \
    \   result += \"(())()()()()()\"\n        } else if s == \"(()())()()()()()\"\
    \ {\n            result += \"(())()()()()()()\"\n        } else if s == \"(()())()()()()()()\"\
    \ {\n            result += \"(())()()()()()()()\"\n        } else if s == \"(()())()()()()()()()\"\
    \ {\n            result += \"(())()()()()()()()()\"\n        } else if s == \"\
    (()())()()()()()()()()\" {\n            result += \"(())()()()()()()()()()\"\n\
    \        } else if s == \"(()())()()()()()()()()()\" {\n            result +=\
    \ \"(())()()()()()()()()()()()\"\n        } else if s == \"(()())()()()()()()()()()()\"\
    \ {\n            result += \"(())()()()()()()()()()()()\"\n        } else if s\
    \ == \"(()())()()()()()()()()()()\" {\n            result += \"(())()()()()()()()()()()()()\"\
    \n        } else if s == \"(()())()()()()()()()()()()()\" {\n            result\
    \ += \"(())()()()()()()()()()()()()()\"\n        } else if s == \"(()())()()()()()()()()()()()()\"\
    \ {\n            result += \"(())()()()\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv0vdngn7_test.go:55:23: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    s := \"\"\n    for _, v := range lst {\n        if v\
    \ == \"(\" || v == \")\" {\n            s += v\n        }\n    }\n    return s\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpw6bagcjl_test.go:51: expected 'Yes', got ')'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpw6bagcjl_test.go:51: expected\
    \ 'No', got '))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n       \
    \ tmpw6bagcjl_test.go:51: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpw6bagcjl_test.go:51: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpw6bagcjl_test.go:51: expected\
    \ 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmpw6bagcjl_test.go:51:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmpw6bagcjl_test.go:51: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpw6bagcjl_test.go:51: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpw6bagcjl_test.go:51: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n        tmpw6bagcjl_test.go:51:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n\
    \        tmpw6bagcjl_test.go:51: expected 'Yes', got '()'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpw6bagcjl_test.go:51: expected 'Yes', got ')('\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074126
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"No\"\n    }\n \
    \   if len(lst) == 1 {\n        return lst[0]\n    }\n    stack1 := make([]string,\
    \ len(lst))\n    stack2 := make([]string, len(lst))\n    stack3 := make([]string,\
    \ len(lst))\n    stack4 := make([]string, len(lst))\n    stack5 := make([]string,\
    \ len(lst))\n    stack6 := make([]string, len(lst))\n    stack7 := make([]string,\
    \ len(lst))\n    stack8 := make([]string, len(lst))\n    stack9 := make([]string,\
    \ len(lst))\n    stack10 := make([]string, len(lst))\n    stack11 := make([]string,\
    \ len(lst))\n    stack12 := make([]string, len(lst))\n    stack13 := make([]string,\
    \ len(lst))\n    stack14 := make([]string, len(lst))\n    stack15 := make([]string,\
    \ len(lst))\n    stack16 := make([]string, len(lst))\n    stack17 := make([]string,\
    \ len(lst))\n    stack18 := make([]string, len(lst))\n    stack19 := make([]string,\
    \ len(lst))\n    stack20 := make([]string, len(lst))\n    stack21 := make([]string,\
    \ len(lst))\n    stack22 := make([]string, len(lst))\n    stack23 := make([]string,\
    \ len(lst))\n    stack24 := make([]string, len(lst))\n    stack25 := make([]string,\
    \ len(lst))\n    stack26 := make([]string, len(lst))\n    stack27 := make([]string,\
    \ len(lst))\n    stack28 := make([]string, len(lst))\n    stack29 := make([]string,\
    \ len(lst))\n    stack30 := make([]string, len(lst))\n    stack31 := make([]string,\
    \ len(lst))\n    stack32 := make([]string, len(lst))\n    stack33 := make([]string,\
    \ len(lst))\n    stack34 := make([]string, len(lst))\n    stack35 := make([]string,\
    \ len(lst))\n    stack36 := make([]string, len(lst))\n    stack37 := make([]string,\
    \ len(lst))\n    stack38 := make([]string, len(lst))\n    stack39 := make([]string,\
    \ len(lst))\n    stack40 := make([]string, len(lst))\n    stack41 := make(\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp1p5_uiw_test.go:65:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\"\
    \n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n        \
    \    stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            stack[i] = \"\"\n        }\n    }\n \
    \   for i := 0; i < len(stack); i++ {\n        if stack[i] == \"\" {\n       \
    \     if result != \"\" {\n                return \"No\"\n            }\n    \
    \        result = \"Yes\"\n        }\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpefs3js5d_test.go:64: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpefs3js5d_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpefs3js5d_test.go:64: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpefs3js5d_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpefs3js5d_test.go:64: expected\
    \ 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n       \
    \ tmpefs3js5d_test.go:64: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack1 := make([]string, len(lst))\n    stack2 := make([]string,\
    \ len(lst))\n    stack1[0] = \"\"\n    stack2[0] = \"\"\n    i := 0\n    for _,\
    \ s := range lst {\n        if s == '(' {\n            stack1[i] = s\n       \
    \     i++\n        } else if s == ')' {\n            stack2[i] = s\n         \
    \   i++\n        } else {\n            if stack1[i] == \"\" {\n              \
    \  stack1[i] = s\n            } else {\n                if stack2[i] == \"\" {\n\
    \                    stack2[i] = s\n                } else {\n               \
    \     if stack1[i-1] != stack2[i-1] {\n                        return \"No\"\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if stack1[i-1] != stack2[i-1] {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpat4jdhlo_test.go:24:17: invalid operation: s == ''('' (mismatched types
    string and untyped rune)

    /tmp/tmpat4jdhlo_test.go:27:24: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var stack = []string{}\n    for\
    \ _, str := range lst {\n        if str == \"(\" {\n            stack = append(stack,\
    \ str)\n        } else if str == \")\" {\n            if len(stack) == 0 {\n \
    \               return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n\
    \            if stack[len(stack)-1] == \"(\" {\n                stack = stack[:len(stack)-1]\n\
    \            }\n        } else {\n            if len(stack) == 0 {\n         \
    \       return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n\
    \            if stack[len(stack)-1] == \"(\" {\n                stack = stack[:len(stack)-1]\n\
    \            }\n            if str != stack[len(stack)] {\n                return\
    \ \"No\"\n            }\n        }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8b4fdqjw_test.go:18:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]string, len(lst))\n    result := \"\
    No\"\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == \"(\" {\n    \
    \        stack[i] = \"(\"\n        } else if lst[i] == \")\" {\n            stack[i]\
    \ = \")\"\n        } else {\n            if stack[len(stack)-1] != \"\" {\n  \
    \              stack[len(stack)-1] = stack[len(stack)-1] + lst[i]\n          \
    \  } else {\n                stack[len(stack)] = lst[i]\n            }\n     \
    \   }\n    }\n    if stack[len(stack)-1] != \"\" {\n        result = \"Yes\"\n\
    \    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\npanic: runtime error: index out of\
    \ range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range\
    \ [2] with length 2\n\ngoroutine 19 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.match_parens({0xc000121ca0, 0x2, 0x2?})\n\
    \t/tmp/tmpo4kkz4fg_test.go:29 +0x1bc\ncommand-line-arguments_test.TestMatch_Parens(0x0?)\n\
    \t/tmp/tmpo4kkz4fg_test.go:46 +0x99\ntesting.tRunner(0xc0001036c0, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    stack := make([]int, len(lst))\n    for i := 0; i <\
    \ len(lst); i++ {\n        stack[i] = i\n    }\n    result := \"\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    (\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result\
    \ += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"(\"\n  \
    \  result += \"(\"\n    result += \"(\"\n    result += \"(\"\n    result += \"\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuj9tt1xg_test.go:118:15: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074124
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    for _, s := range lst {\n   \
    \     if s == \"(\" || s == \")\" {\n            result += s\n        }\n    }\n\
    \    if result == \"()\" {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpp1cnciks_test.go:54: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpp1cnciks_test.go:54: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074119
