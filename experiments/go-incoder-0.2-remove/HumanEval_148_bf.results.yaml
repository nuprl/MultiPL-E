language: go_test.go
name: HumanEval_148_bf
results:
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdvmkx9el_test.go:20:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ng9ii_g_test.go:19:21: undefined: orbit

    /tmp/tmp8ng9ii_g_test.go:20:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet1OrbitRadius, planet1OrbitDistance\
    \ := getOrbit(planet1)\n    planet2Orbit, planet2OrbitRadius, planet2OrbitDistance\
    \ := getOrbit(planet2)\n    \n    planet1SunRadius, planet1SunDistance := getSun(planet1)\n\
    \    planet2SunRadius, planet2SunDistance := getSun(planet2)\n    \n    planet1OrbitDistance\
    \ += planet1SunDistance\n    planet2OrbitDistance += planet2SunDistance\n    \n\
    \    planet1OrbitRadius += planet1SunRadius\n    planet2OrbitRadius += planet2SunRadius\n\
    \    \n    planet1OrbitRadius += planet1OrbitDistance\n    planet2OrbitRadius\
    \ += planet2OrbitDistance\n    \n    planet1OrbitRadius /= 2\n    planet2OrbitRadius\
    \ /= 2\n    \n    planet1OrbitRadius += planet1Orbit\n    planet2OrbitRadius +=\
    \ planet2Orbit\n    \n    planet1OrbitRadius /= 2\n    planet2OrbitRadius /= 2\n\
    \    \n    planet1OrbitRadius += planet1Orbit\n    planet2OrbitRadius += planet2Orbit\n\
    \    \n    planet1OrbitRadius /= 2\n    planet2OrbitRadius /= 2\n    \n    planet1OrbitRadius\
    \ += planet1Orbit\n    planet2OrbitRadius += planet2Orbit\n    \n    planet1OrbitRadius\
    \ /= 2\n    planet2OrbitRadius /= 2\n    \n    planet1OrbitRadius += planet1Orbit\n\
    \    planet2OrbitRadius += planet2Orbit\n    \n    planet1OrbitRadius /= 2\n \
    \   planet2OrbitRadius /= 2\n    \n    planet1OrbitRadius += planet1Orbit\n  \
    \  planet2OrbitRadius += planet2Orbit\n    \n    planet1OrbitRadius /= 2\n   \
    \ planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplualz0od_test.go:69:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgfz0v6_s_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance, err := getDistance(planet1Sun, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunDistance,\
    \ err := getDistance(planet2Sun, planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1OrbitDistance, err := getDistance(planet1Orbit, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitDistance,\
    \ err := getDistance(planet2Orbit, planet2Orbit)\n    if err != nil {\n      \
    \  fmt.Println(err)\n    }\n    \n    planet1OrbitDistance, err := getDistance(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitDistance,\
    \ err := getDistance(planet2Orbit, planet2Orbit)\n    if err != nil {\n      \
    \  fmt.Println(err)\n    }\n    \n    planet1OrbitDistance, err := getDistance(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitDistance,\
    \ err := getDistance(planet2Orbit, planet2Orbit)\n    if err != nil {\n      \
    \  fmt.Println(err)\n    }\n    \n    planet1OrbitDistance, err := getDistance(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitDistance,\
    \ err := getDistance(planet2Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprtmrbfn5_test.go:80:55: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" {\n        return []\n    }\n    if planet2\
    \ == \"\" {\n        return []\n    }\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm10ps866_test.go:21:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSun\
    \ := planet1Orbit - planet1Sun\n    planet2OrbitSun := planet2Orbit - planet2Sun\n\
    \    \n    planet1SunSun := planet1Sun - planet1Sun\n    planet2SunSun := planet2Sun\
    \ - planet2Sun\n    \n    planet1SunOrbitSun := planet1SunOrbit - planet1SunSun\n\
    \    planet2SunOrbitSun := planet2SunOrbit - planet2SunSun\n    \n    planet1SunOrbitSunSun\
    \ := planet1SunOrbitSun - planet1SunOrbitSun\n    planet2SunOrbitSunSun := planet2SunOrbitSun\
    \ - planet2SunOrbitSun\n    \n    planet1SunOrbitSunSun := planet1SunOrbitSunSun\
    \ - planet1SunOrbitSunSun\n    planet2SunOrbitSunSun := planet2SunOrbitSunSun\
    \ - planet2SunOrbitSunSun\n    \n    planet1SunOrbitSunSun := planet1SunOrbitSunSun\
    \ - planet1SunOrbitSunSun\n    planet2SunOrbitSunSun := planet2SunOrbitSunSun\
    \ - planet2SunOrbitSunSun\n    \n    planet1SunOrbitSunSun := planet1SunOrbitSunSun\
    \ - planet1SunOrbitSunSun\n    planet2SunOrbitSunSun := planet2SunOrbitSunSun\
    \ - planet2SunOrbitSunSun\n    \n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqf7vs_4v_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwm3q45ym_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    if planet1 == \"\" || planet2 == \"\" {\n        return []\n\
    \    }\n    \n    planet1Orbit, planet2Orbit, sunOrbit, planet1OrbitDistance,\
    \ planet2OrbitDistance, sunOrbitDistance := getOrbits(planet1, planet2)\n    \n\
    \    if planet1OrbitDistance == 0 || planet2OrbitDistance == 0 || sunOrbitDistance\
    \ == 0 {\n        return []\n    }\n    \n    planet1OrbitDistance = planet1OrbitDistance\
    \ * planet1Orbit\n    planet2OrbitDistance = planet2OrbitDistance * planet2Orbit\n\
    \    sunOrbitDistance = sunOrbitDistance * sunOrbit\n    \n    planet1OrbitDistance\
    \ = planet1OrbitDistance + sunOrbitDistance\n    planet2OrbitDistance = planet2OrbitDistance\
    \ + sunOrbitDistance\n    \n    planet1OrbitDistance = planet1OrbitDistance /\
    \ 2\n    planet2OrbitDistance = planet2OrbitDistance / 2\n    \n    planet1OrbitDistance\
    \ = planet1OrbitDistance / planet1Orbit\n    planet2OrbitDistance = planet2OrbitDistance\
    \ / planet2Orbit\n    \n    planet1OrbitDistance = planet1OrbitDistance + planet2OrbitDistance\n\
    \    planet2OrbitDistance = planet2OrbitDistance + planet1OrbitDistance\n    \n\
    \    planet1OrbitDistance = planet1OrbitDistance / 2\n    planet2OrbitDistance\
    \ = planet2OrbitDistance / 2\n    \n    planet1OrbitDistance = planet1OrbitDistance\
    \ / planet1Orbit\n    planet2OrbitDistance = planet2OrbitDistance / planet2Orbit\n\
    \    \n    planet1OrbitDistance = planet1OrbitDistance + planet2OrbitDistance\n\
    \    planet2OrbitDistance = planet2OrbitDistance + planet1OrbitDistance\n    \n\
    \    planet1OrbitDistance = planet1OrbitDistance / 2\n    planet2OrbitDistance\
    \ = planet2OrbitDistance / 2\n    \n    planet1OrbitDistance = planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj4f3awx1_test.go:22:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Sun, planet2Sun := getSun(planet1, planet2)\n   \
    \ \n    planet1SunProximity := getProximity(planet1Orbit, planet1Sun)\n    planet2SunProximity\
    \ := getProximity(planet2Orbit, planet2Sun)\n    \n    planet1Proximity := getProximity(planet1Orbit,\
    \ planet1Orbit)\n    planet2Proximity := getProximity(planet2Orbit, planet2Orbit)\n\
    \    \n    planet1ProximityProximity := getProximity(planet1Proximity, planet1Proximity)\n\
    \    planet2ProximityProximity := getProximity(planet2Proximity, planet2Proximity)\n\
    \    \n    planet1ProximityProximityProximity := getProximity(planet1ProximityProximity,\
    \ planet1ProximityProximity)\n    planet2ProximityProximityProximity := getProximity(planet2ProximityProximity,\
    \ planet2ProximityProximity)\n    \n    planet1ProximityProximityProximityProximity\
    \ := getProximity(planet1ProximityProximityProximityProximity, planet1ProximityProximityProximityProximity)\n\
    \    planet2ProximityProximityProximityProximity := getProximity(planet2ProximityProximityProximityProximity,\
    \ planet2ProximityProximityProximity)\n    \n    planet1ProximityProximityProximityProximityProximity\
    \ := getProximity(planet1ProximityProximityProximityProximityProximityProximity,\
    \ planet1ProximityProximityProximityProximityProximityProximity)\n    planet2ProximityProxim\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprk0x2q1s_test.go:43:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun := getSun(planet1,\
    \ planet2)\n    planet1SunProximity, planet2SunProximity := getSunProximity(planet1,\
    \ planet2)\n    planet1Proximity, planet2Proximity := getProximity(planet1, planet2)\n\
    \    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet2ProximityProximity := getProximityProximity(planet1,\
    \ planet2)\n    planet1ProximityProximity, planet\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw5pi21u0_test.go:34:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        if planet == planet2 {\n            result = append(result, planet)\n\
    \        }\n    }\n    \n    for _, planet := range planet2Orbit {\n        if\
    \ planet == planet1 {\n            result = append(result, planet)\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqwmqadis_test.go:19:21: undefined: planet1Orbit

    /tmp/tmpqwmqadis_test.go:20:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOr\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmz4xamts_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOr\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25s9zacl_test.go:41:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := getOrbit(planet1)\n    planet2Orbit := getOrbit(planet2)\n\
    \    planet1Orbit.sort()\n    planet2Orbit.sort()\n    planet1Orbit.intersect(planet2Orbit)\n\
    \    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc_h6ae7h_test.go:20:21: undefined: getOrbit

    /tmp/tmpc_h6ae7h_test.go:21:21: undefined: getOrbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet1OrbitSun, err := getOrbitSun(planet1)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    planet2OrbitSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunOrbit,\
    \ err := getOrbitSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2SunOrbit, err := getOrbitSun(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1SunOrbitSun, err := getOrbitSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunOrbitSun,\
    \ err := getOrbitSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunOrbitSunSun, err := getOrbitSun(planet1)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n    }\n    planet2SunOrbitSunSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunOrbitSunSun,\
    \ err := getOrbitSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2SunOrbitSunSun, err := getOrbitSun(planet2)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n    }\n    planet1SunOrbitSunSun, err := getOrbitSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunOrbitSunSun,\
    \ err := getOrbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp235_z4nb_test.go:83:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := getDistance(planet1Orbit, planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgh7u5eqf_test.go:65:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSunProximity :=\
    \ distance(planet1OrbitSun, planet2OrbitSun)\n    planet2OrbitSunProximity :=\
    \ distance(planet2OrbitSun, planet1OrbitSun)\n    planet1OrbitSunProximityProximity\
    \ := distance(planet1OrbitSunProximity, planet2OrbitSunProximity)\n    planet2OrbitSunProximityProximity\
    \ := distance(planet2OrbitSunProximity, planet1OrbitSunProximity)\n    planet1OrbitSunProximityProximityProximity\
    \ := distance(planet1OrbitSunProximityProximity, planet2OrbitSunProximityProximity)\n\
    \    planet1OrbitSunProximityProximityProximityProximity := distance(planet1OrbitSunProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximity)\n    planet1OrbitSunProximityProximityProximityProximityProximity\
    \ := distance(planet1OrbitSunProximityProximityProximityProximity, planet2OrbitSunProximityProximityProximityProximity)\n\
    \    planet1OrbitSunProximityProximityProximityProximityProximityProximity :=\
    \ distance(planet1OrbitSunProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximityProximityProximity)\n    planet1OrbitSunProximityProximityProximityProximityProximityProximityProximity\
    \ := distance(planet1OrbitSunProximityProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximityProximityProximityProximityProximity)\n\
    \    planet1OrbitSunProximity\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_vphnn9c_test.go:32:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance, err := getDistance(planet1Sun, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunDistance,\
    \ err := getDistance(planet2Sun, planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1OrbitDistance, err := getDistance(planet1Orbit, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitDistance,\
    \ err := getDistance(planet2Orbit, planet2Orbit)\n    if err != nil {\n      \
    \  fmt.Println(err)\n    }\n    \n    planet1OrbitDistanceToSun, err := getDistance(planet1Orbit,\
    \ planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitDistanceToSun,\
    \ err := getDistance(planet2Orbit, planet2Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSun, err :=\
    \ getDistance(planet1Orbit, planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSun,\
    \ err := getDistance(planet1Orbit, planet2Orbit)\n    if err != nil {\n      \
    \  fmt.Println(err)\n    }\n    \n    planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSun\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj00_wpt3_test.go:78:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvtn6en4y_test.go:21:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n  \
    \  planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit\
    \ = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n  \
    \  planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit\
    \ = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n  \
    \  planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit\
    \ = getOrbits(planet1, planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit = getOrbits(planet1, plan\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0x2ux1n7_test.go:59:57: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet2Orbit, err\
    \ := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunProximity, err := getProximity(planet1Sun, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet2SunProximity,\
    \ err := getProximity(planet2Sun, planet2Orbit)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n\
    \    planet2Proximity, err := getProximity(planet2Orbit, planet2Orbit)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Proximity, err\
    \ := getProximity(planet1Orbit, planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet2Proximity, err := getProximity(planet2Orbit, planet2Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Proximity,\
    \ err := getProximity(planet1Orbit, planet1Orbit)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    \n    planet2Proximity, err := getProximity(planet2Orbit,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n\
    \    planet1Proximity, err := getProximity(planet1Orbit, planet1Orbit)\n    if\
    \ err\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfytdshub_test.go:84:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunProximity := getProximity(planet1Orbit, planet1Sun)\n\
    \    planet2SunProximity := getProximity(planet2Orbit, planet2Sun)\n    \n   \
    \ planet1OrbitProximity := getProximity(planet1Orbit, planet1Orbit)\n    planet2OrbitProximity\
    \ := getProximity(planet2Orbit, planet2Orbit)\n    \n    planet1OrbitProximity2\
    \ := getProximity(planet1Orbit, planet1Orbit)\n    planet2OrbitProximity2 := getProximity(planet2Orbit,\
    \ planet2Orbit)\n    \n    planet1OrbitProximity3 := getProximity(planet1Orbit,\
    \ planet1Orbit)\n    planet2OrbitProximity3 := getProximity(planet2Orbit, planet2Orbit)\n\
    \    \n    planet1OrbitProximity4 := getProximity(planet1Orbit, planet1Orbit)\n\
    \    planet2OrbitProximity4 := getProximity(planet2Orbit, planet2Orbit)\n    \n\
    \    planet1OrbitProximity5 := getProximity(planet1Orbit, planet1Orbit)\n    planet2OrbitProximity5\
    \ := getProximity(planet2Orbit, planet2Orbit)\n    \n    planet1OrbitProximity6\
    \ := getProximity(planet1Orbit, planet1Or\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkuloylmm_test.go:58:67: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    planet1Orbit.insert(planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwup3iljx_test.go:19:35: undefined: getOrbits

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074540
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:2], planet2[:2]\n\
    \    planet1, planet2 = planet1[:3], planet2[:3]\n    planet1, planet2 = planet1[:4],\
    \ planet2[:4]\n    planet1, planet2 = planet1[:5], planet2[:5]\n    planet1, planet2\
    \ = planet1[:6], planet2[:6]\n    planet1, planet2 = planet1[:7], planet2[:7]\n\
    \    planet1, planet2 = planet1[:8], planet2[:8]\n    planet1, planet2 = planet1[:9],\
    \ planet2[:9]\n    planet1, planet2 = planet1[:10], planet2[:10]\n    planet1,\
    \ planet2 = planet1[:11], planet2[:11]\n    planet1, planet2 = planet1[:12], planet2[:12]\n\
    \    planet1, planet2 = planet1[:13], planet2[:13]\n    planet1, planet2 = planet1[:14],\
    \ planet2[:14]\n    planet1, planet2 = planet1[:15], planet2[:15]\n    planet1,\
    \ planet2 = planet1[:16], planet2[:16]\n    planet1, planet2 = planet1[:17], planet2[:17]\n\
    \    planet1, planet2 = planet1[:18], planet2[:18]\n    planet1, planet2 = planet1[:19],\
    \ planet2[:19]\n    planet1, planet2 = planet1[:20], planet2[:20]\n    planet1,\
    \ planet2 = planet1[:21], planet2[:21]\n    planet1, planet2 = planet1[:22], planet2[:22]\n\
    \    planet1, planet2 = planet1[:23], planet2[:23]\n    planet1, planet2 = planet1[:24],\
    \ planet2[:24]\n    planet1, planet2 = planet1[:25], plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2co9gk1e_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwm3q45ym_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwm3q45ym_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Proximity, planet2Proximity := getProximity(planet1Orbit,\
    \ planet2Orbit, sunOrbit)\n    \n    planet1Proximity, planet2Proximity, sunProximity\
    \ := getProximity(planet1Orbit, planet2Orbit, sunOrbit)\n    \n    planet1Proximity,\
    \ planet2Proximity, sunProximity := getProximity(planet1Orbit, planet2Orbit, sunOrbit)\n\
    \    \n    planet1Proximity, planet2Proximity, sunProximity := getProximity(planet1Orbit,\
    \ planet2Orbit, sunOrbit)\n    \n    planet1Proximity, planet2Proximity, sunProximity\
    \ := getProximity(planet1Orbit, planet2Orbit, sunOrbit)\n    \n    planet1Proximity,\
    \ planet2Proximity, sunProximity := getProximity(planet1Orbit, planet2Orbit, sunOrbit)\n\
    \    \n    planet1Proximity, planet2Proximity, sunProximity := getProximity(planet1Orbit,\
    \ planet2Orbit, sunOrbit)\n    \n    planet1Proximity, planet2Proximity, sunProximity\
    \ := getProximity(planet1Orbit, planet2Orbit, sunOrbit)\n    \n    planet1Proximity,\
    \ planet2Proximity, sunProximity := getProximity(planet1Orbit, planet2Orbit, sunOrbit)\n\
    \    \n    planet1Proximity, planet2Proximity, sunProximity := getProximity(planet1Orbit,\
    \ planet2Orbit, sunOrbit)\n    \n    planet1Proximity, planet2Proximity, sunProximity\
    \ := getProximity(planet1Orbit, \nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpovtechm__test.go:44:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOr\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw40k8il1_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n    \n  \
    \  planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp36iyd4wl_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOr\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw40k8il1_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8i0tg_rf_test.go:77:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" || planet2 == \"\" {\n        return nil\n \
    \   }\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6nllmftx_test.go:57:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := getOrbit(planet1)\n    planet2Orbit := getOrbit(planet2)\n\
    \    planet1Sun := getSun()\n    planet2Sun := getSun()\n    planet1Distance :=\
    \ getDistance(planet1Orbit, planet1Sun)\n    planet2Distance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    planet1OrbitDistance := getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2OrbitDistance := getDistance(planet2Orbit, planet1Orbit)\n    planet1OrbitDistance\
    \ /= getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun,\
    \ planet2Orbit)\n    planet1OrbitDistance /= getDistance(planet1Sun, planet2Orbit)\n\
    \    planet2OrbitDistance /= getDistance(planet2Sun, planet1Orbit)\n    planet1OrbitDistance\
    \ /= getDistance(planet1Sun, planet2Sun)\n    planet2OrbitDistance /= getDistance(planet2Sun,\
    \ planet1Sun)\n    planet1OrbitDistance /= getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2OrbitDistance /= getDistance(planet2Orbit, planet1Orbit)\n    planet1OrbitDistance\
    \ /= getDistance(planet1Orbit, planet2Sun)\n    planet2OrbitDistance /= getDistance(planet2Sun,\
    \ planet1Orbit)\n    planet1OrbitDistance /= getDistance(planet1Sun, planet2Sun)\n\
    \    planet2OrbitDistance /= getDistance(planet2Sun, planet1Sun)\n    planet1OrbitDistance\
    \ /= getDistance(planet1Orbit, planet2Orbit)\n    planet2OrbitDistance /= getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1OrbitDistance /= getDistance(planet1Sun, planet2Sun)\n\
    \    planet2OrbitDistance /= getDistance(planet2Sun, planet1Sun)\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwj1y_641_test.go:44:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdvmkx9el_test.go:20:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun :=\
    \ getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmujby2u9_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp51uqbc9g_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptseqv8ou_test.go:19:21: undefined: orbit

    /tmp/tmptseqv8ou_test.go:20:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074540
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdvmkx9el_test.go:20:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit\
    \ := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n   \
    \ planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n   \
    \ \n    planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsiy6g_hq_test.go:47:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance, err := getDistance(planet1Sun, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunDistance,\
    \ err := getDistance(planet2Sun, planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitDistance, err := getDistance(planet1Orbit, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitDistance,\
    \ err := getDistance(planet2Orbit, planet2Orbit)\n    if err != nil {\n      \
    \  fmt.Println(err)\n    }\n    planet1OrbitSunDistance := planet1OrbitDistance\
    \ - planet1SunDistance\n    planet2OrbitSunDistance := planet2OrbitDistance -\
    \ planet2SunDistance\n    planet1OrbitSunDistanceSquare := planet1OrbitSunDistance\
    \ * planet1OrbitSunDistance\n    planet2OrbitSunDistanceSquare := planet2OrbitSunDistance\
    \ * planet2OrbitSunDistance\n    planet1OrbitSunDistanceSquare += planet1SunDistance\
    \ * planet1SunDistance\n    planet2OrbitSunDistanceSquare += planet2SunDistance\
    \ * planet2SunDistance\n    planet1OrbitSunDistanceSquare /= 2\n    planet2OrbitSunDistanceSquare\
    \ /= 2\n    planet1OrbitSunDistanceSquare += planet1OrbitSunDistance * planet1OrbitSunDistance\n\
    \    planet2OrbitSunDistanceSquare += planet2OrbitSunDistance * planet2OrbitSunDistance\n\
    \    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphsq4e_ec_test.go:65:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1, planet2)\n    planet1SunProximity := getSunProximity(planet1Orbit,\
    \ planet1Sun)\n    planet2SunProximity := getSunProximity(planet2Orbit, planet2Sun)\n\
    \    planet1PlanetProximity := getPlanetProximity(planet1Orbit, planet1)\n   \
    \ planet2PlanetProximity := getPlanetProximity(planet2Orbit, planet2)\n    planet1PlanetProximitySorted\
    \ := getPlanetProximitySorted(planet1PlanetProximity)\n    planet2PlanetProximitySorted\
    \ := getPlanetProximitySorted(planet2PlanetProximity)\n    planet1PlanetProximitySortedSorted\
    \ := getPlanetProximitySortedSorted(planet1PlanetProximitySorted)\n    planet2PlanetProximitySortedSorted\
    \ := getPlanetProximitySortedSorted(planet2PlanetProximitySorted)\n    planet1PlanetProximitySortedSortedSorted\
    \ := getPlanetProximitySortedSortedSorted(planet1PlanetProximitySortedSorted)\n\
    \    planet2PlanetProximitySortedSortedSorted := getPlanetProximitySortedSortedSorted(planet2PlanetProximitySortedSorted)\n\
    \    planet1PlanetProximitySortedSortedSortedSorted := getPlanetProximitySortedSortedSortedSorted(planet1PlanetProximitySortedSortedSorted)\n\
    \    planet2PlanetProximitySortedSortedSortedSorted := getPlanetProximitySortedSortedSortedSorted(planet2PlanetProximitySortedSortedSorted)\n\
    \    planet1PlanetProximitySortedSortedSortedSortedSorted := getPlanetProximitySortedSortedSortedSortedSorted(planet1PlanetProximitySortedSortedSortedSorted)\n\
    \    planet2PlanetProximitySortedSortedSortedSortedSorted := getPlanetProximitySortedSortedSortedSortedSorted(planet2PlanetProxim\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47k0crnw_test.go:35:129: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" || planet2 == \"\" {\n        return []\n  \
    \  }\n    planet1Orbit, planet2Orbit := planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n \
    \   planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp8ybspsq_test.go:21:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitPlanet := planet1\n    planet2OrbitPlanet :=\
    \ planet2\n    \n    planet1OrbitPlanetPlanet := planet1\n    planet2OrbitPlanetPlanet\
    \ := planet2\n    \n    planet1OrbitPlanetPlanetPlanet := planet1\n    planet2OrbitPlanetPlanetPlanet\
    \ := planet2\n    \n    planet1OrbitPlanetPlanetPlanetPlanet := planet1\n    planet2OrbitPlanetPlanetPlanetPlanet\
    \ := planet2\n    \n    planet1OrbitPlanetPlanetPlanetPlanetPlanet := planet1\n\
    \    planet2OrbitPlanetPlanetPlanetPlanetPlanet := planet2\n    \n    planet1OrbitPlanetPlanetPlanetPlanetPlanetPlanet\
    \ := planet1\n    planet2OrbitPlanetPlanetPlanetPlanetPlanetPlanet := planet2\n\
    \    \n    planet1OrbitPlanetPlanetPlanetPlanetPlanetPlanetPlanet := planet1\n\
    \    planet2OrbitPlanetPlanetPlanetPlanetPlanetPlanetPlanet := planet2\n    \n\
    \    planet1OrbitPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanet := planet1\n\
    \    planet2OrbitPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanet := planet2\n\
    \    \n    planet1OrbitPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanet\
    \ := planet1\n    planet2OrbitPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanet\
    \ := planet2\n    \n    planet1OrbitPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanet\
    \ := planet1\n    planet2OrbitPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanetPlanet\
    \ := planet2\n    \n    planet1OrbitPlanet\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8dyfln5u_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    \n \
    \   planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    \n  \
    \  planet1OrbitSunProximity := getProximity(planet1OrbitSun, planet2OrbitSun)\n\
    \    \n    planet1OrbitSunProximityProximity := getProximity(planet1OrbitSunProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximity := getProximity(planet1OrbitSunProximityProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximityProximity\
    \ := getProximity(planet1OrbitSunProximityProximityProximity, planet2OrbitSun)\n\
    \    \n    planet1OrbitSunProximityProximityProximityProximityProximity := getProximity(planet1OrbitSunProximityProximityProximityProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximityProximityProximityProximity\
    \ := getProximity(planet1OrbitSunProximityProximityProximityProximityProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximityProximityProximityProximityProximity\
    \ := getProximity(planet1OrbitSunProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximityProximityProximityProximityProximityProximity\
    \ := getProximity(planet1OrbitSunProximityProximityProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProxim\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpinbj6569_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:2], planet2[:2]\n\
    \    planet1, planet2 = planet1[:3], planet2[:3]\n    planet1, planet2 = planet1[:4],\
    \ planet2[:4]\n    planet1, planet2 = planet1[:5], planet2[:5]\n    planet1, planet2\
    \ = planet1[:6], planet2[:6]\n    planet1, planet2 = planet1[:7], planet2[:7]\n\
    \    planet1, planet2 = planet1[:8], planet2[:8]\n    planet1, planet2 = planet1[:9],\
    \ planet2[:9]\n    planet1, planet2 = planet1[:10], planet2[:10]\n    planet1,\
    \ planet2 = planet1[:11], planet2[:11]\n    planet1, planet2 = planet1[:12], planet2[:12]\n\
    \    planet1, planet2 = planet1[:13], planet2[:13]\n    planet1, planet2 = planet1[:14],\
    \ planet2[:14]\n    planet1, planet2 = planet1[:15], planet2[:15]\n    planet1,\
    \ planet2 = planet1[:16], planet2[:16]\n    planet1, planet2 = planet1[:17], planet2[:17]\n\
    \    planet1, planet2 = planet1[:18], planet2[:18]\n    planet1, planet2 = planet1[:19],\
    \ planet2[:19]\n    planet1, planet2 = planet1[:20], planet2[:20]\n    planet1,\
    \ planet2 = planet1[:21], planet2[:21]\n    planet1, planet2 = planet1[:22], planet2[:22]\n\
    \    planet1, planet2 = planet1[:23], planet2[:23]\n    planet1, planet2 = planet1[:24],\
    \ planet2[:24]\n    planet1, planet2 = planet1[:25], plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp07lndjty_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074540
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance := planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet2Orbit)\n    planet1OrbitDistance\
    \ += planet1SunDistance\n    planet2OrbitDistance += planet2SunDistance\n    planet1OrbitDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    planet1OrbitDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    planet1OrbitDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance += planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    planet1OrbitDistance += planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance += planet2Orbit.Distance(plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptl9fnnxe_test.go:55:55: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074540
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n    \n  \
    \  planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-3], planet2Orbit[:len(planet2Orbit)-3]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-2], planet2Orbit[:len(planet2Orbit)-2]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-3], planet2Orbit[:len(planet2Orbit)-3]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-2], planet2Orbit[:len(planet2Orbit)-2]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-3], planet2Orbit[:len(planet2Orbit)-3]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-2], planet2Orbit[:len(planet2Orbit)-2]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-3], planet2Orbit[:len(planet2Orbit)-3]\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwvz7okyt_test.go:44:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074540
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyuei4lh7_test.go:37:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074540
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := orbit(planet1,\
    \ planet2)\n    \n    planet1Sun, planet2Sun := sun(planet1, planet2)\n    \n\
    \    planet1SunProximity := planet1Orbit - planet1Sun\n    planet2SunProximity\
    \ := planet2Orbit - planet2Sun\n    \n    planet1SunProximityList := []interface{}{planet1,\
    \ planet2}\n    planet2SunProximityList := []interface{}{planet2, planet1}\n \
    \   \n    planet1SunProximityList = append(planet1SunProximityList, planet1Orbit)\n\
    \    planet2SunProximityList = append(planet2SunProximityList, planet2Orbit)\n\
    \    \n    planet1SunProximityList = append(planet1SunProximityList, planet1SunProximity)\n\
    \    planet2SunProximityList = append(planet2SunProximityList, planet2SunProximity)\n\
    \    \n    planet1SunProximityList = append(planet1SunProximityList, planet1SunProximity)\n\
    \    planet2SunProximityList = append(planet2SunProximityList, planet2SunProximity)\n\
    \    \n    planet1SunProximityList = append(planet1SunProximityList, planet1SunProximity)\n\
    \    planet2SunProximityList = append(planet2SunProximityList, planet2SunProximity)\n\
    \    \n    planet1SunProximityList = append(planet1SunProximityList, planet1SunProximity)\n\
    \    planet2SunProximityList = append(planet2SunProximityList, planet2SunProximity)\n\
    \    \n    planet1SunProximityList = append(planet1SunProximityList, planet1SunProximity)\n\
    \    planet2SunProximityList = append(planet2SunProximityList, planet2SunProximity)\n\
    \    \n    planet1SunProximityList = append(planet1SunProximityList, planet1SunProximity)\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpndus0ihf_test.go:52:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074540
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdfx54ey1_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n    planet1,\
    \ planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1, planet2 = planet1.ToTitle(),\
    \ planet2.ToTitle()\n    planet1, planet2 = planet1.ToCamelCase(), planet2.ToCamelCase()\n\
    \    planet1, planet2 = planet1.ToPascalCase(), planet2.ToPascalCase()\n    planet1,\
    \ planet2 = planet1.ToSnakeCase(), planet2.ToSnakeCase()\n    planet1, planet2\
    \ = planet1.ToKebabCase(), planet2.ToKebabCase()\n    planet1, planet2 = planet1.ToHumanize(),\
    \ planet2.ToHumanize()\n    planet1, planet2 = planet1.ToHumanize(), planet2.ToHumanize()\n\
    \    planet1, planet2 = planet1.ToHumanize(), planet2.ToHumanize()\n    planet1,\
    \ planet2 = planet1.ToHumanize(), planet2.ToHumanize()\n    planet1, planet2 =\
    \ planet1.ToHumanize(), planet2.ToHumanize()\n    planet1, planet2 = planet1.ToHumanize(),\
    \ planet2.ToHumanize()\n    planet1, planet2 = planet1.ToHumanize(), planet2.ToHumanize()\n\
    \    planet1, planet2 = planet1.ToHumanize(), planet2.ToHumanize()\n    planet1,\
    \ planet2 = planet1.ToHumanize(), planet2.ToHumanize()\n    planet1, planet2 =\
    \ planet1.ToHumanize(), planet2.ToHumanize()\n    planet1, planet2 = planet1.ToHumanize(),\
    \ planet2.ToHumanize()\n    planet1, planet2 = planet1.ToHumanize(), planet2.ToHumanize()\n\
    \    planet1, planet2 = planet1.ToHumanize(), planet2.ToHumanize()\n    planet1,\
    \ planet2 = planet1.ToHumanize(), planet2.ToHumanize()\n    planet1, \nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpipt4120__test.go:41:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(\"Error getting orbit of planet 1\")\n\
    \    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n    \
    \    fmt.Println(\"Error getting orbit of planet 2\")\n    }\n    \n    planet1Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(\"Error getting sun\
    \ position\")\n    }\n    planet2Sun, err := getSun()\n    if err != nil {\n \
    \       fmt.Println(\"Error getting sun position\")\n    }\n    \n    planet1SunDistance\
    \ := getDistance(planet1Orbit, planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    \n    planet1OrbitDistance := getDistance(planet1Orbit, planet1Orbit)\n\
    \    planet2OrbitDistance := getDistance(planet2Orbit, planet2Orbit)\n    \n \
    \   planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance += planet2SunDistance\n\
    \    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance += planet1OrbitDistance\n\
    \    planet2OrbitDistance += planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ += planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance += planet1OrbitDistance\n\
    \    planet2OrbitDistance += planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ += planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1qz95z36_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(\"Error getting orbit for planet 1\")\n\
    \    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n    \
    \    fmt.Println(\"Error getting orbit for planet 2\")\n    }\n    \n    planet1Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(\"Error getting sun\
    \ for planet 1\")\n    }\n    planet2Sun, err := getSun()\n    if err != nil {\n\
    \        fmt.Println(\"Error getting sun for planet 2\")\n    }\n    \n    planet1SunDistance,\
    \ err := getDistance(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(\"\
    Error getting distance for planet 1\")\n    }\n    planet2SunDistance, err :=\
    \ getDistance(planet2Orbit, planet2Sun)\n    if err != nil {\n        fmt.Println(\"\
    Error getting distance for planet 2\")\n    }\n    \n    planet1SunDistance, err\
    \ := getDistance(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(\"\
    Error getting distance for planet 1\")\n    }\n    planet2SunDistance, err :=\
    \ getDistance(planet2Orbit, planet2Sun)\n    if err != nil {\n        fmt.Println(\"\
    Error getting distance for planet 2\")\n    }\n    \n    planet1SunDistance, err\
    \ := getDistance(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(\"\
    Error getting distance for planet 1\")\n    }\n    planet2SunDistance, err :=\
    \ getDistance(planet2Orbit, planet2Sun)\n    if err != nil {\n        fmt.Println(\"\
    Error getting distance for planet 2\")\n    }\n    \n    planet1SunDistance, err\
    \ := getDistance(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(\"\
    Error getting distance for planet 1\")\n    }\n    planet2SunDistance, err :=\
    \ getDistance(planet2Orbit, planet2Sun)\n    if err != nil {\n        fmt.Println(\"\
    Error getting distance for planet 2\")\n    }\n    \n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp7q1rzj4_test.go:77:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunOrbit, err := getOrbit(planet1Sun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2SunOrbit, err := getOrbit(planet2Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunSun, err\
    \ := getSun(planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2SunSun, err := getSun(planet2Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunSunOrbit, err := getOrbit(planet1SunSun)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n    }\n    planet2SunSunOrbit, err := getOrbit(planet2SunSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunSunSun, err\
    \ := getSun(planet1SunSun)\n    if err != nil {\n        fmt.Println(err)\n  \
    \  }\n    planet2SunSunSun, err := getSun(planet2SunSun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1SunSunSunOrbit, err := getOrbit(planet1SunSunSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunSunSunOrbit,\
    \ err := getOrbit(planet2SunSunSun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunSunSunSun, err := getSun(planet1SunSunSun)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n    }\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4_qog9e6_test.go:83:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    planet1OrbitSun, err := getPlanetOrbitSun(planet1)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err := getPlanetOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunSun,\
    \ err := getPlanetOrbitSunSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunSun, err := getPlanetOrbitSunSun(planet2)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunSunSun, err :=\
    \ getPlanetOrbitSunSunSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunSunSun, err := getPlanetOrbitSunSunSun(planet2)\n \
    \   if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunSunSunSun,\
    \ err := getPlanetOrbitSunSunSunSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunSunSunSun, err := getPlanetOrbitSunSunSunSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunSunSunSun,\
    \ err := getPlanetOrbitSunSunSunSunSun(planet1)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    planet2OrbitSunSunSunSun, err := getPlanetOrbitSunSunSunSunSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunSunSunSunSun,\
    \ err := getPlanetOrbitSunSunSunSunSunSun(planet1)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    planet2\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_wx3i2s__test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplq9lec35_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" || planet2 == \"\" {\n        return nil\n \
    \   }\n    \n    planet1Orbit, planet2Orbit, sunOrbit, planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2Orbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp31i7qjpv_test.go:52:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunProximity, err := getProximity(planet1Orbit, planet1Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunProximity,\
    \ err := getProximity(planet2Orbit, planet2Sun)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Print\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp97rfr8da_test.go:79:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpia8of3pa_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1Sun, planet2Sun := getOrbits(planet1, planet2)\n    planet1SunOrbit,\
    \ planet2SunOrbit := getOrbits(planet1, planet2)\n    planet1SunOrbitSun, planet2SunOrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunSun, planet2OrbitSunSun :=\
    \ getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSun, planet2OrbitSunOrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSunOrbitSunSun, planet2OrbitSunOrbitSunSun\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9o5nzmkl_test.go:36:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit, planet2Orbit, sunOrbit = planet1Orbit, planet2Orbit,\
    \ sunOrbit\n    \n    planet1Orbit\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzek9h1xy_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit\
    \ + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit\
    \ = planet1Orbit + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n  \
    \  \n    planet1Orbit = planet1Orbit + \"Orbit\"\n    planet2Orbit = planet2Orbit\
    \ + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit + \"Orbit\"\n    planet2Orbit\
    \ = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit + \"Orbit\"\
    \n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit\
    \ + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit\
    \ = planet1Orbit + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n  \
    \  \n    planet1Orbit = planet1Orbit + \"Orbit\"\n    planet2Orbit = planet2Orbit\
    \ + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit + \"Orbit\"\n    planet2Orbit\
    \ = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit + \"Orbit\"\
    \n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit\
    \ + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit\
    \ = planet1Orbit + \"Orbit\"\n    planet2Orbit = \nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcxk0v9tz_test.go:63:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_p1jox98_test.go:57:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpwbbv4m5a_test.go:43: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpwbbv4m5a_test.go:43: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpwbbv4m5a_test.go:43:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpwbbv4m5a_test.go:43: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" || planet2 == \"\" {\n        return []\n  \
    \  }\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpauzamezv_test.go:21:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Proximity, planet2Proximity := getProximity(planet1Orbit,\
    \ planet2Orbit, sunOrbit)\n    \n    planet1Proximity, planet2Proximity = sortingProximity(planet1Proximity,\
    \ planet2Proximity)\n    \n    planet1Proximity, planet2Proximity = checkProximity(planet1Proximity,\
    \ planet2Proximity)\n    \n    return planet1Proximity, planet2Proximity\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl8p2aqum_test.go:21:45: undefined: getOrbits

    /tmp/tmpl8p2aqum_test.go:23:43: undefined: getProximity

    /tmp/tmpl8p2aqum_test.go:25:42: undefined: sortingProximity

    /tmp/tmpl8p2aqum_test.go:27:42: undefined: checkProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfdfyvy_3_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    if planet1 == \"\" || planet2 == \"\" {\n        return\
    \ []interface{}{}\n    }\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    plan\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8fvh90ue_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp22znd21x_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    \n    planet1OrbitSunProximity := getProximity(planet1OrbitSun, planet2OrbitSun)\n\
    \    \n    planet1OrbitSunProximityProximity := getProximity(planet1OrbitSunProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximity := getProximity(planet1OrbitSunProximityProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximityProximity\
    \ := getProximity(planet1OrbitSunProximityProximityProximityProximity, planet2OrbitSun)\n\
    \    \n    planet1OrbitSunProximityProximityProximityProximityProximity := getProximity(planet1OrbitSunProximityProximityProximityProximityProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximityProximityProximityProximity\
    \ := getProximity(planet1OrbitSunProximityProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximityProximityProximityProximityProximity\
    \ := getProximity(planet1OrbitSunProximityProximityProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSunProximityProximityProximityProximityProximityProximityProximityProximity\
    \ := getProximity(planet1OrbitSunProximityProximityProximityProximityProximityProximityProx\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpowpf4q78_test.go:40:182: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance, err := getDistance(planet1Sun, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunDistance,\
    \ err := getDistance(planet2Sun, planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitDistance, err := getDistance(planet1Orbit, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitDistance,\
    \ err := getDistance(planet2Orbit, planet2Orbit)\n    if err != nil {\n      \
    \  fmt.Println(err)\n    }\n    planet1OrbitSunDistance := planet1OrbitDistance\
    \ - planet1SunDistance\n    planet2OrbitSunDistance := planet2OrbitDistance -\
    \ planet2SunDistance\n    planet1OrbitSunDistance := planet1OrbitSunDistance /\
    \ planet1OrbitDistance\n    planet2OrbitSunDistance := planet2OrbitSunDistance\
    \ / planet2OrbitDistance\n    planet1OrbitSunDistance := planet1OrbitSunDistance\
    \ * planet1OrbitDistance\n    planet2OrbitSunDistance := planet2OrbitSunDistance\
    \ * planet2OrbitDistance\n    planet1OrbitSunDistance := planet1OrbitSunDistance\
    \ * planet1OrbitSunDistance\n    planet2OrbitSunDistance := planet2OrbitSunDistance\
    \ * planet2OrbitSunDistance\n    planet1OrbitSunDistance := planet1OrbitSunDistance\
    \ * planet1OrbitSunDistance\n    planet2Orbit\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzhvx41zd_test.go:64:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpikou1l4d_test.go:46:34: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:2], planet2[:2]\n\
    \    planet1, planet2 = planet1[:3], planet2[:3]\n    planet1, planet2 = planet1[:4],\
    \ planet2[:4]\n    planet1, planet2 = planet1[:5], planet2[:5]\n    planet1, planet2\
    \ = planet1[:6], planet2[:6]\n    planet1, planet2 = planet1[:7], planet2[:7]\n\
    \    planet1, planet2 = planet1[:8], planet2[:8]\n    planet1, planet2 = planet1[:9],\
    \ planet2[:9]\n    planet1, planet2 = planet1[:10], planet2[:10]\n    planet1,\
    \ planet2 = planet1[:11], planet2[:11]\n    planet1, planet2 = planet1[:12], planet2[:12]\n\
    \    planet1, planet2 = planet1[:13], planet2[:13]\n    planet1, planet2 = planet1[:14],\
    \ planet2[:14]\n    planet1, planet2 = planet1[:15], planet2[:15]\n    planet1,\
    \ planet2 = planet1[:16], planet2[:16]\n    planet1, planet2 = planet1[:17], planet2[:17]\n\
    \    planet1, planet2 = planet1[:18], planet2[:18]\n    planet1, planet2 = planet1[:19],\
    \ planet2[:19]\n    planet1, planet2 = planet1[:20], planet2[:20]\n    planet1,\
    \ planet2 = planet1[:21], planet2[:21]\n    planet1, planet2 = planet1[:22], planet2[:22]\n\
    \    planet1, planet2 = planet1[:23], planet2[:23]\n    planet1, planet2 = planet1[:24],\
    \ planet2[:24]\n    planet1, planet2 = planet1[:25], plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2co9gk1e_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgfz0v6_s_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:2],\
    \ planet2[:2]\n    planet1, planet2 = planet1[:3], planet2[:3]\n    planet1, planet2\
    \ = planet1[:4], planet2[:4]\n    planet1, planet2 = planet1[:5], planet2[:5]\n\
    \    planet1, planet2 = planet1[:6], planet2[:6]\n    planet1, planet2 = planet1[:7],\
    \ planet2[:7]\n    planet1, planet2 = planet1[:8], planet2[:8]\n    planet1, planet2\
    \ = planet1[:9], planet2[:9]\n    planet1, planet2 = planet1[:10], planet2[:10]\n\
    \    planet1, planet2 = planet1[:11], planet2[:11]\n    planet1, planet2 = planet1[:12],\
    \ planet2[:12]\n    planet1, planet2 = planet1[:13], planet2[:13]\n    planet1,\
    \ planet2 = planet1[:14], planet2[:14]\n    planet1, planet2 = planet1[:15], planet2[:15]\n\
    \    planet1, planet2 = planet1[:16], planet2[:16]\n    planet1, planet2 = planet1[:17],\
    \ planet2[:17]\n    planet1, planet2 = planet1[:18], planet2[:18]\n    planet1,\
    \ planet2 = planet1[:19], planet2[:19]\n    planet1, planet2 = planet1[:20], planet2[:20]\n\
    \    planet1, planet2 = planet1[:21], planet2[:21]\n    planet1, planet2 = planet1[:22],\
    \ planet2[:22]\n    planet1, planet2 = planet1[:23], planet2[:23]\n    planet1,\
    \ planet2 = planet1[:24], planet2[:24]\n    planet1, planet2 = planet1[:25\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplhsr801m_test.go:45:35: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err :=\
    \ getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunProximity := getProximity(planet1Orbit, planet1Sun)\n  \
    \  planet2SunProximity := getProximity(planet2Orbit, planet2Sun)\n    planet1OrbitProximity\
    \ := getProximity(planet1Orbit, planet2Orbit)\n    planet2OrbitProximity := getProximity(planet2Orbit,\
    \ planet1Orbit)\n    planet1OrbitProximity = planet1OrbitProximity - planet1SunProximity\n\
    \    planet2OrbitProximity = planet2OrbitProximity - planet2SunProximity\n   \
    \ planet1OrbitProximity = planet1OrbitProximity + planet1SunProximity\n    planet2OrbitProximity\
    \ = planet2OrbitProximity + planet2SunProximity\n    planet1OrbitProximity = planet1OrbitProximity\
    \ / 2\n    planet2OrbitProximity = planet2OrbitProximity / 2\n    planet1OrbitProximity\
    \ = planet1OrbitProximity * 2\n    planet2OrbitProximity = planet2OrbitProximity\
    \ * 2\n    planet1OrbitProximity = planet1OrbitProximity / 2\n    planet2OrbitProximity\
    \ = planet2OrbitProximity / 2\n    planet1OrbitProximity = planet1OrbitProximity\
    \ * 2\n    planet2OrbitProximity = planet2OrbitProximity * 2\n    planet1OrbitProximity\
    \ = planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkkssgv93_test.go:52:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdfx54ey1_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd8o6ec0s_test.go:76:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := orbit(planet1, planet2)\n    planet1OrbitSunProximity :=\
    \ distance(planet1OrbitSun, planet2OrbitSun)\n    planet2OrbitSunProximity :=\
    \ distance(planet2OrbitSun, planet1OrbitSun)\n    planet1OrbitSunProximityProximity\
    \ := distance(planet1OrbitSunProximity, planet2OrbitSunProximity)\n    planet2OrbitSunProximityProximity\
    \ := distance(planet2OrbitSunProximity, planet1OrbitSunProximity)\n    planet1OrbitSunProximityProximityProximity\
    \ := distance(planet1OrbitSunProximityProximity, planet2OrbitSunProximityProximity)\n\
    \    planet1OrbitSunProximityProximityProximityProximity := distance(planet1OrbitSunProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximity)\n    planet1OrbitSunProximityProximityProximityProximityProximity\
    \ := distance(planet1OrbitSunProximityProximityProximityProximity, planet2OrbitSunProximityProximityProximityProximity)\n\
    \    planet1OrbitSunProximityProximityProximityProximityProximityProximity :=\
    \ distance(planet1OrbitSunProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximityProximityProximity)\n    planet1OrbitSunProximityProximityProximityProximityProximityProximityProximity\
    \ := distance(planet1OrbitSunProximityProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximityProximityProximityProximityProximity)\n\
    \    planet1OrbitSunProximity\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_vphnn9c_test.go:32:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1, planet2, err := bf_test.ParsePlanets(planet1, planet2)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet1, planet2, err = bf_test.ParsePlanets(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1,\
    \ planet2, err = bf_test.ParsePlanets(planet1, planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1, planet2, err = bf_test.ParsePlanets(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1,\
    \ planet2, err = bf_test.ParsePlanets(planet1, planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1, planet2, err = bf_test.ParsePlanets(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1,\
    \ planet2, err = bf_test.ParsePlanets(planet1, planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1, planet2, err = bf_test.ParsePlanets(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1,\
    \ planet2, err = bf_test.ParsePlanets(planet1, planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1, planet2, err = bf_test.ParsePlanets(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1,\
    \ planet2, err = bf_test.ParsePlanets(planet1, planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1, planet2, err = bf_test.ParsePlanets(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1,\
    \ planet2, err = bf_test.ParsePlanets(planet1, planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet1, planet2, err = bf_test.ParsePlanets(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1,\
    \ planet2, err = bf_test.ParsePlanets(plan\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp1heeuvu_test.go:76:54: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance\
    \ := planet2Sun.Distance(planet2Orbit)\n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *=\
    \ planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n   \
    \ planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n   \
    \ planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    planet1OrbitDistance *= planet1OrbitDistance\n   \
    \ planet2OrbitDistance *= planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance *=\
    \ planet1OrbitDistance\n    planet2OrbitDistance *= \nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpukvyuddh_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" || planet2 == \"\" {\n        return []interface{}\n\
    \    }\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, \nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb_v0d521_test.go:21:16: expected expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp51uqbc9g_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd8o6ec0s_test.go:76:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Proximity, planet2Proximity, sunProximity := getProximity(planet1Orbit,\
    \ planet2Orbit, sunOrbit)\n    \n    planet1Proximity, planet2Proximity, sunProximity\
    \ = sortProximity(planet1Proximity, planet2Proximity, sunProximity)\n    \n  \
    \  planet1Proximity, planet2Proximity, sunProximity = removeDuplicates(planet1Proximity,\
    \ planet2Proximity, sunProximity)\n    \n    return planet1Proximity, planet2Proximity,\
    \ sunProximity\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyapgtxer_test.go:21:45: undefined: getOrbits

    /tmp/tmpyapgtxer_test.go:23:57: undefined: getProximity

    /tmp/tmpyapgtxer_test.go:25:56: undefined: sortProximity

    /tmp/tmpyapgtxer_test.go:27:56: undefined: removeDuplicates

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074543
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun.DistanceTo(planet2OrbitSun)\n    planet1OrbitSun.DistanceTo(planet2Orbit)\n\
    \    planet1Orbit.DistanceTo(planet2Orbit)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    planet1Orbit.DistanceTo(planet2OrbitSun)\n\
    \    planet1Orbit.DistanceTo(planet2OrbitSun)\n    plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjy8kz9hv_test.go:49:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\n    planet1OrbitSunDistance := planet1\n    planet2OrbitSunDistance\
    \ := planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8qk830d2_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwm3q45ym_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := getOrbit(planet1)\n    planet2Orbit\
    \ := getOrbit(planet2)\n    \n    planet1OrbitSun := getOrbitSun(planet1)\n  \
    \  planet2OrbitSun := getOrbitSun(planet2)\n    \n    planet1Sun := getOrbitSun(planet1)\n\
    \    planet2Sun := getOrbitSun(planet2)\n    \n    planet1SunDistance := getDistance(planet1Sun,\
    \ planet1OrbitSun)\n    planet2SunDistance := getDistance(planet2Sun, planet2OrbitSun)\n\
    \    \n    planet1OrbitSunDistance := getDistance(planet1OrbitSun, planet1Orbit)\n\
    \    planet2OrbitSunDistance := getDistance(planet2OrbitSun, planet2Orbit)\n \
    \   \n    planet1OrbitSunDistance := getDistance(planet1OrbitSun, planet1Orbit)\n\
    \    planet2OrbitSunDistance := getDistance(planet2OrbitSun, planet2Orbit)\n \
    \   \n    planet1OrbitSunDistance := getDistance(planet1OrbitSun, planet1Orbit)\n\
    \    planet2OrbitSunDistance := getDistance(planet2OrbitSun, planet2Orbit)\n \
    \   \n    planet1OrbitSunDistance := getDistance(planet1OrbitSun, planet1Orbit)\n\
    \    planet2OrbitSunDistance := getDistance(planet2OrbitSun, planet2Orbit)\n \
    \   \n    planet1OrbitSunDistance := getDistance(planet1OrbitSun, planet1Orbit)\n\
    \    planet2OrbitSunDistance := getDistance(planet2OrbitSun, planet2Orbit)\n \
    \   \n    planet1OrbitSunDistance := getDistance(planet1OrbitSun, planet1Orbit)\n\
    \    planet2OrbitSunDistance := getDistance(planet2OrbitSun, planet2Orbit)\n \
    \   \n    planet1OrbitSunDistance := getDistance(planet1Or\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpik_wx677_test.go:52:53: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n    planet1OrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw5r1k71l_test.go:44:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpia8of3pa_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err :=\
    \ getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Proximity, err := getProximity(planet1Orbit, planet1Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity, err\
    \ := getProximity(planet2Orbit, planet2Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1ProximitySorted, err := sortByProximity(planet1Proximity)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2ProximitySorted,\
    \ err := sortByProximity(planet2Proximity)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    return planet1ProximitySorted\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpohzz38ti_test.go:19:26: undefined: getOrbit

    /tmp/tmpohzz38ti_test.go:23:26: undefined: getOrbit

    /tmp/tmpohzz38ti_test.go:27:24: undefined: getSun

    /tmp/tmpohzz38ti_test.go:31:24: undefined: getSun

    /tmp/tmpohzz38ti_test.go:35:30: undefined: getProximity

    /tmp/tmpohzz38ti_test.go:39:30: undefined: getProximity

    /tmp/tmpohzz38ti_test.go:43:36: undefined: sortByProximity

    /tmp/tmpohzz38ti_test.go:47:36: undefined: sortByProximity

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074543
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSunProximity, planet2OrbitSunProximity := proximity(planet1OrbitSun,\
    \ planet2OrbitSun)\n    planet1OrbitSunProximityProximity, planet2OrbitSunProximityProximity\
    \ := proximity(planet1OrbitSunProximity, planet2OrbitSunProximity)\n    planet1OrbitSunProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximity := proximity(planet1OrbitSunProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximity)\n    planet1OrbitSunProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximityProximityProximity := proximity(planet1OrbitSunProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximityProximityProximity)\n    planet1OrbitSunProximityProximityProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximityProximityProximityProximityProximity\
    \ := proximity(planet1OrbitSunProximityProximityProximityProximityProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximityProximityProximityProximityProximityProximity)\n\
    \    planet1OrbitSunProximityProximityProximityProximityProximityProximityProximityProximityProximityProximity,\
    \ planet2OrbitSunProximityProximityProximityProximityProximityProximityProximityProximityProximityProx\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4sfh6zfl_test.go:26:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1OrbitSun := planet1Orbit - planet1Sun\n    planet2OrbitSun\
    \ := planet2Orbit - planet2Sun\n    \n    planet1SunSun := planet1Sun - planet2Sun\n\
    \    planet2SunSun := planet2Sun - planet1Sun\n    \n    planet1SunSunSun := planet1SunSun\
    \ - planet2SunSun\n    planet2SunSunSun := planet2SunSun - planet1SunSun\n   \
    \ \n    planet1SunSunSunSun := planet1SunSunSun - planet2SunSunSun\n    planet2SunSunSunSun\
    \ := planet2SunSunSun - planet1SunSunSunSun\n    \n    planet1SunSunSunSunSun\
    \ := planet1SunSunSunSun - planet2SunSunSunSun\n    planet2SunSunSunSunSun :=\
    \ planet2SunSunSunSun - planet1SunSunSunSunSun\n    \n    planet1SunSunSunSunSunSun\
    \ := planet1SunSunSunSunSun - planet2SunSunSunSunSun\n    planet2SunSunSunSunSunSun\
    \ := planet2SunSunSunSunSun - planet1SunSunSunSunSunSun\n    \n    planet1SunSunSunSunSunSunSun\
    \ := planet1SunSunSunSunSunSun - planet2SunSunSunSunSunSun\n    planet2SunSunSunSunSunSunSun\
    \ := planet2SunSunSunSunSunSun - planet1SunSunSunSunSunSunSun\n    \n    planet1SunSunSunSunSunSunSunSun\
    \ := \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp30jcp0zd_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpia8of3pa_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := orbit(planet1,\
    \ planet2)\n    planet1OrbitSunProximity := planet1OrbitSun - planet2OrbitSun\n\
    \    planet2OrbitSunProximity := planet2OrbitSun - planet1OrbitSun\n    planet1OrbitSunProximityProximity\
    \ := planet1OrbitSunProximity / planet2OrbitSunProximity\n    planet2OrbitSunProximityProximity\
    \ := planet2OrbitSunProximity / planet1OrbitSunProximity\n    planet1OrbitSunProximityProximityProximity\
    \ := planet1OrbitSunProximityProximity * planet2OrbitSunProximityProximity\n \
    \   planet2OrbitSunProximityProximityProximity := planet2OrbitSunProximityProximity\
    \ * planet1OrbitSunProximityProximity\n    planet1OrbitSunProximityProximityProximityProximity\
    \ := planet1OrbitSunProximityProximityProximity * planet2OrbitSunProximityProximityProximity\n\
    \    planet2OrbitSunProximityProximityProximityProximityProximity := planet2OrbitSunProximityProximityProximityProximity\
    \ * planet1OrbitSunProximityProximityProximityProximity\n    planet1OrbitSunProximityProximityProximityProximityProximityProximity\
    \ := planet1OrbitSunProximityProximityProximityProximityProximity * planet2OrbitSunProximityProximityProximityProximityProximity\n\
    \    planet2OrbitSunProximityProximityProximityProximityProximityProximityProximity\
    \ := planet2OrbitSunProximityProximityProximityProximityProximityProximityProxim\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq_xl7t5v_test.go:34:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunProximity, err := getProximity(planet1, planet1Orbit,\
    \ planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunProximity,\
    \ err := getProximity(planet2, planet2Orbit, planet2Sun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getProximity(planet1,\
    \ planet1Orbit, planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Proximity, err := getProximity(planet2, planet2Orbit, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Proximity,\
    \ err := getProximity(planet1, planet1Orbit, planet2Orbit)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet2Proximity, err := getProximity(planet2,\
    \ planet2Orbit, planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Proximity, err := getProximity(planet1, planet1Orbit,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Proximity,\
    \ err := getProximity(planet2, planet2Orbit, planet1Orbit)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getProx\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn5qvdr7v_test.go:77:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074543
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfdfyvy_3_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n    planet1,\
    \ planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1, planet2 = planet1.ToTitle(),\
    \ planet2.ToTitle()\n    planet1, planet2 = planet1.ToCamelCase(), planet2.ToCamelCase()\n\
    \    planet1, planet2 = planet1.ToSnakeCase(), planet2.ToSnakeCase()\n    planet1,\
    \ planet2 = planet1.ToPascalCase(), planet2.ToPascalCase()\n    planet1, planet2\
    \ = planet1.ToSentenceCase(), planet2.ToSentenceCase()\n    planet1, planet2 =\
    \ planet1.ToTitleCase(), planet2.ToTitleCase()\n    planet1, planet2 = planet1.ToSnakeTitleCase(),\
    \ planet2.ToSnakeTitleCase()\n    planet1, planet2 = planet1.ToPascalTitleCase(),\
    \ planet2.ToPascalTitleCase()\n    planet1, planet2 = planet1.ToSentenceTitleCase(),\
    \ planet2.ToSentenceTitleCase()\n    planet1, planet2 = planet1.ToTitleSnakeCase(),\
    \ planet2.ToTitleSnakeCase()\n    planet1, planet2 = planet1.ToTitlePascalCase(),\
    \ planet2.ToTitlePascalCase()\n    planet1, planet2 = planet1.ToTitleSentenceCase(),\
    \ planet2.ToTitleSentenceCase()\n    planet1, planet2 = planet1.ToTitleTitleCase(),\
    \ planet2.ToTitleTitleCase()\n    planet1, planet2 = planet1.ToTitleSnakeTitleCase(),\
    \ planet2.ToTitleSnakeTitleCase()\n    planet1, planet2 = planet1.ToTitlePascalTitleCase(),\
    \ planet2.ToTitlePascalTitleCase()\n    planet1, planet2 = planet1.ToTitleSentenceTitleCase(),\
    \ planet2.ToTitleSentenceTitleCase()\n    planet1, planet2 = planet1.ToTitleTitleSnakeCase(),\
    \ planet2.ToTitleTitleSnakeCase()\n    planet1, planet2 = planet1.ToTitleTitlePascalCase(),\
    \ planet2.ToTitleTitlePascalCase()\n    planet1, planet\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdjmeq97t_test.go:40:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074543
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    // your code here\n    \n    return []interface{}{}\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmphb_6oc8o_test.go:45: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmphb_6oc8o_test.go:45: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmphb_6oc8o_test.go:45:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmphb_6oc8o_test.go:45: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n    \n  \
    \  planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp36iyd4wl_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit, planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    \n    planet1Sun, planet2Sun := getSun(planet1,\
    \ planet2)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1Sun,\
    \ planet2Sun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1OrbitSun,\
    \ planet2OrbitSun)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps8yc6qfx_test.go:47:60: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074543
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" || planet2 == \"\" {\n        return []\n  \
    \  }\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOr\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf23qnc9w_test.go:21:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074543
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet2Orbit,\
    \ err := getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    \n    planet2Sun, err := getPlanetOrbit(\"\
    Sun\")\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunProximity,\
    \ err := getPlanetProximity(planet1Sun, planet1Orbit)\n    if err != nil {\n \
    \       fmt.Println(err)\n    }\n    \n    planet2SunProximity, err := getPlanetProximity(planet2Sun,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n\
    \    planet1Proximity, err := getPlanetProximity(planet1Orbit, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet2Proximity,\
    \ err := getPlanetProximity(planet2Orbit, planet2Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n\
    \    planet2Proximity, err := getPlanetProximity(planet2Orbit, planet2Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Proximity,\
    \ err := getPlanetProximity(planet1Orbit, planet1Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet2Proximity, err := getPlanetProximity(planet2Orbit,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph_zgr9i9_test.go:83:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074543
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgfz0v6_s_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit, err :=\
    \ getPlanetOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    planet2Orbit, err := getPlanetOrbit(planet2)\n    if err != nil {\n \
    \       fmt.Println(err)\n    }\n    \n    planet1OrbitSun, err := getPlanetOrbitSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err\
    \ := getPlanetOrbitSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1OrbitSunProximity := getPlanetOrbitSunProximity(planet1OrbitSun,\
    \ planet2OrbitSun)\n    planet2OrbitSunProximity := getPlanetOrbitSunProximity(planet2OrbitSun,\
    \ planet1OrbitSun)\n    \n    planet1OrbitSunProximitySorted := getPlanetOrbitSunProximitySorted(planet1OrbitSunProximity)\n\
    \    planet2OrbitSunProximitySorted := getPlanetOrbitSunProximitySorted(planet2OrbitSunProximity)\n\
    \    \n    planet1OrbitSunProximitySortedSorted := getPlanetOrbitSunProximitySortedSorted(planet1OrbitSunProximitySorted)\n\
    \    planet2OrbitSunProximitySortedSorted := getPlanetOrbitSunProximitySortedSorted(planet2OrbitSunProximitySorted)\n\
    \    \n    planet1OrbitSunProximitySortedSortedSorted := getPlanetOrbitSunProximitySortedSortedSorted(planet1OrbitSunProximitySortedSorted)\n\
    \    planet2OrbitSunProximitySortedSortedSorted := getPlanetOrbitSunProximitySortedSortedSorted(planet2OrbitSunProximitySortedSorted)\n\
    \    \n    planet1OrbitSunProximitySortedSortedSortedSorted := getPlanetOrbitSunProximitySortedSortedSortedSorted(planet1OrbitSunProximitySortedSortedSorted)\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy3ute4el_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074543
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdvmkx9el_test.go:20:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp51uqbc9g_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1, planet2)\n    planet1SunProximity := getSunProximity(planet1Orbit,\
    \ planet1Sun)\n    planet2SunProximity := getSunProximity(planet2Orbit, planet2Sun)\n\
    \    planet1Proximity, planet2Proximity := getProximity(planet1Orbit, planet2Orbit)\n\
    \    planet1ProximityProximity := getProximityProximity(planet1Proximity, planet1Orbit,\
    \ planet1SunProximity)\n    planet2ProximityProximity := getProximityProximity(planet2Proximity,\
    \ planet2Orbit, planet2SunProximity)\n    planet1ProximityProximityProximity :=\
    \ getProximityProximityProximity(planet1ProximityProximity, planet1Orbit, planet1SunProximity,\
    \ planet2SunProximity)\n    planet2ProximityProximityProximity := getProximityProximityProximity(planet2ProximityProximity,\
    \ planet2Orbit, planet2SunProximity, planet1SunProximity)\n    planet1ProximityProximityProximityProximity\
    \ := getProximityProximityProximityProximity(planet1ProximityProximityProximity,\
    \ planet1Orbit, planet1SunProximity, planet2SunProximity, planet2ProximityProximity)\n\
    \    planet2ProximityProximityProximityProximity := getProximityProximityProximityProximity(planet2ProximityProximityProximity,\
    \ planet2Orbit, planet2SunProximity, planet1SunProximity, planet1ProximityProximity)\n\
    \    planet1ProximityProximityProximityProximityProximity := getProx\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7v5lkqjk_test.go:32:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgfz0v6_s_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    \n    planet1Sun, planet2Sun := getOrbits(planet1, planet2)\n    \n    planet1SunOrbit,\
    \ planet2SunOrbit := getOrbits(planet1, planet2)\n    \n    planet1SunOrbitSun,\
    \ planet2SunOrbitSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunSun,\
    \ planet2OrbitSunSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunOrbitSun,\
    \ planet2OrbitSunOrbitSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunOrbitSunSun,\
    \ planet2OrbitSunOrbitSunSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunOrbitSunOrbitSun,\
    \ planet2OrbitSunOrbitSunSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunOrbitSunOrbitSunSun,\
    \ planet2OrbitSunOrbitSunSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunOrbitSunOrbitSunSun,\
    \ planet2OrbitSunOrbitSunSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunOrbitSunOrbitSunSun,\
    \ planet2OrbitSunOrbitSunSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunOrbitSunOrbitSunSun,\
    \ planet2OrbitSunOrbitSunSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunOrbitSunOrbitSunSun,\
    \ planet2OrbitSunOrbitSunSun := getOrbits(planet1, planet2)\n    \n    planet1OrbitSunOrbitSunOr\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz4k0bp_e_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1OrbitSun := planet1Orbit - planet1Sun\n    planet2OrbitSun\
    \ := planet2Orbit - planet2Sun\n    \n    planet1OrbitSun /= 3600000\n    planet2OrbitSun\
    \ /= 3600000\n    \n    planet1OrbitSun /= 3600000\n    planet2OrbitSun /= 3600000\n\
    \    \n    planet1OrbitSun /= 3600000\n    planet2OrbitSun /= 3600000\n    \n\
    \    planet1OrbitSun /= 3600000\n    planet2OrbitSun /= 3600000\n    \n    planet1OrbitSun\
    \ /= 3600000\n    planet2OrbitSun /= 3600000\n    \n    planet1OrbitSun /= 3600000\n\
    \    planet2OrbitSun /= 3600000\n    \n    planet1OrbitSun /= 3600000\n    planet2OrbitSun\
    \ /= 3600000\n    \n    planet1OrbitSun /= 3600000\n    planet2OrbitSun /= 3600000\n\
    \    \n    planet1OrbitSun /= 3600000\n    planet2OrbitSun /= 3600000\n    \n\
    \    planet1OrbitSun /= 3600000\n    planet2OrbitSun /= 3600000\n    \n    planet1OrbitSun\
    \ /= 3600000\n    planet2OrbitSun /= 3600000\n    \n    planet1OrbitSun /= 3600000\n\
    \    planet2OrbitSun /= 3600000\n    \n    planet1OrbitSun /= 3600000\n    planet2OrbitSun\
    \ /= 3600000\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzbi1ind0_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8i0tg_rf_test.go:77:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074539
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit\
    \ := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n   \
    \ planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqrq6j1tb_test.go:47:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.insert(planet2Orbit)\n    planet2Orbit.insert(planet1Orbit)\n\
    \    \n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpal8ewjhs_test.go:19:35: undefined: getOrbits

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplq9lec35_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    return []interface{}{planet1, planet2}\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp5umchme3_test.go:43: expected '[Saturn Uranus]', got '[Jupiter Neptune]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp5umchme3_test.go:43: expected\
    \ '[Venus]', got '[Earth Mercury]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n\
    \        tmp5umchme3_test.go:43: expected '[Venus Earth Mars Jupiter Saturn]',\
    \ got '[Mercury Uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp5umchme3_test.go:43:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Neptune Venus]'\n    ---\
    \ FAIL: TestBf/test_num__4 (0.00s)\n        tmp5umchme3_test.go:43: expected '[]',\
    \ got '[Earth Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmp5umchme3_test.go:43:\
    \ expected '[]', got '[Mars Earth]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmp5umchme3_test.go:43: expected '[]', got '[Jupiter Makemake]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcuv2_6cr_test.go:43: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcuv2_6cr_test.go:43: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcuv2_6cr_test.go:43:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcuv2_6cr_test.go:43: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun.sort()\n\
    \    planet2OrbitSun.sort()\n    planet1OrbitSun.push(planet1Orbit)\n    planet2OrbitSun.push(planet2Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2OrbitSun.push(planet1Orbit)\n\
    \    planet1OrbitSun.push(planet2Orbit)\n    planet2\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv01bsis3_test.go:52:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcuv2_6cr_test.go:43: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcuv2_6cr_test.go:43: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcuv2_6cr_test.go:43:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcuv2_6cr_test.go:43: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpia8of3pa_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1,\
    \ planet2)\n    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfdfyvy_3_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 :=\
    \ planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwm3q45ym_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgfz0v6_s_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    planet1Sun, err := getSun()\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet2Sun, err := getSun()\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet1SunProximity, err\
    \ := getSunProximity(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2SunProximity, err := getSunProximity(planet2Orbit, planet2Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Proximity, err\
    \ := getProximity(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Proximity, err := getProximity(planet2Orbit, planet2Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Proximity, err\
    \ := getProximity(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Proximity, err := getProximity(planet2Orbit, planet2Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Proximity, err\
    \ := getProximity(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Proximity, err := getProximity(planet2Orbit, planet2Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Proximity, err\
    \ := getProximity(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Proximity, err := getProximity(planet2Orbit, planet2Sun)\n\
    \    if err != nil {\n        f\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8s2f70dz_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n    planet1,\
    \ planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdfx54ey1_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpwbbv4m5a_test.go:43: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpwbbv4m5a_test.go:43: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpwbbv4m5a_test.go:43:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpwbbv4m5a_test.go:43: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074542
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    return []interface{}{planet1, planet2}\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp5umchme3_test.go:43: expected '[Saturn Uranus]', got '[Jupiter Neptune]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp5umchme3_test.go:43: expected\
    \ '[Venus]', got '[Earth Mercury]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n\
    \        tmp5umchme3_test.go:43: expected '[Venus Earth Mars Jupiter Saturn]',\
    \ got '[Mercury Uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp5umchme3_test.go:43:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Neptune Venus]'\n    ---\
    \ FAIL: TestBf/test_num__4 (0.00s)\n        tmp5umchme3_test.go:43: expected '[]',\
    \ got '[Earth Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmp5umchme3_test.go:43:\
    \ expected '[]', got '[Mars Earth]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmp5umchme3_test.go:43: expected '[]', got '[Jupiter Makemake]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" {\n        return []\n    }\n    if planet2\
    \ == \"\" {\n        return []\n    }\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm10ps866_test.go:21:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" || planet2 == \"\" {\n        return []\n  \
    \  }\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpauzamezv_test.go:21:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 != planet2 {\n        return nil\n    }\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1,\
    \ planet2 = planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwkef1qn8_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1, planet2)\n    planet1SunProximity := getSunProximity(planet1Orbit,\
    \ planet1Sun)\n    planet2SunProximity := getSunProximity(planet2Orbit, planet2Sun)\n\
    \    planet1Proximity := getProximity(planet1Orbit, planet1Sun)\n    planet2Proximity\
    \ := getProximity(planet2Orbit, planet2Sun)\n    planet1OrbitProximity := getProximity(planet1Orbit,\
    \ planet1Orbit)\n    planet2OrbitProximity := getProximity(planet2Orbit, planet2Orbit)\n\
    \    planet1OrbitProximityProximity := getProximity(planet1OrbitProximity, planet1OrbitProximity)\n\
    \    planet2OrbitProximityProximity := getProximity(planet2OrbitProximity, planet2OrbitProximity)\n\
    \    planet1ProximityProximityProximity := getProximity(planet1ProximityProximity,\
    \ planet1ProximityProximity)\n    planet2ProximityProximityProximity := getProximity(planet2ProximityProximity,\
    \ planet2ProximityProximity)\n    planet1OrbitProximityProximityProximity := getProximity(planet1OrbitProximityProximityProximity,\
    \ planet1OrbitProximityProximity)\n    planet2OrbitProximityProximityProximity\
    \ := getProximity(planet2OrbitProximityProximityProximity, planet2OrbitProximityProximity)\n\
    \    planet1OrbitProximityProximityProximityProximity := getProximity(planet1OrbitProximityProximityProximityProximity,\
    \ planet1OrbitProxim\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplz2iw9ke_test.go:34:138: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_p1jox98_test.go:57:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1, planet2\n\
    \    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_p1jox98_test.go:57:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1OrbitSun, err := getOrbitSun(planet1)\n    if err != nil {\n \
    \       fmt.Println(err)\n    }\n    planet2OrbitSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Sun, err\
    \ := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n\
    \    planet1SunOrbit, err := getOrbitSun(planet1)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    planet2SunOrbit, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunOrbitSun,\
    \ err := getOrbitSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2SunOrbitSun, err := getOrbitSun(planet2)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    \n    planet1SunSun, err := getSun()\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunSun, err\
    \ := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n  \
    \  planet1SunOrbitSunSun, err := getOrbitSun(planet1)\n    if err != nil {\n \
    \       fmt.Println(err)\n    }\n    planet2SunOrbitSunSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunOrbitSunSun,\
    \ err := getOrbitSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2SunOrbitSunSun, err := getOrbitSun(planet2)\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplcb7nk4g_test.go:90:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    planet1 := planet1[:len(planet1)-1]\n    planet2 := planet2[:len(planet2)-1]\n\
    \    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2az_ulmy_test.go:55:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius\
    \ := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n\
    \    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius\
    \ := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n\
    \    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius\
    \ := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n\
    \    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius\
    \ := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n\
    \    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius\
    \ := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n\
    \    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius\
    \ := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n\
    \    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius\
    \ := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n\
    \    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp10uhq1y4_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1Sun, planet2Sun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1Orbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoigyozsj_test.go:39:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpia8of3pa_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    if planet1 == planet2 {\n        return nil\n\
    \    }\n    \n    planet1Orbit, planet2Orbit := orbit(planet1, planet2)\n    \n\
    \    if planet1Orbit == nil || planet2Orbit == nil {\n        return nil\n   \
    \ }\n    \n    planet1OrbitSun, planet2OrbitSun := sun(planet1Orbit), sun(planet2Orbit)\n\
    \    \n    if planet1OrbitSun == nil || planet2OrbitSun == nil {\n        return\
    \ nil\n    }\n    \n    planet1SunOrbit, planet2SunOrbit := planet1OrbitSun, planet2OrbitSun\n\
    \    \n    planet1SunOrbitSun := planet1OrbitSun\n    \n    planet1OrbitSun :=\
    \ planet1OrbitSun\n    \n    planet1OrbitSun := planet1OrbitSun\n    \n    planet1OrbitSun\
    \ := planet1OrbitSun\n    \n    planet1OrbitSun := planet1OrbitSun\n    \n   \
    \ planet1OrbitSun := planet1OrbitSun\n    \n    planet1OrbitSun := planet1OrbitSun\n\
    \    \n    planet1OrbitSun := planet1OrbitSun\n    \n    planet1OrbitSun := planet1OrbitSun\n\
    \    \n    planet1OrbitSun := planet1OrbitSun\n    \n    planet1OrbitSun := planet1OrbitSun\n\
    \    \n    planet1OrbitSun := planet1OrbitSun\n    \n    planet1OrbitSun := planet1OrbitSun\n\
    \    \n    planet1OrbitSun := planet1OrbitSun\n    \n    planet1OrbitSun := planet1OrbitSun\n\
    \    \n    planet1OrbitSun := planet1OrbitSun\n    \n    planet1OrbitSun := planet1OrbitSun\n\
    \    \n    planet1OrbitSun := planet1OrbitSun\n    \n    planet1OrbitSun := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi46m1e8z_test.go:77:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n  \
    \  planet2SunDistance := planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1OrbitDistance\n    planet2SunDistance\
    \ += planet2OrbitDistance\n    \n    planet1SunDistance /= 2\n    planet2SunDistance\
    \ /= 2\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n \
    \   \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance\
    \ /= 2\n    planet2OrbitDistance /= 2\n    \n    planet1OrbitDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2OrbitDistance += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ /= 2\n    planet2OrbitDistance /= 2\n    \n    planet1OrbitDistance += planet1SunDistance\n\
    \    planet2OrbitDistance += planet\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3i8qrl02_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    if planet1 == planet2 {\n        return nil\n    }\n    \n\
    \    planet1Orbit, planet2Orbit, sunOrbit, planet1OrbitSun, planet2OrbitSun, sunOrbitSun\
    \ := getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ sunOrbitSun = getOrbits(planet1, planet2)\n    \n    planet1OrbitSun, planet2OrbitSun,\
    \ \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpngp0x0s9_test.go:53:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance,\
    \ err := getDistance(planet1Sun, planet1Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2SunDistance, err := getDistance(planet2Sun, planet2Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitDistance,\
    \ err := getDistance(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitDistance, err := getDistance(planet2Orbit, planet2Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitDistanceSquare\
    \ := planet1OrbitDistance * planet1OrbitDistance\n    planet2OrbitDistanceSquare\
    \ := planet2OrbitDistance * planet2OrbitDistance\n    \n    planet1SunDistanceSquare\
    \ := planet1SunDistance * planet1SunDistance\n    planet2SunDistanceSquare :=\
    \ planet2SunDistance * planet2SunDistance\n    \n    planet1SunDistanceSquare\
    \ += planet1OrbitDistanceSquare\n    planet2SunDistanceSquare += planet2OrbitDistanceSquare\n\
    \    \n    planet1SunDistanceSquare /= 2\n    planet2SunDistanceSquare /= 2\n\
    \    \n    planet1SunDistanceSquare += planet1OrbitDistanceSquare\n    planet2SunDistanceSquare\
    \ += planet2OrbitDistanceSquare\n    \n    planet1SunDistanceSquare /= 2\n   \
    \ planet2SunDistanceSqu\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8bbm97gm_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius\
    \ := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n\
    \    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius\
    \ := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n\
    \    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius\
    \ := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n\
    \    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius\
    \ := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n\
    \    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius\
    \ := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n\
    \    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius\
    \ := planet1\n    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n\
    \    planet2OrbitRadius := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius\
    \ := planet2\n    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\n\
    \    planet1OrbitRadius := planet1\n    planet2OrbitRadius := planet2\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp10uhq1y4_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    // Your code here\n    \n    return []interface{}{planet1,\
    \ planet2}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpd8xr6zc7_test.go:45: expected '[Saturn Uranus]', got '[Jupiter Neptune]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpd8xr6zc7_test.go:45: expected\
    \ '[Venus]', got '[Earth Mercury]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n\
    \        tmpd8xr6zc7_test.go:45: expected '[Venus Earth Mars Jupiter Saturn]',\
    \ got '[Mercury Uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpd8xr6zc7_test.go:45:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Neptune Venus]'\n    ---\
    \ FAIL: TestBf/test_num__4 (0.00s)\n        tmpd8xr6zc7_test.go:45: expected '[]',\
    \ got '[Earth Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpd8xr6zc7_test.go:45:\
    \ expected '[]', got '[Mars Earth]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmpd8xr6zc7_test.go:45: expected '[]', got '[Jupiter Makemake]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit\
    \ := planet1\n    planet2Orbit := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_rzhm775_test.go:77:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1Sun, planet2Sun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1Orbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoigyozsj_test.go:39:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    \n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpefwaan7r_test.go:44: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpefwaan7r_test.go:44: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpefwaan7r_test.go:44:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpefwaan7r_test.go:44: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1 + \"Orbit\"\n    planet2Orbit\
    \ := planet2 + \"Orbit\"\n    \n    planet1Sun := planet1 + \"Sun\"\n    planet2Sun\
    \ := planet2 + \"Sun\"\n    \n    planet1OrbitSun := planet1Orbit + \"Sun\"\n\
    \    planet2OrbitSun := planet2Orbit + \"Sun\"\n    \n    planet1OrbitMercury\
    \ := planet1Orbit + \"Mercury\"\n    planet2OrbitMercury := planet2Orbit + \"\
    Mercury\"\n    \n    planet1OrbitVenus := planet1Orbit + \"Venus\"\n    planet2OrbitVenus\
    \ := planet2Orbit + \"Venus\"\n    \n    planet1OrbitEarth := planet1Orbit + \"\
    Earth\"\n    planet2OrbitEarth := planet2Orbit + \"Earth\"\n    \n    planet1OrbitMars\
    \ := planet1Orbit + \"Mars\"\n    planet2OrbitMars := planet2Orbit + \"Mars\"\n\
    \    \n    planet1OrbitJupiter := planet1Orbit + \"Jupiter\"\n    planet2OrbitJupiter\
    \ := planet2Orbit + \"Jupiter\"\n    \n    planet1OrbitSaturn := planet1Orbit\
    \ + \"Saturn\"\n    planet2OrbitSaturn := planet2Orbit + \"Saturn\"\n    \n  \
    \  planet1OrbitUranus := planet1Orbit + \"Uranus\"\n    planet2OrbitUranus :=\
    \ planet2Orbit + \"Uranus\"\n    \n    planet1OrbitNeptune := planet1Orbit + \"\
    Neptune\"\n    planet2OrbitNeptune := planet2Orbit + \"Neptune\"\n    \n    planet1OrbitMercurySun\
    \ := planet1OrbitMercury + \"Sun\"\n    planet2OrbitMercurySun := planet2OrbitMercury\
    \ + \"Sun\"\n    \n    planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuy3io87_test.go:59:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun\
    \ := planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n\
    \    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun\
    \ := planet1\n    planet2OrbitSun := planet2\n    \n    planet1OrbitSun := planet1\n\
    \    planet2OrbitSun\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplq9lec35_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit, err := getOrbits(planet1, planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Orbit,\
    \ planet2Orbit, err = getOrbits(planet2, planet1)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    \n    planet1Orbit, planet2Orbit, err = getOrbits(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Orbit,\
    \ planet2Orbit, err = getOrbits(planet2, planet1)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    \n    planet1Orbit, planet2Orbit, err = getOrbits(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Orbit,\
    \ planet2Orbit, err = getOrbits(planet2, planet1)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    \n    planet1Orbit, planet2Orbit, err = getOrbits(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Orbit,\
    \ planet2Orbit, err = getOrbits(planet2, planet1)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    \n    planet1Orbit, planet2Orbit, err = getOrbits(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Orbit,\
    \ planet2Orbit, err = getOrbits(planet2, planet1)\n    if err != nil {\n     \
    \   fmt.Println(err)\n    }\n    \n    planet1Orbit, planet2Orbit, err = getOrbits(planet1,\
    \ planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Orbit,\
    \ planet2Orbit, err = getOrbits(planet2, planet1)\n    if err\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmwdz5m51_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    planet1Orbit.insert(planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwup3iljx_test.go:19:35: undefined: getOrbits

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074540
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := \"Mercury\"\n    planet2 := \"Venus\"\n    planet1 := \"Earth\"\
    \n    planet2 := \"Mars\"\n    planet1 := \"Jupiter\"\n    planet2 := \"Saturn\"\
    \n    planet1 := \"Uranus\"\n    planet2 := \"Neptune\"\n    planet1 := \"Mercury\"\
    \n    planet2 := \"Venus\"\n    planet1 := \"Earth\"\n    planet2 := \"Mars\"\n\
    \    planet1 := \"Jupiter\"\n    planet2 := \"Saturn\"\n    planet1 := \"Uranus\"\
    \n    planet2 := \"Neptune\"\n    planet1 := \"Mercury\"\n    planet2 := \"Venus\"\
    \n    planet1 := \"Earth\"\n    planet2 := \"Mars\"\n    planet1 := \"Jupiter\"\
    \n    planet2 := \"Saturn\"\n    planet1 := \"Uranus\"\n    planet2 := \"Neptune\"\
    \n    planet1 := \"Mercury\"\n    planet2 := \"Venus\"\n    planet1 := \"Earth\"\
    \n    planet2 := \"Mars\"\n    planet1 := \"Jupiter\"\n    planet2 := \"Saturn\"\
    \n    planet1 := \"Uranus\"\n    planet2 := \"Neptune\"\n    planet1 := \"Mercury\"\
    \n    planet2 := \"Venus\"\n    planet1 := \"Earth\"\n    planet2 := \"Mars\"\n\
    \    planet1 := \"Jupiter\"\n    planet2 := \"Saturn\"\n    planet1 := \"Uranus\"\
    \n    planet2 := \"Neptune\"\n    planet1 := \"Mercury\"\n    planet2 := \"Venus\"\
    \n    planet1 := \"Earth\"\n    planet2 := \"Mars\"\n    planet1 := \"Jupiter\"\
    \n    planet2 := \"Saturn\"\n    planet1 := \"Uranus\"\n    planet2 := \"Neptune\"\
    \n    planet1 := \"Mercury\"\n    planet2 := \nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps0rii62j_test.go:70:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n\
    \    planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n \
    \   planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n  \
    \  planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n   \
    \ planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1,\
    \ planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2\
    \ = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2 =\
    \ planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2 = planet1[:len(planet1)-1],\
    \ planet2[:len(planet2)-1]\n    planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n\
    \    planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n \
    \   planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n  \
    \  planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n   \
    \ planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1,\
    \ planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2\
    \ = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2 =\
    \ planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2 = planet1[:len(planet1)-1],\
    \ planet2[:len(planet2)-1]\n    planet1, planet2 = planet1[:len(\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd1xu83fx_test.go:39:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpia8of3pa_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    for _, planet := range planet1Orbit\
    \ {\n        if planet == planet2 {\n            result = append(result, planet)\n\
    \        }\n    }\n    for _, planet := range planet2Orbit {\n        if planet\
    \ == planet1 {\n            result = append(result, planet)\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpctocaysg_test.go:19:35: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun :=\
    \ getOrbits(planet1, planet2)\n    planet1OrbitSun.sort()\n    planet2OrbitSun.sort()\n\
    \    planet1Sun.sort()\n    planet2Sun.sort()\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2OrbitSun.insert(len(planet2OrbitSun)-1)\n    planet1Sun.insert(len(planet1Sun)-1)\n\
    \    planet2Sun.insert(len(planet2Sun)-1)\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2OrbitSun.insert(len(planet2OrbitSun)-1)\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2OrbitSun.insert(len(planet2OrbitSun)-1)\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2OrbitSun.insert(len(planet2OrbitSun)-1)\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2OrbitSun.insert(len(planet2OrbitSun)-1)\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2OrbitSun.insert(len(planet2OrbitSun)-1)\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2OrbitSun.insert(len(planet2OrbitSun)-1)\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2OrbitSun.insert(len(planet2OrbitSun)-1)\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2OrbitSun.insert(len(planet2OrbitSun)-1)\n    planet1OrbitSun.insert(len(planet1OrbitSun)-1)\n\
    \    planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe3vy7xst_test.go:49:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := \"Mercury\"\n    planet2 := \"Venus\"\n    planet3 := \"Earth\"\
    \n    planet4 := \"Mars\"\n    planet5 := \"Jupiter\"\n    planet6 := \"Saturn\"\
    \n    planet7 := \"Uranus\"\n    planet8 := \"Neptune\"\n    planet1 := \"Mercury\"\
    \n    planet2 := \"Venus\"\n    planet3 := \"Earth\"\n    planet4 := \"Mars\"\n\
    \    planet5 := \"Jupiter\"\n    planet6 := \"Saturn\"\n    planet7 := \"Uranus\"\
    \n    planet8 := \"Neptune\"\n    planet1 := \"Mercury\"\n    planet2 := \"Venus\"\
    \n    planet3 := \"Earth\"\n    planet4 := \"Mars\"\n    planet5 := \"Jupiter\"\
    \n    planet6 := \"Saturn\"\n    planet7 := \"Uranus\"\n    planet8 := \"Neptune\"\
    \n    planet1 := \"Mercury\"\n    planet2 := \"Venus\"\n    planet3 := \"Earth\"\
    \n    planet4 := \"Mars\"\n    planet5 := \"Jupiter\"\n    planet6 := \"Saturn\"\
    \n    planet7 := \"Uranus\"\n    planet8 := \"Neptune\"\n    planet1 := \"Mercury\"\
    \n    planet2 := \"Venus\"\n    planet3 := \"Earth\"\n    planet4 := \"Mars\"\n\
    \    planet5 := \"Jupiter\"\n    planet6 := \"Saturn\"\n    planet7 := \"Uranus\"\
    \n    planet8 := \"Neptune\"\n    planet1 := \"Mercury\"\n    planet2 := \"Venus\"\
    \n    planet3 := \"Earth\"\n    planet4 := \"Mars\"\n    planet5 := \"Jupiter\"\
    \n    planet6 := \"Saturn\"\n    planet7 := \"Uranus\"\n    planet8 := \"Neptune\"\
    \n    planet1 := \"Mercury\"\n    planet2 := \nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpruunbxkk_test.go:70:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet2Orbit, err\
    \ := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunProximity, err := getSunProximity(planet1Orbit, planet1Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet2SunProximity,\
    \ err := getSunProximity(planet2Orbit, planet2Sun)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    \n    planet1Proximity, err := getProximity(planet1Orbit,\
    \ planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n  \
    \  planet2Proximity, err := getProximity(planet2Orbit, planet2Sun)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Proximity, err :=\
    \ getProximity(planet1Orbit, planet1Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet2Proximity, err := getProximity(planet2Orbit, planet2Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Proximity,\
    \ err := getProximity(planet1Orbit, planet1Sun)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    \n    planet2Proximity, err := getProximity(planet2Orbit,\
    \ planet2Sun)\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n  \
    \  planet1Proximity, err := getProximity(planet1Orbit, planet1Sun)\n    if err\
    \ != nil {\n        fmt.\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw16rhd0u_test.go:85:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    \n    planet1Orbit, planet2Orbit := getOrbits(planet1, planet2)\n\
    \    \n    planet1Sun, planet2Sun := getSun(planet1)\n    \n    planet1SunProximity\
    \ := getProximity(planet1Orbit, planet1Sun)\n    \n    planet2SunProximity :=\
    \ getProximity(planet2Orbit, planet2Sun)\n    \n    planet1Proximity := getProximity(planet1Orbit,\
    \ planet1Orbit)\n    \n    planet2Proximity := getProximity(planet2Orbit, planet2Orbit)\n\
    \    \n    planet1ProximityProximity := getProximity(planet1Proximity, planet1Proximity)\n\
    \    \n    planet2ProximityProximity := getProximity(planet2Proximity, planet2Proximity)\n\
    \    \n    planet1ProximityProximityProximity := getProximity(planet1ProximityProximity,\
    \ planet1ProximityProximity)\n    \n    planet2ProximityProximityProximity :=\
    \ getProximity(planet2ProximityProximity, planet2ProximityProximity)\n    \n \
    \   planet1ProximityProximityProximityProximity := getProximity(planet1ProximityProximityProximityProximity,\
    \ planet1ProximityProximityProximityProximity)\n    \n    planet2ProximityProximityProximityProximity\
    \ := getProximity(planet2ProximityProximityProximityProximity, planet2ProximityProximityProximityProximity)\n\
    \    \n    planet1ProximityProximityProximityProximityProximity := getProximity(planet1ProximityProximityProximityProximityProximityProximity,\
    \ planet1ProximityProximityProximityProximityProximityProximity)\n    \n    \n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpppqbxcph_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    if planet1 == \"\" || planet2 == \"\" {\n        return []\n  \
    \  }\n    \n    planet1Orbit, planet2Orbit, sunOrbit := getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOrbit = getOrbits(planet1, planet2)\n\
    \    \n    planet1Orbit, planet2Orbit, sunOr\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf23qnc9w_test.go:21:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074543
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpia8of3pa_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074541
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1Sun, planet2Sun := getOrbits(planet1, planet2)\n    planet1SunOrbit,\
    \ planet2SunOrbit := getOrbits(planet1, planet2)\n    planet1SunOrbitSun, planet2SunOrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1SunSun, planet2SunSun := getOrbits(planet1,\
    \ planet2)\n    planet1SunSunOrbit, planet2SunSunOrbit := getOrbits(planet1, planet2)\n\
    \    planet1SunSunOrbitSun, planet2SunSunOrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1SunSunSun, planet2SunSunSun := getOrbits(planet1, planet2)\n    planet1SunSunSunOrbit,\
    \ planet2SunSunSunOrbit := getOrbits(planet1, planet2)\n    planet1SunSunSunOrbitSun,\
    \ planet2SunSunSunOrbitSun := getOrbits(planet1, planet2)\n    planet1SunSunSunSun,\
    \ planet2SunSunSunSun := getOrbits(planet1, planet2)\n    planet1SunSunSunSunOrbit,\
    \ planet2SunSunSunSunOrbit := getOrbits(planet1, planet2)\n    planet1SunSunSunSunOrbitSun,\
    \ planet2SunSunSunSun := getOrbits(planet1, planet2)\n    planet1SunSunSunSunOrbitSun,\
    \ planet2SunSunSunSun := getOrbits(planet1, planet2)\n    planet1SunSunSunSunOrbitSun,\
    \ planet2SunSunSunSun := getOrbits(planet1, planet2)\n    planet1SunSunSunSunOrbitSun,\
    \ planet2SunSunSunSun := getOrbits(planet1, planet2)\n    planet1SunSunSunSunOrbitSun,\
    \ planet2SunSunSunSun \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6ymhaxjf_test.go:36:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    if planet1 == planet2 {\n        return []interface{}{}\n\
    \    }\n    \n    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1Sun, err\
    \ := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n\
    \    planet1SunDistance := getDistance(planet1Sun, planet1Orbit)\n    planet2SunDistance\
    \ := getDistance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance :=\
    \ getDistance(planet1Orbit, planet1Orbit)\n    planet2OrbitDistance := getDistance(planet2Orbit,\
    \ planet2Orbit)\n    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n    }\n\
    \    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n    }\n\
    \    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n    }\n\
    \    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    if planet1OrbitDistance < planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpskdle2mj_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitSun := planet1\n    planet2OrbitSun := planet2\n\
    \    \n    planet1OrbitMercury := planet1\n    planet2OrbitMercury := planet2\n\
    \    \n    planet1OrbitVenus := planet1\n    planet2OrbitVenus := planet2\n  \
    \  \n    planet1OrbitEarth := planet1\n    planet2OrbitEarth := planet2\n    \n\
    \    planet1OrbitMars := planet1\n    planet2OrbitMars := planet2\n    \n    planet1OrbitJupiter\
    \ := planet1\n    planet2OrbitJupiter := planet2\n    \n    planet1OrbitSaturn\
    \ := planet1\n    planet2OrbitSaturn := planet2\n    \n    planet1OrbitUranus\
    \ := planet1\n    planet2OrbitUranus := planet2\n    \n    planet1OrbitNeptune\
    \ := planet1\n    planet2OrbitNeptune := planet2\n    \n    planet1OrbitMercurySun\
    \ := planet1\n    planet2OrbitMercurySun := planet2\n    \n    planet1OrbitVenusSun\
    \ := planet1\n    planet2OrbitVenusSun := planet2\n    \n    planet1OrbitEarthSun\
    \ := planet1\n    planet2OrbitEarthSun := planet2\n    \n    planet1OrbitMarsSun\
    \ := planet1\n    planet2OrbitMarsSun := planet2\n    \n    planet1OrbitJupiterSun\
    \ := planet1\n    planet2OrbitJupiterSun := planet2\n    \n    planet1OrbitSaturnSun\
    \ := planet1\n    planet2OrbitSaturnSun := planet2\n    \n    planet1OrbitUran\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy8i3qz56_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1Sun, planet2Sun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun\
    \ := getOrbits(planet1, planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1,\
    \ planet2)\n    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n\
    \    planet1OrbitSun, planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1OrbitSun,\
    \ planet2OrbitSun := getOrbits(planet1, planet2)\n    planet1Orbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoigyozsj_test.go:39:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074544
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(\"Error getting planet orbit\")\n  \
    \  }\n    \n    planet2Orbit, err := getPlanetOrbit(planet2)\n    if err != nil\
    \ {\n        fmt.Println(\"Error getting planet orbit\")\n    }\n    \n    planet1Sun,\
    \ err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n        fmt.Println(\"\
    Error getting planet orbit\")\n    }\n    \n    planet2Sun, err := getPlanetOrbit(\"\
    Sun\")\n    if err != nil {\n        fmt.Println(\"Error getting planet orbit\"\
    )\n    }\n    \n    planet1SunProximity, err := getPlanetProximity(planet1Sun,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(\"Error getting planet\
    \ proximity\")\n    }\n    \n    planet2SunProximity, err := getPlanetProximity(planet2Sun,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(\"Error getting planet\
    \ proximity\")\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(\"Error getting planet\
    \ proximity\")\n    }\n    \n    planet2Proximity, err := getPlanetProximity(planet2Orbit,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(\"Error getting planet\
    \ proximity\")\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\n        fmt.Println(\"Error getting planet\
    \ proximity\")\n    }\n    \n    planet2Proximity, err := getPlanetProximity(planet2Orbit,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(\"Error getting planet\
    \ proximity\")\n    }\n    \n    planet1Proximity, err := getPlanetProximity(planet1Orbit,\
    \ planet1Orbit)\n    if err != nil {\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwvheo46e_test.go:74:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    if planet1 == \"\" {\n        fmt.Println(\"\
    planet1 cannot be empty\")\n        return nil\n    }\n    if planet2 == \"\"\
    \ {\n        fmt.Println(\"planet2 cannot be empty\")\n        return nil\n  \
    \  }\n    \n    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n\
    \        fmt.Println(\"Error getting orbit of planet1\")\n        return nil\n\
    \    }\n    \n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n\
    \        fmt.Println(\"Error getting orbit of planet2\")\n        return nil\n\
    \    }\n    \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(\"\
    Error getting sun\")\n        return nil\n    }\n    \n    planet2Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(\"Error getting sun\")\n\
    \        return nil\n    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n\
    \    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1SunDistance\n    planet2OrbitDistance\
    \ /= planet2SunDistance\n    \n    planet1OrbitDistance *= planet1SunDistance\n\
    \    planet2OrbitDistance *= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ /= planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance /= planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1OrbitDistance *= planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitDistance\
    \ *= planet2Orbit.Distance(planet2Orbit)\n    \n    planet1OrbitDistance /= planet1SunDistance\n\
    \    planet2OrbitDistance /= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ *= planet1SunDistance\n    planet2\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphv9h5v0z_test.go:78:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = planet1,\
    \ planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2 = plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v2__iva_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074538
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := planet1\n    planet2Orbit := planet2\n    planet1OrbitOrbit\
    \ := planet1Orbit\n    planet2OrbitOrbit := planet2Orbit\n    planet1OrbitOrbitOrbit\
    \ := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdp20z917_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074545
