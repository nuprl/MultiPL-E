language: go_test.go
name: HumanEval_127_intersection
results:
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0]\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x504ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpbw9fnyhk_test.go:29\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpbw9fnyhk_test.go:53\
    \ +0x163c\ntesting.tRunner(0xc0001a0340, 0x529f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpsx1h0xv0_test.go:29 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpsx1h0xv0_test.go:64 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    intersection := interval1Start <=\
    \ interval2Start && interval1End >= interval2End\n    \n    if intersection {\n\
    \        intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \        \n        if intersection {\n            intersection := interval1Start\
    \ <= interval2Start && interval1End >= interval2End\n            \n          \
    \  if intersection {\n                intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n                \n                if intersection\
    \ {\n                    intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                    \n                    if intersection\
    \ {\n                        intersection := interval1Start <= interval2End &&\
    \ interval1End >= interval2Start\n                        \n                 \
    \       if intersection {\n                            intersection := interval1Start\
    \ <= interval2End && interval1End >= interval2Start\n                        \
    \    \n                            if intersection {\n                       \
    \         intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                \n                                if intersection\
    \ {\n                                    intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n                                    \n  \
    \                                  if intersection {\n                       \
    \                 intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                        \n              \
    \                          if intersection {\n                               \
    \             intersection := interval1Start <= interval2End && interval1End >=\
    \ interval2Start\n                                            \n             \
    \                               if intersection {\n                          \
    \                      intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                                \n      \
    \                                          if intersection {\n               \
    \                                     intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n                                        \
    \            \n                                                    if intersection\
    \ {\n                                                        intersection := interval1Start\
    \ <= interval2End && interval1End >= interval2Start\n                        \
    \                                \n                                          \
    \              if intersection {\n                                           \
    \                 intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                                        \
    \    \n                                                            if intersection\
    \ {\n                                                                intersection\
    \ := interval1Start <= interval2End && interval1End >= interval\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpypoxg6tc_test.go:85:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        } else {\n            intersectionStart = interval2Start\n\
    \            intersectionEnd = interval2End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionStart <= interval1End {\n     \
    \       if intersectionEnd <= interval2End {\n                return \"YES\"\n\
    \            }\n            return \"NO\"\n        }\n        return \"NO\"\n\
    \    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpzlx1m51o_test.go:26 +0x1a5\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpzlx1m51o_test.go:63 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var isIntersecting bool\n\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n\
    \        interval1Start = interval1[i].(int)\n        interval1End = interval1Start\
    \ + interval1[i].(int)\n    }\n\n    for i := 0; i < len(interval2); i++ {\n \
    \       interval2Start = interval2[i].(int)\n        interval2End = interval2Start\
    \ + interval2[i].(int)\n    }\n\n    isIntersecting = interval1Start <= interval2End\
    \ && interval2Start <= interval1End\n\n    if isIntersecting {\n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            return \"YES\"\
    \n        } else {\n            return \"NO\"\n        }\n    } else {\n     \
    \   return \"NO\"\n    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmptjsr7z2r_test.go:73: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmptjsr7z2r_test.go:73: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmptjsr7z2r_test.go:73: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Your code here\n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbs07kh_q_test.go:277:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, v := range interval1 {\n        if v == interval2[0] {\n            result\
    \ = append(result, v)\n        }\n    }\n    \n    for _, v := range interval2\
    \ {\n        if v == interval1[1] {\n            result = append(result, v)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n \
    \   if len(result) == 2 {\n        if result[0] == result[1] {\n            return\
    \ \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmplmqoh7ed_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmplmqoh7ed_test.go:77: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmplmqoh7ed_test.go:77: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmplmqoh7ed_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    interval1 := interval1[0]\n    interval2 := interval2[0]\n\
    \n    if interval1.(float64) < interval2.(float64) {\n        interval1, interval2\
    \ = interval2, interval1\n    }\n\n    start := interval1.(float64)\n    end :=\
    \ interval2.(float64)\n\n    start += 0.5\n    end += 0.5\n\n    if start > end\
    \ {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\
    \n    if start > end {\n        start, end = end, start\n    }\n\n    start +=\
    \ 0.5\n    end += 0.5\n\n    if start > end {\n        start, end = end, start\n\
    \    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end {\n        start,\
    \ end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n    if start\
    \ > end {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end\
    \ += 0.5\n\n    if start > end {\n        start, end = end, start\n    }\n\n \
    \   start += 0.5\n    end += 0.5\n\n    if start > end {\n        start, end =\
    \ end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end\
    \ {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\
    \n    if start > end {\n        start, end = end, start\n    }\n\n    start +=\
    \ 0.5\n    end += 0.5\n\n    if start > end {\n        start, end = end, start\n\
    \    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end {\n        start,\
    \ end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n    if start\
    \ > end {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end\
    \ += 0.5\n\n    if start > end {\n        start, end = end, start\n    }\n\n \
    \   start += 0.5\n    end += 0.5\n\n    if start > end {\n        start, end =\
    \ end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end\
    \ {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\
    \n    if start > end {\n        start, end = end, start\n    }\n\n    start +=\
    \ 0.5\n    end += 0.5\n\n    if start > end {\n        start, end = end, start\n\
    \    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end {\n        start,\
    \ end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqdg8pqhx_test.go:166:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var isIntersecting bool\n\
    \    var length int\n    var start1 int\n    var end1 int\n    var start2 int\n\
    \    var end2 int\n    var isPrime bool\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        start1 = interval1[i].(float64)\n        end1 = interval1[i].(float64)\n\
    \        start2 = interval2[i].(float64)\n        end2 = interval2[i].(float64)\n\
    \        \n        if start1 < end2 {\n            if start2 < end1 {\n      \
    \          isIntersecting = true\n                length = end1 - start2\n   \
    \         } else {\n                isIntersecting = false\n                length\
    \ = end2 - start1\n            }\n        } else {\n            if start2 < end1\
    \ {\n                isIntersecting = false\n                length = end1 - start2\n\
    \            } else {\n                isIntersecting = true\n               \
    \ length = end2 - start1\n            }\n        }\n        \n        if isIntersecting\
    \ {\n            if isPrime {\n                result = \"YES\"\n            \
    \    break\n            } else {\n                result = \"NO\"\n          \
    \      break\n            }\n        }\n        \n        isPrime = true\n   \
    \ }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxicj3kwz_test.go:24:9: length declared but not used

    /tmp/tmpxicj3kwz_test.go:36:18: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpxicj3kwz_test.go:37:16: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpxicj3kwz_test.go:38:18: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpxicj3kwz_test.go:39:16: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    for i := 0; i < len(interval1); i++ {\n\
    \        start := interval1[i].(float64)\n        end := interval2[i].(float64)\n\
    \        if start > end {\n            start, end = end, start\n        }\n  \
    \      if start > end {\n            continue\n        }\n        if start < end\
    \ {\n            result += \"YES\"\n            break\n        }\n    }\n    if\
    \ result == \"YES\" {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmp5mrwqsgb_test.go:27\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmp5mrwqsgb_test.go:53\
    \ +0x124b\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].([]interface{})[0].(int) <= interval2[i].([]interface{})[0].(int)\
    \ {\n            if interval1[i].([]interface{})[0].(int) >= interval2[i].([]interface{})[1].(int)\
    \ {\n                result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[1].(int))\n\
    \            } else {\n                result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[0].(int))\n\
    \            }\n        } else {\n            if interval1[i].([]interface{})[0].(int)\
    \ >= interval2[i].([]interface{})[1].(int) {\n                result += fmt.Sprintf(\"\
    %v\", interval1[i].([]interface{})[1].(int))\n            } else {\n         \
    \       result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[0].(int))\n\
    \            }\n        }\n    }\n    \n    if result == \"NO\" {\n        return\
    \ \"NO\"\n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n  \
    \  }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0, 0x2, 0x2?},\
    \ {0xc0000f5ca0, 0x2?, 0x2?})\n\t/tmp/tmp37z0uwzf_test.go:29 +0x465\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp37z0uwzf_test.go:62 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    for _,\
    \ v := range interval1 {\n        if v == nil {\n            continue\n      \
    \  }\n        \n        if v[0] < v[1] {\n            result := append(result,\
    \ v)\n        }\n    }\n    \n    for _, v := range interval2 {\n        if v\
    \ == nil {\n            continue\n        }\n        \n        if v[0] < v[1]\
    \ {\n            result := append(result, v)\n        }\n    }\n    \n    if len(result)\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if len(result) == 1 {\n    \
    \    return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n\
    \    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result \nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplwrun19c_test.go:140:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0]\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        for i := 0; i < len(interval1); i++ {\n            if\
    \ interval1[i].([]interface{})[1] > interval2[i].([]interface{})[1] {\n      \
    \          result = \"NO\"\n                break\n            }\n        }\n\
    \    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n\
    \    if result == \"YES\" {\n        for i := 0; i < len(interval1); i++ {\n \
    \           if interval1[i].([]interface{})[1] < interval2[i].([]interface{})[1]\
    \ {\n                result = \"NO\"\n                break\n            }\n \
    \       }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n   \
    \ }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] == interval2[i].([]interface{})[1]\
    \ {\n                result = \"YES\"\n                break\n            }\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] > interval2[i].([]interface{})[1]\
    \ {\n                result = \"NO\"\n                break\n            }\n \
    \       }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n   \
    \ }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] < interval2[i].([]interface{})[1]\
    \ {\n                result = \"NO\"\n                break\n            }\n \
    \       }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n   \
    \ }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] == interval2[i].([]interface{})[1]\
    \ {\n                result = \"YES\"\n                break\n            }\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4wsrbqrx_test.go:118:45: expected ''{'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpsx1h0xv0_test.go:29 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpsx1h0xv0_test.go:64 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n\n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n\n    for intersectionStart <= interval2End {\n        if interval1Start\
    \ < intersectionStart && intersectionStart < interval2End {\n            intersectionEnd\
    \ = intersectionStart\n        }\n        intersectionStart = intersectionStart\
    \ + 1\n    }\n    \n    if intersectionEnd < interval2End {\n        return \"\
    NO\"\n    }\n    \n    if intersectionStart <= interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionEnd <= interval2End {\n        return\
    \ \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp9u4k49e3_test.go:76: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp9u4k49e3_test.go:76: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmp9u4k49e3_test.go:76: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmp9u4k49e3_test.go:76: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    result := make(map[int]bool)\n    for _, v := range\
    \ interval1 {\n        result[v] = true\n    }\n\n    for _, v := range interval2\
    \ {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\n       \
    \ }\n    }\n\n    for _, v := range interval1 {\n        if _, ok := result[v];\
    \ !ok {\n            return \"NO\"\n        }\n    }\n\n    if len(interval1)\
    \ > len(interval2) {\n        return \"NO\"\n    }\n\n    for _, v := range interval1\
    \ {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\n       \
    \ }\n    }\n\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk3lnf92p_test.go:28:16:\
    \ cannot use v (variable of type interface{}) as type int in map index:\n\tneed\
    \ type assertion\n/tmp/tmpk3lnf92p_test.go:32:28: cannot use v (variable of type\
    \ interface{}) as type int in map index:\n\tneed type assertion\n/tmp/tmpk3lnf92p_test.go:38:28:\
    \ cannot use v (variable of type interface{}) as type int in map index:\n\tneed\
    \ type assertion\n/tmp/tmpk3lnf92p_test.go:48:28: cannot use v (variable of type\
    \ interface{}) as type int in map index:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var interval1Start int\n\
    \    var interval1End int\n    var interval2Start int\n    var interval2End int\n\
    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n\
    \    for i := 0; i < len(interval1); i++ {\n        interval1Start = interval1[i].([]interface{})[0].(int)\n\
    \        interval1End = interval1[i].([]interface{})[1].(int)\n        interval2Start\
    \ = interval2[i].([]interface{})[0].(int)\n        interval2End = interval2[i].([]interface{})[1].(int)\n\
    \n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            result = result + \"(\" + fmt.Sprint(interval1Start) + \", \"\
    \ + fmt.Sprint(interval1End) + \")\"\n        }\n    }\n\n    if result != \"\"\
    \ {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0, 0x2, 0x2?},\
    \ {0xc0000f5ca0, 0x2?, 0x2?})\n\t/tmp/tmp4hnowral_test.go:33 +0x3b7\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp4hnowral_test.go:57 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval1End {\n      \
    \  interval1Start, interval1End = interval1End, interval1Start\n    }\n    if\
    \ interval2Start > interval2End {\n        interval2Start, interval2End = interval2End,\
    \ interval2Start\n    }\n    \n    if interval1Start <= interval2End {\n     \
    \   if interval1End <= interval2Start {\n            return \"NO\"\n        }\n\
    \        \n        interval1Length := interval1End - interval1Start\n        interval2Length\
    \ := interval2End - interval2Start\n        \n        if interval1Length == interval2Length\
    \ {\n            \n            if interval1Start <= interval2Start {\n       \
    \         return \"YES\"\n            }\n            \n            interval1Start\
    \ := interval1Start + interval2Length\n            interval1End := interval1End\
    \ + interval2Length\n            \n            if interval1Start > interval1End\
    \ {\n                return \"NO\"\n            }\n            \n            interval1Length\
    \ := interval1End - interval1Start\n            \n            if interval1Length\
    \ == 1 {\n                return \"YES\"\n            }\n            \n      \
    \      if interval1Length == 2 || interval1Length == 3 {\n                return\
    \ \"YES\"\n            }\n            \n            if interval1Length == 4 ||\
    \ interval1Length == 5 {\n                return \"YES\"\n            }\n    \
    \        \n            if interval1Length == 6 || interval1Length == 7 {\n   \
    \             return \"YES\"\n            }\n            \n            if interval1Length\
    \ == 8 || interval1Length == 9 {\n                return \"YES\"\n           \
    \ }\n            \n            if interval1Length == 10 || interval1Length ==\
    \ 11 {\n                return \"YES\"\n            }\n            \n        \
    \    if interval1Length == 12 || interval1Length == 13 {\n                return\
    \ \"YES\"\n            }\n            \n            if interval1Length == 14 ||\
    \ interval1Length == 15 {\n                return \"YES\"\n            }\n   \
    \         \n            if interval1Length == 16 || interval1Length == 17 {\n\
    \                return \"YES\"\n            }\n            \n            if interval1Length\
    \ == 18 || interval1Length == 19 {\n                return \"YES\"\n         \
    \   }\n            \n            if interval1Length == 20 || interval1Length ==\
    \ 21 {\n                return \"YES\"\n            }\n            \n        \
    \    if interval1Length == 22 || interval1Length == 23\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo27bgbc0_test.go:106:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmphmh91rhz_test.go:30 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmphmh91rhz_test.go:65 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    interval1Start, interval1End\
    \ := interval1[0].(int), interval1[1].(int)\n    interval2Start, interval2End\
    \ := interval2[0].(int), interval2[1].(int)\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        result += \"YES\"\n    } else {\n\
    \        result += \"NO\"\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp54mi6xdg_test.go:56: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp54mi6xdg_test.go:56: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp54mi6xdg_test.go:56: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp54mi6xdg_test.go:56: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n \
    \   interval2 := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1[i] = interval1[i].(int)\n    }\n    for i := 0; i <\
    \ len(interval2); i++ {\n        interval2[i] = interval2[i].(int)\n    }\n  \
    \  \n    result := make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n\
    \        } else {\n            result[i] = interval2[i]\n        }\n    }\n  \
    \  \n    result := make([]int, len(result))\n    \n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i] == 0 {\n            result[i] = 1\n        }\n \
    \   }\n    \n    result := make([]int, len(result))\n    \n    for i := 0; i <\
    \ len(result); i++ {\n        if result[i] == 1 {\n            return \"NO\"\n\
    \        }\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9l_8orrl_test.go:26:15:\
    \ no new variables on left side of :=\n/tmp/tmp9l_8orrl_test.go:26:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmp9l_8orrl_test.go:27:15: no new variables on left side\
    \ of :=\n/tmp/tmp9l_8orrl_test.go:27:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmp9l_8orrl_test.go:39:12:\
    \ invalid operation: interval1[i] > interval2[i] (operator > not defined on interface)\n\
    /tmp/tmp9l_8orrl_test.go:40:25: cannot use interval1[i] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmp9l_8orrl_test.go:42:25:\
    \ cannot use interval2[i] (variable of type interface{}) as type int in assignment:\n\
    \tneed type assertion\n/tmp/tmp9l_8orrl_test.go:46:12: no new variables on left\
    \ side of :=\n/tmp/tmp9l_8orrl_test.go:54:12: no new variables on left side of\
    \ :=\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := interval1[0]\n    interval2 :=\
    \ interval2[0]\n    \n    start := interval1.([]interface{})[1]\n    end := interval2.([]interface{})[1]\n\
    \    \n    if start > end {\n        return \"NO\"\n    }\n    \n    start :=\
    \ start.(int)\n    end := end.(int)\n    \n    result := make([]int, 0, end-start)\n\
    \    \n    for i := start; i < end; i++ {\n        result = append(result, i)\n\
    \    }\n    \n    result := result[:len(result)/2]\n    \n    if len(result) ==\
    \ 1 {\n        return \"YES\"\n    }\n    \n    result := result[:len(result)/2]\n\
    \    \n    for _, i := range result {\n        if result[len(result)-1] != i {\n\
    \            result := append(result, i)\n        }\n    }\n    \n    result :=\
    \ result[:len(result)/2]\n    \n    for _, i := range result {\n        if result[len(result)-1]\
    \ != i {\n            result := append(result, i)\n        }\n    }\n    \n  \
    \  result := result[:len(result)/2]\n    \n    for _, i := range result {\n  \
    \      if result[len(result)-1] != i {\n            result := append(result, i)\n\
    \        }\n    }\n    \n    result := result[:len(result)/2]\n    \n    for _,\
    \ i := range result {\n        if result[len(result)-1] != i {\n            result\
    \ := append(result, i)\n        }\n    }\n    \n    result := result[:len(result)/2]\n\
    \    \n    for _, i := range result {\n        if result[len(result)-1] != i {\n\
    \            result := append(result, i)\n        }\n    }\n    \n    result :=\
    \ result[:len(result)/2]\n    \n    for _, i := range result {\n        if result[len(result)-1]\
    \ != i {\n            result := append(result, i)\n        }\n    }\n    \n  \
    \  result := result[:len(result)/2]\n    \n    for _, i := range result {\n  \
    \      if result[len(result)-1] != i {\n            result := append(result, i)\n\
    \        }\n    }\n    \n    result := result[:len(result)/2]\n    \n    for _,\
    \ i := range result {\n        if result[len(result)-1] != i {\n            result\
    \ := append(result, i)\n        }\n    }\n    \n    result := result[:len(result)/2]\n\
    \    \n    for _, i := range result {\n        if result[len(result)-1] != i {\n\
    \            result := append(\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr3to0lzv_test.go:120:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval := range interval1 {\n        if interval[0] < interval[1] {\n\
    \            result = append(result, interval)\n        }\n    }\n    \n    for\
    \ _, interval := range interval2 {\n        if interval[0] < interval[1] {\n \
    \           result = append(result, interval)\n        }\n    }\n    \n    if\
    \ len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := result[0]\n\
    \    \n    if result[0] > result[1] {\n        return \"NO\"\n    }\n    \n  \
    \  if result[1] < result[0] {\n        return \"NO\"\n    }\n    \n    if result[0]\
    \ < result[1] {\n        return \"YES\"\n    }\n    \n    if result[0] > result[1]\
    \ {\n        return \"YES\"\n    }\n    \n    if result[0] > result[1] {\n   \
    \     return \"YES\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjopa4o7__test.go:29:20:\
    \ invalid operation: cannot index interval (variable of type interface{})\n/tmp/tmpjopa4o7__test.go:35:20:\
    \ invalid operation: cannot index interval (variable of type interface{})\n/tmp/tmpjopa4o7__test.go:44:12:\
    \ no new variables on left side of :=\n/tmp/tmpjopa4o7__test.go:44:15: cannot\
    \ use result[0] (variable of type interface{}) as type []interface{} in assignment:\n\
    \tneed type assertion\n/tmp/tmpjopa4o7__test.go:46:8: invalid operation: result[0]\
    \ > result[1] (operator > not defined on interface)\n/tmp/tmpjopa4o7__test.go:50:8:\
    \ invalid operation: result[1] < result[0] (operator < not defined on interface)\n\
    /tmp/tmpjopa4o7__test.go:54:8: invalid operation: result[0] < result[1] (operator\
    \ < not defined on interface)\n/tmp/tmpjopa4o7__test.go:58:8: invalid operation:\
    \ result[0] > result[1] (operator > not defined on interface)\n/tmp/tmpjopa4o7__test.go:62:8:\
    \ invalid operation: result[0] > result[1] (operator > not defined on interface)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075626
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End\
    \ - interval2Start - interval2End\n    if intersection <= 0 {\n        return\
    \ \"NO\"\n    }\n    if intersection <= 1 {\n        return \"YES\"\n    }\n \
    \   \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa57jzxn4_test.go:46:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075627
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Your code here\n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbs07kh_q_test.go:277:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Map := make(map[int]bool)\n    interval2Map\
    \ := make(map[int]bool)\n    \n    for _, v := range interval1 {\n        interval1Map[v.(int)]=true\n\
    \    }\n    for _, v := range interval2 {\n        interval2Map[v.(int)]=true\n\
    \    }\n    \n    result := make([]interface{}, 0)\n    for k := range interval1Map\
    \ {\n        if interval2Map[k]==true {\n            result = append(result, k)\n\
    \        }\n    }\n    if len(result)==0 {\n        return \"NO\"\n    }\n   \
    \ \n    if len(result)==1 {\n        return \"YES\"\n    }\n    \n    length :=\
    \ len(result)\n    if length%2==0 {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]interface{}, 0)\n    for i := 0; i < length/2; i++ {\n        if interval1Map[result[i]]==true\
    \ {\n            result = append(result, result[i+1])\n        }\n    }\n    \n\
    \    if len(result)==1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqv5297_u_test.go:55:12:\
    \ no new variables on left side of :=\n/tmp/tmpqv5297_u_test.go:57:25: cannot\
    \ use result[i] (variable of type interface{}) as type int in map index:\n\tneed\
    \ type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075627
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var start int\n    var end\
    \ int\n    var length int\n    var intersection []interface{}\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        start = interval1[i].(int)\n        end = interval2[i].(int)\n\
    \        \n        if start > end {\n            start = interval1[i].(int)\n\
    \            end = interval2[i].(int)\n        }\n        \n        length = end\
    \ - start\n        \n        if length == 0 {\n            continue\n        }\n\
    \        \n        intersection = append(intersection, start)\n        intersection\
    \ = append(intersection, end)\n    }\n    \n    if len(intersection) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    for i := 0; i < len(intersection); i++\
    \ {\n        if intersection[i] > intersection[i+1] {\n            intersection[i],\
    \ intersection[i+1] = intersection[i+1], intersection[i]\n        }\n    }\n \
    \   \n    for i := 0; i < len(intersection); i++ {\n        if intersection[i]\
    \ == intersection[i+1] {\n            continue\n        }\n        \n        if\
    \ isPrime(intersection[i], intersection[i+1]) {\n            result = \"YES\"\n\
    \            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwku5tcrf_test.go:56:12: invalid operation: intersection[i] > intersection[i
    + 1] (operator > not defined on interface)

    /tmp/tmpwku5tcrf_test.go:66:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075627
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        result += \"(\"\n        result += fmt.Sprintf(\"\
    %d\", interval1[i].(float64))\n        result += \", \"\n        result += fmt.Sprintf(\"\
    %d\", interval2[i].(float64))\n        result += \")\"\n    }\n    \n    if result\
    \ == \"\" {\n        return \"NO\"\n    }\n    \n    result += \"\\n\"\n    \n\
    \    result += \"The length of intersection of these two intervals is: \"\n  \
    \  result += \"\\n\"\n    result += \"The length of intersection of these two\
    \ intervals is: \"\n    result += \"\\n\"\n    result += \"The length of intersection\
    \ of these two intervals is: \"\n    result += \"\\n\"\n    result += \"The length\
    \ of intersection of these two intervals is: \"\n    result += \"\\n\"\n    result\
    \ += \"The length of intersection of these two intervals is: \"\n    result +=\
    \ \"\\n\"\n    result += \"The length of intersection of these two intervals is:\
    \ \"\n    result += \"\\n\"\n    result += \"The length of intersection of these\
    \ two intervals is: \"\n    result += \"\\n\"\n    result += \"The length of intersection\
    \ of these two intervals is: \"\n    result += \"\\n\"\n    result += \"The length\
    \ of intersection of these two intervals is: \"\n    result += \"\\n\"\n    result\
    \ += \"The length of intersection of these two intervals is: \"\n    result +=\
    \ \"\\n\"\n    result += \"The length of intersection of these two intervals is:\
    \ \"\n    result += \"\\n\"\n    result += \"The length of intersection of these\
    \ two intervals is: \"\n    result += \"\\n\"\n    result += \"The length of intersection\
    \ of these two intervals is: \"\n    result += \"\\n\"\n    result += \"The length\
    \ of intersection of these two intervals is: \"\n    result += \"\\n\"\n    result\
    \ += \"The length of intersection of these two intervals is: \"\n    result +=\
    \ \"\\n\"\n    result += \"The length of intersection of these two intervals is:\
    \ \"\n    result += \"\\n\"\n    result += \"The length of intersection of these\
    \ two intervals is: \"\n    result += \"\\n\"\n    result += \"The length of intersection\
    \ of these two intervals is: \"\n    result += \"\\n\"\n    result += \"The length\
    \ of intersection of these two intervals is: \"\n    result += \"\\n\"\n    result\
    \ += \"The length of intersection of these two intervals is: \"\n    result +=\
    \ \"\\n\"\n    result += \"The length of intersection of these two intervals is:\
    \ \"\n    result += \"\\n\"\n    result += \"The length of intersection of these\
    \ two intervals is: \"\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpohjkf_2l_test.go:85:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n \
    \   interval2 := make([]int, len(interval2))\n    \n    for i, v := range interval1\
    \ {\n        interval1[i] = v.(int)\n    }\n    for i, v := range interval2 {\n\
    \        interval2[i] = v.(int)\n    }\n    \n    result := make([]int, len(interval1))\n\
    \    \n    for i, v := range interval1 {\n        for j, w := range interval2\
    \ {\n            if v >= w {\n                result[i] = v\n                break\n\
    \            }\n        }\n    }\n    \n    if len(result) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    length := len(result)\n    \n    if length == 1 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 2 {\n        if result[0]\
    \ == result[1] {\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    \n    if length == 3 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] {\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    \n    if length == 4 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    if length == 5 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] {\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    \n    if length == 6 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] && result[3] == result[4] && result[4]\
    \ == result[5] {\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    \n    if length == 7 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] && result[3] == result[4] && result[4]\
    \ == result[5] && result[5] == result[6] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    if length == 8 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] && result[4] == result[5] && result[5] == result[6] && result[6]\
    \ == result[7] {\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    \n    if length == 9 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] && result[3] == result[4] && result[4]\
    \ == result[5] && result[5] == result[6] && result[6] == result[7] && result[7]\
    \ == result[8] {\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5yd966zp_test.go:108:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if interval1Start <= interval2Start && interval1End >= interval2End {\n \
    \       return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00018a360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00018a360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f0cc0?, 0x2?, 0x2?},\
    \ {0xc0000f0ca0?, 0x2?, 0x2?})\n\t/tmp/tmpj4a1dysl_test.go:26 +0x217\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpj4a1dysl_test.go:67 +0xe7\ntesting.tRunner(0xc0001851e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075627
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval := range interval1 {\n        if interval == nil {\n       \
    \     continue\n        }\n        \n        start, end := interval.([]interface{})\n\
    \        \n        if start > end {\n            continue\n        }\n       \
    \ \n        result := append(result, interval)\n    }\n    \n    for _, interval\
    \ := range interval2 {\n        if interval == nil {\n            continue\n \
    \       }\n        \n        start, end := interval.([]interface{})\n        \n\
    \        if start > end {\n            continue\n        }\n        \n       \
    \ result := append(result, interval)\n    }\n    \n    if len(result) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i].([]interface{})[1] < result[j].([]interface{})[1]\n\
    \    })\n    \n    length := 0\n    \n    for _, interval := range result {\n\
    \        start, end := interval.([]interface{})\n        \n        if start >\
    \ end {\n            continue\n        }\n        \n        length = length +\
    \ 1\n    }\n    \n    if length == 1 {\n        return \"YES\"\n    }\n    \n\
    \    if length == 2 && result[0].([]interface{})[1] > result[1].([]interface{})[1]\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwjbpxfj5_test.go:35:20: invalid operation: start > end (mismatched types
    []interface{} and bool)

    /tmp/tmpwjbpxfj5_test.go:39:9: result declared but not used

    /tmp/tmpwjbpxfj5_test.go:49:20: invalid operation: start > end (mismatched types
    []interface{} and bool)

    /tmp/tmpwjbpxfj5_test.go:53:9: result declared but not used

    /tmp/tmpwjbpxfj5_test.go:60:5: undefined: sort

    /tmp/tmpwjbpxfj5_test.go:61:16: invalid operation: result[i].([]interface{})[1]
    < result[j].([]interface{})[1] (operator < not defined on interface)

    /tmp/tmpwjbpxfj5_test.go:69:20: invalid operation: start > end (mismatched types
    []interface{} and bool)

    /tmp/tmpwjbpxfj5_test.go:80:23: invalid operation: result[0].([]interface{})[1]
    > result[1].([]interface{})[1] (operator > not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075627
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var interval1Start int\n\
    \    var interval1End int\n    var interval2Start int\n    var interval2End int\n\
    \    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        interval1Start = interval1[i].(float64)\n\
    \        interval1End = interval1[i].(float64)\n        \n        for j := 0;\
    \ j < len(interval2); j++ {\n            interval2Start = interval2[j].(float64)\n\
    \            interval2End = interval2[j].(float64)\n            \n           \
    \ if interval1Start <= interval2Start && interval1End >= interval2End {\n    \
    \            \n                if interval1Start <= interval2End {\n         \
    \           result = result + \"(\" + fmt.Sprint(interval1Start) + \", \" + fmt.Sprint(interval1End)\
    \ + \")\"\n                }\n                \n                if interval1End\
    \ >= interval2Start {\n                    result = result + \"(\" + fmt.Sprint(interval1End)\
    \ + \", \" + fmt.Sprint(interval1Start) + \")\"\n                }\n         \
    \       \n                break\n            }\n        }\n    }\n    \n    if\
    \ result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"\
    YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmeqjs7dk_test.go:33:26: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpmeqjs7dk_test.go:34:24: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpmeqjs7dk_test.go:37:30: cannot use interval2[j].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpmeqjs7dk_test.go:38:28: cannot use interval2[j].(float64) (comma, ok expression
    of type float64) as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075627
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := interval1.([]interface{})\n   \
    \ interval2 := interval2.([]interface{})\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, v := range interval1 {\n        if v >= interval2[0] {\n\
    \            result = append(result, v)\n        }\n    }\n    \n    for _, v\
    \ := range interval2 {\n        if v >= interval1[0] {\n            result = append(result,\
    \ v)\n        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\
    \n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 1 {\n        if result[0] == result[1] {\n            return \"YES\"\n  \
    \      }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 2 {\n        if result[0] == result[1] {\n      \
    \      return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 3 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 4 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 5 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] && result[3] == result[4] {\n       \
    \     return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 6 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] && result[4] == result[5] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 7 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] && result[3] == result[4] && result[4]\
    \ == result[5] && result[5] == result[6] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 8 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] && result[3] == result[4] && result[4]\
    \ == result[5] && \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ex6qyum_test.go:114:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075627
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    interval1Start :=\
    \ interval1[0].(int)\n    interval1End := interval1[1].(int)\n    interval2Start\
    \ := interval2[0].(int)\n    interval2End := interval2[1].(int)\n    \n    if\
    \ interval1Start <= interval1End && interval2Start <= interval2End {\n       \
    \ if interval1Start <= interval2Start && interval1End >= interval2End {\n    \
    \        if interval1Start <= interval2End {\n                result = fmt.Sprintf(\"\
    YES\")\n            } else {\n                result = fmt.Sprintf(\"NO\")\n \
    \           }\n        } else {\n            result = fmt.Sprintf(\"NO\")\n  \
    \      }\n    } else {\n        result = fmt.Sprintf(\"NO\")\n    }\n    \n  \
    \  return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp4op_9du4_test.go:66: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp4op_9du4_test.go:66: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp4op_9du4_test.go:66: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp4op_9du4_test.go:66: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for _, v := range\
    \ interval1 {\n        if v == nil {\n            continue\n        }\n      \
    \  \n        if interval2[0] == nil {\n            result = \"NO\"\n         \
    \   break\n        }\n        \n        if v == interval2[0].(type) {\n      \
    \      if interval1[1] == nil {\n                result = \"NO\"\n           \
    \     break\n            }\n            \n            if v == interval1[1].(type)\
    \ {\n                if interval2[1] == nil {\n                    result = \"\
    NO\"\n                    break\n                }\n                \n       \
    \         if v == interval2[1].(type) {\n                    if interval1[0].(int)\
    \ <= interval2[0].(int) && interval1[1].(int) >= interval2[1].(int) {\n      \
    \                  result = \"YES\"\n                        break\n         \
    \           }\n                }\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_yefwpj4_test.go:38:17: invalid AST: use of .(type) outside type switch

    /tmp/tmp_yefwpj4_test.go:44:21: invalid AST: use of .(type) outside type switch

    /tmp/tmp_yefwpj4_test.go:50:25: invalid AST: use of .(type) outside type switch

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Map := make(map[int]bool)\n    interval2Map\
    \ := make(map[int]bool)\n    \n    for _, v := range interval1 {\n        interval1Map[v.(int)]=true\n\
    \    }\n    for _, v := range interval2 {\n        interval2Map[v.(int)]=true\n\
    \    }\n    \n    result := make([]interface{}, 0)\n    for _, v := range interval1Map\
    \ {\n        if interval2Map[v] {\n            result = append(result, v)\n  \
    \      }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n\
    \    \n    length := len(result)\n    if length == 1 {\n        return \"YES\"\
    \n    }\n    \n    if length == 2 && result[0] == result[1] {\n        return\
    \ \"YES\"\n    }\n    \n    if length == 2 && result[0] < result[1] {\n      \
    \  return \"NO\"\n    }\n    \n    if length == 2 && result[0] > result[1] {\n\
    \        return \"NO\"\n    }\n    \n    if length == 3 && result[0] == result[1]\
    \ && result[2] == result[1] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && result[0] < result[1] && result[2] < result[1] {\n        return \"\
    NO\"\n    }\n    \n    if length == 3 && result[0] > result[1] && result[2] >\
    \ result[1] {\n        return \"NO\"\n    }\n    \n    if length == 4 && result[0]\
    \ == result[1] && result[2] == result[1] && result[3] == result[1] {\n       \
    \ return \"YES\"\n    }\n    \n    if length == 4 && result[0] < result[1] &&\
    \ result[2] < result[1] && result[3] < result[1] {\n        return \"NO\"\n  \
    \  }\n    \n    if length == 4 && result[0] > result[1] && result[2] > result[1]\
    \ && result[3] > result[1] {\n        return \"NO\"\n    }\n    \n    if length\
    \ == 5 && result[0] == result[1] && result[2] == result[1] && result[3] == result[1]\
    \ && result[4] == result[1] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 5 && result[0] < result[1] && result[2] < result[1] && result[3] < result[1]\
    \ && result[4] < result[1] {\n        return \"NO\"\n    }\n    \n    if length\
    \ == 5 && result[0] > result[1] && result[2] > result[1] && result[3] > result[1]\
    \ && result[4] > result[1] {\n        return \"NO\"\n    }\n    \n    if length\
    \ == 6 && result[0] == result[1] && result[2] == result[1] && result[3] == result[1]\
    \ && result[4] == result[1] && result\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9ok67ymf_test.go:101:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075627
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    interval1Start, interval1End := interval1[0].(int),\
    \ interval1[1].(int)\n    interval2Start, interval2End := interval2[0].(int),\
    \ interval2[1].(int)\n\n    if interval1Start > interval2End {\n        return\
    \ \"NO\"\n    }\n\n    if interval1End < interval2Start {\n        return \"NO\"\
    \n    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__3\
    \ (0.00s)\n        tmp6nz_jbe1_test.go:96: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmp6nz_jbe1_test.go:96: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmp6nz_jbe1_test.go:96: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmp6nz_jbe1_test.go:96: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result += \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) > interval2[i].(float64)\
    \ {\n            result += \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpk4k3125__test.go:29 +0x21c\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpk4k3125__test.go:64 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) <= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0001103c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0001103c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000108cc0?, 0x2?, 0x2?},\
    \ {0xc000108ca0?, 0x2?, 0x2?})\n\t/tmp/tmp57izi_56_test.go:30 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp57izi_56_test.go:65 +0xe7\ntesting.tRunner(0xc00011b040, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075628
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var interval1Start int\n\
    \    var interval1End int\n    var interval2Start int\n    var interval2End int\n\
    \    var interval1Length int\n    var interval2Length int\n    var isIntersecting\
    \ bool\n\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n \
    \   }\n\n    for i := 0; i < len(interval1); i++ {\n        interval1Start = interval1[i].(float64)\n\
    \        interval1End = interval1[i].(float64)\n        interval1Length = interval1End\
    \ - interval1Start\n\n        interval2Start = interval2[i].(float64)\n      \
    \  interval2End = interval2[i].(float64)\n        interval2Length = interval2End\
    \ - interval2Start\n\n        if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n            isIntersecting = true\n        } else {\n   \
    \         isIntersecting = false\n        }\n\n        if isIntersecting {\n \
    \           if interval1Length == interval2Length {\n                result =\
    \ \"YES\"\n            } else {\n                result = \"NO\"\n           \
    \ }\n        } else {\n            result = \"NO\"\n        }\n    }\n\n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp065lfm7a_test.go:36:26: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmp065lfm7a_test.go:37:24: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmp065lfm7a_test.go:40:26: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmp065lfm7a_test.go:41:24: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var lengthOfIntersection int\n    var isPrime bool\n\n\
    \    interval1Start, interval1End = interval1[0].(int), interval1[1].(int)\n \
    \   interval2Start, interval2End = interval2[0].(int), interval2[1].(int)\n\n\
    \    if interval1Start > interval1End {\n        fmt.Println(\"interval1Start\
    \ > interval1End\")\n        return \"NO\"\n    }\n    if interval2Start > interval2End\
    \ {\n        fmt.Println(\"interval2Start > interval2End\")\n        return \"\
    NO\"\n    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        fmt.Println(\"interval1Start <=\
    \ interval2End && interval1End >= interval2Start\")\n        return \"NO\"\n \
    \   }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        fmt.Println(\"interval1Start <= interval2Start\
    \ && interval1End >= interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        fmt.Println(\"\
    interval1Start <= interval2Start && interval1End >= interval2End\")\n        return\
    \ \"NO\"\n    }\n\n    if interval1Start <= interval2Start && interval1End >=\
    \ interval2End {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End\
    \ >= interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n        fmt.Println(\"interval1Start\
    \ <= interval2Start && interval1End >= interval2End\")\n        return \"NO\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        fmt.Println(\"interval1Start <= interval2Start\
    \ \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuz5_m5pc_test.go:80:21: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075627
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var length1 int\n    var\
    \ length2 int\n    var isIntersecting bool\n    \n    length1 = len(interval1)\n\
    \    length2 = len(interval2)\n    \n    if length1 == 0 || length2 == 0 {\n \
    \       result = \"NO\"\n    } else {\n        isIntersecting = true\n       \
    \ for i := 0; i < length1; i++ {\n            if interval1[i].(float64) <= interval2[i].(float64)\
    \ {\n                isIntersecting = false\n                break\n         \
    \   }\n        }\n    }\n    \n    if isIntersecting {\n        result = \"YES\"\
    \n    } else {\n        result = \"NO\"\n    }\n    \n    return result\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpooh5neb5_test.go:35\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpooh5neb5_test.go:58\
    \ +0xd65\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        return fmt.Sprintf(\"YES\")\n    }\n    \n   \
    \ if interval1Length > interval2Length {\n        interval1Length -= interval2Length\n\
    \    }\n    \n    if interval1Length == 0 {\n        return \"NO\"\n    }\n  \
    \  \n    if interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Length == interval2Length {\n        return fmt.Sprintf(\"YES\")\n\
    \    }\n    \n    if interval1Length == interval2Length {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Length > interval2Length {\n        interval1Length\
    \ -= interval2Length\n    }\n    \n    if interval1Length == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if interval2Length == 0 {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Length == interval2Length {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Length == interval2Length {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    \n    if interval1Length > interval2Length\
    \ {\n        interval1Length -= interval2Length\n    }\n    \n    if interval1Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval2Length == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        return fmt.Sprintf(\"YES\")\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        return fmt.Sprintf(\"YES\")\n    }\n    \n   \
    \ if interval1Length > interval2Length {\n        interval1Length -= interval2Length\n\
    \    }\n    \n    if interval1Length == 0 {\n        return \"NO\"\n    }\n  \
    \  \n    if interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Length == interval2Length {\n        return \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpitpu9yb__test.go:123:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var interval1Start int\n\
    \    var interval1End int\n    var interval2Start int\n    var interval2End int\n\
    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n\
    \    for i := 0; i < len(interval1); i++ {\n        interval1Start, interval1End\
    \ = interval1[i].(int64)\n        interval2Start, interval2End = interval2[i].(int64)\n\
    \n        if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n            result += \"YES\"\n        } else {\n            result += \"\
    NO\"\n        }\n    }\n\n    return result\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpps6nrogq_test.go:33:40: cannot use interval1[i].(int64) (value of type
    int64) as type int in assignment

    /tmp/tmpps6nrogq_test.go:33:40: cannot use interval1[i].(int64) (untyped bool
    value) as int value in assignment

    /tmp/tmpps6nrogq_test.go:34:40: cannot use interval2[i].(int64) (value of type
    int64) as type int in assignment

    /tmp/tmpps6nrogq_test.go:34:40: cannot use interval2[i].(int64) (untyped bool
    value) as int value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n \
    \   interval2 := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1[i] = interval1[i].(int)\n    }\n    for i := 0; i <\
    \ len(interval2); i++ {\n        interval2[i] = interval2[i].(int)\n    }\n  \
    \  \n    result := make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n\
    \        } else {\n            result[i] = interval2[i]\n        }\n    }\n  \
    \  \n    length := 0\n    for i := 0; i < len(result); i++ {\n        if result[i]\
    \ != result[i+1] {\n            length++\n        }\n    }\n    \n    if length\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    if length == 2 && result[0]\
    \ == result[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0jqope17_test.go:26:15:\
    \ no new variables on left side of :=\n/tmp/tmp0jqope17_test.go:26:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmp0jqope17_test.go:27:15: no new variables on left side\
    \ of :=\n/tmp/tmp0jqope17_test.go:27:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmp0jqope17_test.go:39:12:\
    \ invalid operation: interval1[i] > interval2[i] (operator > not defined on interface)\n\
    /tmp/tmp0jqope17_test.go:40:25: cannot use interval1[i] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmp0jqope17_test.go:42:25:\
    \ cannot use interval2[i] (variable of type interface{}) as type int in assignment:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := interval1[0]\n    interval2 :=\
    \ interval2[0]\n    \n    start := interval1.([]interface{})[0]\n    end := interval1.([]interface{})[1]\n\
    \    \n    start := start.(int)\n    end := end.(int)\n    \n    start := start\
    \ + 1\n    end := end + 1\n    \n    start := start - 1\n    end := end - 1\n\
    \    \n    start := start - 1\n    end := end - 1\n    \n    start := start -\
    \ 1\n    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n  \
    \  \n    start := start - 1\n    end := end - 1\n    \n    start := start - 1\n\
    \    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n\
    \    start := start - 1\n    end := end - 1\n    \n    start := start - 1\n  \
    \  end := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n  \
    \  start := start - 1\n    end := end - 1\n    \n    start := start - 1\n    end\
    \ := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n    start\
    \ := start - 1\n    end := end - 1\n    \n    start := start - 1\n    end := end\
    \ - 1\n    \n    start := start - 1\n    end := end - 1\n    \n    start := start\
    \ - 1\n    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n\
    \    \n    start := start - 1\n    end := end - 1\n    \n    start := start -\
    \ 1\n    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n  \
    \  \n    start := start - 1\n    end := end - 1\n    \n    start := start - 1\n\
    \    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n\
    \    start := start - 1\n    end := end - 1\n    \n    start := start - 1\n  \
    \  end := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n  \
    \  start := start - 1\n    end := end - 1\n    \n    start := start - 1\n    end\
    \ := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n    start\
    \ := start - 1\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpigvzzpat_test.go:130:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n \
    \   interval2 := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1[i] = interval1[i].(int)\n    }\n    for i := 0; i <\
    \ len(interval2); i++ {\n        interval2[i] = interval2[i].(int)\n    }\n  \
    \  \n    result := make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n\
    \        } else {\n            result[i] = interval2[i]\n        }\n    }\n  \
    \  \n    length := 0\n    for i := 0; i < len(result); i++ {\n        if result[i]\
    \ != result[i+1] {\n            length++\n        }\n    }\n    \n    if length\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    if length == 2 && result[0]\
    \ == result[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0jqope17_test.go:26:15:\
    \ no new variables on left side of :=\n/tmp/tmp0jqope17_test.go:26:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmp0jqope17_test.go:27:15: no new variables on left side\
    \ of :=\n/tmp/tmp0jqope17_test.go:27:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmp0jqope17_test.go:39:12:\
    \ invalid operation: interval1[i] > interval2[i] (operator > not defined on interface)\n\
    /tmp/tmp0jqope17_test.go:40:25: cannot use interval1[i] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmp0jqope17_test.go:42:25:\
    \ cannot use interval2[i] (variable of type interface{}) as type int in assignment:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval := range interval1 {\n        start := interval.([]interface{})[0].(int)\n\
    \        end := interval.([]interface{})[1].(int)\n        \n        for _, interval2\
    \ := range interval2 {\n            interval2 := interval2.([]interface{})\n \
    \           \n            if start >= interval2[0] && end <= interval2[1] {\n\
    \                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6j2dsp2p_test.go:83:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpsx1h0xv0_test.go:29 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpsx1h0xv0_test.go:64 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var interval1Start int\n\
    \    var interval1End int\n    var interval2Start int\n    var interval2End int\n\
    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n\
    \    for i := 0; i < len(interval1); i++ {\n        interval1Start = interval1[i].(float64)\n\
    \        interval1End = interval1[i].(float64)\n    }\n\n    for i := 0; i < len(interval2);\
    \ i++ {\n        interval2Start = interval2[i].(float64)\n        interval2End\
    \ = interval2[i].(float64)\n    }\n\n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        if interval1Start <= interval2End {\n\
    \            result = fmt.Sprintf(\"YES\")\n        } else {\n            result\
    \ = fmt.Sprintf(\"NO\")\n        }\n    } else {\n        if interval1Start <=\
    \ interval2Start {\n            result = fmt.Sprintf(\"YES\")\n        } else\
    \ {\n            result = fmt.Sprintf(\"NO\")\n        }\n    }\n\n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcxtw8cv__test.go:33:26: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpcxtw8cv__test.go:34:24: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpcxtw8cv__test.go:38:26: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpcxtw8cv__test.go:39:24: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    interval1_start := interval1[0].(float64)\n\
    \    interval1_end := interval1[1].(float64)\n    interval2_start := interval2[0].(float64)\n\
    \    interval2_end := interval2[1].(float64)\n    \n    interval1_length := interval1_end\
    \ - interval1_start\n    interval2_length := interval2_end - interval2_start\n\
    \    \n    if interval1_length == 0 || interval2_length == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1_start += interval1_length / 2\n    interval1_end\
    \ -= interval1_length / 2\n    interval2_start += interval2_length / 2\n    interval2_end\
    \ -= interval2_length / 2\n    \n    if interval1_start > interval2_end {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1_end < interval2_start {\n\
    \        return \"NO\"\n    }\n    \n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return \"YES\"\n\
    \        }\n        return \"NO\"\n    }\n    \n    if interval1_start < interval2_start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1_end > interval2_end\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return \"YES\"\n\
    \        }\n        return \"NO\"\n    }\n    \n    if interval1_start > interval2_start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1_end < interval2_end\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return \"YES\"\n\
    \        }\n        return \"NO\"\n    }\n    \n    if interval1_start < interval2_start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1_end > interval2_end\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return \"YES\"\n\
    \        }\n        return \"NO\"\n    }\n    \n    if interval1_start > interval2_start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1_end < interval2_end\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return \"YES\"\n\
    \        }\n        return \"NO\"\n    }\n    \n    if interval1_start < interval\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_4_yhmzy_test.go:119:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var interval1Start, interval1End\
    \ int\n    var interval2Start, interval2End int\n    var isIntersecting bool\n\
    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n\
    \    for i := 0; i < len(interval1); i++ {\n        interval1Start, interval1End\
    \ = interval1[i].(int)\n        interval2Start, interval2End = interval2[i].(int)\n\
    \        isIntersecting = interval1Start <= interval2End && interval2Start <=\
    \ interval1End\n\n        if !isIntersecting {\n            return \"NO\"\n  \
    \      }\n    }\n\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwmts1s_9_test.go:22:9: result declared but not used

    /tmp/tmpwmts1s_9_test.go:32:40: cannot use interval1[i].(int) (untyped bool value)
    as int value in assignment

    /tmp/tmpwmts1s_9_test.go:33:40: cannot use interval2[i].(int) (untyped bool value)
    as int value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1End < interval2Start {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1Start >= interval2Start && interval1End >= interval2End {\n    \
    \    return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpdqkgz_4f_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpdqkgz_4f_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpdqkgz_4f_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        start := interval1[i].(float64)\n        end\
    \ := interval2[i].(float64)\n        \n        if start > end {\n            start,\
    \ end = end, start\n        }\n        \n        if start <= end {\n         \
    \   result += \"YES\"\n        } else {\n            result += \"NO\"\n      \
    \  }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpx0renp7f_test.go:29\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpx0renp7f_test.go:53\
    \ +0x1191\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n    for i :=\
    \ interval1Start; i <= interval1End; i++ {\n        for j := interval2Start; j\
    \ <= interval2End; j++ {\n            if i == j {\n                continue\n\
    \            }\n            if j%i == 0 {\n                result := append(result,\
    \ j)\n            }\n        }\n    }\n    \n    if len(result) == 0 {\n     \
    \   return \"NO\"\n    }\n    \n    if len(result) == 1 {\n        return \"YES\"\
    \n    }\n    \n    length := len(result)\n    \n    if length == 2 {\n       \
    \ if result[0] == result[1] {\n            return \"YES\"\n        }\n    }\n\
    \    \n    if length == 3 {\n        if result[0] == result[1] && result[1] ==\
    \ result[2] {\n            return \"YES\"\n        }\n    }\n    \n    if length\
    \ == 4 {\n        if result[0] == result[1] && result[1] == result[2] && result[2]\
    \ == result[3] {\n            return \"YES\"\n        }\n    }\n    \n    if length\
    \ == 5 {\n        if result[0] == result[1] && result[1] == result[2] && result[2]\
    \ == result[3] && result[3] == result[4] {\n            return \"YES\"\n     \
    \   }\n    }\n    \n    if length == 6 {\n        if result[0] == result[1] &&\
    \ result[1] == result[2] && result[2] == result[3] && result[3] == result[4] &&\
    \ result[4] == result[5] {\n            return \"YES\"\n        }\n    }\n   \
    \ \n    if length == 7 {\n        if result[0] == result[1] && result[1] == result[2]\
    \ && result[2] == result[3] && result[3] == result[4] && result[4] == result[5]\
    \ && result[5] == result[6] {\n            return \"YES\"\n        }\n    }\n\
    \    \n    if length == 8 {\n        if result[0] == result[1] && result[1] ==\
    \ result[2] && result[2] == result[3] && result[3] == result[4] && result[4] ==\
    \ result[5] && result[5] == result[6] && result[6] == result[7] {\n          \
    \  return \"YES\"\n        }\n    }\n    \n    if length == 9 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] && result[4] == result[5] && result[5] == result[6] && \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo5qvt20__test.go:105:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075628
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := interval1[0]\n    interval2 :=\
    \ interval2[0]\n    \n    if interval1[0] > interval2[1] {\n        interval1\
    \ = interval1[1:]\n    }\n    if interval1[1] < interval2[0] {\n        interval1\
    \ = interval1[:1]\n    }\n    \n    if interval1[1] < interval2[1] {\n       \
    \ interval1 = interval1[:1]\n    }\n    \n    if interval1[1] > interval2[1] {\n\
    \        interval1 = interval1[:1]\n    }\n    \n    result := \"\"\n    \n  \
    \  for _, v := range interval1 {\n        if v == interval2[0] {\n           \
    \ result += \"YES\"\n            break\n        }\n    }\n    \n    if result\
    \ != \"\" {\n        return result\n    }\n    \n    for _, v := range interval2\
    \ {\n        if v == interval1[0] {\n            result += \"YES\"\n         \
    \   break\n        }\n    }\n    \n    if result != \"\" {\n        return result\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8ih3td81_test.go:26:15:\
    \ no new variables on left side of :=\n/tmp/tmp8ih3td81_test.go:26:18: cannot\
    \ use interval1[0] (variable of type interface{}) as type []interface{} in assignment:\n\
    \tneed type assertion\n/tmp/tmp8ih3td81_test.go:27:15: no new variables on left\
    \ side of :=\n/tmp/tmp8ih3td81_test.go:27:18: cannot use interval2[0] (variable\
    \ of type interface{}) as type []interface{} in assignment:\n\tneed type assertion\n\
    /tmp/tmp8ih3td81_test.go:29:8: invalid operation: interval1[0] > interval2[1]\
    \ (operator > not defined on interface)\n/tmp/tmp8ih3td81_test.go:32:8: invalid\
    \ operation: interval1[1] < interval2[0] (operator < not defined on interface)\n\
    /tmp/tmp8ih3td81_test.go:36:8: invalid operation: interval1[1] < interval2[1]\
    \ (operator < not defined on interface)\n/tmp/tmp8ih3td81_test.go:40:8: invalid\
    \ operation: interval1[1] > interval2[1] (operator > not defined on interface)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            return \"NO\"\n        }\n        if interval1End < interval1Start\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ > intersectionEnd {\n            intersectionEnd = interval1End\n        }\n\
    \        if interval1End < intersectionStart {\n            intersectionStart\
    \ = interval1End\n        }\n    }\n    \n    if intersectionEnd > interval2End\
    \ {\n        return \"NO\"\n    }\n    if intersectionEnd < interval2Start {\n\
    \        return \"NO\"\n    }\n    \n    if intersectionStart > interval2End {\n\
    \        return \"NO\"\n    }\n    if intersectionStart < interval2Start {\n \
    \       return \"NO\"\n    }\n    \n    if intersectionStart > intersectionEnd\
    \ {\n        return \"NO\"\n    }\n    if intersectionEnd < intersectionStart\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        intersectionLength := intersectionEnd - intersectionStart\n     \
    \   if isPrime(intersectionLength) {\n            return \"YES\"\n        }\n\
    \    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_wif_8sa_test.go:83:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        \n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            \n            if interval1[i].(float64) > interval2[i].(float64)\
    \ {\n                \n                interval1[i], interval2[i] = interval2[i],\
    \ interval1[i]\n            }\n            \n            result = result + \"\
    YES\"\n        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\
    \n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n   \
    \ \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmp8cqfql7g_test.go:31\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmp8cqfql7g_test.go:60\
    \ +0x14f1\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        \n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            \n            if result == \"NO\" {\n                result =\
    \ \"YES\"\n            }\n            \n            break\n        }\n       \
    \ \n        if interval1[i].(float64) > interval2[i].(float64) {\n           \
    \ \n            if result == \"YES\" {\n                result = \"NO\"\n    \
    \        }\n            \n            break\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpdypoi8sz_test.go:31\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpdypoi8sz_test.go:60\
    \ +0xb34\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make(map[int]bool)\n    for _, v :=\
    \ range interval1 {\n        result[v] = true\n    }\n    for _, v := range interval2\
    \ {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n  \
    \  \n    length := 0\n    for _, v := range result {\n        length = length\
    \ + v\n    }\n    if length == 1 {\n        return \"YES\"\n    }\n    if length\
    \ == 2 && result[1] && result[2] {\n        return \"YES\"\n    }\n    if length\
    \ == 2 && !result[1] {\n        return \"NO\"\n    }\n    if length == 3 && result[1]\
    \ && result[2] && result[3] {\n        return \"YES\"\n    }\n    if length ==\
    \ 3 && !result[1] && result[2] {\n        return \"NO\"\n    }\n    if length\
    \ == 4 && result[1] && result[2] && result[3] && result[4] {\n        return \"\
    YES\"\n    }\n    if length == 4 && !result[1] && result[2] && !result[3] {\n\
    \        return \"NO\"\n    }\n    if length == 5 && result[1] && result[2] &&\
    \ result[3] && result[4] && result[5] {\n        return \"YES\"\n    }\n    if\
    \ length == 5 && !result[1] && result[2] && !result[3] && result[4] {\n      \
    \  return \"NO\"\n    }\n    if length == 6 && result[1] && result[2] && result[3]\
    \ && result[4] && result[5] && result[6] {\n        return \"YES\"\n    }\n  \
    \  if length == 6 && !result[1] && result[2] && !result[3] && result[4] && result[5]\
    \ {\n        return \"NO\"\n    }\n    if length == 7 && result[1] && result[2]\
    \ && result[3] && result[4] && result[5] && result[6] && result[7] {\n       \
    \ return \"YES\"\n    }\n    if length == 7 && !result[1] && result[2] && !result[3]\
    \ && result[4] && result[5] && result[6] {\n        return \"NO\"\n    }\n   \
    \ if length == 8 && result[1] && result[2] && result[3] && result[4] && result[5]\
    \ && result[6] && result[7] && result[8] {\n        return \"YES\"\n    }\n  \
    \  if length == 8 && !result[1] && result[2] && !result[3] && result[4] && result[5]\
    \ && result[6] && result[7] {\n        return \"NO\"\n    }\n    if length ==\
    \ 9 && result[1] && result[2] && result[3] && result[4] && result[5] && result[6]\
    \ && result[7] && result[8] && result[9] {\n        return \"YES\"\n    }\n  \
    \  if length == 9 && !result[1] && result[2] && !result[3] && result[4\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeoezjgm6_test.go:92:72: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var start1 int\n    var\
    \ end1 int\n    var start2 int\n    var end2 int\n    var length1 int\n    var\
    \ length2 int\n    var isPrime bool\n    \n    start1 = interval1[0].(int)\n \
    \   end1 = interval1[1].(int)\n    start2 = interval2[0].(int)\n    end2 = interval2[1].(int)\n\
    \    \n    length1 = end1 - start1\n    length2 = end2 - start2\n    \n    isPrime\
    \ = true\n    \n    if length1 == 0 || length2 == 0 {\n        result = \"NO\"\
    \n    } else {\n        if length1 == length2 {\n            if start1 < start2\
    \ {\n                start1 = start1 + 1\n                end1 = end1 + 1\n  \
    \          } else {\n                start2 = start2 + 1\n                end2\
    \ = end2 + 1\n            }\n        }\n        \n        if length1 > length2\
    \ {\n            length1 = length1 - length2\n            isPrime = false\n  \
    \      } else {\n            length2 = length2 - length1\n            isPrime\
    \ = false\n        }\n        \n        if length1 == 1 {\n            if start1\
    \ < start2 {\n                start1 = start1 + 1\n                end1 = end1\
    \ + 1\n            } else {\n                start2 = start2 + 1\n           \
    \     end2 = end2 + 1\n            }\n        }\n        \n        if length2\
    \ == 1 {\n            if start1 < start2 {\n                start1 = start1 +\
    \ 1\n                end1 = end1 + 1\n            } else {\n                start2\
    \ = start2 + 1\n                end2 = end2 + 1\n            }\n        }\n  \
    \      \n        if start1 < start2 {\n            start1 = start1 + 1\n     \
    \       end1 = end1 + 1\n        } else {\n            start2 = start2 + 1\n \
    \           end2 = end2 + 1\n        }\n        \n        if end1 > end2 {\n \
    \           end1 = end1 - 1\n            isPrime = false\n        } else {\n \
    \           end2 = end2 - 1\n            isPrime = false\n        }\n        \n\
    \        if start1 > end2 {\n            start1 = start1 - 1\n            isPrime\
    \ = false\n        } else {\n            start2 = start2 - 1\n            isPrime\
    \ = false\n        }\n        \n        if end1 < end2 {\n            end1 = end1\
    \ - 1\n            isPrime = false\n        } else {\n            end2 = end2\
    \ - 1\n            isPrime = false\n        }\n        \n        if start1 ==\
    \ end1 {\n            result = \"YES\"\n        } else {\n            if start1\
    \ == start2 {\n                result = \"YES\"\n            } else {\n      \
    \          if start1 < start2 {\n                    result = \"NO\"\n       \
    \         } else {\n                    result = \"NO\"\n                }\n \
    \           }\n        }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg_xwu6mp_test.go:29:9: isPrime declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].([]interface{})[0].(int) <= interval2[i].([]interface{})[0].(int)\
    \ {\n            if interval1[i].([]interface{})[0].(int) >= interval2[i].([]interface{})[1].(int)\
    \ {\n                result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[1].(int))\n\
    \            } else {\n                result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[0].(int))\n\
    \            }\n        } else {\n            if interval1[i].([]interface{})[1].(int)\
    \ >= interval2[i].([]interface{})[0].(int) {\n                result += fmt.Sprintf(\"\
    %v\", interval1[i].([]interface{})[1].(int))\n            } else {\n         \
    \       result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[0].(int))\n\
    \            }\n        }\n    }\n    \n    if result == \"NO\" {\n        return\
    \ \"NO\"\n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n  \
    \  }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0, 0x2, 0x2?},\
    \ {0xc0000f5ca0, 0x2?, 0x2?})\n\t/tmp/tmpmqcjh7iq_test.go:29 +0x425\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpmqcjh7iq_test.go:62 +0xe7\ntesting.tRunner(0xc0001964e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpybs4_95p_test.go:92:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Write your code here\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptrb6rco4_test.go:277:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval1 := range interval1 {\n        for _, interval2 := range interval2\
    \ {\n            if interval1.(float64) >= interval2.(float64) {\n           \
    \     continue\n            }\n            \n            result := append(result,\
    \ interval1)\n            result := append(result, interval2)\n        }\n   \
    \ }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n   \
    \ result := make([]interface{}, 0)\n    \n    for _, interval := range result\
    \ {\n        if isPrime(interval.(float64)) {\n            return \"YES\"\n  \
    \      }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpporfg_de_test.go:35:20: no new variables on left side of :=

    /tmp/tmpporfg_de_test.go:43:12: no new variables on left side of :=

    /tmp/tmpporfg_de_test.go:46:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    interval1Start, interval1End := interval1[0].(int),\
    \ interval1[1].(int)\n    interval2Start, interval2End := interval2[0].(int),\
    \ interval2[1].(int)\n\n    if interval1Start > interval2End {\n        return\
    \ \"NO\"\n    }\n\n    if interval1End < interval2Start {\n        return \"NO\"\
    \n    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2End &&\
    \ interval1End >= interval2Start {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ > interval2Start && interval1Start <= interval2End {\n        return \"YES\"\
    \n    }\n\n    if interval1End > interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End > interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ > interval2Start && interval1End > interval2End {\n        return \"YES\"\n\
    \    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp569ysm06_test.go:84: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp569ysm06_test.go:84: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp569ysm06_test.go:84: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp569ysm06_test.go:84: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp569ysm06_test.go:84: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075630
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n\n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n\n    for interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        } else {\n            intersectionStart = interval2Start\n\
    \            intersectionEnd = interval2End\n        }\n    }\n\n    if intersectionStart\
    \ <= intersectionEnd {\n        intersectionLength := intersectionEnd - intersectionStart\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp44aszu_j_test.go:46:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075630
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := interval1[0].([]interface{})\n\
    \    interval2 := interval2[0].([]interface{})\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i]\
    \ > interval2[i] {\n            interval1[i], interval2[i] = interval2[i], interval1[i]\n\
    \        }\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if\
    \ interval1[i] <= interval2[i] {\n            result = append(result, interval1[i])\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := result[0].([]interface{})\n    \n    if len(result)\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    if isPrime(result[0]) {\n \
    \       return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplrzv88pk_test.go:26:15: no new variables on left side of :=

    /tmp/tmplrzv88pk_test.go:27:15: no new variables on left side of :=

    /tmp/tmplrzv88pk_test.go:32:12: invalid operation: interval1[i] > interval2[i]
    (operator > not defined on interface)

    /tmp/tmplrzv88pk_test.go:38:12: invalid operation: interval1[i] <= interval2[i]
    (operator <= not defined on interface)

    /tmp/tmplrzv88pk_test.go:47:12: no new variables on left side of :=

    /tmp/tmplrzv88pk_test.go:53:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        interval1Start, interval2Start = interval2Start, interval1Start\n\
    \    }\n    \n    if interval1End >= interval2End {\n        interval1End, interval2End\
    \ = interval2End, interval1End\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        interval1Start, interval2Start = interval2Start, interval1Start\n\
    \    }\n    \n    if interval1End >= interval2End {\n        interval1End, interval2End\
    \ = interval2End, interval1End\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        interval1Start, interval2Start = interval2Start, interval1Start\n\
    \    }\n    \n    if interval1End >= interval2End {\n        interval1End, interval2End\
    \ = interval2End, interval1End\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        interval1Start, interval2Start = interval2Start, interval1Start\n\
    \    }\n    \n    if interval1End >= interval2End {\n        interval1End, interval2End\
    \ = interval2End, interval1End\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        interval1Start, interval2Start = interval2Start, interval1Start\n\
    \    }\n    \n    if interval1End >= interval2End {\n        interval1End, interval2End\
    \ = \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv92grxco_test.go:98:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval1 := range interval1 {\n        start := interval1.([]interface{})[0]\n\
    \        end := interval1.([]interface{})[1]\n        \n        for _, interval2\
    \ := range interval2 {\n            interval2 := interval2.([]interface{})\n \
    \           \n            if start <= interval2[0] && end >= interval2[1] {\n\
    \                fmt.Println(start, end)\n                \n                fmt.Println(interval1)\n\
    \                fmt.Println(interval2)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmdu9nhex_test.go:139:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    for i := 0; i < len(interval1); i++ {\n\
    \        result += \"YES\"\n    }\n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp52oiz982_test.go:52: expected 'NO', got 'YESYES'\n    ---\
    \ FAIL: TestIntersection/test_num__1 (0.00s)\n        tmp52oiz982_test.go:52:\
    \ expected 'NO', got 'YESYES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n\
    \        tmp52oiz982_test.go:52: expected 'YES', got 'YESYES'\n    --- FAIL: TestIntersection/test_num__3\
    \ (0.00s)\n        tmp52oiz982_test.go:52: expected 'YES', got 'YESYES'\n    ---\
    \ FAIL: TestIntersection/test_num__4 (0.00s)\n        tmp52oiz982_test.go:52:\
    \ expected 'NO', got 'YESYES'\n    --- FAIL: TestIntersection/test_num__5 (0.00s)\n\
    \        tmp52oiz982_test.go:52: expected 'NO', got 'YESYES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp52oiz982_test.go:52: expected 'NO', got 'YESYES'\n    ---\
    \ FAIL: TestIntersection/test_num__7 (0.00s)\n        tmp52oiz982_test.go:52:\
    \ expected 'NO', got 'YESYES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Write your code here\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptrb6rco4_test.go:277:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n \
    \   interval2 := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1[i] = interval1[i].(int)\n    }\n    for i := 0; i <\
    \ len(interval2); i++ {\n        interval2[i] = interval2[i].(int)\n    }\n  \
    \  \n    result := make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n\
    \        } else {\n            result[i] = interval2[i]\n        }\n    }\n  \
    \  \n    result := make([]int, len(result))\n    \n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i] == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    \n    result := make([]int, len(result))\n    \n    for i := 0; i <\
    \ len(result); i++ {\n        if result[i] == 1 {\n            return \"YES\"\n\
    \        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzty1wyzz_test.go:26:15:\
    \ no new variables on left side of :=\n/tmp/tmpzty1wyzz_test.go:26:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmpzty1wyzz_test.go:27:15: no new variables on left side\
    \ of :=\n/tmp/tmpzty1wyzz_test.go:27:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmpzty1wyzz_test.go:39:12:\
    \ invalid operation: interval1[i] > interval2[i] (operator > not defined on interface)\n\
    /tmp/tmpzty1wyzz_test.go:40:25: cannot use interval1[i] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmpzty1wyzz_test.go:42:25:\
    \ cannot use interval2[i] (variable of type interface{}) as type int in assignment:\n\
    \tneed type assertion\n/tmp/tmpzty1wyzz_test.go:46:12: no new variables on left\
    \ side of :=\n/tmp/tmpzty1wyzz_test.go:54:12: no new variables on left side of\
    \ :=\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        for i := 0; i < len(interval1); i++ {\n            if\
    \ interval1[i].(float64) >= interval2[i].(float64) {\n                return \"\
    NO\"\n            }\n        }\n        return \"YES\"\n    }\n    \n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpfet14nch_test.go:29\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpfet14nch_test.go:58\
    \ +0x14a5\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n \
    \   interval2 := make([]int, len(interval2))\n    \n    for i, v := range interval1\
    \ {\n        interval1[i] = v.(int)\n    }\n    for i, v := range interval2 {\n\
    \        interval2[i] = v.(int)\n    }\n    \n    result := make([]int, len(interval1))\n\
    \    \n    for i, v := range interval1 {\n        for j, w := range interval2\
    \ {\n            if v < w {\n                break\n            }\n          \
    \  if v == w {\n                result[i] = v\n            }\n        }\n    }\n\
    \    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    length\
    \ := len(result)\n    \n    if length == 1 {\n        return \"YES\"\n    }\n\
    \    \n    if length == 2 && result[0] == result[1] {\n        return \"YES\"\n\
    \    }\n    \n    if length == 2 && result[0] == result[1] {\n        return \"\
    NO\"\n    }\n    \n    if length == 3 && result[0] == result[1] && result[1] ==\
    \ result[2] {\n        return \"YES\"\n    }\n    \n    if length == 3 && result[0]\
    \ == result[1] && result[1] == result[2] {\n        return \"NO\"\n    }\n   \
    \ \n    if length == 4 && result[0] == result[1] && result[1] == result[2] &&\
    \ result[2] == result[3] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 4 && result[0] == result[1] && result[1] == result[2] && result[2] == result[3]\
    \ {\n        return \"NO\"\n    }\n    \n    if length == 5 && result[0] == result[1]\
    \ && result[1] == result[2] && result[2] == result[3] && result[3] == result[4]\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 5 && result[0] == result[1]\
    \ && result[1] == result[2] && result[2] == result[3] && result[3] == result[4]\
    \ {\n        return \"NO\"\n    }\n    \n    if length == 6 && result[0] == result[1]\
    \ && result[1] == result[2] && result[2] == result[3] && result[3] == result[4]\
    \ && result[4] == result[5] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 6 && result[0] == result[1] && result[1] == result[2] && result[2] == result[3]\
    \ && result[3] == result[4] && result[4] == result[5] {\n        return \"NO\"\
    \n    }\n    \n    if length == 7 && result[0] == result[1] && result[1] == result[2]\
    \ && result[2] == result[3] && result[3] == result[4] && result[4] == result[5]\
    \ && result[5] == result[6] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 7 && result[0] == result\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsnhks4kl_test.go:104:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval := range interval1 {\n        if interval == nil {\n       \
    \     continue\n        }\n        \n        start, end := interval.([]interface{})\n\
    \        \n        for _, interval2 := range interval2 {\n            if interval2\
    \ == nil {\n                continue\n            }\n            \n          \
    \  start, end := interval2.([]interface{})\n            \n            if start\
    \ > end {\n                start, end = end, start\n            }\n          \
    \  \n            if start < end {\n                result := append(result, []interface{}{start,\
    \ end})\n            }\n        }\n    }\n    \n    if len(result) == 0 {\n  \
    \      return \"NO\"\n    }\n    \n    length := len(result)\n    \n    if length\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    for i := 2; i < length; i++\
    \ {\n        if length%i == 0 {\n            return \"NO\"\n        }\n    }\n\
    \    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6byyy4kl_test.go:33:9: start declared but not used

    /tmp/tmp6byyy4kl_test.go:33:16: end declared but not used

    /tmp/tmp6byyy4kl_test.go:42:24: invalid operation: start > end (mismatched types
    []interface{} and bool)

    /tmp/tmp6byyy4kl_test.go:43:30: cannot use end (variable of type bool) as type
    []interface{} in assignment

    /tmp/tmp6byyy4kl_test.go:43:35: cannot use start (variable of type []interface{})
    as type bool in assignment

    /tmp/tmp6byyy4kl_test.go:46:24: invalid operation: start < end (mismatched types
    []interface{} and bool)

    /tmp/tmp6byyy4kl_test.go:47:17: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075630
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := interval1[0].([]interface{})\n\
    \    interval2 := interval2[0].([]interface{})\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range interval1 {\n        if interval[0] >=\
    \ interval[1] {\n            continue\n        }\n        \n        for _, interval2\
    \ := range interval2 {\n            if interval2[0] >= interval2[1] {\n      \
    \          continue\n            }\n            \n            if interval[0] ==\
    \ interval2[0] && interval[1] == interval2[1] {\n                result = append(result,\
    \ interval)\n            }\n        }\n    }\n    \n    if len(result) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if len(result) == 1 {\n        return\
    \ \"YES\"\n    }\n    \n    result := result[0].([]interface{})\n    \n    if\
    \ len(result) == 2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp99qkc881_test.go:26:15: no new variables on left side of :=

    /tmp/tmp99qkc881_test.go:27:15: no new variables on left side of :=

    /tmp/tmp99qkc881_test.go:32:20: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmp99qkc881_test.go:37:25: invalid operation: cannot index interval2 (variable
    of type interface{})

    /tmp/tmp99qkc881_test.go:41:24: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmp99qkc881_test.go:41:40: invalid operation: cannot index interval2 (variable
    of type interface{})

    /tmp/tmp99qkc881_test.go:41:55: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmp99qkc881_test.go:41:71: invalid operation: cannot index interval2 (variable
    of type interface{})

    /tmp/tmp99qkc881_test.go:55:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Write your code here\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptrb6rco4_test.go:277:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for _, interval\
    \ := range interval1 {\n        if interval == nil {\n            continue\n \
    \       }\n        \n        if interval2 != nil {\n            interval2 := interval2.([]interface{})\n\
    \            \n            if interval[0] == interval2[0] {\n                result\
    \ += \"YES\"\n                continue\n            }\n            \n        \
    \    if interval[1] < interval2[1] {\n                result += \"NO\"\n     \
    \           continue\n            }\n            \n            if interval[1]\
    \ > interval2[1] {\n                result += \"NO\"\n                continue\n\
    \            }\n        }\n        \n        if interval[1] < interval[0] {\n\
    \            result += \"NO\"\n            continue\n        }\n        \n   \
    \     if interval[1] > interval[0] {\n            result += \"NO\"\n         \
    \   continue\n        }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpco1kg18h_test.go:34:26: invalid operation: interval2 (variable of type
    []interface{}) is not an interface

    /tmp/tmpco1kg18h_test.go:36:24: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmpco1kg18h_test.go:41:24: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmpco1kg18h_test.go:46:24: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmpco1kg18h_test.go:52:20: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmpco1kg18h_test.go:57:20: invalid operation: cannot index interval (variable
    of type interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) <= interval2[i].(float64)\
    \ {\n            result += \"YES\"\n        } else {\n            result += \"\
    NO\"\n        }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpdn5xtopk_test.go:29\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpdn5xtopk_test.go:46\
    \ +0x1131\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Map := make(map[int]bool)\n    interval2Map\
    \ := make(map[int]bool)\n    \n    for _, v := range interval1 {\n        interval1Map[v]\
    \ = true\n    }\n    for _, v := range interval2 {\n        interval2Map[v] =\
    \ true\n    }\n    \n    result := make([]int, 0)\n    for k := range interval1Map\
    \ {\n        if interval2Map[k] {\n            result = append(result, k)\n  \
    \      }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n\
    \    \n    length := len(result)\n    if length == 1 {\n        return \"YES\"\
    \n    }\n    \n    if length == 2 && interval1Map[result[0]] && interval2Map[result[1]]\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 2 && !interval1Map[result[0]]\
    \ && !interval2Map[result[1]] {\n        return \"NO\"\n    }\n    \n    if length\
    \ == 3 && interval1Map[result[0]] && interval2Map[result[1]] && interval1Map[result[2]]\
    \ && interval2Map[result[3]] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && !interval1Map[result[0]] && !interval2Map[result[1]] && !interval1Map[result[2]]\
    \ && !interval2Map[result[3]] {\n        return \"NO\"\n    }\n    \n    if length\
    \ == 4 && interval1Map[result[0]] && interval2Map[result[1]] && interval1Map[result[2]]\
    \ && interval2Map[result[3]] && interval1Map[result[4]] && interval2Map[result[5]]\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 4 && !interval1Map[result[0]]\
    \ && !interval2Map[result[1]] && !interval1Map[result[2]] && !interval2Map[result[3]]\
    \ && !interval1Map[result[4]] && !interval2Map[result[5]] {\n        return \"\
    NO\"\n    }\n    \n    if length == 5 && interval1Map[result[0]] && interval2Map[result[1]]\
    \ && interval1Map[result[2]] && interval2Map[result[3]] && interval1Map[result[4]]\
    \ && interval2Map[result[5]] && interval1Map[result[6]] && interval2Map[result[7]]\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 5 && !interval1Map[result[0]]\
    \ && !interval2Map[result[1]] && !interval1Map[result[2]] && !interval2Map[result[3]]\
    \ && !interval1Map[result[4]] && !interval2Map[result[5]] && !interval1Map[result[6]]\
    \ && !interval2Map[result[7]] {\n        return \"NO\"\n    }\n    \n    if length\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpviryjx93_test.go:85:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval1End || interval2Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    intersection := interval1Start\
    \ <= interval2End && interval2Start <= interval1End\n    \n    if intersection\
    \ {\n        intersection := interval1End - interval1Start <= interval2End - interval2Start\n\
    \    }\n    \n    if intersection {\n        intersection := interval1Start <=\
    \ interval2Start && interval2Start <= interval1End\n    }\n    \n    if intersection\
    \ {\n        intersection := interval1End - interval1Start <= interval2End - interval2Start\n\
    \    }\n    \n    if intersection {\n        intersection := interval1Start <=\
    \ interval2Start && interval2Start <= interval1End\n    }\n    \n    if intersection\
    \ {\n        intersection := interval1End - interval1Start <= interval2End - interval2Start\n\
    \    }\n    \n    if intersection {\n        intersection := interval1Start <=\
    \ interval2Start && interval2Start <= interval1End\n    }\n    \n    if intersection\
    \ {\n        intersection := interval1End - interval1Start <= interval2End - interval2Start\n\
    \    }\n    \n    if intersection {\n        intersection := interval1Start <=\
    \ interval2Start && interval2Start <= interval1End\n    }\n    \n    if intersection\
    \ {\n        intersection := interval1End - interval1Start <= interval2End - interval2Start\n\
    \    }\n    \n    if intersection {\n        intersection := interval1Start <=\
    \ interval2Start && interval2Start <= interval1End\n    }\n    \n    if intersection\
    \ {\n        intersection := interval1End - interval1Start <= interval2End - interval2Start\n\
    \    }\n    \n    if intersection {\n        intersection := interval1Start <=\
    \ interval2Start && interval2Start <= interval1End\n    }\n    \n    if intersection\
    \ {\n        intersection := interval1End - interval1Start <= interval2End - interval2Start\n\
    \    }\n    \n    if intersection {\n        intersection := interval1Start <=\
    \ interval2Start && interval2Start <= interval1End\n    }\n    \n    if intersection\
    \ {\n        intersection := interval1End - interval1\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp560z38na_test.go:95:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075630
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    interval1Start :=\
    \ interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n    interval2Start\
    \ := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n    \n\
    \    if interval1Start <= interval2End && interval1End <= interval2Start {\n \
    \       result += \"YES\"\n    } else {\n        result += \"NO\"\n    }\n   \
    \ \n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmps71mq2bs_test.go:24\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmps71mq2bs_test.go:45\
    \ +0x1065\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075631
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, v := range interval1 {\n        if v == nil {\n            continue\n\
    \        }\n        \n        if v > interval2[0] {\n            continue\n  \
    \      }\n        \n        if v < interval2[1] {\n            continue\n    \
    \    }\n        \n        result = append(result, v)\n    }\n    \n    if len(result)\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if len(result) == 1 {\n    \
    \    return result[0].(string)\n    }\n    \n    if len(result) == 2 {\n     \
    \   return result[0].(string) + \"-\" + result[1].(string)\n    }\n    \n    if\
    \ len(result) > 2 {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqr0zad9k_test.go:33:12: invalid operation: v > interval2[0] (operator
    > not defined on interface)

    /tmp/tmpqr0zad9k_test.go:37:12: invalid operation: v < interval2[1] (operator
    < not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    intersectionLength\
    \ := interval1Length * interval2Length\n    \n    if intersectionLength == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if isPrime(intersectionLength) {\n  \
    \      return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1uan7v7t_test.go:51:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var intersectionLength int\n\n    if len(interval1) !=\
    \ len(interval2) {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1Start, interval1End = interval1[i].(int64)\n       \
    \ interval2Start, interval2End = interval2[i].(int64)\n        if interval1Start\
    \ <= interval2End && interval1End <= interval2Start {\n            intersectionLength\
    \ = interval1End - interval1Start\n        } else {\n            intersectionLength\
    \ = interval2End - interval2Start\n        }\n        if intersectionLength ==\
    \ 0 {\n            return \"NO\"\n        }\n        if isPrime(intersectionLength)\
    \ {\n            return \"YES\"\n        }\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa9plase5_test.go:31:40: cannot use interval1[i].(int64) (value of type
    int64) as type int in assignment

    /tmp/tmpa9plase5_test.go:31:40: cannot use interval1[i].(int64) (untyped bool
    value) as int value in assignment

    /tmp/tmpa9plase5_test.go:32:40: cannot use interval2[i].(int64) (value of type
    int64) as type int in assignment

    /tmp/tmpa9plase5_test.go:32:40: cannot use interval2[i].(int64) (untyped bool
    value) as int value in assignment

    /tmp/tmpa9plase5_test.go:41:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    if intersection == 0 {\n        return \"NO\"\n    }\n \
    \   \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0_h4rbe7_test.go:43:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionLength := interval1End\
    \ - interval1Start\n    \n    if interval2Start < interval2End {\n        interval2Start\
    \ += interval1Start\n        interval2End += interval1Start\n    }\n    \n   \
    \ if interval1Start < interval1End {\n        interval1Start += interval2Start\n\
    \        interval1End += interval2Start\n    }\n    \n    if interval1Start >\
    \ interval1End {\n        return \"NO\"\n    }\n    \n    if interval2Start >\
    \ interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n        return \"YES\"\n \
    \   }\n    \n    if interval2Start <= interval1Start && interval2End >= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval2Start <= interval1Start && interval2End <= interval1End {\n    \
    \    return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    \n    if interval2Start\
    \ <= interval1Start && interval2End >= interval1End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval2Start <= interval1Start\
    \ && interval2End <= interval1End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1Start <= interval2Start && interval1End >= interval2End {\n    \
    \    return \"YES\"\n    }\n    \n    if interval2Start <= interval1Start && interval2End\
    \ >= interval1End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        return \"\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdoiw85o6_test.go:99:16: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var start1, end1, start2,\
    \ end2 int\n    var isIntersecting bool\n    var isPrime bool\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        start1 = interval1[i].(int)\n        end1 = interval1[i].(int)\n\
    \        \n        for j := 0; j < len(interval2); j++ {\n            start2 =\
    \ interval2[j].(int)\n            end2 = interval2[j].(int)\n            \n  \
    \          if start1 < end2 {\n                if start2 < end1 {\n          \
    \          isIntersecting = true\n                    isPrime = true\n       \
    \         } else {\n                    isIntersecting = false\n             \
    \       isPrime = false\n                }\n            } else {\n           \
    \     if start1 > end2 {\n                    isIntersecting = true\n        \
    \            isPrime = true\n                } else {\n                    isIntersecting\
    \ = false\n                    isPrime = false\n                }\n          \
    \  }\n            \n            if isIntersecting {\n                if isPrime\
    \ {\n                    result = \"YES\"\n                } else {\n        \
    \            result = \"NO\"\n                }\n                break\n     \
    \       }\n        }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpx119xte7_test.go:91: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpx119xte7_test.go:91: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpx119xte7_test.go:91: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__5\
    \ (0.00s)\n        tmpx119xte7_test.go:91: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpx119xte7_test.go:91: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpx119xte7_test.go:91: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var interval1_start, interval1_end\
    \ int\n    var interval2_start, interval2_end int\n    \n    interval1_start =\
    \ interval1[0].(int)\n    interval1_end = interval1[1].(int)\n    interval2_start\
    \ = interval2[0].(int)\n    interval2_end = interval2[1].(int)\n    \n    if interval1_start\
    \ < interval2_start {\n        result = fmt.Sprintf(\"NO\")\n    } else {\n  \
    \      if interval1_end < interval2_end {\n            result = fmt.Sprintf(\"\
    NO\")\n        } else {\n            if interval1_start <= interval2_end {\n \
    \               result = fmt.Sprintf(\"YES\")\n            } else {\n        \
    \        result = fmt.Sprintf(\"NO\")\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpo1a21gw8_test.go:67: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpo1a21gw8_test.go:67: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpo1a21gw8_test.go:67: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075631
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval1 := range interval1 {\n        for _, interval2 := range interval2\
    \ {\n            if interval1.(float64) >= interval2.(float64) {\n           \
    \     continue\n            }\n            \n            result := append(result,\
    \ interval1)\n            result := append(result, interval2)\n            \n\
    \            if len(result) == 2 {\n                break\n            }\n   \
    \     }\n    }\n    \n    if len(result) == 2 {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmp85vl0h_test.go:35:20: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].(int),\
    \ interval1[1].(int)\n    interval2Start, interval2End := interval2[0].(int),\
    \ interval2[1].(int)\n    \n    if interval1Start > interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End < interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start < interval2Start && interval1End >= interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start < interval2Start && interval1End\
    \ <= interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End < interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start < interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End < interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start < interval2Start && interval1End <= interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ < interval2Start && interval1End < interval2End {\n        return \"NO\"\n \
    \   }\n    \n    if interval1Start >= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start < interval2Start && interval1End >= interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ < interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ < interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzaehuwuo_test.go:102:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval1End {\n      \
    \  return \"NO\"\n    }\n    if interval2Start > interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start <= interval2Start &&\
    \ interval1End >= interval2End\n    if intersection {\n        intersectionLength\
    \ := interval1End - interval1Start\n        if isPrime(intersectionLength) {\n\
    \            return \"YES\"\n        }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9415j81p_test.go:41:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0]\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].([]interface{})[1] > interval2[i].([]interface{})[1]\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].([]interface{})[1] < interval2[i].([]interface{})[1]\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj8n9a667_test.go:22:9: result declared but not used

    /tmp/tmpj8n9a667_test.go:35:12: invalid operation: interval1[i].([]interface{})[1]
    > interval2[i].([]interface{})[1] (operator > not defined on interface)

    /tmp/tmpj8n9a667_test.go:41:12: invalid operation: interval1[i].([]interface{})[1]
    < interval2[i].([]interface{})[1] (operator < not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var interval1Length, interval2Length int\n    var isIntersecting\
    \ bool\n\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n \
    \   }\n\n    for _, interval := range interval1 {\n        interval1Start, interval1End\
    \ = interval.([]interface{})[0].(int)\n    }\n\n    for _, interval := range interval2\
    \ {\n        interval2Start, interval2End = interval.([]interface{})[0].(int)\n\
    \    }\n\n    interval1Length = interval1End - interval1Start + 1\n    interval2Length\
    \ = interval2End - interval2Start + 1\n\n    isIntersecting = interval1Start <=\
    \ interval2End && interval2Start <= interval1End\n\n    if isIntersecting {\n\
    \        if interval1Length == interval2Length {\n            if interval1Length\
    \ == 2 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 3 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 4 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 5 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 6 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 7 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 8 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 9 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 10 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 11 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 12 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 13 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 14 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 15 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 16 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 17 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 18 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 19 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 20 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 21 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 22 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 100 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 101 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 102 {\n                return \"YES\"\n            }\n            if interval1\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfgf_xf4h_test.go:119:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].([]interface{})[0].(int) <= interval2[i].([]interface{})[0].(int)\
    \ {\n            if interval1[i].([]interface{})[0].(int) >= interval2[i].([]interface{})[1].(int)\
    \ {\n                result += fmt.Sprintf(\"(%d, %d)\\n\", interval1[i].([]interface{})[0].(int),\
    \ interval2[i].([]interface{})[1].(int))\n            } else {\n             \
    \   result += fmt.Sprintf(\"(%d, %d)\\n\", interval1[i].([]interface{})[0].(int),\
    \ interval2[i].([]interface{})[0].(int))\n            }\n        } else {\n  \
    \          if interval1[i].([]interface{})[0].(int) >= interval2[i].([]interface{})[1].(int)\
    \ {\n                result += fmt.Sprintf(\"(%d, %d)\\n\", interval1[i].([]interface{})[1].(int),\
    \ interval2[i].([]interface{})[0].(int))\n            } else {\n             \
    \   result += fmt.Sprintf(\"(%d, %d)\\n\", interval1[i].([]interface{})[1].(int),\
    \ interval2[i].([]interface{})[1].(int))\n            }\n        }\n    }\n  \
    \  \n    if result == \"(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0df5mba_test.go:44:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := interval1[0]\n    interval2 :=\
    \ interval2[0]\n    \n    if interval1.(float64) < interval2.(float64) {\n   \
    \     interval1, interval2 = interval2, interval1\n    }\n    \n    start := interval1.(float64)\n\
    \    end := interval2.(float64)\n    \n    length := end - start\n    \n    if\
    \ length == 0 {\n        return \"NO\"\n    }\n    \n    if length == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    if length == 2 && start == end {\n   \
    \     return \"YES\"\n    }\n    \n    if length == 2 && start == end + 1 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 2 && start == end - 1 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 1 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end - 1 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 2 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end - 2 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 3 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end - 3 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 4 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end - 4 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 5 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end - 5 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 6 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end - 6 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 7 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end - 7 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 8 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end - 8 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 9 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end - 9 {\n\
    \        return \"YES\"\n    }\n    \n    if length == 3 && start == end + 10\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 3 && \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbzibijbc_test.go:135:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    result := make([]interface{}, 0)\n    for _, interval\
    \ := range interval1 {\n        if interval == nil {\n            continue\n \
    \       }\n        start, end := interval.([]interface{})\n        if start >\
    \ end {\n            continue\n        }\n        for _, interval2 := range interval2\
    \ {\n            if interval2 == nil {\n                continue\n           \
    \ }\n            start, end := interval2.([]interface{})\n            if start\
    \ > end {\n                continue\n            }\n            if start <= end\
    \ {\n                result := append(result, interval)\n            }\n     \
    \   }\n    }\n    if len(result) == 0 {\n        return \"NO\"\n    }\n    length\
    \ := len(result)\n    if length == 1 {\n        return fmt.Sprintf(\"YES\")\n\
    \    }\n    if length == 2 {\n        return fmt.Sprintf(\"YES\")\n    }\n   \
    \ if length == 3 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length\
    \ == 4 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length == 5 {\n \
    \       return fmt.Sprintf(\"YES\")\n    }\n    if length == 6 {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    if length == 7 {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    if length == 8 {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if length == 9 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if\
    \ length == 10 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length ==\
    \ 11 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length == 12 {\n  \
    \      return fmt.Sprintf(\"YES\")\n    }\n    if length == 13 {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    if length == 14 {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    if length == 15 {\n        return fmt.Sprintf(\"YES\")\n  \
    \  }\n    if length == 16 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if\
    \ length == 17 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length ==\
    \ 18 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length == 19 {\n  \
    \      return fmt.Sprintf(\"YES\")\n    }\n    if length == 20 {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    if length == 21 {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    if length == 22 {\n        return fmt.Sprintf(\"YES\")\n  \
    \  }\n    if length == 100 {\n        return fmt.Sprintf(\"YES\")\n    }\n   \
    \ if length == 200 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length\
    \ == 300 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length == 400 {\n\
    \        return fmt.Sprintf(\"YES\")\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_2em4icv_test.go:130:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval1End {\n      \
    \  interval1Start, interval1End = interval1End, interval1Start\n    }\n    if\
    \ interval2Start > interval2End {\n        interval2Start, interval2End = interval2End,\
    \ interval2Start\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval2Start < interval2End {\n        interval2Start += interval1End\
    \ - interval1Start\n        interval2End += interval1End - interval1Start\n  \
    \  }\n    \n    if interval1Start < interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval1Start > interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval2Start > interval2End {\n        interval2Start +=\
    \ interval1End - interval1Start\n        interval2End += interval1End - interval1Start\n\
    \    }\n    \n    if interval1Start < interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval1Start > interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval2Start > interval2End {\n        interval2Start +=\
    \ interval1End - interval1Start\n        interval2End += interval1End - interval1Start\n\
    \    }\n    \n    if interval1Start < interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval1Start > interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval2Start > interval2End {\n        interval2Start +=\
    \ interval1End - interval1Start\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgvr88mxt_test.go:88:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1End <= interval2End\
    \ {\n        if interval1End < intersectionStart {\n            intersectionStart\
    \ = interval1End\n        }\n        if interval1End < intersectionEnd {\n   \
    \         intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        intersectionLength := intersectionEnd - intersectionStart\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvs3_5i8f_test.go:52:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var interval1Start, interval1End\
    \ int\n    var interval2Start, interval2End int\n\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n\
    \        interval1Start = interval1[i].(int)\n        interval1End = interval1Start\
    \ + 1\n        interval2Start = interval2[i].(int)\n        interval2End = interval2Start\
    \ + 1\n\n        if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n            if interval1Start < interval2Start {\n                interval1Start,\
    \ interval1End = interval2Start, interval1Start\n            }\n            if\
    \ interval1End > interval2End {\n                interval1End, interval1Start\
    \ = interval2End, interval1End\n            }\n            if interval1Start <=\
    \ interval1End {\n                result += fmt.Sprintf(\"%v-%v\\n\", interval1Start,\
    \ interval1End)\n            }\n        }\n    }\n    if result == \"NO\" {\n\
    \        return \"NO\"\n    }\n    if result == \"YES\" {\n        return \"YES\"\
    \n    }\n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpnba799yh_test.go:77: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpnba799yh_test.go:77: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpnba799yh_test.go:77:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpnba799yh_test.go:77: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpnba799yh_test.go:77: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpnba799yh_test.go:77: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpnba799yh_test.go:77:\
    \ expected 'NO', got '1-2\n            2-3\n            '\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpnba799yh_test.go:77: expected 'NO', got '-2--1\n       \
    \     '\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    result := 0\n    \n   \
    \ if interval1Start <= interval2Start {\n        result = interval1Start <= interval2End\
    \ ? interval1End : interval2End\n    } else {\n        result = interval1Start\
    \ <= interval2End ? interval2Start : interval1Start\n    }\n    \n    if result\
    \ % 2 == 0 {\n        return \"NO\"\n    }\n    \n    if result > 100 {\n    \
    \    return \"NO\"\n    }\n    \n    if result < 100 {\n        return \"YES\"\
    \n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfo0d14mt_test.go:34:49: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval := range interval1 {\n        if interval[0] < interval[1] {\n\
    \            result = append(result, interval)\n        }\n    }\n    \n    for\
    \ _, interval := range interval2 {\n        if interval[0] < interval[1] {\n \
    \           result = append(result, interval)\n        }\n    }\n    \n    if\
    \ len(result) == 0 {\n        return \"NO\"\n    }\n    \n    if len(result) ==\
    \ 1 {\n        return \"YES\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range result {\n        if interval[0] < interval[1]\
    \ {\n            result = append(result, interval)\n        }\n    }\n    \n \
    \   if len(result) == 1 {\n        return \"YES\"\n    }\n    \n    return \"\
    NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplodqym52_test.go:29:20: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmplodqym52_test.go:35:20: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmplodqym52_test.go:48:12: no new variables on left side of :=

    /tmp/tmplodqym52_test.go:51:20: invalid operation: cannot index interval (variable
    of type interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for _, interval\
    \ := range interval1 {\n        if interval == nil {\n            continue\n \
    \       }\n        \n        start, end := interval.([]interface{})\n        \n\
    \        if start > end {\n            continue\n        }\n        \n       \
    \ for _, interval2 := range interval2 {\n            if interval2 == nil {\n \
    \               continue\n            }\n            \n            start2, end2\
    \ := interval2.([]interface{})\n            \n            if start2 > end2 {\n\
    \                continue\n            }\n            \n            if start <\
    \ end2 && start2 < end {\n                result = result + \"YES\"\n        \
    \        break\n            }\n        }\n    }\n    \n    if result == \"YES\"\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt6i345sx_test.go:35:20: invalid operation: start > end (mismatched types
    []interface{} and bool)

    /tmp/tmpt6i345sx_test.go:46:25: invalid operation: start2 > end2 (mismatched types
    []interface{} and bool)

    /tmp/tmpt6i345sx_test.go:50:24: invalid operation: start < end2 (mismatched types
    []interface{} and bool)

    /tmp/tmpt6i345sx_test.go:50:41: invalid operation: start2 < end (mismatched types
    []interface{} and bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) > interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpwk1j1q6f_test.go:29 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpwk1j1q6f_test.go:64 +0xe7\ntesting.tRunner(0xc000192680, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1End < interval2Start {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n   \
    \     interval1Start += 1\n        interval1End -= 1\n    }\n    \n    if interval1End\
    \ >= interval2End {\n        interval1End -= 1\n        interval1Start += 1\n\
    \    }\n    \n    result := 0\n    \n    for i := interval1Start; i <= interval1End;\
    \ i++ {\n        for j := interval2Start; j <= interval2End; j++ {\n         \
    \   result += 1\n            if i == j {\n                continue\n         \
    \   }\n            if result % j == 0 {\n                return \"NO\"\n     \
    \       }\n        }\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: runtime error: integer divide\
    \ by zero [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5038a0, 0x5f29a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5038a0, 0x5f29a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5e00?, 0x2?, 0x2?},\
    \ {0xc0000f5de0?, 0x2?, 0x2?})\n\t/tmp/tmpus5livvt_test.go:57 +0x192\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpus5livvt_test.go:76 +0x330\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n\
    \        return \"NO\"\n    }\n\n    interval1_start, interval1_end := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2_start, interval2_end := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n\n    if interval1_end < interval2_start {\n\
    \        interval1_start, interval1_end = interval2_start, interval2_end\n   \
    \ }\n\n    if interval1_end < interval2_end {\n        interval2_start, interval2_end\
    \ = interval1_end, interval1_end\n    }\n\n    if interval1_start > interval2_end\
    \ {\n        interval1_start, interval1_end = interval2_end, interval2_end\n \
    \   }\n\n    if interval1_start > interval2_start {\n        interval2_start,\
    \ interval2_end = interval1_start, interval1_start\n    }\n\n    if interval1_start\
    \ == interval1_end {\n        if interval2_start == interval2_end {\n        \
    \    return \"YES\"\n        } else {\n            return \"NO\"\n        }\n\
    \    }\n\n    if interval1_start < interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval2_end\n    }\n\n    if interval1_start\
    \ < interval2_end {\n        interval2_start, interval2_end = interval1_start,\
    \ interval1_end\n    }\n\n    if interval1_start == interval1_end {\n        if\
    \ interval2_start == interval2_end {\n            return \"YES\"\n        } else\
    \ {\n            return \"NO\"\n        }\n    }\n\n    if interval1_start < interval2_start\
    \ {\n        interval1_start, interval1_end = interval2_start, interval2_end\n\
    \    }\n\n    if interval1_start < interval2_end {\n        interval2_start, interval2_end\
    \ = interval1_start, interval1_end\n    }\n\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            return \"YES\"\
    \n        } else {\n            return \"NO\"\n        }\n    }\n\n    if interval1_start\
    \ < interval2_start {\n        interval1_start, interval1_end = interval2_start,\
    \ interval2_end\n    }\n\n    if interval1_start < interval2_end {\n        interval2_start,\
    \ interval2_end = interval1_start, interval1_end\n    }\n\n    if interval1_start\
    \ == interval1_end {\n        if interval2_start == interval2_end {\n        \
    \    return \"YES\"\n        } else {\n            return \"NO\"\n        }\n\
    \    }\n\n    if interval1_start < interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval2_end\n    }\n\n    if interval1_start\
    \ < interval2_end {\n        interval2_start, interval2_end = interval1_start,\
    \ interval1_end\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1ojmn27w_test.go:108:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Your code here\n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbs07kh_q_test.go:277:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval2Start\
    \ > interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start {\n            if interval1End > intersectionEnd\
    \ {\n                intersectionEnd = interval1End\n            }\n        }\
    \ else {\n            if interval1Start < intersectionStart {\n              \
    \  intersectionStart = interval1Start\n            }\n        }\n    }\n    \n\
    \    if intersectionStart <= intersectionEnd {\n        if intersectionEnd > interval2End\
    \ {\n            return \"NO\"\n        }\n        \n        if intersectionEnd\
    \ <= interval2End {\n            if intersectionEnd > intersectionStart {\n  \
    \              intersectionEnd = intersectionEnd\n            }\n        } else\
    \ {\n            if intersectionEnd < interval2Start {\n                intersectionEnd\
    \ = interval2End\n            }\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionEnd > interval2End {\n        \
    \    return \"NO\"\n        }\n        \n        if intersectionEnd <= interval2End\
    \ {\n            if intersectionEnd > intersectionStart {\n                intersectionEnd\
    \ = intersectionEnd\n            }\n        } else {\n            if intersectionEnd\
    \ < interval2Start {\n                intersectionEnd = interval2End\n       \
    \     }\n        }\n    }\n    \n    if intersectionStart <= intersectionEnd {\n\
    \        if intersectionEnd > interval2End {\n            return \"NO\"\n    \
    \    }\n        \n        if intersectionEnd <= interval2End {\n            if\
    \ intersectionEnd > intersectionStart {\n                intersectionEnd = intersectionEnd\n\
    \            }\n        } else {\n            if intersectionEnd < interval2Start\
    \ {\n                intersectionEnd = interval2End\n            }\n        }\n\
    \    }\n    \n    if intersectionStart <= intersectionEnd {\n        if intersectionEnd\
    \ > interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ intersectionEnd <= interval2End {\n            if intersectionEnd > intersectionStart\
    \ {\n                intersectionEnd = intersectionEnd\n            }\n      \
    \  } else {\n            if intersectionEnd < interval2Start {\n             \
    \   intersectionEnd = interval2End\n            }\n        }\n    }\n    \n  \
    \  if \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7v81avvl_test.go:122:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    if len(interval1) > len(interval2)\
    \ {\n        interval1, interval2 = interval2, interval1\n    }\n    for i :=\
    \ 0; i < len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    if\
    \ result == \"NO\" {\n        result = \"YES\"\n    }\n    return result\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmp886l69u2_test.go:27\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmp886l69u2_test.go:45\
    \ +0xe45\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) <= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpb65zxz_w_test.go:29 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpb65zxz_w_test.go:64 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval2);\
    \ i++ {\n        interval2Start := interval2[i].(float64)\n        interval2End\
    \ := interval2[i+1].(float64)\n        \n        if interval2Start > interval2End\
    \ {\n            return \"NO\"\n        }\n        if interval2End < interval2Start\
    \ {\n            return \"NO\"\n        }\n        \n        if intersectionStart\
    \ > interval2End {\n            return \"NO\"\n        }\n        if intersectionEnd\
    \ < interval2Start {\n            return \"NO\"\n        }\n        \n       \
    \ if intersectionStart <= intersectionEnd {\n            intersectionStart = interval2Start\n\
    \            intersectionEnd = interval2End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp2usf2ein_test.go:26 +0x26b\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp2usf2ein_test.go:78 +0xe7\ntesting.tRunner(0xc000192680, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if interval1Start <= interval2Start {\n        interval1Start += interval1End\
    \ - interval2Start\n        interval1End -= interval2End - interval1Start\n  \
    \  }\n    if interval1End >= interval2End {\n        interval1End -= interval2End\
    \ - interval1Start\n        interval1Start += interval2End - interval1Start\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        return \"NO\"\
    \n    }\n    if interval1End >= interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2End {\n        interval1Start += interval1End\
    \ - interval2Start\n        interval1End -= interval2End - interval1Start\n  \
    \  }\n    if interval1End >= interval2End {\n        interval1End -= interval2End\
    \ - interval1Start\n        interval1Start += interval2End - interval1Start\n\
    \    }\n    \n    if interval1Start <= interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1End >= interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2End {\n        interval1Start += interval1End\
    \ - interval2Start\n        interval1End -= interval2End - interval1Start\n  \
    \  }\n    if interval1End >= interval2End {\n        interval1End -= interval2End\
    \ - interval1Start\n        interval1Start += interval2End - interval1Start\n\
    \    }\n    \n    if interval1Start <= interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1End >= interval2End {\n        return \"NO\"\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyg6epczr_test.go:97:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Write your code here\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptrb6rco4_test.go:277:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, len(interval1))\n\
    \    for i, v := range interval1 {\n        result[i] = v\n    }\n    for i, v\
    \ := range interval2 {\n        if result[i] < v {\n            result[i] = v\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, len(result))\n    for i, v := range\
    \ result {\n        if result[i] == v {\n            continue\n        }\n   \
    \     \n        if result[i] < v {\n            result[i] = v\n        }\n   \
    \ }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n   \
    \ result := make([]interface{}, len(result))\n    for i, v := range result {\n\
    \        if result[i] == v {\n            continue\n        }\n        \n    \
    \    if result[i] > v {\n            result[i] = v\n        }\n    }\n    \n \
    \   if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ len(result))\n    for i, v := range result {\n        if result[i] == v {\n\
    \            continue\n        }\n        \n        if result[i] < v {\n     \
    \       result[i] = v\n        }\n    }\n    \n    if len(result) == 0 {\n   \
    \     return \"NO\"\n    }\n    \n    result := make([]interface{}, len(result))\n\
    \    for i, v := range result {\n        if result[i] == v {\n            continue\n\
    \        }\n        \n        if result[i] > v {\n            result[i] = v\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, len(result))\n    for i, v := range\
    \ result {\n        if result[i] == v {\n            continue\n        }\n   \
    \     \n        if result[i] < v {\n            result[i] = v\n        }\n   \
    \ }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n   \
    \ result := make([]interface{}, len(result))\n    for i, v := range result {\n\
    \        if result[i] == v {\n            continue\n        }\n        \n    \
    \    if result[i] > v {\n            result[i] = v\n        }\n    }\n    \n \
    \   if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ len(result))\n    for i, v := range result {\n        if result[i] == v {\n\
    \            continue\n        }\n        \n        if result[i] < v {\n     \
    \       result[i] = v\n        }\n    }\n    \n    if len(result) == 0 {\n   \
    \     return \"NO\"\n    }\n    \n    result := make([]interface\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpowqv50no_test.go:146:1: expected ''{'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2Start && interval1End < interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start && interval1End\
    \ >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start\
    \ && interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ < interval2Start && interval1End < interval2End {\n        return \"NO\"\n \
    \   }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"NO\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"NO\"\n  \
    \  }\n    if interval1Start >= interval2Start && interval1End < interval2End {\n\
    \        return \"NO\"\n    }\n    if interval1Start < interval2Start && interval1End\
    \ >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start\
    \ && interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ < interval2Start && interval1End < interval2End {\n        return \"NO\"\n \
    \   }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0ve_9xn__test.go:38:5: intersectionLength declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var interval1Start int\n\
    \    var interval1End int\n    var interval2Start int\n    var interval2End int\n\
    \    var isIntersecting bool\n\n    if len(interval1) != len(interval2) {\n  \
    \      return \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n   \
    \     interval1Start = interval1[i].(int)\n        interval1End = interval1[i].(int)\n\
    \    }\n\n    for i := 0; i < len(interval2); i++ {\n        interval2Start =\
    \ interval2[i].(int)\n        interval2End = interval2[i].(int)\n    }\n\n   \
    \ isIntersecting = interval1Start <= interval2End && interval2Start <= interval1End\n\
    \n    if isIntersecting {\n        if interval1Start > interval2Start {\n    \
    \        interval1Start, interval2Start = interval2Start, interval1Start\n   \
    \     }\n\n        if interval1End < interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n\n        if interval1Start\
    \ <= interval2Start {\n            interval1Start, interval2Start = interval2Start,\
    \ interval1Start\n        }\n\n        if interval1End >= interval2End {\n   \
    \         interval1End, interval2End = interval2End, interval1End\n        }\n\
    \n        if interval1Start <= interval2End {\n            interval1Start, interval2End\
    \ = interval2End, interval1End\n        }\n\n        if interval1Start <= interval2Start\
    \ {\n            interval1Start, interval2Start = interval2Start, interval1Start\n\
    \        }\n\n        if interval1End >= interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n\n        if interval1Start\
    \ <= interval2End {\n            interval1Start, interval2End = interval2End,\
    \ interval1End\n        }\n\n        if interval1Start <= interval2Start {\n \
    \           interval1Start, interval2Start = interval2Start, interval1Start\n\
    \        }\n\n        if interval1End >= interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n\n        if interval1Start\
    \ <= interval2End {\n            interval1Start, interval2End = interval2End,\
    \ interval1End\n        }\n\n        if interval1Start <= interval2Start {\n \
    \           interval1Start, interval2Start = interval2Start, interval1Start\n\
    \        }\n\n        if interval1End >= interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n\n        if interval1Start\
    \ <= interval2Start {\n            interval1Start, interval2Start = interval2Start,\
    \ interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm23zi416_test.go:100:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075632
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) <= interval2[i].(float64)\
    \ {\n            result += fmt.Sprintf(\"%v\", interval1[i])\n        } else {\n\
    \            result += fmt.Sprintf(\"%v\", interval2[i])\n        }\n    }\n \
    \   \n    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0, 0x2, 0x2?},\
    \ {0xc0000f5ca0, 0x2?, 0x2?})\n\t/tmp/tmp34w4zp6y_test.go:29 +0x217\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp34w4zp6y_test.go:54 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075634
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval := range interval1 {\n        start := interval.([]interface{})[0].(int)\n\
    \        end := interval.([]interface{})[1].(int)\n        \n        if start\
    \ < end {\n            result = append(result, interval)\n        }\n    }\n \
    \   \n    for _, interval := range interval2 {\n        start := interval.([]interface{})[0].(int)\n\
    \        end := interval.([]interface{})[1].(int)\n        \n        if start\
    \ < end {\n            result = append(result, interval)\n        }\n    }\n \
    \   \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]interface{}, 0)\n    \n    for _, interval := range result {\n   \
    \     start := interval.([]interface{})[0].(int)\n        end := interval.([]interface{})[1].(int)\n\
    \        \n        if start <= end {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval :=\
    \ range result {\n        start := interval.([]interface{})[0].(int)\n       \
    \ end := interval.([]interface{})[1].(int)\n        \n        if start <= end\
    \ {\n            result = append(result, interval)\n        }\n    }\n    \n \
    \   if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range result {\n        start := interval.([]interface{})[0].(int)\n\
    \        end := interval.([]interface{})[1].(int)\n        \n        if start\
    \ <= end {\n            result = append(result, interval)\n        }\n    }\n\
    \    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]interface{}, 0)\n    \n    for _, interval := range result {\n   \
    \     start := interval.([]interface{})[0].(int)\n        end := interval.([]interface{})[1].(int)\n\
    \        \n        if start <= end {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval :=\
    \ range result {\n        start := interval.([]interface{})[0].(int)\n       \
    \ end := interval.([]interface{})[1].(int)\n        \n        if start <= end\
    \ {\n            result = append(result, interval)\n        }\n    }\n    \n \
    \   if len(result) == 0 {\n        return \"NO\"\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo3d190g2_test.go:124:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075633
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n\n    if interval1Start > interval2End {\n\
    \        return \"NO\"\n    }\n\n    if interval1End < interval2Start {\n    \
    \    return \"NO\"\n    }\n\n    if interval1Start > interval2Start {\n      \
    \  return \"NO\"\n    }\n\n    if interval1End < interval2End {\n        return\
    \ \"NO\"\n    }\n\n    if interval1Start <= interval2Start && interval1End >=\
    \ interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        return \"YES\"\n    }\n\n    if\
    \ interval1Start >= interval2Start && interval1End <= interval2End {\n       \
    \ return \"YES\"\n    }\n\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzjmj86no_test.go:29:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpzjmj86no_test.go:33:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpzjmj86no_test.go:37:8: invalid operation: interval1Start > interval2Start
    (operator > not defined on interface)

    /tmp/tmpzjmj86no_test.go:41:8: invalid operation: interval1End < interval2End
    (operator < not defined on interface)

    /tmp/tmpzjmj86no_test.go:45:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpzjmj86no_test.go:45:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpzjmj86no_test.go:49:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpzjmj86no_test.go:49:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpzjmj86no_test.go:53:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpzjmj86no_test.go:53:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpzjmj86no_test.go:53:44: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075633
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        return \"NO\"\
    \n    }\n    if interval1End >= interval2End {\n        return \"NO\"\n    }\n\
    \    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqu_nl70b_test.go:29:8: invalid operation: interval1Start > interval1End
    (operator > not defined on interface)

    /tmp/tmpqu_nl70b_test.go:32:8: invalid operation: interval2Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpqu_nl70b_test.go:36:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpqu_nl70b_test.go:36:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpqu_nl70b_test.go:39:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpqu_nl70b_test.go:39:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpqu_nl70b_test.go:43:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpqu_nl70b_test.go:46:8: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    for _,\
    \ v := range interval1 {\n        if v == nil {\n            continue\n      \
    \  }\n        \n        start := v.(int)\n        end := interval2[len(interval2)-1].(int)\n\
    \        if start > end {\n            start, end = end, start\n        }\n  \
    \      \n        if start <= end {\n            result = append(result, start)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n \
    \   result := make([]interface{}, 0)\n    for _, v := range result {\n       \
    \ if v == nil {\n            continue\n        }\n        \n        start := v.(int)\n\
    \        end := interval2[len(interval2)-1].(int)\n        if start > end {\n\
    \            start, end = end, start\n        }\n        \n        if start <=\
    \ end {\n            result = append(result, end)\n        }\n    }\n    \n  \
    \  if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    if len(result)\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    for _, v := range result {\n        if v == nil {\n            continue\n\
    \        }\n        \n        start := v.(int)\n        end := interval2[len(interval2)-1].(int)\n\
    \        if start > end {\n            start, end = end, start\n        }\n  \
    \      \n        if start <= end {\n            result = append(result, start)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n \
    \   result := make([]interface{}, 0)\n    for _, v := range result {\n       \
    \ if v == nil {\n            continue\n        }\n        \n        start := v.(int)\n\
    \        end := interval2[len(interval2)-1].(int)\n        if start > end {\n\
    \            start, end = end, start\n        }\n        \n        if start <=\
    \ end {\n            result = append(result, end)\n        }\n    }\n    \n  \
    \  if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    if len(result)\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    for _, v := range result {\n        if v == nil {\n            continue\n\
    \        }\n        \n        start := v.(int)\n        end := interval2[len(interval2)-1].(int)\n\
    \        if start > end {\n            start, end = end, start\n        }\n  \
    \      \n        if start <= end {\n            result = append(result, \nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplz5cpuwv_test.go:140:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075633
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := interval1[0].([]int)\n    interval2\
    \ := interval2[0].([]int)\n    \n    i := 0\n    for i < len(interval1) {\n  \
    \      if interval1[i] > interval2[i] {\n            break\n        }\n      \
    \  i++\n    }\n    \n    j := 0\n    for j < len(interval2) {\n        if interval2[j]\
    \ > interval1[j] {\n            break\n        }\n        j++\n    }\n    \n \
    \   if i == len(interval1) && j == len(interval2) {\n        return \"YES\"\n\
    \    }\n    \n    if i == len(interval1) {\n        return \"NO\"\n    }\n   \
    \ \n    if j == len(interval2) {\n        return \"NO\"\n    }\n    \n    if interval1[i]\
    \ < interval2[j] {\n        return \"NO\"\n    }\n    \n    if interval1[i] >\
    \ interval2[j] {\n        return \"NO\"\n    }\n    \n    if interval1[i] == interval2[j]\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1[i] < interval2[j] {\n\
    \        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqxtqj7t9_test.go:26:15: no new variables on left side of :=

    /tmp/tmpqxtqj7t9_test.go:26:18: cannot use interval1[0].([]int) (comma, ok expression
    of type []int) as type []interface{} in assignment

    /tmp/tmpqxtqj7t9_test.go:27:15: no new variables on left side of :=

    /tmp/tmpqxtqj7t9_test.go:27:18: cannot use interval2[0].([]int) (comma, ok expression
    of type []int) as type []interface{} in assignment

    /tmp/tmpqxtqj7t9_test.go:31:12: invalid operation: interval1[i] > interval2[i]
    (operator > not defined on interface)

    /tmp/tmpqxtqj7t9_test.go:39:12: invalid operation: interval2[j] > interval1[j]
    (operator > not defined on interface)

    /tmp/tmpqxtqj7t9_test.go:57:8: invalid operation: interval1[i] < interval2[j]
    (operator < not defined on interface)

    /tmp/tmpqxtqj7t9_test.go:61:8: invalid operation: interval1[i] > interval2[j]
    (operator > not defined on interface)

    /tmp/tmpqxtqj7t9_test.go:69:8: invalid operation: interval1[i] < interval2[j]
    (operator < not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075633
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Map := make(map[int]bool)\n    interval2Map\
    \ := make(map[int]bool)\n    \n    for _, v := range interval1 {\n        interval1Map[v]\
    \ = true\n    }\n    for _, v := range interval2 {\n        interval2Map[v] =\
    \ true\n    }\n    \n    result := make([]int, 0)\n    for k := range interval1Map\
    \ {\n        if interval2Map[k] {\n            result = append(result, k)\n  \
    \      }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n\
    \    \n    if len(result) == 1 {\n        return fmt.Sprintf(\"YES\")\n    }\n\
    \    \n    result := make([]int, 0)\n    for _, v := range result {\n        if\
    \ isPrime(float64(len(result))) && isPrime(float64(len(result))-1) {\n       \
    \     return fmt.Sprintf(\"YES\")\n        }\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5lozoh43_test.go:30:22:\
    \ cannot use v (variable of type interface{}) as type int in map index:\n\tneed\
    \ type assertion\n/tmp/tmp5lozoh43_test.go:33:22: cannot use v (variable of type\
    \ interface{}) as type int in map index:\n\tneed type assertion\n/tmp/tmp5lozoh43_test.go:51:12:\
    \ no new variables on left side of :=\n/tmp/tmp5lozoh43_test.go:52:12: v declared\
    \ but not used\n/tmp/tmp5lozoh43_test.go:53:12: undefined: isPrime\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval := range interval1 {\n        start = interval.([]interface{})[0].(int)\n\
    \        end = interval.([]interface{})[1].(int)\n        \n        if start <=\
    \ end {\n            result = append(result, interval)\n        }\n    }\n   \
    \ \n    for _, interval := range interval2 {\n        start = interval.([]interface{})[0].(int)\n\
    \        end = interval.([]interface{})[1].(int)\n        \n        if start <=\
    \ end {\n            result = append(result, interval)\n        }\n    }\n   \
    \ \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]interface{}, 0)\n    \n    for _, interval := range result {\n   \
    \     start = interval.([]interface{})[0].(int)\n        end = interval.([]interface{})[1].(int)\n\
    \        \n        if start <= end {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval :=\
    \ range result {\n        start = interval.([]interface{})[0].(int)\n        end\
    \ = interval.([]interface{})[1].(int)\n        \n        if start <= end {\n \
    \           result = append(result, interval)\n        }\n    }\n    \n    if\
    \ len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range result {\n        start = interval.([]interface{})[0].(int)\n\
    \        end = interval.([]interface{})[1].(int)\n        \n        if start <=\
    \ end {\n            result = append(result, interval)\n        }\n    }\n   \
    \ \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]interface{}, 0)\n    \n    for _, interval := range result {\n   \
    \     start = interval.([]interface{})[0].(int)\n        end = interval.([]interface{})[1].(int)\n\
    \        \n        if start <= end {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval :=\
    \ range result {\n        start = interval.([]interface{})[0].(int)\n        end\
    \ = interval.([]interface{})[1].(int)\n        \n        if start <= end {\n \
    \           result = append(result, interval)\n        }\n    }\n    \n    if\
    \ len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ye1xot4_test.go:127:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, len(interval1))\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        result[i] = interval1[i]\n\
    \    }\n    \n    for i := 0; i < len(interval2); i++ {\n        result[i] = interval2[i]\n\
    \    }\n    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n    \n    result := append(result, interval1...)\n\
    \    result := append(result, interval2...)\n    \n    result := append(result,\
    \ interval1...)\n    result := append(result, interval2...)\n    \n    result\
    \ := append(result, interval1...)\n    result := append(result, interval2...)\n\
    \    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n    \n    result := append(result, interval1...)\n\
    \    result := append(result, interval2...)\n    \n    result := append(result,\
    \ interval1...)\n    result := append(result, interval2...)\n    \n    result\
    \ := append(result, interval1...)\n    result := append(result, interval2...)\n\
    \    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n    \n    result := append(result, interval1...)\n\
    \    result := append(result, interval2...)\n    \n    result := append(result,\
    \ interval1...)\n    result := append(result, interval2...)\n    \n    result\
    \ := append(result, interval1...)\n    result := append(result, interval2...)\n\
    \    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n    \n    result := append(result, interval1...)\n\
    \    result := append(result, interval2...)\n    \n    result := append(result,\
    \ interval1...)\n    result := append(result, interval2...)\n    \n    result\
    \ := append(result, interval1...)\n    result := append(result, interval2...)\n\
    \    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv7fvxr_m_test.go:102:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075633
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1Start < interval1End\
    \ {\n        interval1End += 1\n        \n        for interval2Start < interval2End\
    \ {\n            interval2End += 1\n            \n            if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n                intersectionStart\
    \ = interval1Start\n                intersectionEnd = interval1End\n         \
    \       break\n            }\n            if interval1Start <= interval2End &&\
    \ interval1End >= interval2Start {\n                intersectionStart = interval1End\n\
    \                intersectionEnd = interval1End\n                break\n     \
    \       }\n            if interval1Start <= interval2Start && interval1End <=\
    \ interval2End {\n                intersectionStart = interval1Start\n       \
    \         intersectionEnd = interval1End\n                break\n            }\n\
    \        }\n    }\n    \n    if intersectionStart > intersectionEnd {\n      \
    \  return \"NO\"\n    }\n    \n    if intersectionStart <= intersectionEnd {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp48w98m3o_test.go:26 +0x205\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp48w98m3o_test.go:83 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075634
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make(map[int]bool)\n    for _, v :=\
    \ range interval1 {\n        result[v] = true\n    }\n    for _, v := range interval2\
    \ {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    length := 0\n    for _, v := range result {\n        if\
    \ v {\n            length++\n        }\n    }\n    if length == 2 {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1vrqcktr_test.go:28:16:\
    \ cannot use v (variable of type interface{}) as type int in map index:\n\tneed\
    \ type assertion\n/tmp/tmp1vrqcktr_test.go:31:28: cannot use v (variable of type\
    \ interface{}) as type int in map index:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var isIntersect bool\n \
    \   \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    for _, interval := range interval1 {\n        if interval == nil {\n\
    \            continue\n        }\n        \n        if interval2 != nil {\n  \
    \          isIntersect = true\n        } else {\n            isIntersect = false\n\
    \        }\n        \n        if interval[0] > interval[1] {\n            interval[0],\
    \ interval[1] = interval[1], interval[0]\n        }\n        \n        if isIntersect\
    \ {\n            result += \"(\" + fmt.Sprint(interval[0]) + \", \" + fmt.Sprint(interval[1])\
    \ + \")\"\n        }\n    }\n    \n    if result != \"\" {\n        if isPrime(result)\
    \ {\n            return \"YES\"\n        } else {\n            return \"NO\"\n\
    \        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ghhal3j_test.go:40:20: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmp5ghhal3j_test.go:41:48: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmp5ghhal3j_test.go:45:48: invalid operation: cannot index interval (variable
    of type interface{})

    /tmp/tmp5ghhal3j_test.go:50:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    result := make([]interface{}, 0)\n    for _, interval\
    \ := range interval1 {\n        if interval[0] < interval[1] {\n            result\
    \ = append(result, interval)\n        }\n    }\n\n    for _, interval := range\
    \ interval2 {\n        if interval[0] < interval[1] {\n            result = append(result,\
    \ interval)\n        }\n    }\n\n    if len(result) == 0 {\n        return \"\
    NO\"\n    }\n\n    length := 0\n    for _, interval := range result {\n      \
    \  length = length + interval[1] - interval[0]\n    }\n\n    if length == 1 {\n\
    \        return \"YES\"\n    }\n\n    if length == 2 && result[0][0] == result[1][0]\
    \ {\n        return \"YES\"\n    }\n\n    if length == 2 && result[0][0] == result[1][1]\
    \ {\n        return \"YES\"\n    }\n\n    if length == 2 && result[1][0] == result[0][1]\
    \ {\n        return \"YES\"\n    }\n\n    if length == 3 && result[0][0] == result[1][1]\
    \ && result[1][0] == result[2][1] {\n        return \"YES\"\n    }\n\n    if length\
    \ == 3 && result[0][0] == result[1][1] && result[1][1] == result[2][0] {\n   \
    \     return \"YES\"\n    }\n\n    if length == 3 && result[1][0] == result[0][1]\
    \ && result[1][1] == result[2][0] {\n        return \"YES\"\n    }\n\n    if length\
    \ == 3 && result[1][0] == result[2][0] && result[1][1] == result[0][1] {\n   \
    \     return \"YES\"\n    }\n\n    if length == 3 && result[2][0] == result[0][1]\
    \ && result[2][1] == result[1][1] {\n        return \"YES\"\n    }\n\n    if length\
    \ == 3 && result[2][0] == result[1][1] && result[2][1] == result[0][1] {\n   \
    \     return \"YES\"\n    }\n\n    if length == 3 && result[2][0] == result[0][1]\
    \ && result[2][1] == result[1][1] {\n        return \"YES\"\n    }\n\n    if length\
    \ == 3 && result[0][0] == result[1][1] && result[1][1] == result[2][1] {\n   \
    \     return \"YES\"\n    }\n\n    if length == 3 && result[0][0] == result[1][1]\
    \ && result[1][1] == result[2][1] {\n        return \"YES\"\n    }\n\n    if length\
    \ == 3 && result[1][0] == result[2][1] && result[1][1] == result[0][1] {\n   \
    \     return \"YES\"\n    }\n\n    if length == 3 && result[1][0] == result[2][1]\
    \ && result[1][1] == result[0][1] {\n        return \"YES\"\n    }\n\n    if length\
    \ == 3 && result[2][0] == result[0][1] && result[2][1] == result[1][1] {\n   \
    \     return \"YES\"\n    }\n\n    if length == 3 && result[2][0] == result[1][1]\
    \ && result[2][1] == result[0][1] {\n        return \"YES\"\n    }\n\n    if length\
    \ == 3 && result[2][0] == result[0][1] && \nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjrk2xm4__test.go:117:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0]\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x504ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpbw9fnyhk_test.go:29\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpbw9fnyhk_test.go:53\
    \ +0x163c\ntesting.tRunner(0xc0001a0340, 0x529f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0]\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if isPrime(interval1[0].([]interface{})[1])\
    \ && isPrime(interval2[0].([]interface{})[1]) {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7rdnvu5c_test.go:39:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n \
    \   interval2 := make([]int, len(interval2))\n    \n    for i, v := range interval1\
    \ {\n        interval1[i] = v.(int)\n    }\n    for i, v := range interval2 {\n\
    \        interval2[i] = v.(int)\n    }\n    \n    result := make([]int, len(interval1))\n\
    \    \n    for i, v := range interval1 {\n        for j, w := range interval2\
    \ {\n            if v >= w {\n                result[i] = v\n                break\n\
    \            }\n        }\n    }\n    \n    if len(result) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    result := make([]int, len(result))\n    \n    for i,\
    \ v := range result {\n        if v == 0 {\n            result[i] = 1\n      \
    \  }\n    }\n    \n    result := make([]int, len(result))\n    \n    for i, v\
    \ := range result {\n        if v == 1 {\n            result[i] = 1\n        }\n\
    \    }\n    \n    result := make([]int, len(result))\n    \n    for i, v := range\
    \ result {\n        if v == 2 {\n            result[i] = 1\n        }\n    }\n\
    \    \n    result := make([]int, len(result))\n    \n    for i, v := range result\
    \ {\n        if v == 3 {\n            result[i] = 1\n        }\n    }\n    \n\
    \    result := make([]int, len(result))\n    \n    for i, v := range result {\n\
    \        if v == 4 {\n            result[i] = 1\n        }\n    }\n    \n    result\
    \ := make([]int, len(result))\n    \n    for i, v := range result {\n        if\
    \ v == 5 {\n            result[i] = 1\n        }\n    }\n    \n    result := make([]int,\
    \ len(result))\n    \n    for i, v := range result {\n        if v == 6 {\n  \
    \          result[i] = 1\n        }\n    }\n    \n    result := make([]int, len(result))\n\
    \    \n    for i, v := range result {\n        if v == 7 {\n            result[i]\
    \ = 1\n        }\n    }\n    \n    result := make([]int, len(result))\n    \n\
    \    for i, v := range result {\n        if v == 8 {\n            result[i] =\
    \ 1\n        }\n    }\n    \n    result := make([]int, len(result))\n    \n  \
    \  for i, v := range result {\n        if v == 9 {\n            result[i] = 1\n\
    \        }\n    }\n    \n    result := make([]int, len(result))\n    \n    for\
    \ i, v := range result {\n        if v == 10 {\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjw_kn_8t_test.go:136:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].(int),\
    \ interval1[1].(int)\n    interval2Start, interval2End := interval2[0].(int),\
    \ interval2[1].(int)\n    \n    if interval1Start > interval2End {\n        return\
    \ fmt.Sprintf(\"NO\")\n    }\n    if interval1End < interval2Start {\n       \
    \ return fmt.Sprintf(\"NO\")\n    }\n    \n    result := 0\n    \n    for i :=\
    \ interval1Start; i <= interval1End; i++ {\n        if interval2Start <= i &&\
    \ i <= interval2End {\n            result += i\n        }\n    }\n    \n    if\
    \ result % 2 == 0 {\n        return fmt.Sprintf(\"YES\")\n    }\n    return fmt.Sprintf(\"\
    NO\")\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpjk68dl7f_test.go:70: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpjk68dl7f_test.go:70: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpjk68dl7f_test.go:70: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2End && interval1End <= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9vwfxem5_test.go:91:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End\
    \ - interval2Start - interval2End\n    if intersection <= 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_wfmldxt_test.go:43:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var start int\n    var end\
    \ int\n    var length int\n    var isPrime bool\n    \n    if len(interval1) !=\
    \ len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        start = interval1[i].(float64)\n        end = interval2[i].(float64)\n\
    \        \n        if start > end {\n            fmt.Println(\"start > end\")\n\
    \            return \"NO\"\n        }\n        \n        length = end - start\n\
    \        \n        if length == 0 {\n            fmt.Println(\"length == 0\")\n\
    \            return \"NO\"\n        }\n        \n        isPrime = true\n    \
    \    \n        for j := 0; j < length; j++ {\n            if j%2 == 0 {\n    \
    \            isPrime = false\n                break\n            }\n        }\n\
    \        \n        if isPrime {\n            result = \"YES\"\n            break\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplrilts4e_test.go:33:17: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmplrilts4e_test.go:34:15: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].(int),\
    \ interval1[1].(int)\n    interval2Start, interval2End := interval2[0].(int),\
    \ interval2[1].(int)\n    \n    if interval1Start > interval2End {\n        return\
    \ \"NO\"\n    }\n    if interval1End < interval2Start {\n        return \"NO\"\
    \n    }\n    \n    result := 0\n    \n    for i := 0; i < interval1End; i++ {\n\
    \        if interval1Start <= i && i <= interval2End {\n            result +=\
    \ i\n        }\n    }\n    \n    if result % 2 == 0 {\n        return \"NO\"\n\
    \    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdu36uf17_test.go:71: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpdu36uf17_test.go:71: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpdu36uf17_test.go:71: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpdu36uf17_test.go:71: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make(map[int]bool)\n    for _, v :=\
    \ range interval1 {\n        result[v] = true\n    }\n    for _, v := range interval2\
    \ {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    result := make(map[int]bool)\n    for _, v := range interval1\
    \ {\n        result[v] = true\n    }\n    for _, v := range interval2 {\n    \
    \    if _, ok := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n\
    \    \n    result := make(map[int]bool)\n    for _, v := range interval1 {\n \
    \       result[v] = true\n    }\n    for _, v := range interval2 {\n        if\
    \ _, ok := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n   \
    \ \n    result := make(map[int]bool)\n    for _, v := range interval1 {\n    \
    \    result[v] = true\n    }\n    for _, v := range interval2 {\n        if _,\
    \ ok := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n    \n\
    \    result := make(map[int]bool)\n    for _, v := range interval1 {\n       \
    \ result[v] = true\n    }\n    for _, v := range interval2 {\n        if _, ok\
    \ := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n    \n   \
    \ result := make(map[int]bool)\n    for _, v := range interval1 {\n        result[v]\
    \ = true\n    }\n    for _, v := range interval2 {\n        if _, ok := result[v];\
    \ !ok {\n            return \"NO\"\n        }\n    }\n    \n    result := make(map[int]bool)\n\
    \    for _, v := range interval1 {\n        result[v] = true\n    }\n    for _,\
    \ v := range interval2 {\n        if _, ok := result[v]; !ok {\n            return\
    \ \"NO\"\n        }\n    }\n    \n    result := make(map[int]bool)\n    for _,\
    \ v := range interval1 {\n        result[v] = true\n    }\n    for _, v := range\
    \ interval2 {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\
    \n        }\n    }\n    \n    result := make(map[int]bool)\n    for _, v := range\
    \ interval1 {\n        result[v] = true\n    }\n    for _, v := range interval2\
    \ {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    result := make(map[int]bool)\n    for \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvsm8xtkh_test.go:118:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1Start < interval1End\
    \ {\n        interval1End += 1\n        \n        for interval2Start < interval2End\
    \ {\n            interval2End += 1\n            \n            if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n                intersectionStart\
    \ = interval1Start\n                intersectionEnd = interval1End\n         \
    \   }\n            if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n                intersectionStart = interval1End\n                intersectionEnd\
    \ = interval1Start\n            }\n            if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n                intersectionStart = interval1Start\n\
    \                intersectionEnd = interval1End\n            }\n            if\
    \ interval1Start >= interval2Start && interval1End <= interval2End {\n       \
    \         intersectionStart = interval1End\n                intersectionEnd =\
    \ interval1Start\n            }\n            if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n                intersectionStart = interval1Start\n\
    \                intersectionEnd = interval1End\n            }\n        }\n  \
    \  }\n    \n    if intersectionStart <= intersectionEnd {\n        if intersectionStart\
    \ % 2 == 0 {\n            return \"YES\"\n        }\n        return \"NO\"\n \
    \   }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwe5y483f_test.go:71:12: invalid operation: operator % not defined on intersectionStart
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2End\
    \ && interval2Start <= interval1End {\n        \n        if interval1Start < interval2Start\
    \ {\n            interval1Start, interval2Start = interval2Start, interval1Start\n\
    \        }\n        if interval1End > interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n        \n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            \n        \
    \    if interval1Start < interval2End {\n                interval1Start, interval2End\
    \ = interval2End, interval1Start\n            }\n            if interval1End >\
    \ interval2Start {\n                interval1End, interval2Start = interval2Start,\
    \ interval1End\n            }\n            \n            if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n                \n       \
    \         if interval1Start < interval2End {\n                    interval1Start,\
    \ interval2End = interval2End, interval1Start\n                }\n           \
    \     if interval1End > interval2Start {\n                    interval1End, interval2Start\
    \ = interval2Start, interval1End\n                }\n                \n      \
    \          if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n                    \n                    if interval1Start < interval2End\
    \ {\n                        interval1Start, interval2End = interval2End, interval1Start\n\
    \                    }\n                    if interval1End > interval2Start {\n\
    \                        interval1End, interval2Start = interval2Start, interval1End\n\
    \                    }\n                    \n                    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n                      \
    \  \n                        if interval1Start < interval2End {\n            \
    \                interval1Start, interval2End = interval2End, interval1Start\n\
    \                        }\n                        if interval1End > interval2Start\
    \ {\n                            interval1End, interval2Start = interval2Start,\
    \ interval1End\n                        }\n                        \n        \
    \                if interval1Start <= interval\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptziy33xx_test.go:82:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0]\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].([]interface{})[1] > interval2[i].([]interface{})[1]\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].([]interface{})[1] < interval2[i].([]interface{})[1]\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].([]interface{})[0] == interval2[i].([]interface{})[0]\
    \ {\n            result += fmt.Sprintf(\"%d\", interval1[i].([]interface{})[1])\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n    \n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxz4p5zqr_test.go:35:12: invalid operation: interval1[i].([]interface{})[1]
    > interval2[i].([]interface{})[1] (operator > not defined on interface)

    /tmp/tmpxz4p5zqr_test.go:41:12: invalid operation: interval1[i].([]interface{})[1]
    < interval2[i].([]interface{})[1] (operator < not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) <= interval2[i].(float64)\
    \ {\n            result += \"YES\"\n        } else {\n            result += \"\
    NO\"\n        }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpdn5xtopk_test.go:29\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpdn5xtopk_test.go:46\
    \ +0x1131\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075631
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if isPrime(interval1[0].(float64))\
    \ && isPrime(interval2[0].(float64)) {\n        return \"YES\"\n    }\n    \n\
    \    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpodiwv2wt_test.go:39:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n \
    \   interval2 := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1[i] = interval1[i].(int)\n    }\n    for i := 0; i <\
    \ len(interval2); i++ {\n        interval2[i] = interval2[i].(int)\n    }\n  \
    \  \n    result := make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n\
    \        } else {\n            result[i] = interval2[i]\n        }\n    }\n  \
    \  \n    result := make([]int, len(result))\n    \n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i] == 0 {\n            result[i] = 1\n        }\n \
    \   }\n    \n    result := make([]int, len(result))\n    \n    for i := 0; i <\
    \ len(result); i++ {\n        if result[i] == 1 {\n            return \"NO\"\n\
    \        }\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9l_8orrl_test.go:26:15:\
    \ no new variables on left side of :=\n/tmp/tmp9l_8orrl_test.go:26:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmp9l_8orrl_test.go:27:15: no new variables on left side\
    \ of :=\n/tmp/tmp9l_8orrl_test.go:27:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmp9l_8orrl_test.go:39:12:\
    \ invalid operation: interval1[i] > interval2[i] (operator > not defined on interface)\n\
    /tmp/tmp9l_8orrl_test.go:40:25: cannot use interval1[i] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmp9l_8orrl_test.go:42:25:\
    \ cannot use interval2[i] (variable of type interface{}) as type int in assignment:\n\
    \tneed type assertion\n/tmp/tmp9l_8orrl_test.go:46:12: no new variables on left\
    \ side of :=\n/tmp/tmp9l_8orrl_test.go:54:12: no new variables on left side of\
    \ :=\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"\" {\n        return \"YES\"\n    }\n    \n    return result\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpthzviqni_test.go:29 +0x1bb\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpthzviqni_test.go:64 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var i int\n    var j int\n\
    \    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n \
    \   var p int\n    var q int\n    var r int\n    var s int\n    var t int\n  \
    \  var u int\n    var v int\n    var w int\n    var x int\n    var y int\n   \
    \ var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\
    \ e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j\
    \ int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n\
    \    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n \
    \   var u int\n    var v int\n    var w int\n    var x int\n    var y int\n  \
    \  var z int\n    var a int\n    var b int\n    var c int\n    var d int\n   \
    \ var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var\
    \ j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o\
    \ int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n\
    \    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n \
    \   var z int\n    var a int\n    var b int\n    var c int\n    var d int\n  \
    \  var e int\n    var f int\n    var g int\n    var h int\n    var i int\n   \
    \ var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var\
    \ o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t\
    \ int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n\
    \    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n \
    \   var e int\n    var f int\n    var g int\n    var h int\n    var i int\n  \
    \  var j int\n    var k int\n    var l int\n    var m int\n    var n int\n   \
    \ var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var\
    \ t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y\
    \ int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n\
    \    var e int\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp52a8l6i7_test.go:151:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval := range interval1 {\n        start := interval.([]interface{})[0].(int)\n\
    \        end := interval.([]interface{})[1].(int)\n        \n        for _, interval2\
    \ := range interval2 {\n            interval2 := interval2.([]interface{})\n \
    \           \n            if start <= interval2[0] && interval2[1] <= end {\n\
    \                result := append(result, interval2)\n            }\n        }\n\
    \    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n    result :=\
    \ make([]interface{}, 0)\n    \n    for _, interval := range result {\n      \
    \  start := interval.([]interface{})[0].(int)\n        end := interval.([]interface{})[1].(int)\n\
    \        \n        if isPrime(start, end) {\n            return \"YES\"\n    \
    \    }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidk5l4_w_test.go:35:25: invalid operation: start <= interval2[0] (operator
    <= not defined on interface)

    /tmp/tmpidk5l4_w_test.go:35:41: invalid operation: interval2[1] <= end (operator
    <= not defined on interface)

    /tmp/tmpidk5l4_w_test.go:36:17: result declared but not used

    /tmp/tmpidk5l4_w_test.go:49:12: no new variables on left side of :=

    /tmp/tmpidk5l4_w_test.go:55:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionLength := interval1End\
    \ - interval1Start\n    \n    if interval2Start < interval2End {\n        intersectionLength\
    \ += interval2End - interval2Start\n    }\n    \n    if intersectionLength ==\
    \ 0 {\n        return \"NO\"\n    }\n    \n    if intersectionLength == 1 {\n\
    \        return \"YES\"\n    }\n    \n    if isPrime(intersectionLength) {\n \
    \       return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyy2anuhh_test.go:52:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    interval1Start, interval1End\
    \ := interval1[0].([]interface{})[0], interval1[0].([]interface{})[1]\n    interval2Start,\
    \ interval2End := interval2[0].([]interface{})[0], interval2[0].([]interface{})[1]\n\
    \    \n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        \n        if interval1Start <= interval2Start {\n            result\
    \ = fmt.Sprintf(\"YES\")\n        } else {\n            result = fmt.Sprintf(\"\
    NO\")\n        }\n    } else {\n        result = fmt.Sprintf(\"NO\")\n    }\n\
    \    \n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7je8hi6n_test.go:27:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmp7je8hi6n_test.go:27:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmp7je8hi6n_test.go:29:12: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Write your code here\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptrb6rco4_test.go:277:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n\n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n\n    for interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n        }\n        if interval1End\
    \ >= interval2End {\n            intersectionEnd = interval1End\n        }\n \
    \       if intersectionStart <= intersectionEnd {\n            intersectionEnd\
    \ = interval1End\n        }\n    }\n\n    if intersectionStart <= intersectionEnd\
    \ {\n        if interval1Start <= interval2Start {\n            intersectionStart\
    \ = interval1Start\n        }\n        if interval1End >= interval2End {\n   \
    \         intersectionEnd = interval1End\n        }\n        if intersectionStart\
    \ <= intersectionEnd {\n            intersectionEnd = interval1End\n        }\n\
    \    }\n\n    if intersectionStart <= intersectionEnd {\n        if interval1Start\
    \ <= interval2Start {\n            intersectionStart = interval1Start\n      \
    \  }\n        if interval1End >= interval2End {\n            intersectionEnd =\
    \ interval1End\n        }\n        if intersectionStart <= intersectionEnd {\n\
    \            intersectionEnd = interval1End\n        }\n    }\n\n    if intersectionStart\
    \ <= intersectionEnd {\n        if interval1Start <= interval2Start {\n      \
    \      intersectionStart = interval1Start\n        }\n        if interval1End\
    \ >= interval2End {\n            intersectionEnd = interval1End\n        }\n \
    \       if intersectionStart <= intersectionEnd {\n            intersectionEnd\
    \ = interval1End\n        }\n    }\n\n    if intersectionStart <= intersectionEnd\
    \ {\n        if interval1Start <= interval2Start {\n            intersectionStart\
    \ = interval1Start\n        }\n        if interval1End >= interval2End {\n   \
    \         intersectionEnd = interval1End\n        }\n        if intersectionStart\
    \ <= intersectionEnd {\n            intersectionEnd = interval1End\n        }\n\
    \    }\n\n    if intersectionStart <= intersectionEnd {\n        if interval1Start\
    \ <= interval2Start {\n            intersectionStart = interval1Start\n      \
    \  }\n        if interval1End >= interval2End {\n            intersectionEnd =\
    \ interval1End\n        }\n        if intersectionStart <= intersectionEnd {\n\
    \            intersectionEnd = interval1End\n        }\n    }\n\n    if intersectionStart\
    \ <= intersectionEnd {\n        if interval1Start <= interval2Start {\n      \
    \      intersectionStart = interval1Start\n        }\n        if interval1End\
    \ >= interval2End {\n            \nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0zym_5dl_test.go:112:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Write your code here\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptrb6rco4_test.go:277:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075629
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    var interval1Start int\n    var interval1End\
    \ int\n    var interval2Start int\n    var interval2End int\n    \n    interval1Start\
    \ = interval1[0].(int)\n    interval1End = interval1[1].(int)\n    interval2Start\
    \ = interval2[0].(int)\n    interval2End = interval2[1].(int)\n    \n    if interval1Start\
    \ > interval1End {\n        fmt.Println(\"interval1Start > interval1End\")\n \
    \       return \"NO\"\n    }\n    if interval2Start > interval2End {\n       \
    \ fmt.Println(\"interval2Start > interval2End\")\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start <=\
    \ interval2End && interval1End >= interval2Start {\n        fmt.Println(\"interval1Start\
    \ <= interval2End && interval1End >= interval2Start\")\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start >= interval2Start && interval1End <=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start >=\
    \ interval2End && interval1End <= interval2Start {\n        fmt.Println(\"interval1Start\
    \ >= interval2End && interval1End <= interval2Start\")\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start <=\
    \ interval2End && interval1End >= interval2Start {\n        fmt.Println(\"interval1Start\
    \ <= interval2End && interval1End >= interval2Start\")\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start >= interval2Start && interval1End <=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start >=\
    \ interval2End && interval1End <= interval2Start {\n        fmt.Println(\"interval1Start\
    \ >= interval2End && interval1End <= interval2Start\")\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqkvjnz3w_test.go:83:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var length int\n    var\
    \ start int\n    var end int\n    var isPrime bool\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        start = interval1[i].(float64)\n        end =\
    \ interval2[i].(float64)\n        \n        if start > end {\n            start\
    \ = end\n        }\n        \n        length = end - start\n        \n       \
    \ if length == 0 {\n            continue\n        }\n        \n        isPrime\
    \ = true\n        \n        for j := 1; j < length; j++ {\n            if start%j\
    \ == 0 && end%j == 0 {\n                isPrime = false\n                break\n\
    \            }\n        }\n        \n        if isPrime {\n            result\
    \ = \"YES\"\n            break\n        }\n    }\n    \n    return result\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqwjnqee__test.go:33:17: cannot use interval1[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    /tmp/tmpqwjnqee__test.go:34:15: cannot use interval2[i].(float64) (comma, ok expression
    of type float64) as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    for _, v := range interval1 {\n       \
    \ if v == nil {\n            continue\n        }\n        start, end := v.(int64)\n\
    \        if start > end {\n            continue\n        }\n        for _, v1\
    \ := range interval2 {\n            if v1 == nil {\n                continue\n\
    \            }\n            start1, end1 := v1.(int64)\n            if start1\
    \ > end1 {\n                continue\n            }\n            if start1 <=\
    \ end && end1 >= start {\n                result += fmt.Sprintf(\"%v\", end -\
    \ start)\n            }\n        }\n    }\n    if result == \"YES\" {\n      \
    \  return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_hi3k6ns_test.go:31:20: invalid operation: start > end (mismatched types
    int64 and bool)

    /tmp/tmp_hi3k6ns_test.go:39:25: invalid operation: start1 > end1 (mismatched types
    int64 and bool)

    /tmp/tmp_hi3k6ns_test.go:42:26: invalid operation: start1 <= end (mismatched types
    int64 and bool)

    /tmp/tmp_hi3k6ns_test.go:42:41: invalid operation: end1 >= start (mismatched types
    bool and int64)

    /tmp/tmp_hi3k6ns_test.go:43:45: invalid operation: end - start (mismatched types
    bool and int64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n\n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n\n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n\n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n\n    if interval1Start < interval2Start {\n\
    \        return \"NO\"\n    }\n\n    if interval1End < interval2End {\n      \
    \  return \"NO\"\n    }\n\n    if interval1Start <= interval2Start {\n       \
    \ if interval1End <= interval2End {\n            if interval1Start <= interval2Start\
    \ {\n                return \"YES\"\n            }\n            if interval1End\
    \ >= interval2End {\n                return \"NO\"\n            }\n        }\n\
    \    }\n\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp6edwvues_test.go:26 +0x1a8\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp6edwvues_test.go:72 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075636
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    // Your code here\n    \n    return \"\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpf83g345q_test.go:48: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpf83g345q_test.go:48: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpf83g345q_test.go:48:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpf83g345q_test.go:48: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpf83g345q_test.go:48: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpf83g345q_test.go:48: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpf83g345q_test.go:48:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpf83g345q_test.go:48: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075636
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    for i := 0; i < len(interval1); i++ {\n\
    \        if interval1[i].([]interface{})[0].(int) <= interval2[i].([]interface{})[0].(int)\
    \ {\n            if interval1[i].([]interface{})[0].(int) >= interval2[i].([]interface{})[1].(int)\
    \ {\n                result += \"YES\"\n            } else {\n               \
    \ result += \"NO\"\n            }\n        } else {\n            if interval1[i].([]interface{})[1].(int)\
    \ >= interval2[i].([]interface{})[0].(int) {\n                result += \"NO\"\
    \n            } else {\n                result += \"YES\"\n            }\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0, 0x2, 0x2?},\
    \ {0xc0000f5ca0, 0x2?, 0x2?})\n\t/tmp/tmp4zfdukcc_test.go:27 +0x277\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp4zfdukcc_test.go:51 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075636
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpsx1h0xv0_test.go:29 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpsx1h0xv0_test.go:64 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075626
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    \n    interval1Start :=\
    \ interval1[0].(int)\n    interval1End := interval1[1].(int)\n    interval2Start\
    \ := interval2[0].(int)\n    interval2End := interval2[1].(int)\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ result += \"YES\"\n    } else {\n        result += \"NO\"\n    }\n    \n   \
    \ return result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpfdge5fnq_test.go:58: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpfdge5fnq_test.go:58: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpfdge5fnq_test.go:58: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpfdge5fnq_test.go:58: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075636
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var i int\n    var j int\n\
    \    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n \
    \   var p int\n    var q int\n    var r int\n    var s int\n    var t int\n  \
    \  var u int\n    var v int\n    var w int\n    var x int\n    var y int\n   \
    \ var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\
    \ e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j\
    \ int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n\
    \    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n \
    \   var u int\n    var v int\n    var w int\n    var x int\n    var y int\n  \
    \  var z int\n    var a int\n    var b int\n    var c int\n    var d int\n   \
    \ var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var\
    \ j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o\
    \ int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n\
    \    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n \
    \   var z int\n    var a int\n    var b int\n    var c int\n    var d int\n  \
    \  var e int\n    var f int\n    var g int\n    var h int\n    var i int\n   \
    \ var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var\
    \ o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t\
    \ int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n\
    \    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n \
    \   var e int\n    var f int\n    var g int\n    var h int\n    var i int\n  \
    \  var j int\n    var k int\n    var l int\n    var m int\n    var n int\n   \
    \ var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var\
    \ t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y\
    \ int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n\
    \    var e int\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp52a8l6i7_test.go:151:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3l55cf17_test.go:279:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075625
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    var intersection []interface{}\n\
    \    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        intersection := []interface{}{interval1[i].([]interface{})[0],\
    \ interval1[i].([]interface{})[1]}\n        \n        if intersect(intersection,\
    \ interval2) {\n            result = \"YES\"\n            break\n        }\n \
    \   }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfdmbgvks_test.go:23:9: intersection declared but not used

    /tmp/tmpfdmbgvks_test.go:32:12: undefined: intersect

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var result string\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result += fmt.Sprintf(\"%v\", interval1[i])\n        }\n    }\n    \n    if\
    \ result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"\
    YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0, 0x2, 0x2?},\
    \ {0xc0000f5ca0, 0x2?, 0x2?})\n\t/tmp/tmpme75lpwm_test.go:28 +0x1c5\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpme75lpwm_test.go:51 +0xe7\ntesting.tRunner(0xc000120340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075636
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1End < interval2Start {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start > interval2Start && interval1Start <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start > interval2End\
    \ && interval1End <= interval2Start {\n        return \"YES\"\n    }\n    \n \
    \   if interval1Start <= interval2Start && interval1End > interval2End {\n   \
    \     return \"YES\"\n    }\n    \n    if interval1Start > interval2Start && interval1Start\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ > interval2End && interval1End <= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End > interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start > interval2Start\
    \ && interval1Start <= interval2End {\n        return \"YES\"\n    }\n    \n \
    \   if interval1Start > interval2End && interval1End <= interval2Start {\n   \
    \     return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start &&\
    \ interval1End > interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ > interval2Start && interval1Start <= interval2End {\n        return \"YES\"\
    \n    }\n    \n    if interval1Start > interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End > interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start > interval2Start && interval1Start <= interval2End {\n      \
    \  return \"YES\"\n    }\n    \n    if interval1Start > interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    if interval\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt64u61h7_test.go:104:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075635
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp2hq5ukfx_test.go:26 +0x1bc\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp2hq5ukfx_test.go:60 +0xe7\ntesting.tRunner(0xc000120340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075636
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval2End\
    \ {\n            return \"NO\"\n        }\n        if interval1End < interval2Start\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ <= intersectionEnd && interval1End >= intersectionStart {\n            intersectionEnd\
    \ = interval1End\n        } else {\n            return \"NO\"\n        }\n   \
    \ }\n    \n    if intersectionEnd <= interval2End {\n        return \"NO\"\n \
    \   }\n    \n    if intersectionEnd >= interval2Start {\n        return \"NO\"\
    \n    }\n    \n    if intersectionEnd >= interval1Start && intersectionEnd <=\
    \ interval1End {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00012a3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00012a3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000125cc0?, 0x2?, 0x2?},\
    \ {0xc000125ca0?, 0x2?, 0x2?})\n\t/tmp/tmpald_nkuo_test.go:26 +0x29b\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpald_nkuo_test.go:81 +0xe7\ntesting.tRunner(0xc000103860, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075636
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make(map[int]bool)\n    for _, v :=\
    \ range interval1 {\n        result[v] = true\n    }\n    for _, v := range interval2\
    \ {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    length := 0\n    for _, v := range result {\n        if\
    \ v {\n            length++\n        }\n    }\n    if length == 2 {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1vrqcktr_test.go:28:16:\
    \ cannot use v (variable of type interface{}) as type int in map index:\n\tneed\
    \ type assertion\n/tmp/tmp1vrqcktr_test.go:31:28: cannot use v (variable of type\
    \ interface{}) as type int in map index:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075634
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, interval := range interval1 {\n        start = interval.([]interface{})[0].(int)\n\
    \        end = interval.([]interface{})[1].(int)\n        \n        if start >\
    \ end {\n            continue\n        }\n        \n        intersection := make([]interface{},\
    \ 0)\n        for _, interval2 := range interval2 {\n            start = interval2.([]interface{})[0].(int)\n\
    \            end = interval2.([]interface{})[1].(int)\n            \n        \
    \    if start > end {\n                continue\n            }\n            \n\
    \            if start <= end {\n                intersection = append(intersection,\
    \ []interface{}{start, end})\n            }\n        }\n        \n        if len(intersection)\
    \ == 0 {\n            continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9effd9uw_test.go:125:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075635
