language: go_test.go
name: HumanEval_87_get_row
results:
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++\
    \ {\n        r[i] = make([]interface{}, len(lst[i]))\n    }\n    r := r[:0]\n\
    \    r := append(r, lst[x])\n    return r\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvwj2no6l_test.go:22:7:\
    \ no new variables on left side of :=\n/tmp/tmpvwj2no6l_test.go:23:7: no new variables\
    \ on left side of :=\n/tmp/tmpvwj2no6l_test.go:23:20: cannot use lst[x] (variable\
    \ of type []int) as type []interface{} in argument to append\n/tmp/tmpvwj2no6l_test.go:34:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpvwj2no6l_test.go:35:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpvwj2no6l_test.go:36:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpvwj2no6l_test.go:39:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpvwj2no6l_test.go:39:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    var row = [][]int{}\n    var column =\
    \ []int{}\n    var row_index int\n    var column_index int\n    var row_length\
    \ int\n    var column_length int\n    for row_index = 0; row_index < len(lst);\
    \ row_index++ {\n        row_length = len(lst[row_index])\n        for column_index\
    \ = 0; column_index < row_length; column_index++ {\n            column_length\
    \ = len(lst[row_index][column_index])\n            if lst[row_index][column_index]\
    \ == nil {\n                continue\n            }\n            if lst[row_index][column_index][x]\
    \ != nil {\n                row = append(row, lst[row_index][column_index])\n\
    \                column = append(column, column_index)\n            }\n      \
    \  }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row)))\n    sort.Sort(sort.Reverse(sort.IntSlice(column)))\n\
    \    for row_index = 0; row_index < len(row); row_index++ {\n        row_length\
    \ = len(row[row_index])\n        for column_index = 0; column_index < row_length;\
    \ column_index++ {\n            if row[row_index][column_index] == nil {\n   \
    \             continue\n            }\n            result = append(result, []interface{}{row_index,\
    \ column_index})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphuf6rcmi_test.go:28:33:\
    \ invalid argument: lst[row_index][column_index] (variable of type int) for len\n\
    /tmp/tmphuf6rcmi_test.go:29:48: invalid operation: lst[row_index][column_index]\
    \ == nil (mismatched types int and untyped nil)\n/tmp/tmphuf6rcmi_test.go:32:44:\
    \ invalid operation: cannot index lst[row_index][column_index] (variable of type\
    \ int)\n/tmp/tmphuf6rcmi_test.go:33:35: cannot use lst[row_index][column_index]\
    \ (variable of type int) as type []int in argument to append\n/tmp/tmphuf6rcmi_test.go:38:5:\
    \ undefined: sort\n/tmp/tmphuf6rcmi_test.go:39:5: undefined: sort\n/tmp/tmphuf6rcmi_test.go:43:48:\
    \ invalid operation: row[row_index][column_index] == nil (mismatched types int\
    \ and untyped nil)\n/tmp/tmphuf6rcmi_test.go:59:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphuf6rcmi_test.go:60:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphuf6rcmi_test.go:61:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphuf6rcmi_test.go:61:232:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        result := append(result, make([]interface{},\
    \ cols))\n        for j := 0; j < cols; j++ {\n            result[i][j] = lst[i][j]\n\
    \        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return getRow(result, x, rows)\n}\n\nfunc TestGet_Row(t *testing.T) {\n \
    \ candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz8jdtdz9_test.go:26:5:\
    \ undefined: sort\n/tmp/tmpz8jdtdz9_test.go:26:15: undefined: byRow\n/tmp/tmpz8jdtdz9_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpz8jdtdz9_test.go:27:15: undefined: byCol\n/tmp/tmpz8jdtdz9_test.go:28:12:\
    \ undefined: getRow\n/tmp/tmpz8jdtdz9_test.go:38:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz8jdtdz9_test.go:39:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz8jdtdz9_test.go:40:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz8jdtdz9_test.go:43:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpz8jdtdz9_test.go:43:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz8jdtdz9_test.go:43:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        sort.Ints(row)\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n        sort.Sort(sort.Reverse(sort.IntSlice(row[x:])))\n\
    \        result := append(result, row[:x])\n    }\n    return result\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqvjrdb6_test.go:20:9:\
    \ undefined: sort\n/tmp/tmpeqvjrdb6_test.go:21:9: undefined: sort\n/tmp/tmpeqvjrdb6_test.go:22:9:\
    \ undefined: sort\n/tmp/tmpeqvjrdb6_test.go:23:9: result declared but not used\n\
    /tmp/tmpeqvjrdb6_test.go:23:37: cannot use row[:x] (value of type []int) as type\
    \ []interface{} in argument to append\n/tmp/tmpeqvjrdb6_test.go:35:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpeqvjrdb6_test.go:36:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpeqvjrdb6_test.go:37:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpeqvjrdb6_test.go:40:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpeqvjrdb6_test.go:40:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpeqvjrdb6_test.go:40:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuzd5rmld_test.go:273:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        r\
    \ := make([]interface{}, len(row))\n        for i := range row {\n           \
    \ r[i] = row[i]\n        }\n        sort.Slice(r, func(i, j int) bool {\n    \
    \        return r[i].([]interface{})[0].(int) < r[j].([]interface{})[0].(int)\n\
    \        })\n        sort.Slice(r, func(i, j int) bool {\n            return r[i].([]interface{})[1].(int)\
    \ < r[j].([]interface{})[1].(int)\n        })\n        result = append(result,\
    \ r)\n    }\n    return filter_by_x(result[x], x)\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnrm9vosr_test.go:24:9:\
    \ undefined: sort\n/tmp/tmpnrm9vosr_test.go:27:9: undefined: sort\n/tmp/tmpnrm9vosr_test.go:32:12:\
    \ undefined: filter_by_x\n/tmp/tmpnrm9vosr_test.go:42:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnrm9vosr_test.go:43:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnrm9vosr_test.go:44:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnrm9vosr_test.go:47:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpnrm9vosr_test.go:47:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgfsx6dxa_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpgfsx6dxa_test.go:31:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpgfsx6dxa_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpgfsx6dxa_test.go:34:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpgfsx6dxa_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgfsx6dxa_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpgfsx6dxa_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgfsx6dxa_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpgfsx6dxa_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    \n    return nil\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn1udtj3t_test.go:31:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn1udtj3t_test.go:32:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpn1udtj3t_test.go:33:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn1udtj3t_test.go:36:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpn1udtj3t_test.go:36:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuzd5rmld_test.go:273:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    \n    for i\
    \ := range lst {\n        for j := range lst[i] {\n            if lst[i][j] ==\
    \ x {\n                result[i] = append(result[i], j)\n            }\n     \
    \   }\n    }\n    \n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    \n    sort.Slice(result, func(i, j\
    \ int) bool {\n        return result[i][1] > result[j][1]\n    })\n    \n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9me6cog3_test.go:31:5:\
    \ undefined: sort\n/tmp/tmp9me6cog3_test.go:32:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp9me6cog3_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp9me6cog3_test.go:36:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp9me6cog3_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9me6cog3_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9me6cog3_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9me6cog3_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9me6cog3_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdfgcwvh0_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpdfgcwvh0_test.go:30:5: undefined: sort\n/tmp/tmpdfgcwvh0_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdfgcwvh0_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdfgcwvh0_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdfgcwvh0_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdfgcwvh0_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = make([]interface{},\
    \ 2)\n                result[i][j] = append(result[i][j], i)\n               \
    \ result[i][j] = append(result[i][j], j)\n            }\n        }\n    }\n  \
    \  sort.Slice(result, func(i, j int) bool {\n        return result[i][j][0].([]interface{})[0].(int)\
    \ < result[i][j][1].([]interface{})[0].(int)\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][j][1].([]interface{})[0].(int) < result[i][j][0].([]interface{})[0].(int)\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj18lzjbl_test.go:26:39:\
    \ first argument to append must be a slice; have result[i][j] (variable of type\
    \ interface{})\n/tmp/tmpj18lzjbl_test.go:27:39: first argument to append must\
    \ be a slice; have result[i][j] (variable of type interface{})\n/tmp/tmpj18lzjbl_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpj18lzjbl_test.go:32:28: invalid operation: cannot index\
    \ result[i][j] (variable of type interface{})\n/tmp/tmpj18lzjbl_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpj18lzjbl_test.go:35:28: invalid operation: cannot index\
    \ result[i][j] (variable of type interface{})\n/tmp/tmpj18lzjbl_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpj18lzjbl_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpj18lzjbl_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpj18lzjbl_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpj18lzjbl_test.go:52:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    \n    for i := 0; i < len(lst); i++ {\n        for\
    \ j := 0; j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n          \
    \      result[i][j] = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n       \
    \ }\n    }\n    \n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    \n    sort.Slice(result, func(i, j\
    \ int) bool {\n        return result[i][1] > result[j][1]\n    })\n    \n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxb09z3xz_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpxb09z3xz_test.go:34:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpxb09z3xz_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpxb09z3xz_test.go:38:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpxb09z3xz_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxb09z3xz_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxb09z3xz_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxb09z3xz_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxb09z3xz_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuzd5rmld_test.go:273:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    x := x\n   \
    \ for i := range lst {\n        for j := range lst[i] {\n            if lst[i][j]\
    \ == x {\n                result[i] = append(result[i], j)\n            }\n  \
    \      }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphocb1_wk_test.go:22:7:\
    \ no new variables on left side of :=\n/tmp/tmphocb1_wk_test.go:30:5: undefined:\
    \ sort\n/tmp/tmphocb1_wk_test.go:30:15: undefined: byRow\n/tmp/tmphocb1_wk_test.go:31:5:\
    \ undefined: sort\n/tmp/tmphocb1_wk_test.go:31:15: undefined: byCol\n/tmp/tmphocb1_wk_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphocb1_wk_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphocb1_wk_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphocb1_wk_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmphocb1_wk_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphocb1_wk_test.go:47:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyjojuk4i_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpyjojuk4i_test.go:30:5: undefined: sort\n/tmp/tmpyjojuk4i_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyjojuk4i_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyjojuk4i_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyjojuk4i_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyjojuk4i_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row[x:])))\n        result := append(result,\
    \ row[x:])\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8y1dgbs2_test.go:20:9:\
    \ undefined: sort\n/tmp/tmp8y1dgbs2_test.go:21:9: undefined: sort\n/tmp/tmp8y1dgbs2_test.go:22:9:\
    \ result declared but not used\n/tmp/tmp8y1dgbs2_test.go:22:37: cannot use row[x:]\
    \ (value of type []int) as type []interface{} in argument to append\n/tmp/tmp8y1dgbs2_test.go:34:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:35:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:36:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:39:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp8y1dgbs2_test.go:39:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i, row := range lst {\n        sort.Ints(row)\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row[x:])))\n        result[i] =\
    \ row[:x]\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n \
    \ candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6qmbd5sm_test.go:21:9:\
    \ undefined: sort\n/tmp/tmp6qmbd5sm_test.go:22:9: undefined: sort\n/tmp/tmp6qmbd5sm_test.go:23:9:\
    \ undefined: sort\n/tmp/tmp6qmbd5sm_test.go:24:24: cannot use row[:x] (value of\
    \ type []int) as type []interface{} in assignment\n/tmp/tmp6qmbd5sm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6qmbd5sm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6qmbd5sm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6qmbd5sm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6qmbd5sm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := make([]interface{}, cols)\n \
    \       for j := 0; j < cols; j++ {\n            row[j] = lst[i][j]\n        }\n\
    \        result = append(result, row)\n    }\n    sort.Sort(byRow(result))\n \
    \   sort.Sort(byCol(result))\n    result := make([][]interface{}, 0)\n    for\
    \ i := 0; i < rows; i++ {\n        row := make([]interface{}, cols)\n        for\
    \ j := 0; j < cols; j++ {\n            row[j] = result[i][j]\n        }\n    \
    \    result = append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n  \
    \      result := make([]interface{}, cols)\n        for j := 0; j < cols; j++\
    \ {\n            result[j] = result[i][j]\n        }\n        result = append(result,\
    \ i)\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqahkrsv_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpeqahkrsv_test.go:27:15: undefined: byRow\n/tmp/tmpeqahkrsv_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpeqahkrsv_test.go:28:15: undefined: byCol\n/tmp/tmpeqahkrsv_test.go:29:12:\
    \ no new variables on left side of :=\n/tmp/tmpeqahkrsv_test.go:40:34: invalid\
    \ operation: cannot index result[i] (variable of type interface{})\n/tmp/tmpeqahkrsv_test.go:54:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpeqahkrsv_test.go:55:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpeqahkrsv_test.go:56:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpeqahkrsv_test.go:59:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpeqahkrsv_test.go:59:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \ }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnojipzdb_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:29:15: undefined: byRow\n/tmp/tmpnojipzdb_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:30:15: undefined: byCol\n/tmp/tmpnojipzdb_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnojipzdb_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnojipzdb_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := [][]interface{}{}\n    for _, row :=\
    \ range lst {\n        sort.Ints(row)\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row[x:])))\n        result := append(result,\
    \ row[x:])\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2_u7el_9_test.go:21:9:\
    \ undefined: sort\n/tmp/tmp2_u7el_9_test.go:22:9: undefined: sort\n/tmp/tmp2_u7el_9_test.go:23:9:\
    \ undefined: sort\n/tmp/tmp2_u7el_9_test.go:24:9: result declared but not used\n\
    /tmp/tmp2_u7el_9_test.go:24:37: cannot use row[x:] (value of type []int) as type\
    \ []interface{} in argument to append\n/tmp/tmp2_u7el_9_test.go:36:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmp2_u7el_9_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2_u7el_9_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2_u7el_9_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp2_u7el_9_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2_u7el_9_test.go:41:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row[x:])))\n        result := append(result,\
    \ row[x:])\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8y1dgbs2_test.go:20:9:\
    \ undefined: sort\n/tmp/tmp8y1dgbs2_test.go:21:9: undefined: sort\n/tmp/tmp8y1dgbs2_test.go:22:9:\
    \ result declared but not used\n/tmp/tmp8y1dgbs2_test.go:22:37: cannot use row[x:]\
    \ (value of type []int) as type []interface{} in argument to append\n/tmp/tmp8y1dgbs2_test.go:34:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:35:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:36:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:39:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp8y1dgbs2_test.go:39:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = make([]interface{},\
    \ 2)\n                result[i][j][0] = i\n                result[i][j][1] = j\n\
    \            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnywmv6t0_test.go:26:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpnywmv6t0_test.go:27:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmpnywmv6t0_test.go:31:5: undefined: sort\n/tmp/tmpnywmv6t0_test.go:31:15:\
    \ undefined: byRow\n/tmp/tmpnywmv6t0_test.go:32:5: undefined: sort\n/tmp/tmpnywmv6t0_test.go:32:15:\
    \ undefined: byCol\n/tmp/tmpnywmv6t0_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnywmv6t0_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnywmv6t0_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnywmv6t0_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpnywmv6t0_test.go:48:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_helper(row, x))\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return rows[i][0] > rows[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return rows[i][1] < rows[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqo7_kqau_test.go:20:9:\
    \ result declared but not used\n/tmp/tmpqo7_kqau_test.go:20:34: undefined: get_row_helper\n\
    /tmp/tmpqo7_kqau_test.go:22:5: undefined: sort\n/tmp/tmpqo7_kqau_test.go:23:16:\
    \ undefined: rows\n/tmp/tmpqo7_kqau_test.go:25:5: undefined: sort\n/tmp/tmpqo7_kqau_test.go:26:16:\
    \ undefined: rows\n/tmp/tmpqo7_kqau_test.go:38:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqo7_kqau_test.go:39:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqo7_kqau_test.go:40:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqo7_kqau_test.go:43:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpqo7_kqau_test.go:43:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := lst[i]\n        sort.Ints(row)\n\
    \        sort.Ints(row[len(row)-1])\n        row := row[:len(row)-1]\n       \
    \ sort.Ints(row)\n        sort.Ints(row[len(row)-1])\n        result := append(result,\
    \ row[:])\n    }\n    for i := 0; i < rows; i++ {\n        row := result[i]\n\
    \        sort.Ints(row)\n        sort.Ints(row[len(row)-1])\n        row := row[:len(row)-1]\n\
    \        sort.Ints(row)\n        sort.Ints(row[len(row)-1])\n        for j :=\
    \ 0; j < cols; j++ {\n            if row[0] == x {\n                return result\n\
    \            }\n        }\n    }\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_924j44k_test.go:22:9: undefined: sort

    /tmp/tmp_924j44k_test.go:23:9: undefined: sort

    /tmp/tmp_924j44k_test.go:24:13: no new variables on left side of :=

    /tmp/tmp_924j44k_test.go:25:9: undefined: sort

    /tmp/tmp_924j44k_test.go:26:9: undefined: sort

    /tmp/tmp_924j44k_test.go:27:37: cannot use row[:] (value of type []int) as type
    []interface{} in argument to append

    /tmp/tmp_924j44k_test.go:31:9: undefined: sort

    /tmp/tmp_924j44k_test.go:32:9: undefined: sort

    /tmp/tmp_924j44k_test.go:33:13: no new variables on left side of :=

    /tmp/tmp_924j44k_test.go:34:9: undefined: sort

    /tmp/tmp_924j44k_test.go:34:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_helper(row, x))\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] > result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] < result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1vrhzvic_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp1vrhzvic_test.go:20:34: undefined: get_row_helper\n\
    /tmp/tmp1vrhzvic_test.go:22:5: undefined: sort\n/tmp/tmp1vrhzvic_test.go:23:16:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmp1vrhzvic_test.go:25:5: undefined: sort\n/tmp/tmp1vrhzvic_test.go:26:16:\
    \ invalid operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmp1vrhzvic_test.go:38:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp1vrhzvic_test.go:39:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1vrhzvic_test.go:40:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1vrhzvic_test.go:43:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp1vrhzvic_test.go:43:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmyly9rit_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpmyly9rit_test.go:29:15: undefined: byRow\n/tmp/tmpmyly9rit_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpmyly9rit_test.go:30:15: undefined: byCol\n/tmp/tmpmyly9rit_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmyly9rit_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmyly9rit_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmyly9rit_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmyly9rit_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row[x:])))\n        result := append(result,\
    \ row[:x])\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpry7hji48_test.go:20:9:\
    \ undefined: sort\n/tmp/tmpry7hji48_test.go:21:9: undefined: sort\n/tmp/tmpry7hji48_test.go:22:9:\
    \ result declared but not used\n/tmp/tmpry7hji48_test.go:22:37: cannot use row[:x]\
    \ (value of type []int) as type []interface{} in argument to append\n/tmp/tmpry7hji48_test.go:34:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpry7hji48_test.go:35:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpry7hji48_test.go:36:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpry7hji48_test.go:39:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpry7hji48_test.go:39:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, make([]interface{}, 0))\n        for _, col :=\
    \ range row {\n            if col == x {\n                result := append(result,\
    \ make([]interface{}, 1))\n                result[len(result)-1] = make([]interface{},\
    \ 2)\n                result[len(result)-1][0] = row\n                result[len(result)-1][1]\
    \ = col\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpttmprr8f_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpttmprr8f_test.go:30:15: undefined: byRow\n/tmp/tmpttmprr8f_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpttmprr8f_test.go:31:15: undefined: byCol\n/tmp/tmpttmprr8f_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpttmprr8f_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpttmprr8f_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpttmprr8f_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpttmprr8f_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuzd5rmld_test.go:273:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row[x:])))\n        result := append(result,\
    \ row[x:])\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8y1dgbs2_test.go:20:9:\
    \ undefined: sort\n/tmp/tmp8y1dgbs2_test.go:21:9: undefined: sort\n/tmp/tmp8y1dgbs2_test.go:22:9:\
    \ result declared but not used\n/tmp/tmp8y1dgbs2_test.go:22:37: cannot use row[x:]\
    \ (value of type []int) as type []interface{} in argument to append\n/tmp/tmp8y1dgbs2_test.go:34:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:35:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:36:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:39:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp8y1dgbs2_test.go:39:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range r {\n  \
    \      for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n   \
    \ }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n\
    \    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdnpzeh2e_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpdnpzeh2e_test.go:27:42: undefined: row\n/tmp/tmpdnpzeh2e_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpdnpzeh2e_test.go:28:42: undefined: col\n/tmp/tmpdnpzeh2e_test.go:39:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdnpzeh2e_test.go:40:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdnpzeh2e_test.go:41:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdnpzeh2e_test.go:44:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdnpzeh2e_test.go:44:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0fw7g6cm_test.go:30:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:31:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:32:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:35:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0fw7g6cm_test.go:35:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        r\
    \ := make([]interface{}, len(row))\n        for i := range row {\n           \
    \ r[i] = row[i]\n        }\n        sort.Slice(r, func(i, j int) bool {\n    \
    \        return r[i].([]interface{})[0].(int) < r[j].([]interface{})[0].(int)\n\
    \        })\n        sort.Slice(r, func(i, j int) bool {\n            return r[i].([]interface{})[1].(int)\
    \ < r[j].([]interface{})[1].(int)\n        })\n        result = append(result,\
    \ r)\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][0].(int)\
    \ < result[j][0].(int)\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][1].(int) < result[j][1].(int)\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxs48kruu_test.go:24:9:\
    \ undefined: sort\n/tmp/tmpxs48kruu_test.go:27:9: undefined: sort\n/tmp/tmpxs48kruu_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpxs48kruu_test.go:35:5: undefined: sort\n/tmp/tmpxs48kruu_test.go:48:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxs48kruu_test.go:49:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxs48kruu_test.go:50:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxs48kruu_test.go:53:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxs48kruu_test.go:53:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n\
    \        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57a37kzs_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp57a37kzs_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp57a37kzs_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp57a37kzs_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp57a37kzs_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp57a37kzs_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp57a37kzs_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp57a37kzs_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp57a37kzs_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = make([]interface{}, 2)\n                result[i][j][0]\
    \ = i\n                result[i][j][1] = j\n            }\n        }\n    }\n\
    \    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxaujnkky_test.go:26:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpxaujnkky_test.go:27:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmpxaujnkky_test.go:31:5: undefined: sort\n/tmp/tmpxaujnkky_test.go:31:15:\
    \ undefined: byRow\n/tmp/tmpxaujnkky_test.go:32:5: undefined: sort\n/tmp/tmpxaujnkky_test.go:32:15:\
    \ undefined: byCol\n/tmp/tmpxaujnkky_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxaujnkky_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxaujnkky_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxaujnkky_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpxaujnkky_test.go:48:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = make([]interface{},\
    \ 2)\n                result[i][j][0] = i\n                result[i][j][1] = j\n\
    \            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnywmv6t0_test.go:26:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpnywmv6t0_test.go:27:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmpnywmv6t0_test.go:31:5: undefined: sort\n/tmp/tmpnywmv6t0_test.go:31:15:\
    \ undefined: byRow\n/tmp/tmpnywmv6t0_test.go:32:5: undefined: sort\n/tmp/tmpnywmv6t0_test.go:32:15:\
    \ undefined: byCol\n/tmp/tmpnywmv6t0_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnywmv6t0_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnywmv6t0_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnywmv6t0_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpnywmv6t0_test.go:48:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    \n    // sort rows by rows in ascending order\n    sort.Slice(lst, func(i,\
    \ j int) bool {\n        return lst[i][0] < lst[j][0]\n    })\n    \n    // sort\
    \ columns by columns in descending order\n    for i := 0; i < rows; i++ {\n  \
    \      sort.Slice(lst[i], func(i, j int) bool {\n            return lst[i][j]\
    \ > lst[i][j-1]\n        })\n    }\n    \n    // find x coordinate in each row\n\
    \    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n      \
    \      if lst[i][j] == x {\n                result := append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuxp_jh8g_test.go:22:5:\
    \ undefined: sort\n/tmp/tmpuxp_jh8g_test.go:28:9: undefined: sort\n/tmp/tmpuxp_jh8g_test.go:37:17:\
    \ result declared but not used\n/tmp/tmpuxp_jh8g_test.go:52:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpuxp_jh8g_test.go:53:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpuxp_jh8g_test.go:54:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpuxp_jh8g_test.go:57:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpuxp_jh8g_test.go:57:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \ }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnojipzdb_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:29:15: undefined: byRow\n/tmp/tmpnojipzdb_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:30:15: undefined: byCol\n/tmp/tmpnojipzdb_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnojipzdb_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnojipzdb_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \     break\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9gwk21e1_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp9gwk21e1_test.go:31:5: undefined: sort\n/tmp/tmp9gwk21e1_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9gwk21e1_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9gwk21e1_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9gwk21e1_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9gwk21e1_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \ }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnojipzdb_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:29:15: undefined: byRow\n/tmp/tmpnojipzdb_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:30:15: undefined: byCol\n/tmp/tmpnojipzdb_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnojipzdb_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnojipzdb_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range r {\n  \
    \      for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n   \
    \ }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n\
    \    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdnpzeh2e_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpdnpzeh2e_test.go:27:42: undefined: row\n/tmp/tmpdnpzeh2e_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpdnpzeh2e_test.go:28:42: undefined: col\n/tmp/tmpdnpzeh2e_test.go:39:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdnpzeh2e_test.go:40:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdnpzeh2e_test.go:41:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdnpzeh2e_test.go:44:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdnpzeh2e_test.go:44:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_test(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vm1i32c_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp0vm1i32c_test.go:20:34: undefined: get_row_test\n\
    /tmp/tmp0vm1i32c_test.go:22:5: undefined: sort\n/tmp/tmp0vm1i32c_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmp0vm1i32c_test.go:23:5: undefined: sort\n/tmp/tmp0vm1i32c_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmp0vm1i32c_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vm1i32c_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0vm1i32c_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vm1i32c_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp0vm1i32c_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_helper(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzpi_0b_e_test.go:20:9:\
    \ result declared but not used\n/tmp/tmpzpi_0b_e_test.go:20:34: undefined: get_row_helper\n\
    /tmp/tmpzpi_0b_e_test.go:22:5: undefined: sort\n/tmp/tmpzpi_0b_e_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmpzpi_0b_e_test.go:23:5: undefined: sort\n/tmp/tmpzpi_0b_e_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmpzpi_0b_e_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzpi_0b_e_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpzpi_0b_e_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzpi_0b_e_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpzpi_0b_e_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        sort.Slice(row,\
    \ func(i, j int) bool {\n            return row[i][0] < row[j][0]\n        })\n\
    \        sort.Slice(row, func(i, j int) bool {\n            return row[i][1] >\
    \ row[j][1]\n        })\n        result := append(result, row)\n    }\n    return\
    \ filter(x, result)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1e0tva7y_test.go:20:9:\
    \ undefined: sort\n/tmp/tmp1e0tva7y_test.go:21:26: invalid operation: cannot index\
    \ row[i] (variable of type int)\n/tmp/tmp1e0tva7y_test.go:21:38: invalid operation:\
    \ cannot index row[j] (variable of type int)\n/tmp/tmp1e0tva7y_test.go:23:9: undefined:\
    \ sort\n/tmp/tmp1e0tva7y_test.go:24:26: invalid operation: cannot index row[i]\
    \ (variable of type int)\n/tmp/tmp1e0tva7y_test.go:24:38: invalid operation: cannot\
    \ index row[j] (variable of type int)\n/tmp/tmp1e0tva7y_test.go:26:9: result declared\
    \ but not used\n/tmp/tmp1e0tva7y_test.go:26:34: cannot use row (variable of type\
    \ []int) as type []interface{} in argument to append\n/tmp/tmp1e0tva7y_test.go:28:12:\
    \ undefined: filter\n/tmp/tmp1e0tva7y_test.go:38:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1e0tva7y_test.go:38:132:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = make([]interface{},\
    \ 2)\n                result[i][j][0] = i\n                result[i][j][1] = j\n\
    \            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnywmv6t0_test.go:26:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpnywmv6t0_test.go:27:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmpnywmv6t0_test.go:31:5: undefined: sort\n/tmp/tmpnywmv6t0_test.go:31:15:\
    \ undefined: byRow\n/tmp/tmpnywmv6t0_test.go:32:5: undefined: sort\n/tmp/tmpnywmv6t0_test.go:32:15:\
    \ undefined: byCol\n/tmp/tmpnywmv6t0_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnywmv6t0_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnywmv6t0_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnywmv6t0_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpnywmv6t0_test.go:48:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for _, row := range lst {\n        var\
    \ found bool\n        for _, v := range row {\n            if v == x {\n     \
    \           found = true\n                break\n            }\n        }\n  \
    \      if found {\n            result = append(result, row)\n        }\n    }\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return len(result[i]) >\
    \ len(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n     \
    \   return len(result[i]) < len(result[j])\n    })\n    return result\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjq6vxpib_test.go:28:37:\
    \ cannot use row (variable of type []int) as type []interface{} in argument to\
    \ append\n/tmp/tmpjq6vxpib_test.go:31:5: undefined: sort\n/tmp/tmpjq6vxpib_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpjq6vxpib_test.go:47:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjq6vxpib_test.go:48:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjq6vxpib_test.go:49:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjq6vxpib_test.go:52:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpjq6vxpib_test.go:52:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++\
    \ {\n        r[i] = make([]interface{}, len(lst[i]))\n        for j := 0; j <\
    \ len(lst[i]); j++ {\n            r[i][j] = lst[i][j]\n        }\n    }\n    sort.Sort(byRow(r))\n\
    \    sort.Sort(byCol(r))\n    r := make([][]interface{}, len(r))\n    for i :=\
    \ 0; i < len(r); i++ {\n        r[i] = make([]interface{}, len(r[i]))\n      \
    \  for j := 0; j < len(r[i]); j++ {\n            r[i][j] = r[i][j].([]interface{})\n\
    \        }\n    }\n    for i := 0; i < len(r); i++ {\n        for j := 0; j <\
    \ len(r[i]); j++ {\n            if r[i][j] == x {\n                return r\n\
    \            }\n        }\n    }\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpggtymyzf_test.go:25:5:\
    \ undefined: sort\n/tmp/tmpggtymyzf_test.go:25:15: undefined: byRow\n/tmp/tmpggtymyzf_test.go:26:5:\
    \ undefined: sort\n/tmp/tmpggtymyzf_test.go:26:15: undefined: byCol\n/tmp/tmpggtymyzf_test.go:27:7:\
    \ no new variables on left side of :=\n/tmp/tmpggtymyzf_test.go:51:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpggtymyzf_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpggtymyzf_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpggtymyzf_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpggtymyzf_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpggtymyzf_test.go:56:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] < result[j][0] {\n          \
    \  return true\n        }\n        if result[i][0] == result[j][0] {\n       \
    \     return result[i][1] > result[j][1]\n        }\n        return false\n  \
    \  })\n    sort.Slice(result, func(i, j int) bool {\n        if result[i][1] >\
    \ result[j][1] {\n            return true\n        }\n        if result[i][1]\
    \ == result[j][1] {\n            return result[i][0] < result[j][0]\n        }\n\
    \        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3hzmb3u_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpe3hzmb3u_test.go:30:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpe3hzmb3u_test.go:34:20:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpe3hzmb3u_test.go:38:5: undefined: sort\n/tmp/tmpe3hzmb3u_test.go:39:12:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpe3hzmb3u_test.go:43:20: invalid operation: result[i][0] < result[j][0]\
    \ (operator < not defined on interface)\n/tmp/tmpe3hzmb3u_test.go:57:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpe3hzmb3u_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpe3hzmb3u_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe3hzmb3u_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpe3hzmb3u_test.go:62:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := lst[i]\n        row_sorted, row_sorted\
    \ := row[:], row[:]\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sor\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfkzxiwe9_test.go:61:36: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range r {\n  \
    \      for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n   \
    \ }\n    r := r[x]\n    r := r[len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp80kplv0u_test.go:77:19: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    i := 0\n    for _, row\
    \ := range lst {\n        j = 0\n        for _, col := range row {\n         \
    \   r[i][j] = col\n            j++\n        }\n        i++\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(rows(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(columns(r))))\n    result := make([][]interface{},\
    \ len(r))\n    for i := range r {\n        result[i] = make([]interface{}, len(r[i]))\n\
    \    }\n    i := 0\n    for _, row := range r {\n        j = 0\n        for _,\
    \ col := range row {\n            result[i][j] = col\n            j++\n      \
    \  }\n        i++\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjn2g2xur_test.go:24:9: undefined: j

    /tmp/tmpjn2g2xur_test.go:26:18: undefined: j

    /tmp/tmpjn2g2xur_test.go:27:13: undefined: j

    /tmp/tmpjn2g2xur_test.go:31:5: undefined: sort

    /tmp/tmpjn2g2xur_test.go:31:42: undefined: rows

    /tmp/tmpjn2g2xur_test.go:32:5: undefined: sort

    /tmp/tmpjn2g2xur_test.go:32:42: undefined: columns

    /tmp/tmpjn2g2xur_test.go:37:7: no new variables on left side of :=

    /tmp/tmpjn2g2xur_test.go:39:9: undefined: j

    /tmp/tmpjn2g2xur_test.go:41:23: undefined: j

    /tmp/tmpjn2g2xur_test.go:41:23: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdfgcwvh0_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpdfgcwvh0_test.go:30:5: undefined: sort\n/tmp/tmpdfgcwvh0_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdfgcwvh0_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdfgcwvh0_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdfgcwvh0_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdfgcwvh0_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    i := 0\n    for _, row\
    \ := range lst {\n        for _, v := range row {\n            r[i][x] = v\n \
    \           i++\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(r)))\n    return r\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkw2j5_6o_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpkw2j5_6o_test.go:29:42: undefined: row\n/tmp/tmpkw2j5_6o_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpkw2j5_6o_test.go:41:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkw2j5_6o_test.go:42:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkw2j5_6o_test.go:43:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkw2j5_6o_test.go:46:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpkw2j5_6o_test.go:46:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, _ := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := make([]interface{}, 0)\n    \
    \    for j := 0; j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n   \
    \             row = append(row, j)\n            }\n        }\n        result =\
    \ append(result, row)\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpib097div_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpib097div_test.go:30:5: undefined: sort\n/tmp/tmpib097div_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpib097div_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpib097div_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpib097div_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpib097div_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        for\
    \ _, value := range row {\n            if value == x {\n                result\
    \ = append(result, []interface{}{row, value})\n            }\n        }\n    }\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][0] < result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc5uazix3_test.go:26:5:\
    \ undefined: sort\n/tmp/tmpc5uazix3_test.go:27:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpc5uazix3_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpc5uazix3_test.go:30:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpc5uazix3_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpc5uazix3_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpc5uazix3_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpc5uazix3_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpc5uazix3_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_helper(row, x))\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] > result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] < result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1vrhzvic_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp1vrhzvic_test.go:20:34: undefined: get_row_helper\n\
    /tmp/tmp1vrhzvic_test.go:22:5: undefined: sort\n/tmp/tmp1vrhzvic_test.go:23:16:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmp1vrhzvic_test.go:25:5: undefined: sort\n/tmp/tmp1vrhzvic_test.go:26:16:\
    \ invalid operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmp1vrhzvic_test.go:38:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp1vrhzvic_test.go:39:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1vrhzvic_test.go:40:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1vrhzvic_test.go:43:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp1vrhzvic_test.go:43:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0fw7g6cm_test.go:30:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:31:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:32:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:35:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0fw7g6cm_test.go:35:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        result\
    \ := append(result, []interface{}{row[x], len(row)})\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] > result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] < result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpegcd7y4j_test.go:20:9:\
    \ result declared but not used\n/tmp/tmpegcd7y4j_test.go:22:5: undefined: sort\n\
    /tmp/tmpegcd7y4j_test.go:23:16: invalid operation: result[i][0] > result[j][0]\
    \ (operator > not defined on interface)\n/tmp/tmpegcd7y4j_test.go:25:5: undefined:\
    \ sort\n/tmp/tmpegcd7y4j_test.go:26:16: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpegcd7y4j_test.go:38:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpegcd7y4j_test.go:39:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpegcd7y4j_test.go:40:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpegcd7y4j_test.go:43:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpegcd7y4j_test.go:43:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpegcd7y4j_test.go:43:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075496
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] < result[j][0] {\n          \
    \  return true\n        }\n        if result[i][0] > result[j][0] {\n        \
    \    return false\n        }\n        if result[i][1] > result[j][1] {\n     \
    \       return true\n        }\n        if result[i][1] < result[j][1] {\n   \
    \         return false\n        }\n        return false\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][1] > result[j][1] {\n          \
    \  return true\n        }\n        if result[i][1] < result[j][1] {\n        \
    \    return false\n        }\n        return false\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbiid0x_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpixbiid0x_test.go:30:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpixbiid0x_test.go:33:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmpixbiid0x_test.go:36:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpixbiid0x_test.go:39:12: invalid\
    \ operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmpixbiid0x_test.go:44:5: undefined: sort\n/tmp/tmpixbiid0x_test.go:45:12:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpixbiid0x_test.go:48:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpixbiid0x_test.go:63:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpixbiid0x_test.go:64:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpixbiid0x_test.go:64:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range r {\n  \
    \      for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n   \
    \ }\n    sort.Sort(byRow(r))\n    sort.Sort(byCol(r))\n    r := [][]interface{}{}\n\
    \    for _, r := range r {\n        r := r[:0]\n        sort.Sort(byRow(r))\n\
    \        sort.Sort(byCol(r))\n        r = append(r, r)\n    }\n    return r\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpieisjg66_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpieisjg66_test.go:27:15: undefined: byRow\n/tmp/tmpieisjg66_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpieisjg66_test.go:28:15: undefined: byCol\n/tmp/tmpieisjg66_test.go:29:7:\
    \ no new variables on left side of :=\n/tmp/tmpieisjg66_test.go:32:9: undefined:\
    \ sort\n/tmp/tmpieisjg66_test.go:32:19: undefined: byRow\n/tmp/tmpieisjg66_test.go:33:9:\
    \ undefined: sort\n/tmp/tmpieisjg66_test.go:33:19: undefined: byCol\n/tmp/tmpieisjg66_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpieisjg66_test.go:46:132: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n                break\n            }\n      \
    \  }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][0]\
    \ < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool {\n     \
    \   return result[i][1] > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2f3ukiy5_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp2f3ukiy5_test.go:31:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp2f3ukiy5_test.go:33:5:\
    \ undefined: sort\n/tmp/tmp2f3ukiy5_test.go:34:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp2f3ukiy5_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2f3ukiy5_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2f3ukiy5_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2f3ukiy5_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp2f3ukiy5_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfbz8qmrv_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpfbz8qmrv_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpfbz8qmrv_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpfbz8qmrv_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpfbz8qmrv_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfbz8qmrv_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    \n    for i\
    \ := range lst {\n        for j := range lst[i] {\n            if lst[i][j] ==\
    \ x {\n                result[i] = append(result[i], j)\n            }\n     \
    \   }\n    }\n    \n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    \n    sort.Slice(result, func(i, j\
    \ int) bool {\n        return result[i][1] > result[j][1]\n    })\n    \n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9me6cog3_test.go:31:5:\
    \ undefined: sort\n/tmp/tmp9me6cog3_test.go:32:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp9me6cog3_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp9me6cog3_test.go:36:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp9me6cog3_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9me6cog3_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9me6cog3_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9me6cog3_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9me6cog3_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6s7_vyzr_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp6s7_vyzr_test.go:31:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp6s7_vyzr_test.go:33:5:\
    \ undefined: sort\n/tmp/tmp6s7_vyzr_test.go:34:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp6s7_vyzr_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6s7_vyzr_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6s7_vyzr_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6s7_vyzr_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6s7_vyzr_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \ }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnojipzdb_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:29:15: undefined: byRow\n/tmp/tmpnojipzdb_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:30:15: undefined: byCol\n/tmp/tmpnojipzdb_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnojipzdb_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnojipzdb_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n\
    \        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57a37kzs_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp57a37kzs_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp57a37kzs_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp57a37kzs_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp57a37kzs_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp57a37kzs_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp57a37kzs_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp57a37kzs_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp57a37kzs_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    \n    sort.Slice(lst,\
    \ func(i, j int) bool {\n        return lst[i][0] > lst[j][0]\n    })\n    \n\
    \    sort.Slice(lst[0], func(i, j int) bool {\n        return lst[0][i] > lst[0][j]\n\
    \    })\n    \n    for i := range lst {\n        for j := range lst[0] {\n   \
    \         if lst[i][j] == x {\n                result[i] = append(result[i], j)\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq8na1roh_test.go:23:5:\
    \ undefined: sort\n/tmp/tmpq8na1roh_test.go:27:5: undefined: sort\n/tmp/tmpq8na1roh_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq8na1roh_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpq8na1roh_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq8na1roh_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpq8na1roh_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_helper(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzpi_0b_e_test.go:20:9:\
    \ result declared but not used\n/tmp/tmpzpi_0b_e_test.go:20:34: undefined: get_row_helper\n\
    /tmp/tmpzpi_0b_e_test.go:22:5: undefined: sort\n/tmp/tmpzpi_0b_e_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmpzpi_0b_e_test.go:23:5: undefined: sort\n/tmp/tmpzpi_0b_e_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmpzpi_0b_e_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzpi_0b_e_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpzpi_0b_e_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzpi_0b_e_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpzpi_0b_e_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       r := make([]interface{}, 0)\n        for _, v := range row {\n       \
    \     if v == x {\n                r = append(r, v)\n            }\n        }\n\
    \        result = append(result, r)\n    }\n    sort.Sort(byRow(result))\n   \
    \ sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplm8l94m6_test.go:28:5:\
    \ undefined: sort\n/tmp/tmplm8l94m6_test.go:28:15: undefined: byRow\n/tmp/tmplm8l94m6_test.go:29:5:\
    \ undefined: sort\n/tmp/tmplm8l94m6_test.go:29:15: undefined: byCol\n/tmp/tmplm8l94m6_test.go:40:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplm8l94m6_test.go:41:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmplm8l94m6_test.go:42:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplm8l94m6_test.go:45:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmplm8l94m6_test.go:45:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    result := [][]interface{}{}\n    rows, _\
    \ := len(lst), len(lst[0])\n    for i := 0; i < rows; i++ {\n        row := lst[i]\n\
    \        row_sorted, _ := sort.Ints(row)\n        row_sorted = row_sorted[:x]\n\
    \        row_sorted = row_sorted[::-1]\n        row_sorted = append(row_sorted,\
    \ row_sorted[0])\n        row_sorted = append(row_sorted, row_sorted[len(row_sorted)-1])\n\
    \        row_sorted = append(row_sorted, row_sorted[0])\n        row_sorted =\
    \ append(row_sorted, row_sorted[len(row_sorted)-1])\n        row_sorted = append(row_sorted,\
    \ row_sorted[0])\n        row_sorted = append(row_sorted, row_sorted[len(row_sorted)-1])\n\
    \        row_sorted = append(row_sorted, row_sorted[0])\n        row_sorted =\
    \ append(row_sorted, row_sorted[len(row_sorted)-1])\n        row_sorted = append(row_sorted,\
    \ row_sorted[0])\n        row_sorted = append(row_sorted, row_sorted[len(row_sorted)-1])\n\
    \        row_sorted = append(row_sorted, row_sorted[0])\n        row_sorted =\
    \ append(row_sorted, row_sorted[len(row_sorted)-1])\n        row_sorted = append(row_sorted,\
    \ row_sorted[0])\n        row_sorted = append(row_sorted, row_sorted[len(row_sorted)-1])\n\
    \        row_sorted = append(row_sorted, row_sorted[0])\n        row_sorted =\
    \ append(row_sorted, row_sorted[len(row_sorted)-1])\n        row_sorted = append(row_sorted,\
    \ row_sorted[0])\n        row_sorted = append(row_sorted, row_sorted[len(row_sorted)-1])\n\
    \        row_sorted = append(row_sorted, row_sorted[0])\n        row_sorted =\
    \ append(row_sorted, row_sorted[len(row_sorted)-1])\n        row_sorted = append(row_sorted,\
    \ row_sorted[0])\n        row_sorted = append(row_sorted, row_sorted[len(row_sorted)-1])\n\
    \        row_sorted = append(row_sorted, row_sorted[0])\n        row_sorted =\
    \ append(row_sorted, row_sorted[len(row_sorted)-1])\n        row_sorted = append(row_sorted,\
    \ row_sorted[0])\n        row_sorted = append(row_sorted, row_sorted[len(row_sorted)-1])\n\
    \        row_sorted = append(row_sorted, row_sorted[0])\n        row_sorted =\
    \ append(row_sorted, row_sorted[len(row_sorted)-1])\n        row_sorted = append(row_sorted,\
    \ row_sorted[0])\n        row_sorted = append(row_sorted, row_sorted[len(row_sorted)-1])\n\
    \        row_sorted = append(row_sorted, row_sorted[0])\n        row_sorted =\
    \ append(row_sorted, row_sorted[len(\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpabw_g2vo_test.go:25:33: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = make([]interface{}, 2)\n                result[i][j][0]\
    \ = i\n                result[i][j][1] = j\n            }\n        }\n    }\n\
    \    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxaujnkky_test.go:26:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpxaujnkky_test.go:27:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmpxaujnkky_test.go:31:5: undefined: sort\n/tmp/tmpxaujnkky_test.go:31:15:\
    \ undefined: byRow\n/tmp/tmpxaujnkky_test.go:32:5: undefined: sort\n/tmp/tmpxaujnkky_test.go:32:15:\
    \ undefined: byCol\n/tmp/tmpxaujnkky_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxaujnkky_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxaujnkky_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxaujnkky_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpxaujnkky_test.go:48:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++\
    \ {\n        r := append(r, make([]interface{}, len(lst[i]))) // add columns to\
    \ each row\n        for j := 0; j < len(lst[i]); j++ {\n            r[i][j] =\
    \ lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n    return r\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppobxx0a2_test.go:25:5:\
    \ undefined: sort\n/tmp/tmppobxx0a2_test.go:25:42: undefined: row\n/tmp/tmppobxx0a2_test.go:26:5:\
    \ undefined: sort\n/tmp/tmppobxx0a2_test.go:26:42: undefined: col\n/tmp/tmppobxx0a2_test.go:37:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppobxx0a2_test.go:38:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmppobxx0a2_test.go:39:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppobxx0a2_test.go:42:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmppobxx0a2_test.go:42:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    r := r[:0]\n    for i :=\
    \ range lst {\n        for j := range lst[i] {\n            if lst[i][j] == x\
    \ {\n                r[len(r)] = append(r[len(r)], fmt.Sprintf(\"(%d, %d)\", i,\
    \ j))\n            }\n        }\n    }\n    sort.Slice(r, func(i, j int) bool\
    \ {\n        if r[i].Len() > r[j].Len() {\n            return true\n        }\n\
    \        if r[i].Len() < r[j].Len() {\n            return false\n        }\n \
    \       for k := 0; k < r[i].Len(); k++ {\n            if r[i][k] > r[j][k] {\n\
    \                return true\n            }\n            if r[i][k] < r[j][k]\
    \ {\n                return false\n            }\n        }\n        return false\n\
    \    })\n    sort.Slice(r, func(i, j int) bool {\n        if r[i].Len() > r[j].Len()\
    \ {\n            return true\n        }\n        if r[i].Len() < r[j].Len() {\n\
    \            return false\n        }\n        for k := 0; k < r[i].Len(); k++\
    \ {\n            if r[i][k] > r[j][k] {\n                return true\n       \
    \     }\n            if r[i][k] < r[j][k] {\n                return false\n  \
    \          }\n        }\n        return false\n    })\n    return r\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgcq93v0l_test.go:22:7: no new variables on left side of :=

    /tmp/tmpgcq93v0l_test.go:30:5: undefined: sort

    /tmp/tmpgcq93v0l_test.go:31:17: r[i].Len undefined (type []interface{} has no
    field or method Len)

    /tmp/tmpgcq93v0l_test.go:31:30: r[j].Len undefined (type []interface{} has no
    field or method Len)

    /tmp/tmpgcq93v0l_test.go:34:17: r[i].Len undefined (type []interface{} has no
    field or method Len)

    /tmp/tmpgcq93v0l_test.go:34:30: r[j].Len undefined (type []interface{} has no
    field or method Len)

    /tmp/tmpgcq93v0l_test.go:37:30: r[i].Len undefined (type []interface{} has no
    field or method Len)

    /tmp/tmpgcq93v0l_test.go:38:16: invalid operation: r[i][k] > r[j][k] (operator
    > not defined on interface)

    /tmp/tmpgcq93v0l_test.go:41:16: invalid operation: r[i][k] < r[j][k] (operator
    < not defined on interface)

    /tmp/tmpgcq93v0l_test.go:47:5: undefined: sort

    /tmp/tmpgcq93v0l_test.go:47:5: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = make([]interface{}, 2)\n                result[i][j][0]\
    \ = i\n                result[i][j][1] = j\n            }\n        }\n    }\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][0] > result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6mm90vn6_test.go:26:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmp6mm90vn6_test.go:27:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmp6mm90vn6_test.go:31:5: undefined: sort\n/tmp/tmp6mm90vn6_test.go:32:16:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmp6mm90vn6_test.go:34:5: undefined: sort\n/tmp/tmp6mm90vn6_test.go:35:16:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmp6mm90vn6_test.go:47:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp6mm90vn6_test.go:48:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6mm90vn6_test.go:49:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6mm90vn6_test.go:52:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp6mm90vn6_test.go:52:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_test(row, x))\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return row[i][0] > row[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return row[i][1] < row[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3kp5zocy_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp3kp5zocy_test.go:20:34: undefined: get_row_test\n\
    /tmp/tmp3kp5zocy_test.go:22:5: undefined: sort\n/tmp/tmp3kp5zocy_test.go:23:16:\
    \ undefined: row\n/tmp/tmp3kp5zocy_test.go:25:5: undefined: sort\n/tmp/tmp3kp5zocy_test.go:26:16:\
    \ undefined: row\n/tmp/tmp3kp5zocy_test.go:38:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp3kp5zocy_test.go:39:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp3kp5zocy_test.go:40:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp3kp5zocy_test.go:43:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp3kp5zocy_test.go:43:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for _, row := range lst {\n        var\
    \ row_result []interface{}\n        for _, value := range row {\n            if\
    \ value == x {\n                row_result = append(row_result, value)\n     \
    \       }\n        }\n        result = append(result, row_result)\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return result[i][0] > result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ < result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp33pkig5n_test.go:28:5:\
    \ undefined: sort\n/tmp/tmp33pkig5n_test.go:29:16: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmp33pkig5n_test.go:31:5:\
    \ undefined: sort\n/tmp/tmp33pkig5n_test.go:32:16: invalid operation: result[i][1]\
    \ < result[j][1] (operator < not defined on interface)\n/tmp/tmp33pkig5n_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp33pkig5n_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp33pkig5n_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp33pkig5n_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp33pkig5n_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range r {\n  \
    \      for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n   \
    \ }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n\
    \    for i := range r {\n        r[i] = r[i][col(r[i])]\n    }\n    return r\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfllqsrvl_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpfllqsrvl_test.go:27:42: undefined: row\n/tmp/tmpfllqsrvl_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpfllqsrvl_test.go:28:42: undefined: col\n/tmp/tmpfllqsrvl_test.go:30:16:\
    \ cannot use r[i][col(r[i])] (variable of type interface{}) as type []interface{}\
    \ in assignment:\n\tneed type assertion\n/tmp/tmpfllqsrvl_test.go:30:21: undefined:\
    \ col\n/tmp/tmpfllqsrvl_test.go:42:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfllqsrvl_test.go:43:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfllqsrvl_test.go:44:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfllqsrvl_test.go:47:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpfllqsrvl_test.go:47:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \ }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        if\
    \ result[i][0] < result[j][0] {\n            return true\n        }\n        return\
    \ false\n    })\n    sort.Slice(result, func(i, j int) bool {\n        if result[i][1]\
    \ > result[j][1] {\n            return true\n        }\n        return false\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq04c8_xs_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpq04c8_xs_test.go:30:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpq04c8_xs_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpq04c8_xs_test.go:36:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpq04c8_xs_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq04c8_xs_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpq04c8_xs_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq04c8_xs_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpq04c8_xs_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        if result[i][0] < result[j][0] {\n            return\
    \ true\n        }\n        return false\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        if result[i][1] > result[j][1] {\n            return\
    \ true\n        }\n        return false\n    })\n    return result\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7t4uunps_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp7t4uunps_test.go:31:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp7t4uunps_test.go:36:5:\
    \ undefined: sort\n/tmp/tmp7t4uunps_test.go:37:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp7t4uunps_test.go:52:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7t4uunps_test.go:53:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7t4uunps_test.go:54:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7t4uunps_test.go:57:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7t4uunps_test.go:57:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        result\
    \ := append(result, get_row_test(row, x))\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7t5x5z95_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp7t5x5z95_test.go:20:34: undefined: get_row_test\n\
    /tmp/tmp7t5x5z95_test.go:22:5: undefined: sort\n/tmp/tmp7t5x5z95_test.go:23:16:\
    \ invalid operation: result[i][0] < result[j][0] (operator < not defined on interface)\n\
    /tmp/tmp7t5x5z95_test.go:25:5: undefined: sort\n/tmp/tmp7t5x5z95_test.go:26:16:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmp7t5x5z95_test.go:38:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp7t5x5z95_test.go:39:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7t5x5z95_test.go:40:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7t5x5z95_test.go:43:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp7t5x5z95_test.go:43:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, make([]interface{}, len(row)))\n        for _,\
    \ v := range row {\n            if v == x {\n                result[len(result)-1]\
    \ = make([]interface{}, 1)\n                result[len(result)-1][0] = v\n   \
    \         }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return rows[i][len(rows[i])-1] < rows[j][len(rows[j])-1]\n    })\n  \
    \  sort.Slice(rows, func(i, j int) bool {\n        return rows[i][len(rows[i])-1]\
    \ > rows[j][len(rows[j])-1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9b7ca_sr_test.go:28:5:\
    \ undefined: sort\n/tmp/tmp9b7ca_sr_test.go:29:16: undefined: rows\n/tmp/tmp9b7ca_sr_test.go:31:5:\
    \ undefined: sort\n/tmp/tmp9b7ca_sr_test.go:31:16: undefined: rows\n/tmp/tmp9b7ca_sr_test.go:32:16:\
    \ undefined: rows\n/tmp/tmp9b7ca_sr_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9b7ca_sr_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9b7ca_sr_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9b7ca_sr_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp9b7ca_sr_test.go:49:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9b7ca_sr_test.go:49:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuzd5rmld_test.go:273:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    \n    for i := range r\
    \ {\n        for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n\
    \    }\n    \n    r := r[x]\n    \n    sort.Slice(r, func(i, j int) bool {\n \
    \       if r[i].([]interface{})[j].(int) < r[j].([]interface{})[j].(int) {\n \
    \           return true\n        }\n        return false\n    })\n    \n    sort.Slice(r,\
    \ func(i, j int) bool {\n        if r[i].([]interface{})[j].(int) > r[j].([]interface{})[j].(int)\
    \ {\n            return false\n        }\n        return true\n    })\n    \n\
    \    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vzjgc8e_test.go:29:7:\
    \ no new variables on left side of :=\n/tmp/tmp0vzjgc8e_test.go:29:10: cannot\
    \ use r[x] (variable of type []interface{}) as type [][]interface{} in assignment\n\
    /tmp/tmp0vzjgc8e_test.go:31:5: undefined: sort\n/tmp/tmp0vzjgc8e_test.go:32:12:\
    \ invalid operation: r[i] (variable of type []interface{}) is not an interface\n\
    /tmp/tmp0vzjgc8e_test.go:32:44: invalid operation: r[j] (variable of type []interface{})\
    \ is not an interface\n/tmp/tmp0vzjgc8e_test.go:38:5: undefined: sort\n/tmp/tmp0vzjgc8e_test.go:39:12:\
    \ invalid operation: r[i] (variable of type []interface{}) is not an interface\n\
    /tmp/tmp0vzjgc8e_test.go:39:44: invalid operation: r[j] (variable of type []interface{})\
    \ is not an interface\n/tmp/tmp0vzjgc8e_test.go:55:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vzjgc8e_test.go:56:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0vzjgc8e_test.go:56:207: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfbz8qmrv_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpfbz8qmrv_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpfbz8qmrv_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpfbz8qmrv_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpfbz8qmrv_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfbz8qmrv_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n\
    \        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        if result[i][0]\
    \ < result[j][0] {\n            return true\n        }\n        if result[i][0]\
    \ > result[j][0] {\n            return false\n        }\n        if result[i][1]\
    \ > result[j][1] {\n            return true\n        }\n        if result[i][1]\
    \ < result[j][1] {\n            return false\n        }\n        return false\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        if result[i][1]\
    \ > result[j][1] {\n            return true\n        }\n        if result[i][1]\
    \ < result[j][1] {\n            return false\n        }\n        if result[i][0]\
    \ > result[j][0] {\n            return true\n        }\n        if result[i][0]\
    \ < result[j][0] {\n            return false\n        }\n        return false\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7szy2j6n_test.go:29:5: undefined: sort

    /tmp/tmp7szy2j6n_test.go:30:12: invalid operation: result[i][0] < result[j][0]
    (operator < not defined on interface)

    /tmp/tmp7szy2j6n_test.go:33:12: invalid operation: result[i][0] > result[j][0]
    (operator > not defined on interface)

    /tmp/tmp7szy2j6n_test.go:36:12: invalid operation: result[i][1] > result[j][1]
    (operator > not defined on interface)

    /tmp/tmp7szy2j6n_test.go:39:12: invalid operation: result[i][1] < result[j][1]
    (operator < not defined on interface)

    /tmp/tmp7szy2j6n_test.go:44:5: undefined: sort

    /tmp/tmp7szy2j6n_test.go:45:12: invalid operation: result[i][1] > result[j][1]
    (operator > not defined on interface)

    /tmp/tmp7szy2j6n_test.go:48:12: invalid operation: result[i][1] < result[j][1]
    (operator < not defined on interface)

    /tmp/tmp7szy2j6n_test.go:51:12: invalid operation: result[i][0] > result[j][0]
    (operator > not defined on interface)

    /tmp/tmp7szy2j6n_test.go:54:12: invalid operation: result[i][0] < result[j][0]
    (operator < not defined on interface)

    /tmp/tmp7szy2j6n_test.go:54:12: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, make([]interface{}, len(row)))\n        for _,\
    \ col := range row {\n            if col == x {\n                result := append(result,\
    \ make([]interface{}, 1))\n                result := append(result[0], make([]interface{},\
    \ 1))\n                result := append(result[0], make([]interface{}, 1))\n \
    \               result := append(result[0], make([]interface{}, 1))\n        \
    \        result := append(result[0], make([]interface{}, 1))\n               \
    \ result := append(result[0], make([]interface{}, 1))\n                result\
    \ := append(result[0], make([]interface{}, 1))\n                result := append(result[0],\
    \ make([]interface{}, 1))\n                result := append(result[0], make([]interface{},\
    \ 1))\n                result := append(result[0], make([]interface{}, 1))\n \
    \               result := append(result[0], make([]interface{}, 1))\n        \
    \        result := append(result[0], make([]interface{}, 1))\n               \
    \ result := append(result[0], make([]interface{}, 1))\n                result\
    \ := append(result[0], make([]interface{}, 1))\n                result := append(result[0],\
    \ make([]interface{}, 1))\n                result := append(result[0], make([]interface{},\
    \ 1))\n                result := append(result[0], make([]interface{}, 1))\n \
    \               result := append(result[0], make([]interface{}, 1))\n        \
    \        result := append(result[0], make([]interface{}, 1))\n               \
    \ result := append(result[0], make([]interface{}, 1))\n                result\
    \ := append(result[0], make([]interface{}, 1))\n                result := append(result[0],\
    \ make([]interface{}, 1))\n                result := append(result[0], make([]interface{},\
    \ 1))\n                result := append(result[0], make([]interface{}, 1))\n \
    \               result := append(result[0], make([]interface{}, 1))\n        \
    \        result := append(result[0], make([]interface{}, 1))\n               \
    \ result := append(result[0], make([]interface{}, 1))\n                result\
    \ := append(result[0], make([]interface{}, 1))\n                result := append(result[0],\
    \ make([]interface{}, 1))\n                result := append(result[0], make([]interface{},\
    \ 1))\n                result := append(result[0], make([]interface{}, 1))\n \
    \               result := append(result[0], make([]interface{}, 1))\n        \
    \        result := append(result[0], make([]interface{}, 1))\n               \
    \ result := append(result[0], make([]interface{}, 1))\n                result\
    \ := append(result[0], make([]interface{}, 1))\n                result := append(result[0],\
    \ make([]interface\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplmmq_k5i_test.go:59:1: expected ''{'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0fw7g6cm_test.go:30:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:31:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:32:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:35:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0fw7g6cm_test.go:35:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] > result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] < result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkvza5ut6_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpkvza5ut6_test.go:30:16: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmpkvza5ut6_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpkvza5ut6_test.go:33:16: invalid operation: result[i][1]\
    \ < result[j][1] (operator < not defined on interface)\n/tmp/tmpkvza5ut6_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkvza5ut6_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkvza5ut6_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkvza5ut6_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkvza5ut6_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    \n    for i\
    \ := range lst {\n        for j := range lst[i] {\n            if lst[i][j] ==\
    \ x {\n                result[i][j] = make([]interface{}, 2)\n               \
    \ result[i][j][0] = i\n                result[i][j][1] = j\n            }\n  \
    \      }\n    }\n    \n    for i := range result {\n        sort.SliceStable(result[i],\
    \ func(i, j int) bool {\n            return result[i][j][0] == result[i][len(result[i])-1][0]\n\
    \        })\n        sort.SliceStable(result[i], func(i, j int) bool {\n     \
    \       return result[i][j][1] == result[i][len(result[i])-1][1]\n        })\n\
    \    }\n    \n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiyy7s2fh_test.go:27:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpiyy7s2fh_test.go:28:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmpiyy7s2fh_test.go:34:9: undefined: sort\n/tmp/tmpiyy7s2fh_test.go:35:32:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpiyy7s2fh_test.go:35:66: invalid operation: cannot index result[i][len(result[i])\
    \ - 1] (variable of type interface{})\n/tmp/tmpiyy7s2fh_test.go:37:9: undefined:\
    \ sort\n/tmp/tmpiyy7s2fh_test.go:38:32: invalid operation: cannot index result[i][j]\
    \ (variable of type interface{})\n/tmp/tmpiyy7s2fh_test.go:38:66: invalid operation:\
    \ cannot index result[i][len(result[i]) - 1] (variable of type interface{})\n\
    /tmp/tmpiyy7s2fh_test.go:52:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpiyy7s2fh_test.go:53:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiyy7s2fh_test.go:53:207: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075498
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_helper(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzpi_0b_e_test.go:20:9:\
    \ result declared but not used\n/tmp/tmpzpi_0b_e_test.go:20:34: undefined: get_row_helper\n\
    /tmp/tmpzpi_0b_e_test.go:22:5: undefined: sort\n/tmp/tmpzpi_0b_e_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmpzpi_0b_e_test.go:23:5: undefined: sort\n/tmp/tmpzpi_0b_e_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmpzpi_0b_e_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzpi_0b_e_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpzpi_0b_e_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzpi_0b_e_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpzpi_0b_e_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_test(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vm1i32c_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp0vm1i32c_test.go:20:34: undefined: get_row_test\n\
    /tmp/tmp0vm1i32c_test.go:22:5: undefined: sort\n/tmp/tmp0vm1i32c_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmp0vm1i32c_test.go:23:5: undefined: sort\n/tmp/tmp0vm1i32c_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmp0vm1i32c_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vm1i32c_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0vm1i32c_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vm1i32c_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp0vm1i32c_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        result := append(result, make([]interface{},\
    \ cols))\n        for j := 0; j < cols; j++ {\n            if lst[i][j] == x {\n\
    \                result[i] = append(result[i], j)\n            }\n        }\n\
    \    }\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][0]\
    \ < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool {\n     \
    \   return result[i][1] > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcovou6jn_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpcovou6jn_test.go:29:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpcovou6jn_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpcovou6jn_test.go:32:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpcovou6jn_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcovou6jn_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcovou6jn_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcovou6jn_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcovou6jn_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for _, row := range lst {\n        var\
    \ row_result []interface{}\n        for _, val := range row {\n            if\
    \ val == x {\n                row_result = append(row_result, val)\n         \
    \   }\n        }\n        result = append(result, row_result)\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdghhd0fa_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpdghhd0fa_test.go:29:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpdghhd0fa_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpdghhd0fa_test.go:32:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpdghhd0fa_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdghhd0fa_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdghhd0fa_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdghhd0fa_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdghhd0fa_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuzd5rmld_test.go:273:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i] = append(result[i], j)\n            }\n        }\n  \
    \  }\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][0]\
    \ > result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool {\n     \
    \   return result[i][1] < result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5tr1vevg_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp5tr1vevg_test.go:30:16: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmp5tr1vevg_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp5tr1vevg_test.go:33:16: invalid operation: result[i][1]\
    \ < result[j][1] (operator < not defined on interface)\n/tmp/tmp5tr1vevg_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5tr1vevg_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5tr1vevg_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5tr1vevg_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5tr1vevg_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        row_result\
    \ := []interface{}{}\n        for _, value := range row {\n            if value\
    \ == x {\n                row_result = append(row_result, value)\n           \
    \ }\n        }\n        result = append(result, row_result)\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz0uqx1f1_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpz0uqx1f1_test.go:29:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpz0uqx1f1_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpz0uqx1f1_test.go:32:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpz0uqx1f1_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz0uqx1f1_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz0uqx1f1_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz0uqx1f1_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpz0uqx1f1_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    \n    // sort coordinates by rows in\
    \ ascending order\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i][0]\
    \ < lst[j][0]\n    })\n    \n    // sort coordinates of row by columns in descending\
    \ order\n    for _, row := range lst {\n        sort.Slice(row, func(i, j int)\
    \ bool {\n            return row[i] > row[j]\n        })\n    }\n    \n    //\
    \ find coordinates of x in the list\n    for _, row := range lst {\n        if\
    \ row[0] == x {\n            result = append(result, []interface{}{row[0], row[1]})\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9tk3djao_test.go:21:5:\
    \ undefined: sort\n/tmp/tmp9tk3djao_test.go:27:9: undefined: sort\n/tmp/tmp9tk3djao_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9tk3djao_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9tk3djao_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9tk3djao_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9tk3djao_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++\
    \ {\n        r[i] = make([]interface{}, len(lst[i]))\n        for j := 0; j <\
    \ len(lst[i]); j++ {\n            r[i][j] = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n    return r\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7tndomfz_test.go:25:5:\
    \ undefined: sort\n/tmp/tmp7tndomfz_test.go:25:42: undefined: row\n/tmp/tmp7tndomfz_test.go:26:5:\
    \ undefined: sort\n/tmp/tmp7tndomfz_test.go:26:42: undefined: col\n/tmp/tmp7tndomfz_test.go:37:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7tndomfz_test.go:38:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7tndomfz_test.go:39:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7tndomfz_test.go:42:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7tndomfz_test.go:42:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range r {\n  \
    \      for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n   \
    \ }\n    r := r[x]\n    r := r[len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n\
    \    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r := r[:len(r)-1]\n    r :=\
    \ r[:len(r)-1]\n    r := r[:len(r)\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp80kplv0u_test.go:77:19: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyjojuk4i_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpyjojuk4i_test.go:30:5: undefined: sort\n/tmp/tmpyjojuk4i_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyjojuk4i_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyjojuk4i_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyjojuk4i_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyjojuk4i_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8kaf6v2r_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp8kaf6v2r_test.go:29:15: undefined: byRow\n/tmp/tmp8kaf6v2r_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp8kaf6v2r_test.go:30:15: undefined: byCol\n/tmp/tmp8kaf6v2r_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8kaf6v2r_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8kaf6v2r_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8kaf6v2r_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp8kaf6v2r_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, make([]interface{}, len(row)))\n        for _,\
    \ col := range row {\n            result[len(result)-1] = append(result[len(result)-1],\
    \ col)\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    result := result[x:]\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgfa135i4_test.go:25:5:\
    \ undefined: sort\n/tmp/tmpgfa135i4_test.go:25:15: undefined: byRow\n/tmp/tmpgfa135i4_test.go:26:5:\
    \ undefined: sort\n/tmp/tmpgfa135i4_test.go:26:15: undefined: byCol\n/tmp/tmpgfa135i4_test.go:27:12:\
    \ no new variables on left side of :=\n/tmp/tmpgfa135i4_test.go:38:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpgfa135i4_test.go:39:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpgfa135i4_test.go:40:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgfa135i4_test.go:43:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpgfa135i4_test.go:43:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgfa135i4_test.go:43:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := make([]interface{}, cols)\n \
    \       for j := 0; j < cols; j++ {\n            row[j] = lst[i][j]\n        }\n\
    \        sort.Ints(row)\n        sort.Ints(row[:cols])\n        result = append(result,\
    \ row)\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n\
    \    return [][]interface{}{result[x]}\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp721ne0ca_test.go:25:9:\
    \ undefined: sort\n/tmp/tmp721ne0ca_test.go:26:9: undefined: sort\n/tmp/tmp721ne0ca_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp721ne0ca_test.go:30:5: undefined: sort\n/tmp/tmp721ne0ca_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp721ne0ca_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp721ne0ca_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp721ne0ca_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp721ne0ca_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for _, row := range lst {\n        var\
    \ found bool\n        for _, col := range row {\n            if col == x {\n \
    \               found = true\n                break\n            }\n        }\n\
    \        if found {\n            result = append(result, []interface{}{row, col})\n\
    \        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpddp5l09q_test.go:28:56:\
    \ undefined: col\n/tmp/tmpddp5l09q_test.go:31:5: undefined: sort\n/tmp/tmpddp5l09q_test.go:32:16:\
    \ invalid operation: result[i][0] < result[j][0] (operator < not defined on interface)\n\
    /tmp/tmpddp5l09q_test.go:34:5: undefined: sort\n/tmp/tmpddp5l09q_test.go:35:16:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpddp5l09q_test.go:47:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpddp5l09q_test.go:48:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpddp5l09q_test.go:49:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpddp5l09q_test.go:52:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpddp5l09q_test.go:52:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpddp5l09q_test.go:52:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        result\
    \ := append(result, []interface{}{row, get_col(row, x)})\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaecjw1vf_test.go:20:9:\
    \ result declared but not used\n/tmp/tmpaecjw1vf_test.go:20:53: undefined: get_col\n\
    /tmp/tmpaecjw1vf_test.go:22:5: undefined: sort\n/tmp/tmpaecjw1vf_test.go:23:5:\
    \ undefined: sort\n/tmp/tmpaecjw1vf_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpaecjw1vf_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpaecjw1vf_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpaecjw1vf_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpaecjw1vf_test.go:39:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i] = append(result[i], j)\n            }\n        }\n  \
    \  }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp63iqpr6r_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp63iqpr6r_test.go:29:15: undefined: byRow\n/tmp/tmp63iqpr6r_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp63iqpr6r_test.go:30:15: undefined: byCol\n/tmp/tmp63iqpr6r_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp63iqpr6r_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp63iqpr6r_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp63iqpr6r_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp63iqpr6r_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n                break\n            }\n      \
    \  }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5x9_f8r2_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp5x9_f8r2_test.go:31:5: undefined: sort\n/tmp/tmp5x9_f8r2_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5x9_f8r2_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5x9_f8r2_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5x9_f8r2_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5x9_f8r2_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\ntype byRow [][]interface{}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt12g4ytn_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpt12g4ytn_test.go:30:5: undefined: sort\n/tmp/tmpt12g4ytn_test.go:30:15:\
    \ undefined: byCol\n/tmp/tmpt12g4ytn_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpt12g4ytn_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpt12g4ytn_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpt12g4ytn_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpt12g4ytn_test.go:48:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        for\
    \ _, v := range row {\n            if v == x {\n                result := append(result,\
    \ []interface{}{row, v})\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjbw82q7r_test.go:22:17:\
    \ result declared but not used\n/tmp/tmpjbw82q7r_test.go:26:5: undefined: sort\n\
    /tmp/tmpjbw82q7r_test.go:27:16: invalid operation: result[i][0] < result[j][0]\
    \ (operator < not defined on interface)\n/tmp/tmpjbw82q7r_test.go:29:5: undefined:\
    \ sort\n/tmp/tmpjbw82q7r_test.go:30:16: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpjbw82q7r_test.go:42:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpjbw82q7r_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjbw82q7r_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjbw82q7r_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpjbw82q7r_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjbw82q7r_test.go:47:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] > result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] < result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkvza5ut6_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpkvza5ut6_test.go:30:16: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmpkvza5ut6_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpkvza5ut6_test.go:33:16: invalid operation: result[i][1]\
    \ < result[j][1] (operator < not defined on interface)\n/tmp/tmpkvza5ut6_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkvza5ut6_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkvza5ut6_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkvza5ut6_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkvza5ut6_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i] = append(result[i], j)\n            }\n        }\n  \
    \  }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp63iqpr6r_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp63iqpr6r_test.go:29:15: undefined: byRow\n/tmp/tmp63iqpr6r_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp63iqpr6r_test.go:30:15: undefined: byCol\n/tmp/tmp63iqpr6r_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp63iqpr6r_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp63iqpr6r_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp63iqpr6r_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp63iqpr6r_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := lst[i]\n        row_sorted, row_sorted\
    \ := sort_row_by_col(row, cols)\n        row_sorted = sort_row_by_row(row_sorted,\
    \ rows)\n        row_sorted = sort_row_by_col(row_sorted, cols)\n        row_sorted\
    \ = sort_row_by_row(row_sorted, rows)\n        row_sorted = sort_row_by_col(row_sorted,\
    \ cols)\n        row_sorted = sort_row_by_row(row_sorted, rows)\n        row_sorted\
    \ = sort_row_by_col(row_sorted, cols)\n        row_sorted = sort_row_by_row(row_sorted,\
    \ rows)\n        row_sorted = sort_row_by_col(row_sorted, cols)\n        row_sorted\
    \ = sort_row_by_row(row_sorted, rows)\n        row_sorted = sort_row_by_col(row_sorted,\
    \ cols)\n        row_sorted = sort_row_by_row(row_sorted, rows)\n        row_sorted\
    \ = sort_row_by_col(row_sorted, cols)\n        row_sorted = sort_row_by_row(row_sorted,\
    \ rows)\n        row_sorted = sort_row_by_col(row_sorted, cols)\n        row_sorted\
    \ = sort_row_by_row(row_sorted, rows)\n        row_sorted = sort_row_by_col(row_sorted,\
    \ cols)\n        row_sorted = sort_row_by_row(row_sorted, rows)\n        row_sorted\
    \ = sort_row_by_col(row_sorted, cols)\n        row_sorted = sort_row_by_row(row_sorted,\
    \ rows)\n        row_sorted = sort_row_by_col(row_sorted, cols)\n        row_sorted\
    \ = sort_row_by_row(row_sorted, rows)\n        row_sorted = sort_row_by_col(row_sorted,\
    \ cols)\n        row_sorted = sort_row_by_row(row_sorted, rows)\n        row_sorted\
    \ = sort_row_by_col(row_sorted, cols)\n        row_sorted = sort_row_by_row(row_sorted,\
    \ rows)\n        row_sorted = sort_row_by_col(row_sorted, cols)\n        row_sorted\
    \ = sort_row_by_row(row_sorted, rows)\n        row_sorted = sort_row_by_col(row_sorted,\
    \ cols)\n        row_sorted = sort_row_by_row(row_sorted, rows)\n        row_sorted\
    \ = sort_row_by_col(row_sorted, cols)\n        row_sorted = sort_row_by_row(row_sorted,\
    \ rows)\n        row_sorted = sort_row_by_col(row_sorted, cols)\n        row_sorted\
    \ = sort_row_by_row(row_sorted, rows)\n        row_sorted = sort_row_by_col(row_sorted,\
    \ cols)\n        row_\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6rviy81v_test.go:58:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    \n    sort.Slice(lst,\
    \ func(i, j int) bool {\n        return lst[i][0] < lst[j][0]\n    })\n    sort.Slice(lst[0],\
    \ func(i, j int) bool {\n        return lst[0][i] > lst[0][j]\n    })\n    \n\
    \    for i := range lst {\n        j := 0\n        for ; j < len(lst[i]); j++\
    \ {\n            if lst[i][j] == x {\n                result[i] = append(result[i],\
    \ j)\n                break\n            }\n        }\n    }\n    \n    return\
    \ append([][]interface{}{}, result...)\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp891pmhl0_test.go:23:5:\
    \ undefined: sort\n/tmp/tmp891pmhl0_test.go:26:5: undefined: sort\n/tmp/tmp891pmhl0_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp891pmhl0_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp891pmhl0_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp891pmhl0_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp891pmhl0_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0fw7g6cm_test.go:30:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:31:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:32:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:35:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0fw7g6cm_test.go:35:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row[x:])))\n        result := append(result,\
    \ row[x:])\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8y1dgbs2_test.go:20:9:\
    \ undefined: sort\n/tmp/tmp8y1dgbs2_test.go:21:9: undefined: sort\n/tmp/tmp8y1dgbs2_test.go:22:9:\
    \ result declared but not used\n/tmp/tmp8y1dgbs2_test.go:22:37: cannot use row[x:]\
    \ (value of type []int) as type []interface{} in argument to append\n/tmp/tmp8y1dgbs2_test.go:34:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:35:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:36:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8y1dgbs2_test.go:39:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp8y1dgbs2_test.go:39:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++\
    \ {\n        r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := 0; i\
    \ < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n    r := make([][]interface{},\
    \ len(r))\n    for i := 0; i < len(r); i++ {\n        for j := 0; j < len(r[i]);\
    \ j++ {\n            r[i][j] = r[i][j].(int)\n        }\n    }\n    return r\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph0m7pr3m_test.go:27:5:\
    \ undefined: sort\n/tmp/tmph0m7pr3m_test.go:27:42: undefined: row\n/tmp/tmph0m7pr3m_test.go:28:5:\
    \ undefined: sort\n/tmp/tmph0m7pr3m_test.go:28:42: undefined: col\n/tmp/tmph0m7pr3m_test.go:29:7:\
    \ no new variables on left side of :=\n/tmp/tmph0m7pr3m_test.go:45:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmph0m7pr3m_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmph0m7pr3m_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmph0m7pr3m_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmph0m7pr3m_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmph0m7pr3m_test.go:50:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       for _, val := range row {\n            if val == x {\n               \
    \ result = append(result, []interface{}{row, val})\n            }\n        }\n\
    \    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgdspbhbc_test.go:26:5:\
    \ undefined: sort\n/tmp/tmpgdspbhbc_test.go:27:5: undefined: sort\n/tmp/tmpgdspbhbc_test.go:38:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgdspbhbc_test.go:39:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpgdspbhbc_test.go:40:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgdspbhbc_test.go:43:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpgdspbhbc_test.go:43:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i] = append(result[i], j)\n            }\n        }\n  \
    \  }\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][0]\
    \ < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool {\n     \
    \   return result[i][1] > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6_i5v7hn_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp6_i5v7hn_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp6_i5v7hn_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp6_i5v7hn_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp6_i5v7hn_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6_i5v7hn_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6_i5v7hn_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6_i5v7hn_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6_i5v7hn_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++\
    \ {\n        r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := 0; i\
    \ < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(byRow(r))\n    sort.Sort(byCol(r))\n\
    \    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmxga3o1a_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpmxga3o1a_test.go:27:15: undefined: byRow\n/tmp/tmpmxga3o1a_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpmxga3o1a_test.go:28:15: undefined: byCol\n/tmp/tmpmxga3o1a_test.go:39:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmxga3o1a_test.go:40:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmxga3o1a_test.go:41:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmxga3o1a_test.go:44:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmxga3o1a_test.go:44:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    r := r[:0]\n    r := append(r,\
    \ lst[x])\n    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_9bbfvm9_test.go:22:7:\
    \ no new variables on left side of :=\n/tmp/tmp_9bbfvm9_test.go:23:7: no new variables\
    \ on left side of :=\n/tmp/tmp_9bbfvm9_test.go:23:20: cannot use lst[x] (variable\
    \ of type []int) as type []interface{} in argument to append\n/tmp/tmp_9bbfvm9_test.go:34:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_9bbfvm9_test.go:35:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_9bbfvm9_test.go:36:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_9bbfvm9_test.go:39:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp_9bbfvm9_test.go:39:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075500
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfbz8qmrv_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpfbz8qmrv_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpfbz8qmrv_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpfbz8qmrv_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpfbz8qmrv_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfbz8qmrv_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++\
    \ {\n        r[i] = make([]interface{}, len(lst[i]))\n        for j := 0; j <\
    \ len(lst[i]); j++ {\n            r[i][j] = lst[i][j]\n        }\n    }\n    sort.Sort(byRow(r))\n\
    \    sort.Sort(byCol(r))\n    r := r[x]\n    return r\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf_u0_80b_test.go:25:5:\
    \ undefined: sort\n/tmp/tmpf_u0_80b_test.go:25:15: undefined: byRow\n/tmp/tmpf_u0_80b_test.go:26:5:\
    \ undefined: sort\n/tmp/tmpf_u0_80b_test.go:26:15: undefined: byCol\n/tmp/tmpf_u0_80b_test.go:27:7:\
    \ no new variables on left side of :=\n/tmp/tmpf_u0_80b_test.go:27:10: cannot\
    \ use r[x] (variable of type []interface{}) as type [][]interface{} in assignment\n\
    /tmp/tmpf_u0_80b_test.go:38:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpf_u0_80b_test.go:39:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpf_u0_80b_test.go:40:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpf_u0_80b_test.go:43:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpf_u0_80b_test.go:43:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        result\
    \ := append(result, []interface{}{row[x], row[len(row)-x-1]})\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][len(result[i])-1]\
    \ > result[j][len(result[j])-1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1n_y1nhu_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp1n_y1nhu_test.go:22:5: undefined: sort\n\
    /tmp/tmp1n_y1nhu_test.go:23:16: invalid operation: result[i][0] < result[j][0]\
    \ (operator < not defined on interface)\n/tmp/tmp1n_y1nhu_test.go:25:5: undefined:\
    \ sort\n/tmp/tmp1n_y1nhu_test.go:26:16: invalid operation: result[i][len(result[i])\
    \ - 1] > result[j][len(result[j]) - 1] (operator > not defined on interface)\n\
    /tmp/tmp1n_y1nhu_test.go:38:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp1n_y1nhu_test.go:39:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1n_y1nhu_test.go:40:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1n_y1nhu_test.go:43:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp1n_y1nhu_test.go:43:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1n_y1nhu_test.go:43:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++\
    \ {\n        r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := 0; i\
    \ < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n    result := make([][]interface{},\
    \ len(r))\n    for i := 0; i < len(r); i++ {\n        result[i] = make([]interface{},\
    \ len(r[i]))\n        for j := 0; j < len(r[i]); j++ {\n            result[i][j]\
    \ = r[i][j]\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwla8lyrp_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpwla8lyrp_test.go:27:42: undefined: row\n/tmp/tmpwla8lyrp_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpwla8lyrp_test.go:28:42: undefined: col\n/tmp/tmpwla8lyrp_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwla8lyrp_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwla8lyrp_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwla8lyrp_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpwla8lyrp_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := lst[i]\n        row_sorted, row_sorted\
    \ := row[:], row[:]\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sorted, row_sorted...)\n        row_sorted = append(row_sorted, row_sorted...)\n\
    \        row_sorted = append(row_sorted, row_sorted...)\n        row_sorted =\
    \ append(row_sor\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfkzxiwe9_test.go:61:36: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075494
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_helper(row, x))\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjzvo62b5_test.go:20:9:\
    \ result declared but not used\n/tmp/tmpjzvo62b5_test.go:20:34: undefined: get_row_helper\n\
    /tmp/tmpjzvo62b5_test.go:22:5: undefined: sort\n/tmp/tmpjzvo62b5_test.go:33:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjzvo62b5_test.go:34:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjzvo62b5_test.go:35:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjzvo62b5_test.go:38:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpjzvo62b5_test.go:38:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_test(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vm1i32c_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp0vm1i32c_test.go:20:34: undefined: get_row_test\n\
    /tmp/tmp0vm1i32c_test.go:22:5: undefined: sort\n/tmp/tmp0vm1i32c_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmp0vm1i32c_test.go:23:5: undefined: sort\n/tmp/tmp0vm1i32c_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmp0vm1i32c_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vm1i32c_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0vm1i32c_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vm1i32c_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp0vm1i32c_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = make([]interface{},\
    \ 2)\n                result[i][j][0] = i\n                result[i][j][1] = j\n\
    \            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnywmv6t0_test.go:26:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpnywmv6t0_test.go:27:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmpnywmv6t0_test.go:31:5: undefined: sort\n/tmp/tmpnywmv6t0_test.go:31:15:\
    \ undefined: byRow\n/tmp/tmpnywmv6t0_test.go:32:5: undefined: sort\n/tmp/tmpnywmv6t0_test.go:32:15:\
    \ undefined: byCol\n/tmp/tmpnywmv6t0_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnywmv6t0_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnywmv6t0_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnywmv6t0_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpnywmv6t0_test.go:48:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    x :=\
    \ x\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                result[i] = append(result[i],\
    \ j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[i])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_ybf_def_test.go:22:7:\
    \ no new variables on left side of :=\n/tmp/tmp_ybf_def_test.go:30:5: undefined:\
    \ sort\n/tmp/tmp_ybf_def_test.go:31:5: undefined: sort\n/tmp/tmp_ybf_def_test.go:31:49:\
    \ undefined: i\n/tmp/tmp_ybf_def_test.go:42:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_ybf_def_test.go:43:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_ybf_def_test.go:44:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_ybf_def_test.go:47:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp_ybf_def_test.go:47:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = make([]interface{}, 2)\n                result[i][j][0]\
    \ = i\n                result[i][j][1] = j\n            }\n        }\n    }\n\
    \    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxaujnkky_test.go:26:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpxaujnkky_test.go:27:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmpxaujnkky_test.go:31:5: undefined: sort\n/tmp/tmpxaujnkky_test.go:31:15:\
    \ undefined: byRow\n/tmp/tmpxaujnkky_test.go:32:5: undefined: sort\n/tmp/tmpxaujnkky_test.go:32:15:\
    \ undefined: byCol\n/tmp/tmpxaujnkky_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxaujnkky_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxaujnkky_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxaujnkky_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpxaujnkky_test.go:48:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, make([]interface{}, len(row)))\n        for _,\
    \ cell := range row {\n            result[len(result)-1] = append(result[len(result)-1],\
    \ cell)\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    result := result[:len(result)-1]\n    for _, row := range result {\n    \
    \    sort.Sort(byCol(row))\n    }\n    for _, row := range result {\n        for\
    \ _, cell := range row {\n            if cell == x {\n                return result\n\
    \            }\n        }\n    }\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp36_9fbyh_test.go:25:5:\
    \ undefined: sort\n/tmp/tmp36_9fbyh_test.go:25:15: undefined: byRow\n/tmp/tmp36_9fbyh_test.go:26:5:\
    \ undefined: sort\n/tmp/tmp36_9fbyh_test.go:26:15: undefined: byCol\n/tmp/tmp36_9fbyh_test.go:27:12:\
    \ no new variables on left side of :=\n/tmp/tmp36_9fbyh_test.go:29:9: undefined:\
    \ sort\n/tmp/tmp36_9fbyh_test.go:29:19: undefined: byCol\n/tmp/tmp36_9fbyh_test.go:48:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp36_9fbyh_test.go:49:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp36_9fbyh_test.go:50:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp36_9fbyh_test.go:50:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n\
    \        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57a37kzs_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp57a37kzs_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp57a37kzs_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp57a37kzs_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp57a37kzs_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp57a37kzs_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp57a37kzs_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp57a37kzs_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp57a37kzs_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        result := append(result, make([]interface{},\
    \ cols))\n        for j := 0; j < cols; j++ {\n            if lst[i][j] == x {\n\
    \                result[i] = append(result[i], j)\n            }\n        }\n\
    \    }\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][0]\
    \ < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool {\n     \
    \   return result[i][1] > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcovou6jn_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpcovou6jn_test.go:29:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpcovou6jn_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpcovou6jn_test.go:32:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpcovou6jn_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcovou6jn_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcovou6jn_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcovou6jn_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcovou6jn_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := make([]interface{}, cols)\n \
    \       for j := 0; j < cols; j++ {\n            row[j] = lst[i][j]\n        }\n\
    \        result = append(result, row)\n    }\n    sort.Slice(result, func(i, j\
    \ int) bool {\n        return rows[i][0] < rows[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return cols[i][0] < cols[j][0]\n    })\n    result\
    \ := result[:x]\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfyf5hho6_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpfyf5hho6_test.go:28:20: invalid operation: cannot index\
    \ rows (variable of type int)\n/tmp/tmpfyf5hho6_test.go:30:5: undefined: sort\n\
    /tmp/tmpfyf5hho6_test.go:31:20: invalid operation: cannot index cols (variable\
    \ of type int)\n/tmp/tmpfyf5hho6_test.go:33:12: no new variables on left side\
    \ of :=\n/tmp/tmpfyf5hho6_test.go:44:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfyf5hho6_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfyf5hho6_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfyf5hho6_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpfyf5hho6_test.go:49:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfyf5hho6_test.go:49:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        result\
    \ := append(result, get_row_test(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp63tjaqi6_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp63tjaqi6_test.go:20:34: undefined: get_row_test\n\
    /tmp/tmp63tjaqi6_test.go:22:5: undefined: sort\n/tmp/tmp63tjaqi6_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmp63tjaqi6_test.go:23:5: undefined: sort\n/tmp/tmp63tjaqi6_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmp63tjaqi6_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp63tjaqi6_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp63tjaqi6_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp63tjaqi6_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp63tjaqi6_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := make([]interface{}, cols)\n \
    \       for j := 0; j < cols; j++ {\n            row[j] = lst[i][j]\n        }\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        result = append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row := result[i]\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n    }\n    for i := 0; i\
    \ < rows; i++ {\n        row := result[i]\n        j := 0\n        for _, val\
    \ := range row {\n            if val == x {\n                result := make([][]interface{},\
    \ 0)\n                for k := 0; k < cols; k++ {\n                    result\
    \ = append(result, make([]interface{}, 2))\n                    result[i][j] =\
    \ k\n                    result[i][k] = x\n                }\n               \
    \ return result\n            }\n            j++\n        }\n    }\n    return\
    \ nil\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoo8wnd1k_test.go:25:9:\
    \ undefined: sort\n/tmp/tmpoo8wnd1k_test.go:26:9: undefined: sort\n/tmp/tmpoo8wnd1k_test.go:31:9:\
    \ undefined: sort\n/tmp/tmpoo8wnd1k_test.go:32:9: undefined: sort\n/tmp/tmpoo8wnd1k_test.go:60:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoo8wnd1k_test.go:61:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoo8wnd1k_test.go:62:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoo8wnd1k_test.go:65:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoo8wnd1k_test.go:65:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \ }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        if\
    \ result[i][0] < result[j][0] {\n            return true\n        }\n        if\
    \ result[i][0] > result[j][0] {\n            return false\n        }\n       \
    \ if result[i][1] < result[j][1] {\n            return true\n        }\n     \
    \   if result[i][1] > result[j][1] {\n            return false\n        }\n  \
    \      return false\n    })\n    sort.Slice(result, func(i, j int) bool {\n  \
    \      if result[i][1] > result[j][1] {\n            return true\n        }\n\
    \        if result[i][1] < result[j][1] {\n            return false\n        }\n\
    \        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphpz0xyto_test.go:29:5:\
    \ undefined: sort\n/tmp/tmphpz0xyto_test.go:30:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmphpz0xyto_test.go:33:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmphpz0xyto_test.go:36:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmphpz0xyto_test.go:39:12: invalid\
    \ operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmphpz0xyto_test.go:44:5: undefined: sort\n/tmp/tmphpz0xyto_test.go:45:12:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmphpz0xyto_test.go:48:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmphpz0xyto_test.go:63:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmphpz0xyto_test.go:64:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphpz0xyto_test.go:64:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        if result[i][0] < result[j][0] {\n            return\
    \ true\n        }\n        return false\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        if result[i][1] > result[j][1] {\n            return\
    \ true\n        }\n        return false\n    })\n    return result\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7t4uunps_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp7t4uunps_test.go:31:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp7t4uunps_test.go:36:5:\
    \ undefined: sort\n/tmp/tmp7t4uunps_test.go:37:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp7t4uunps_test.go:52:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7t4uunps_test.go:53:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7t4uunps_test.go:54:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7t4uunps_test.go:57:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7t4uunps_test.go:57:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdfgcwvh0_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpdfgcwvh0_test.go:30:5: undefined: sort\n/tmp/tmpdfgcwvh0_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdfgcwvh0_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdfgcwvh0_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdfgcwvh0_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdfgcwvh0_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    \n \
    \   for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++\
    \ {\n            if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    \n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] < result[j][0] {\n          \
    \  return true\n        }\n        if result[i][0] > result[j][0] {\n        \
    \    return false\n        }\n        \n        if result[i][1] < result[j][1]\
    \ {\n            return true\n        }\n        if result[i][1] > result[j][1]\
    \ {\n            return false\n        }\n        \n        return false\n   \
    \ })\n    \n    sort.Slice(result, func(i, j int) bool {\n        if result[i][1]\
    \ < result[j][1] {\n            return true\n        }\n        if result[i][1]\
    \ > result[j][1] {\n            return false\n        }\n        \n        return\
    \ false\n    })\n    \n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq6ngo0ut_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpq6ngo0ut_test.go:32:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpq6ngo0ut_test.go:35:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmpq6ngo0ut_test.go:39:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpq6ngo0ut_test.go:42:12: invalid\
    \ operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpq6ngo0ut_test.go:49:5: undefined: sort\n/tmp/tmpq6ngo0ut_test.go:50:12:\
    \ invalid operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmpq6ngo0ut_test.go:53:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpq6ngo0ut_test.go:70:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpq6ngo0ut_test.go:71:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpq6ngo0ut_test.go:71:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = make([]interface{}, 2)\n\
    \                result[i][j] = append(result[i][j], i)\n                result[i][j]\
    \ = append(result[i][j], j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlq4bcfk_test.go:27:39:\
    \ first argument to append must be a slice; have result[i][j] (variable of type\
    \ interface{})\n/tmp/tmpqlq4bcfk_test.go:28:39: first argument to append must\
    \ be a slice; have result[i][j] (variable of type interface{})\n/tmp/tmpqlq4bcfk_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpqlq4bcfk_test.go:33:5: undefined: sort\n/tmp/tmpqlq4bcfk_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqlq4bcfk_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqlq4bcfk_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqlq4bcfk_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqlq4bcfk_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \ }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] > result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] < result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb0hi96na_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpb0hi96na_test.go:30:16: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmpb0hi96na_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpb0hi96na_test.go:33:16: invalid operation: result[i][1]\
    \ < result[j][1] (operator < not defined on interface)\n/tmp/tmpb0hi96na_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpb0hi96na_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpb0hi96na_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpb0hi96na_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpb0hi96na_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        result\
    \ := append(result, get_row_helper(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptdq_w0ai_test.go:20:9:\
    \ result declared but not used\n/tmp/tmptdq_w0ai_test.go:20:34: undefined: get_row_helper\n\
    /tmp/tmptdq_w0ai_test.go:22:5: undefined: sort\n/tmp/tmptdq_w0ai_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmptdq_w0ai_test.go:23:5: undefined: sort\n/tmp/tmptdq_w0ai_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmptdq_w0ai_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmptdq_w0ai_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmptdq_w0ai_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmptdq_w0ai_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmptdq_w0ai_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = i\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] < result[j][0] {\n          \
    \  return true\n        }\n        return false\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][1] > result[j][1] {\n          \
    \  return true\n        }\n        return false\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc3jo9y15_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpc3jo9y15_test.go:30:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpc3jo9y15_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpc3jo9y15_test.go:36:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpc3jo9y15_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpc3jo9y15_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpc3jo9y15_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpc3jo9y15_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpc3jo9y15_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = make([]interface{},\
    \ 2)\n                result[i][j] = append(result[i][j], i)\n               \
    \ result[i][j] = append(result[i][j], j)\n            }\n        }\n    }\n  \
    \  sort.Slice(result, func(i, j int) bool {\n        return result[i][0] < result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgwseroe4_test.go:26:39:\
    \ first argument to append must be a slice; have result[i][j] (variable of type\
    \ interface{})\n/tmp/tmpgwseroe4_test.go:27:39: first argument to append must\
    \ be a slice; have result[i][j] (variable of type interface{})\n/tmp/tmpgwseroe4_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpgwseroe4_test.go:32:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpgwseroe4_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpgwseroe4_test.go:35:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpgwseroe4_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgwseroe4_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpgwseroe4_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgwseroe4_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpgwseroe4_test.go:52:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, make([]interface{}, len(row)))\n        for _,\
    \ cell := range row {\n            if cell == x {\n                result := append(result,\
    \ []interface{}{cell, cell})\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] > result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpairckd21_test.go:23:17:\
    \ result declared but not used\n/tmp/tmpairckd21_test.go:27:5: undefined: sort\n\
    /tmp/tmpairckd21_test.go:28:16: invalid operation: result[i][0] > result[j][0]\
    \ (operator > not defined on interface)\n/tmp/tmpairckd21_test.go:30:5: undefined:\
    \ sort\n/tmp/tmpairckd21_test.go:31:16: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpairckd21_test.go:43:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpairckd21_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpairckd21_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpairckd21_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpairckd21_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpairckd21_test.go:48:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        row_result\
    \ := []interface{}{}\n        for _, value := range row {\n            if value\
    \ == x {\n                row_result = append(row_result, value)\n           \
    \ }\n        }\n        result = append(result, row_result)\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz0uqx1f1_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpz0uqx1f1_test.go:29:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpz0uqx1f1_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpz0uqx1f1_test.go:32:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpz0uqx1f1_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz0uqx1f1_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz0uqx1f1_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz0uqx1f1_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpz0uqx1f1_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        result\
    \ := append(result, get_row_helper(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptdq_w0ai_test.go:20:9:\
    \ result declared but not used\n/tmp/tmptdq_w0ai_test.go:20:34: undefined: get_row_helper\n\
    /tmp/tmptdq_w0ai_test.go:22:5: undefined: sort\n/tmp/tmptdq_w0ai_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmptdq_w0ai_test.go:23:5: undefined: sort\n/tmp/tmptdq_w0ai_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmptdq_w0ai_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmptdq_w0ai_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmptdq_w0ai_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmptdq_w0ai_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmptdq_w0ai_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        result\
    \ := append(result, []interface{}{row, get_col(row, x)})\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result[0], func(i, j int) bool {\n        return result[0][i]\
    \ > result[0][j]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqvglltq6_test.go:20:9:\
    \ result declared but not used\n/tmp/tmpqvglltq6_test.go:20:53: undefined: get_col\n\
    /tmp/tmpqvglltq6_test.go:22:5: undefined: sort\n/tmp/tmpqvglltq6_test.go:23:16:\
    \ invalid operation: result[i][0] < result[j][0] (operator < not defined on interface)\n\
    /tmp/tmpqvglltq6_test.go:25:5: undefined: sort\n/tmp/tmpqvglltq6_test.go:26:16:\
    \ invalid operation: result[0][i] > result[0][j] (operator > not defined on interface)\n\
    /tmp/tmpqvglltq6_test.go:38:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpqvglltq6_test.go:39:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqvglltq6_test.go:40:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqvglltq6_test.go:43:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpqvglltq6_test.go:43:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] < result[j][0] {\n          \
    \  return true\n        }\n        if result[i][0] > result[j][0] {\n        \
    \    return false\n        }\n        if result[i][1] > result[j][1] {\n     \
    \       return true\n        }\n        if result[i][1] < result[j][1] {\n   \
    \         return false\n        }\n        return false\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][1] < result[j][1] {\n          \
    \  return true\n        }\n        if result[i][1] > result[j][1] {\n        \
    \    return false\n        }\n        return false\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_ac_hxqm_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp_ac_hxqm_test.go:30:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp_ac_hxqm_test.go:33:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmp_ac_hxqm_test.go:36:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmp_ac_hxqm_test.go:39:12: invalid\
    \ operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmp_ac_hxqm_test.go:44:5: undefined: sort\n/tmp/tmp_ac_hxqm_test.go:45:12:\
    \ invalid operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmp_ac_hxqm_test.go:48:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmp_ac_hxqm_test.go:63:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmp_ac_hxqm_test.go:64:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_ac_hxqm_test.go:64:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    \n \
    \   for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++\
    \ {\n            if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n    \n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    \n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    \n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphgn1cv4h_test.go:31:5:\
    \ undefined: sort\n/tmp/tmphgn1cv4h_test.go:32:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmphgn1cv4h_test.go:35:5:\
    \ undefined: sort\n/tmp/tmphgn1cv4h_test.go:36:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmphgn1cv4h_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphgn1cv4h_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphgn1cv4h_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphgn1cv4h_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmphgn1cv4h_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        r\
    \ := make([]interface{}, len(row))\n        for i := range row {\n           \
    \ r[i] = row[i]\n        }\n        sort.Slice(r, func(i, j int) bool {\n    \
    \        return r[i].([]interface{})[0].(int) < r[j].([]interface{})[0].(int)\n\
    \        })\n        sort.Slice(r, func(i, j int) bool {\n            return r[i].([]interface{})[1].(int)\
    \ < r[j].([]interface{})[1].(int)\n        })\n        result = append(result,\
    \ r)\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return result[i].([]interface{})[0].(int)\
    \ < result[j].([]interface{})[0].(int)\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i].([]interface{})[1].(int) < result[j].([]interface{})[1].(int)\n\
    \    })\n    for _, r := range result {\n        if r[0].(int) == x {\n      \
    \      return r\n        }\n    }\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu2so1837_test.go:24:9:\
    \ undefined: sort\n/tmp/tmpu2so1837_test.go:27:9: undefined: sort\n/tmp/tmpu2so1837_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpu2so1837_test.go:33:16: invalid operation: result[i]\
    \ (variable of type []interface{}) is not an interface\n/tmp/tmpu2so1837_test.go:33:53:\
    \ invalid operation: result[j] (variable of type []interface{}) is not an interface\n\
    /tmp/tmpu2so1837_test.go:35:5: undefined: sort\n/tmp/tmpu2so1837_test.go:36:16:\
    \ invalid operation: result[i] (variable of type []interface{}) is not an interface\n\
    /tmp/tmpu2so1837_test.go:36:53: invalid operation: result[j] (variable of type\
    \ []interface{}) is not an interface\n/tmp/tmpu2so1837_test.go:40:20: cannot use\
    \ r (variable of type []interface{}) as type [][]interface{} in return statement\n\
    /tmp/tmpu2so1837_test.go:53:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpu2so1837_test.go:53:132:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    \n    for i := range r\
    \ {\n        for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n\
    \    }\n    \n    r := r[x]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n    \n    r := r[len(r)-1]\n\
    \    \n    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsq6vj4r5_test.go:120:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075501
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuzd5rmld_test.go:273:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := lst[i]\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row[i])))\n        result := append(result,\
    \ []interface{}{i, row[i]})\n    }\n    for i := 0; i < rows; i++ {\n        row\
    \ := lst[i]\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n        sort.Sort(sort.Reverse(sort.IntSlice(row[i])))\n\
    \        result := append(result, []interface{}{i, row[i]})\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl64rqfs2_test.go:19:11:\
    \ cols declared but not used\n/tmp/tmpl64rqfs2_test.go:22:9: undefined: sort\n\
    /tmp/tmpl64rqfs2_test.go:23:9: undefined: sort\n/tmp/tmpl64rqfs2_test.go:24:9:\
    \ result declared but not used\n/tmp/tmpl64rqfs2_test.go:28:9: undefined: sort\n\
    /tmp/tmpl64rqfs2_test.go:29:9: undefined: sort\n/tmp/tmpl64rqfs2_test.go:30:9:\
    \ result declared but not used\n/tmp/tmpl64rqfs2_test.go:42:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpl64rqfs2_test.go:43:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpl64rqfs2_test.go:44:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpl64rqfs2_test.go:44:232:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                result[i][j] = make([]interface{},\
    \ 2)\n                result[i][j] = append(result[i][j], i)\n               \
    \ result[i][j] = append(result[i][j], j)\n            }\n        }\n    }\n  \
    \  sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0w9n8our_test.go:27:39:\
    \ first argument to append must be a slice; have result[i][j] (variable of type\
    \ interface{})\n/tmp/tmp0w9n8our_test.go:28:39: first argument to append must\
    \ be a slice; have result[i][j] (variable of type interface{})\n/tmp/tmp0w9n8our_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp0w9n8our_test.go:33:5: undefined: sort\n/tmp/tmp0w9n8our_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0w9n8our_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0w9n8our_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0w9n8our_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0w9n8our_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn_f7ouoe_test.go:273:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++\
    \ {\n        r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := 0; i\
    \ < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            if\
    \ lst[i][j] == x {\n                r[i][j] = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n\
    \            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(rows(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(columns(r))))\n    return r\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf5g9bjag_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpf5g9bjag_test.go:29:42: undefined: rows\n/tmp/tmpf5g9bjag_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpf5g9bjag_test.go:30:42: undefined: columns\n/tmp/tmpf5g9bjag_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpf5g9bjag_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpf5g9bjag_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpf5g9bjag_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpf5g9bjag_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row := make([]interface{}, cols)\n \
    \       for j := 0; j < cols; j++ {\n            row[j] = lst[i][j]\n        }\n\
    \        sort.SliceStable(row, func(i, j int) bool {\n            return row[i].([]int)[0]\
    \ > row[j].([]int)[0]\n        })\n        sort.SliceStable(row, func(i, j int)\
    \ bool {\n            return row[i].([]int)[1] < row[j].([]int)[1]\n        })\n\
    \        result = append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        sort.SliceStable(result[i], func(i, j int) bool {\n            return\
    \ result[i][j].([]interface{})[1] > result[i][j].([]interface{})[0]\n        })\n\
    \    }\n    for i := 0; i < rows; i++ {\n        sort.SliceStable(result[i], func(i,\
    \ j int) bool {\n            return result[i][j].([]interface{})[1] < result[i][j].([]interface{})[0]\n\
    \        })\n    }\n    for i := 0; i < rows; i++ {\n        sort.SliceStable(result[i],\
    \ func(i, j int) bool {\n            return result[i][j].([]interface{})[0] >\
    \ x\n        })\n    }\n    for i := 0; i < rows; i++ {\n        sort.SliceStable(result[i],\
    \ func(i, j int) bool {\n            return result[i][j].([]interface{})[0] <\
    \ x\n        })\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvwv2cpff_test.go:25:9: undefined: sort

    /tmp/tmpvwv2cpff_test.go:28:9: undefined: sort

    /tmp/tmpvwv2cpff_test.go:34:9: undefined: sort

    /tmp/tmpvwv2cpff_test.go:35:20: invalid operation: result[i][j].([]interface{})[1]
    > result[i][j].([]interface{})[0] (operator > not defined on interface)

    /tmp/tmpvwv2cpff_test.go:39:9: undefined: sort

    /tmp/tmpvwv2cpff_test.go:40:20: invalid operation: result[i][j].([]interface{})[1]
    < result[i][j].([]interface{})[0] (operator < not defined on interface)

    /tmp/tmpvwv2cpff_test.go:44:9: undefined: sort

    /tmp/tmpvwv2cpff_test.go:45:20: invalid operation: result[i][j].([]interface{})[0]
    > x (operator > not defined on interface)

    /tmp/tmpvwv2cpff_test.go:49:9: undefined: sort

    /tmp/tmpvwv2cpff_test.go:50:20: invalid operation: result[i][j].([]interface{})[0]
    < x (operator < not defined on interface)

    /tmp/tmpvwv2cpff_test.go:50:20: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = make([]interface{}, 2)\n                result[i][j][0]\
    \ = i\n                result[i][j][1] = j\n            }\n        }\n    }\n\
    \    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxaujnkky_test.go:26:29:\
    \ invalid operation: cannot index result[i][j] (variable of type interface{})\n\
    /tmp/tmpxaujnkky_test.go:27:29: invalid operation: cannot index result[i][j] (variable\
    \ of type interface{})\n/tmp/tmpxaujnkky_test.go:31:5: undefined: sort\n/tmp/tmpxaujnkky_test.go:31:15:\
    \ undefined: byRow\n/tmp/tmpxaujnkky_test.go:32:5: undefined: sort\n/tmp/tmpxaujnkky_test.go:32:15:\
    \ undefined: byCol\n/tmp/tmpxaujnkky_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxaujnkky_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxaujnkky_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxaujnkky_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpxaujnkky_test.go:48:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8kaf6v2r_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp8kaf6v2r_test.go:29:15: undefined: byRow\n/tmp/tmp8kaf6v2r_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp8kaf6v2r_test.go:30:15: undefined: byCol\n/tmp/tmp8kaf6v2r_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8kaf6v2r_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8kaf6v2r_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8kaf6v2r_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp8kaf6v2r_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075499
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        r\
    \ := make([]interface{}, len(row))\n        for i := range row {\n           \
    \ r[i] = row[i]\n        }\n        sort.Slice(r, func(i, j int) bool {\n    \
    \        return r[i].(int) < r[j].(int)\n        })\n        sort.Slice(r, func(i,\
    \ j int) bool {\n            return r[j].(int) > r[i].(int)\n        })\n    \
    \    r := r[:len(r):len(r)]\n        if r[x] == nil {\n            continue\n\
    \        }\n        result = append(result, r)\n    }\n    return result\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqnekqv4o_test.go:24:9:\
    \ undefined: sort\n/tmp/tmpqnekqv4o_test.go:27:9: undefined: sort\n/tmp/tmpqnekqv4o_test.go:30:11:\
    \ no new variables on left side of :=\n/tmp/tmpqnekqv4o_test.go:46:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpqnekqv4o_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqnekqv4o_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqnekqv4o_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqnekqv4o_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range r {\n  \
    \      for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n   \
    \ }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n\
    \    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdnpzeh2e_test.go:27:5:\
    \ undefined: sort\n/tmp/tmpdnpzeh2e_test.go:27:42: undefined: row\n/tmp/tmpdnpzeh2e_test.go:28:5:\
    \ undefined: sort\n/tmp/tmpdnpzeh2e_test.go:28:42: undefined: col\n/tmp/tmpdnpzeh2e_test.go:39:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdnpzeh2e_test.go:40:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdnpzeh2e_test.go:41:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdnpzeh2e_test.go:44:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdnpzeh2e_test.go:44:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    \n    return nil\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn1udtj3t_test.go:31:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn1udtj3t_test.go:32:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpn1udtj3t_test.go:33:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn1udtj3t_test.go:36:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpn1udtj3t_test.go:36:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94x9f514_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp94x9f514_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp94x9f514_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp94x9f514_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp94x9f514_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp94x9f514_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp94x9f514_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    rows, cols := len(lst), len(lst[0])\n\
    \    for i := 0; i < rows; i++ {\n        row = make([]interface{}, cols)\n  \
    \      for j := 0; j < cols; j++ {\n            row[j] = lst[i][j]\n        }\n\
    \        sort.Ints(row)\n        sort.Ints(row)\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result = append(result, row)\n    }\n    sort.Sort(sort.Reverse(sort.Reverse(result)))\n\
    \    for i := 0; i < rows; i++ {\n        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n    for i := 0; i < rows; i++ {\n\
    \        row = result[i]\n        sort.Sort(sort.Reverse(sort.Reverse(row)))\n\
    \        result := append(result, row)\n    }\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmlqoqari_test.go:82:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075502
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for _, row := range lst {\n        var\
    \ result []interface{}\n        for _, col := range row {\n            if col\
    \ == x {\n                result = append(result, []interface{}{row, col})\n \
    \           }\n        }\n        result = append(result, get_row(row, x))\n \
    \   }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvb_67jr7_test.go:26:41:\
    \ cannot use row (variable of type []int) as type [][]int in argument to get_row\n\
    /tmp/tmpvb_67jr7_test.go:28:5: undefined: sort\n/tmp/tmpvb_67jr7_test.go:39:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpvb_67jr7_test.go:40:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpvb_67jr7_test.go:41:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpvb_67jr7_test.go:44:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpvb_67jr7_test.go:44:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6s7_vyzr_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp6s7_vyzr_test.go:31:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp6s7_vyzr_test.go:33:5:\
    \ undefined: sort\n/tmp/tmp6s7_vyzr_test.go:34:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp6s7_vyzr_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6s7_vyzr_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6s7_vyzr_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6s7_vyzr_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6s7_vyzr_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    \n    return nil\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn1udtj3t_test.go:31:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn1udtj3t_test.go:32:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpn1udtj3t_test.go:33:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn1udtj3t_test.go:36:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpn1udtj3t_test.go:36:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6s7_vyzr_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp6s7_vyzr_test.go:31:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp6s7_vyzr_test.go:33:5:\
    \ undefined: sort\n/tmp/tmp6s7_vyzr_test.go:34:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp6s7_vyzr_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6s7_vyzr_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6s7_vyzr_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6s7_vyzr_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6s7_vyzr_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \     break\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9gwk21e1_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp9gwk21e1_test.go:31:5: undefined: sort\n/tmp/tmp9gwk21e1_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9gwk21e1_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9gwk21e1_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9gwk21e1_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9gwk21e1_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := [][]interface{}{}\n    for _, row := range lst {\n        result\
    \ := append(result, []interface{}{row[x], row[len(row)-x-1]})\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] > result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] < result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwe1_5bub_test.go:20:9:\
    \ result declared but not used\n/tmp/tmpwe1_5bub_test.go:22:5: undefined: sort\n\
    /tmp/tmpwe1_5bub_test.go:23:16: invalid operation: result[i][0] > result[j][0]\
    \ (operator > not defined on interface)\n/tmp/tmpwe1_5bub_test.go:25:5: undefined:\
    \ sort\n/tmp/tmpwe1_5bub_test.go:26:16: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpwe1_5bub_test.go:38:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpwe1_5bub_test.go:39:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwe1_5bub_test.go:40:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwe1_5bub_test.go:43:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpwe1_5bub_test.go:43:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwe1_5bub_test.go:43:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \ }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] > result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7ggmfxe3_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp7ggmfxe3_test.go:30:16: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmp7ggmfxe3_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp7ggmfxe3_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp7ggmfxe3_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7ggmfxe3_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7ggmfxe3_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7ggmfxe3_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7ggmfxe3_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0fw7g6cm_test.go:30:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:31:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:32:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0fw7g6cm_test.go:35:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0fw7g6cm_test.go:35:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, make([]interface{}, len(row)))\n        for i,\
    \ val := range row {\n            result[len(result)-1][i] = val\n        }\n\
    \    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    return\
    \ getRow(result, x)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdh7ipakw_test.go:25:5:\
    \ undefined: sort\n/tmp/tmpdh7ipakw_test.go:25:15: undefined: byRow\n/tmp/tmpdh7ipakw_test.go:26:5:\
    \ undefined: sort\n/tmp/tmpdh7ipakw_test.go:26:15: undefined: byCol\n/tmp/tmpdh7ipakw_test.go:27:12:\
    \ undefined: getRow\n/tmp/tmpdh7ipakw_test.go:37:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdh7ipakw_test.go:38:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdh7ipakw_test.go:39:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdh7ipakw_test.go:42:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpdh7ipakw_test.go:42:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdh7ipakw_test.go:42:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        if result[i][0] < result[j][0] {\n            return\
    \ true\n        }\n        if result[i][0] > result[j][0] {\n            return\
    \ false\n        }\n        if result[i][1] < result[j][1] {\n            return\
    \ true\n        }\n        if result[i][1] > result[j][1] {\n            return\
    \ false\n        }\n        return false\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        if result[i][1] < result[j][1] {\n            return\
    \ true\n        }\n        if result[i][1] > result[j][1] {\n            return\
    \ false\n        }\n        return false\n    })\n    return result\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4x7fuhgs_test.go:30:5:\
    \ undefined: sort\n/tmp/tmp4x7fuhgs_test.go:31:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp4x7fuhgs_test.go:34:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmp4x7fuhgs_test.go:37:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmp4x7fuhgs_test.go:40:12: invalid\
    \ operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmp4x7fuhgs_test.go:45:5: undefined: sort\n/tmp/tmp4x7fuhgs_test.go:46:12:\
    \ invalid operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmp4x7fuhgs_test.go:49:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmp4x7fuhgs_test.go:64:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmp4x7fuhgs_test.go:65:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp4x7fuhgs_test.go:65:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, make([]interface{}, len(row)))\n        for _,\
    \ cell := range row {\n            if cell == x {\n                result := append(result,\
    \ []interface{}{row, cell})\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp79r38acx_test.go:23:17:\
    \ result declared but not used\n/tmp/tmp79r38acx_test.go:27:5: undefined: sort\n\
    /tmp/tmp79r38acx_test.go:28:16: invalid operation: result[i][0] < result[j][0]\
    \ (operator < not defined on interface)\n/tmp/tmp79r38acx_test.go:30:5: undefined:\
    \ sort\n/tmp/tmp79r38acx_test.go:31:16: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmp79r38acx_test.go:43:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmp79r38acx_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp79r38acx_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp79r38acx_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp79r38acx_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp79r38acx_test.go:48:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for _, row := range lst {\n        r\
    \ := make([]interface{}, len(row))\n        for i := range r {\n            r[i]\
    \ = row[i]\n        }\n        sort.Slice(r, func(i, j int) bool {\n         \
    \   return r[i].([]interface{})[0].(int) < r[j].([]interface{})[0].(int)\n   \
    \     })\n        sort.Slice(r, func(i, j int) bool {\n            return r[i].([]interface{})[1].(int)\
    \ < r[j].([]interface{})[1].(int)\n        })\n        result = append(result,\
    \ r)\n    }\n    return filter_by_x(result, x)\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph0c2e31p_test.go:24:9:\
    \ undefined: sort\n/tmp/tmph0c2e31p_test.go:27:9: undefined: sort\n/tmp/tmph0c2e31p_test.go:32:12:\
    \ undefined: filter_by_x\n/tmp/tmph0c2e31p_test.go:42:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmph0c2e31p_test.go:43:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmph0c2e31p_test.go:44:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmph0c2e31p_test.go:47:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmph0c2e31p_test.go:47:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, make([]interface{}, 0))\n        for _, col :=\
    \ range row {\n            if col == x {\n                result := append(result,\
    \ make([]interface{}, 1))\n                result[len(result)-1] = make([]interface{},\
    \ 1)\n                result[len(result)-1][0] = row\n                result[len(result)-1][1]\
    \ = col\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplqhnrsk3_test.go:30:5:\
    \ undefined: sort\n/tmp/tmplqhnrsk3_test.go:30:15: undefined: byRow\n/tmp/tmplqhnrsk3_test.go:31:5:\
    \ undefined: sort\n/tmp/tmplqhnrsk3_test.go:31:15: undefined: byCol\n/tmp/tmplqhnrsk3_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplqhnrsk3_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmplqhnrsk3_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplqhnrsk3_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmplqhnrsk3_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfbz8qmrv_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpfbz8qmrv_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpfbz8qmrv_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpfbz8qmrv_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpfbz8qmrv_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfbz8qmrv_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfbz8qmrv_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075497
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n      \
    \  r[i] = make([]interface{}, len(lst[i]))\n    }\n    \n    for i := range r\
    \ {\n        for j := range r[i] {\n            r[i][j] = lst[i][j]\n        }\n\
    \    }\n    \n    r := r[x:]\n    r := r[:len(r)/2]\n    r := r[::-1]\n    r :=\
    \ r[:len(r)/2]\n    \n    for i := range r {\n        for j := range r[i] {\n\
    \            r[i][j] = r[i][j].(int)\n        }\n    }\n    \n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppr2fuyn9_test.go:31:12: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, 0)\n    for _, row := range lst {\n \
    \       result := append(result, get_row_test(row, x))\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vm1i32c_test.go:20:9:\
    \ result declared but not used\n/tmp/tmp0vm1i32c_test.go:20:34: undefined: get_row_test\n\
    /tmp/tmp0vm1i32c_test.go:22:5: undefined: sort\n/tmp/tmp0vm1i32c_test.go:22:15:\
    \ undefined: byRow\n/tmp/tmp0vm1i32c_test.go:23:5: undefined: sort\n/tmp/tmp0vm1i32c_test.go:23:15:\
    \ undefined: byCol\n/tmp/tmp0vm1i32c_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vm1i32c_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0vm1i32c_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vm1i32c_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp0vm1i32c_test.go:39:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Your code here\n    result := make([][]interface{}, len(lst))\n  \
    \  for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn516jdf4_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpn516jdf4_test.go:31:5: undefined: sort\n/tmp/tmpn516jdf4_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn516jdf4_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpn516jdf4_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn516jdf4_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpn516jdf4_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    \n    for _, row := range lst {\n   \
    \     r := make([]interface{}, len(row))\n        \n        for i, v := range\
    \ row {\n            r[i] = v\n        }\n        \n        if x == 0 {\n    \
    \        result = append(result, r)\n        } else {\n            r := r[x-1]\n\
    \            \n            if r == nil {\n                result = append(result,\
    \ r)\n            } else {\n                result := append(result, r)\n    \
    \        }\n        }\n    }\n    \n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][0] < result[j][0]\n    })\n    \n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    \n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_22e70u8_test.go:33:41:\
    \ cannot use r (variable of type interface{}) as type []interface{} in argument\
    \ to append:\n\tneed type assertion\n/tmp/tmp_22e70u8_test.go:35:17: result declared\
    \ but not used\n/tmp/tmp_22e70u8_test.go:35:42: cannot use r (variable of type\
    \ interface{}) as type []interface{} in argument to append:\n\tneed type assertion\n\
    /tmp/tmp_22e70u8_test.go:40:5: undefined: sort\n/tmp/tmp_22e70u8_test.go:41:16:\
    \ invalid operation: result[i][0] < result[j][0] (operator < not defined on interface)\n\
    /tmp/tmp_22e70u8_test.go:44:5: undefined: sort\n/tmp/tmp_22e70u8_test.go:45:16:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmp_22e70u8_test.go:58:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp_22e70u8_test.go:59:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_22e70u8_test.go:60:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_22e70u8_test.go:60:232:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := range lst {\n\
    \        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for i := range\
    \ lst {\n        for j := range lst[i] {\n            if lst[i][j] == x {\n  \
    \              result[i][j] = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n\
    \        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57a37kzs_test.go:29:5:\
    \ undefined: sort\n/tmp/tmp57a37kzs_test.go:30:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp57a37kzs_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp57a37kzs_test.go:33:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp57a37kzs_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp57a37kzs_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp57a37kzs_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp57a37kzs_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp57a37kzs_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075495
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for _, row := range lst {\n        var\
    \ tmp []interface{}\n        for _, value := range row {\n            tmp = []interface{}{value,\
    \ x}\n            result = append(result, tmp)\n        }\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprps_hqcj_test.go:26:5:\
    \ undefined: sort\n/tmp/tmprps_hqcj_test.go:26:15: undefined: byRow\n/tmp/tmprps_hqcj_test.go:27:5:\
    \ undefined: sort\n/tmp/tmprps_hqcj_test.go:27:15: undefined: byCol\n/tmp/tmprps_hqcj_test.go:38:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprps_hqcj_test.go:39:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprps_hqcj_test.go:40:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprps_hqcj_test.go:43:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprps_hqcj_test.go:43:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuzd5rmld_test.go:273:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075492
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n    }\n    for\
    \ i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n  \
    \          if lst[i][j] == x {\n                result[i][j] = i\n           \
    \ }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnojipzdb_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:29:15: undefined: byRow\n/tmp/tmpnojipzdb_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpnojipzdb_test.go:30:15: undefined: byCol\n/tmp/tmpnojipzdb_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnojipzdb_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnojipzdb_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnojipzdb_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075493
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    var row []interface{}\n    var col int\n\
    \    for _, row := range lst {\n        col = 0\n        for _, val := range row\
    \ {\n            if val == x {\n                result = append(result, []interface{}{row,\
    \ col})\n            }\n            col++\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprys8asun_test.go:19:9:\
    \ row declared but not used\n/tmp/tmprys8asun_test.go:30:5: undefined: sort\n\
    /tmp/tmprys8asun_test.go:31:16: invalid operation: result[i][0] < result[j][0]\
    \ (operator < not defined on interface)\n/tmp/tmprys8asun_test.go:33:5: undefined:\
    \ sort\n/tmp/tmprys8asun_test.go:34:16: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmprys8asun_test.go:46:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmprys8asun_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprys8asun_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprys8asun_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprys8asun_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprys8asun_test.go:51:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075503
