language: go_test.go
name: HumanEval_161_solve
results:
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result = result + string(char - 'a') + string(char - 'A')\n        } else\
    \ {\n            result = result + string(char)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpcsqcfgs__test.go:46: expected 'aSdF', got 'A\x122D\x05%'\n    ---\
    \ FAIL: TestSolve/test_num__1 (0.00s)\n        tmpcsqcfgs__test.go:46: expected\
    \ '4321', got '1234'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmpcsqcfgs__test.go:46:\
    \ expected 'AB', got '\0 \x01!'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n\
    \        tmpcsqcfgs__test.go:46: expected '#A@c', got '#\0 @C'\n    --- FAIL:\
    \ TestSolve/test_num__4 (0.00s)\n        tmpcsqcfgs__test.go:46: expected '#aSDFw^45',\
    \ got '#A\x122\x03#\x05%W^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n \
    \       tmpcsqcfgs__test.go:46: expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpcsqcfgs__test.go:46: expected '#$A^d', got '#$\0 ^D'\n \
    \   --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpcsqcfgs__test.go:46: expected\
    \ '#CCC', got '#\x02\"\x02\"\x02\"'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpus8f8hyf_test.go:94: expected 'aSdF', got 'TE'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpus8f8hyf_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpus8f8hyf_test.go:94: expected 'AB',\
    \ got 'BA'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpus8f8hyf_test.go:94:\
    \ expected '#A@c', got 'B'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n    \
    \    tmpus8f8hyf_test.go:94: expected '#aSDFw^45', got 'TCE'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpus8f8hyf_test.go:94: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpus8f8hyf_test.go:94: expected '#$A^d',\
    \ got 'B'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpus8f8hyf_test.go:94:\
    \ expected '#CCC', got 'DDD'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result = result + string([]byte(letter))\
    \ + string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplur2xugt_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmplur2xugt_test.go:20:45: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result += string(char - 'a' + 'A')\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmcp3l6ob_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter))\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpriu3k8wx_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpriu3k8wx_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result = result + string([]byte(letter))\
    \ + string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplur2xugt_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmplur2xugt_test.go:20:45: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += \" \"\n        } else {\n            result += string([]byte(letter))\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9hvmce7f_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result += string(letter)\
    \ + string(letter)\n        } else {\n            result += letter\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzwj7wlbd_test.go:20:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpus8f8hyf_test.go:94: expected 'aSdF', got 'TE'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpus8f8hyf_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpus8f8hyf_test.go:94: expected 'AB',\
    \ got 'BA'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpus8f8hyf_test.go:94:\
    \ expected '#A@c', got 'B'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n    \
    \    tmpus8f8hyf_test.go:94: expected '#aSDFw^45', got 'TCE'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpus8f8hyf_test.go:94: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpus8f8hyf_test.go:94: expected '#$A^d',\
    \ got 'B'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpus8f8hyf_test.go:94:\
    \ expected '#CCC', got 'DDD'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += string([]byte(letter))\
    \ + string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4icdh4st_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmp4icdh4st_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter))\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpriu3k8wx_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpriu3k8wx_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result += string(letter)\
    \ + string(letter)\n        } else {\n            result += letter\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzwj7wlbd_test.go:20:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplmtq6jxl_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:18:43: undefined: unicode

    /tmp/tmplmtq6jxl_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:20:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            letter\
    \ = 'A'\n        }\n        if letter == 'A' {\n            letter = 'a'\n   \
    \     }\n        result += letter\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmccm2gy0_test.go:23:9: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[int8(char)-'a'])\n        } else {\n     \
    \       result += string([]rune(char)[int8(char)-'A'])\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxkb8goa_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpuxkb8goa_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ = result + \"A\"\n        } else if letter == 'b' {\n            result = result\
    \ + \"B\"\n        } else if letter == 'c' {\n            result = result + \"\
    C\"\n        } else if letter == 'd' {\n            result = result + \"D\"\n\
    \        } else if letter == 'e' {\n            result = result + \"E\"\n    \
    \    } else if letter == 'f' {\n            result = result + \"F\"\n        }\
    \ else if letter == 'g' {\n            result = result + \"G\"\n        } else\
    \ if letter == 'h' {\n            result = result + \"H\"\n        } else if letter\
    \ == 'i' {\n            result = result + \"I\"\n        } else if letter == 'j'\
    \ {\n            result = result + \"J\"\n        } else if letter == 'k' {\n\
    \            result = result + \"K\"\n        } else if letter == 'l' {\n    \
    \        result = result + \"L\"\n        } else if letter == 'm' {\n        \
    \    result = result + \"M\"\n        } else if letter == 'n' {\n            result\
    \ = result + \"N\"\n        } else if letter == 'o' {\n            result = result\
    \ + \"O\"\n        } else if letter == 'p' {\n            result = result + \"\
    P\"\n        } else if letter == 'q' {\n            result = result + \"Q\"\n\
    \        } else if letter == 'r' {\n            result = result + \"R\"\n    \
    \    } else if letter == 's' {\n            result = result + \"S\"\n        }\
    \ else if letter == 't' {\n            result = result + \"T\"\n        } else\
    \ if letter == 'u' {\n            result = result + \"U\"\n        } else if letter\
    \ == 'v' {\n            result = result + \"V\"\n        } else if letter == 'w'\
    \ {\n            result = result + \"W\"\n        } else if letter == 'x' {\n\
    \            result = result + \"X\"\n        } else if letter == 'y' {\n    \
    \        result = result + \"Y\"\n        } else if letter == 'z' {\n        \
    \    result = result + \"Z\"\n        } else {\n            result = result +\
    \ letter\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe7nv5b9h_test.go:70:22: invalid operation: result + letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    [letter]\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw6awudyi_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmpw6awudyi_test.go:20:13: invalid operation: result += "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[letter]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += string([]byte(letter))\
    \ + string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4icdh4st_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmp4icdh4st_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a' + 1)\n        } else if v >= 'A' && v <= 'Z' {\n         \
    \   result += string(v - 'A' + 1)\n        } else {\n            result += v\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5zyfcxlk_test.go:22:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{byte(char)})\n        } else {\n            result\
    \ += string([]byte{byte(char) - 32})\n        }\n    }\n    return result\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpvw6rqywn_test.go:46: expected 'aSdF', got '!s$f'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpvw6rqywn_test.go:46: expected '4321', got '\x11\x12\x13\x14\
    '\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmpvw6rqywn_test.go:46:\
    \ expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n     \
    \   tmpvw6rqywn_test.go:46: expected '#A@c', got '\x03a #'\n    --- FAIL: TestSolve/test_num__4\
    \ (0.00s)\n        tmpvw6rqywn_test.go:46: expected '#aSDFw^45', got '\x03!sdf7>\x14\
    \x15'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmpvw6rqywn_test.go:46:\
    \ expected '2@6#', got '\x03\x16 \x12'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmpvw6rqywn_test.go:46: expected '#$A^d', got '\x03\x04a>$'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpvw6rqywn_test.go:46: expected\
    \ '#CCC', got '\x03ccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string(\"a\")))\n        }\n    }\n \
    \   return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0iftmvhp_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmp0iftmvhp_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += \" \"\n            continue\n        }\n        if letter == 'a' {\n    \
    \        result += \"A\"\n        } else if letter == 'b' {\n            result\
    \ += \"B\"\n        } else if letter == 'c' {\n            result += \"C\"\n \
    \       } else if letter == 'd' {\n            result += \"D\"\n        } else\
    \ if letter == 'e' {\n            result += \"E\"\n        } else if letter ==\
    \ 'f' {\n            result += \"F\"\n        } else if letter == 'g' {\n    \
    \        result += \"G\"\n        } else if letter == 'h' {\n            result\
    \ += \"H\"\n        } else if letter == 'i' {\n            result += \"I\"\n \
    \       } else if letter == 'j' {\n            result += \"J\"\n        } else\
    \ if letter == 'k' {\n            result += \"K\"\n        } else if letter ==\
    \ 'l' {\n            result += \"L\"\n        } else if letter == 'm' {\n    \
    \        result += \"M\"\n        } else if letter == 'n' {\n            result\
    \ += \"N\"\n        } else if letter == 'o' {\n            result += \"O\"\n \
    \       } else if letter == 'p' {\n            result += \"P\"\n        } else\
    \ if letter == 'q' {\n            result += \"Q\"\n        } else if letter ==\
    \ 'r' {\n            result += \"R\"\n        } else if letter == 's' {\n    \
    \        result += \"S\"\n        } else if letter == 't' {\n            result\
    \ += \"T\"\n        } else if letter == 'u' {\n            result += \"U\"\n \
    \       } else if letter == 'v' {\n            result += \"V\"\n        } else\
    \ if letter == 'w' {\n            result += \"W\"\n        } else if letter ==\
    \ 'x' {\n            result += \"X\"\n        } else if letter == 'y' {\n    \
    \        result += \"Y\"\n        } else if letter == 'z' {\n            result\
    \ += \"Z\"\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp0cn7uhqs_test.go:98: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp0cn7uhqs_test.go:98: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmp0cn7uhqs_test.go:98: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmp0cn7uhqs_test.go:98:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmp0cn7uhqs_test.go:98: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmp0cn7uhqs_test.go:98: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmp0cn7uhqs_test.go:98: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[26-int(char)-97])\n        } else {\n    \
    \        result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo8pl2bku_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpo8pl2bku_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result += string([]rune(char)[26-int(char)])\n        } else {\n     \
    \       result += string([]rune(char)[int('a')-int(char)])\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpup2nko7f_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpup2nko7f_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter))\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpriu3k8wx_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpriu3k8wx_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpuu504gc1_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpuu504gc1_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpuu504gc1_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"a\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpttxjyv8w_test.go:22:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result = result + string(char - 'a') + string(char - 'A')\n        } else\
    \ {\n            result = result + string(char)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpcsqcfgs__test.go:46: expected 'aSdF', got 'A\x122D\x05%'\n    ---\
    \ FAIL: TestSolve/test_num__1 (0.00s)\n        tmpcsqcfgs__test.go:46: expected\
    \ '4321', got '1234'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmpcsqcfgs__test.go:46:\
    \ expected 'AB', got '\0 \x01!'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n\
    \        tmpcsqcfgs__test.go:46: expected '#A@c', got '#\0 @C'\n    --- FAIL:\
    \ TestSolve/test_num__4 (0.00s)\n        tmpcsqcfgs__test.go:46: expected '#aSDFw^45',\
    \ got '#A\x122\x03#\x05%W^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n \
    \       tmpcsqcfgs__test.go:46: expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpcsqcfgs__test.go:46: expected '#$A^d', got '#$\0 ^D'\n \
    \   --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpcsqcfgs__test.go:46: expected\
    \ '#CCC', got '#\x02\"\x02\"\x02\"'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i_m_46g_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            letter\
    \ = 'A'\n        }\n        if letter == 'b' {\n            letter = 'B'\n   \
    \     }\n        if letter == 'c' {\n            letter = 'C'\n        }\n   \
    \     if letter == 'd' {\n            letter = 'D'\n        }\n        if letter\
    \ == 'e' {\n            letter = 'E'\n        }\n        if letter == 'f' {\n\
    \            letter = 'F'\n        }\n        if letter == 'g' {\n           \
    \ letter = 'G'\n        }\n        if letter == 'h' {\n            letter = 'H'\n\
    \        }\n        if letter == 'i' {\n            letter = 'I'\n        }\n\
    \        if letter == 'j' {\n            letter = 'J'\n        }\n        if letter\
    \ == 'k' {\n            letter = 'K'\n        }\n        if letter == 'l' {\n\
    \            letter = 'L'\n        }\n        if letter == 'm' {\n           \
    \ letter = 'M'\n        }\n        if letter == 'n' {\n            letter = 'N'\n\
    \        }\n        if letter == 'o' {\n            letter = 'O'\n        }\n\
    \        if letter == 'p' {\n            letter = 'P'\n        }\n        if letter\
    \ == 'q' {\n            letter = 'Q'\n        }\n        if letter == 'r' {\n\
    \            letter = 'R'\n        }\n        if letter == 's' {\n           \
    \ letter = 'S'\n        }\n        if letter == 't' {\n            letter = 'T'\n\
    \        }\n        if letter == 'u' {\n            letter = 'U'\n        }\n\
    \        if letter == 'v' {\n            letter = 'V'\n        }\n        if letter\
    \ == 'w' {\n            letter = 'W'\n        }\n        if letter == 'x' {\n\
    \            letter = 'X'\n        }\n        if letter == 'y' {\n           \
    \ letter = 'Y'\n        }\n        if letter == 'z' {\n            letter = 'Z'\n\
    \        }\n        if letter == 'A' {\n            letter = 'a'\n        }\n\
    \        if letter == 'B' {\n            letter = 'b'\n        }\n        if letter\
    \ == 'C' {\n            letter = 'c'\n        }\n        if letter == 'D' {\n\
    \            letter = 'd'\n        }\n        if letter == 'E' {\n           \
    \ letter = 'e'\n        }\n        if letter == 'F' {\n            letter = 'f'\n\
    \        }\n        if letter == 'G' {\n            letter = 'g'\n        }\n\
    \        if letter == 'H' {\n            letter = 'h'\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1dr2n7vc_test.go:118:6: expected ''('', found TestSolve

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073584
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i_m_46g_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphbade4xy_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ = result + string(v - 'a')\n        } else {\n            result = result +\
    \ v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc63pfpxx_test.go:20:22: invalid operation: result + v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[int8(char)-'a'])\n        } else {\n     \
    \       result += string([]rune(char)[int8(char)-'A'])\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxkb8goa_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpuxkb8goa_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ = result + \"A\"\n        } else if letter == 'b' {\n            result = result\
    \ + \"B\"\n        } else if letter == 'c' {\n            result = result + \"\
    C\"\n        } else if letter == 'd' {\n            result = result + \"D\"\n\
    \        } else if letter == 'e' {\n            result = result + \"E\"\n    \
    \    } else if letter == 'f' {\n            result = result + \"F\"\n        }\
    \ else if letter == 'g' {\n            result = result + \"G\"\n        } else\
    \ if letter == 'h' {\n            result = result + \"H\"\n        } else if letter\
    \ == 'i' {\n            result = result + \"I\"\n        } else if letter == 'j'\
    \ {\n            result = result + \"J\"\n        } else if letter == 'k' {\n\
    \            result = result + \"K\"\n        } else if letter == 'l' {\n    \
    \        result = result + \"L\"\n        } else if letter == 'm' {\n        \
    \    result = result + \"M\"\n        } else if letter == 'n' {\n            result\
    \ = result + \"N\"\n        } else if letter == 'o' {\n            result = result\
    \ + \"O\"\n        } else if letter == 'p' {\n            result = result + \"\
    P\"\n        } else if letter == 'q' {\n            result = result + \"Q\"\n\
    \        } else if letter == 'r' {\n            result = result + \"R\"\n    \
    \    } else if letter == 's' {\n            result = result + \"S\"\n        }\
    \ else if letter == 't' {\n            result = result + \"T\"\n        } else\
    \ if letter == 'u' {\n            result = result + \"U\"\n        } else if letter\
    \ == 'v' {\n            result = result + \"V\"\n        } else if letter == 'w'\
    \ {\n            result = result + \"W\"\n        } else if letter == 'x' {\n\
    \            result = result + \"X\"\n        } else if letter == 'y' {\n    \
    \        result = result + \"Y\"\n        } else if letter == 'z' {\n        \
    \    result = result + \"Z\"\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpihve_gjr_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpihve_gjr_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpihve_gjr_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpihve_gjr_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpihve_gjr_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpihve_gjr_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpihve_gjr_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplmtq6jxl_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:18:43: undefined: unicode

    /tmp/tmplmtq6jxl_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:20:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += string([]rune(letter)[0])\n        } else {\n            result += string([]rune(letter)[1])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp47da1rbz_test.go:18:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp47da1rbz_test.go:20:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpus8f8hyf_test.go:94: expected 'aSdF', got 'TE'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpus8f8hyf_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpus8f8hyf_test.go:94: expected 'AB',\
    \ got 'BA'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpus8f8hyf_test.go:94:\
    \ expected '#A@c', got 'B'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n    \
    \    tmpus8f8hyf_test.go:94: expected '#aSDFw^45', got 'TCE'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpus8f8hyf_test.go:94: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpus8f8hyf_test.go:94: expected '#$A^d',\
    \ got 'B'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpus8f8hyf_test.go:94:\
    \ expected '#CCC', got 'DDD'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(string([]byte(letter))\
    \ + string([]byte(letter))))))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpegceau1z_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpegceau1z_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[26-int(char)-65])\n        } else {\n    \
    \        result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7v15t29j_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp7v15t29j_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result += string([]byte{char - 'a' + 'A'})\n        } else {\n       \
    \     result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvq2_onaw_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmpvq2_onaw_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ = result + \"A\"\n        } else if letter == 'b' {\n            result = result\
    \ + \"B\"\n        } else if letter == 'c' {\n            result = result + \"\
    C\"\n        } else if letter == 'd' {\n            result = result + \"D\"\n\
    \        } else if letter == 'e' {\n            result = result + \"E\"\n    \
    \    } else if letter == 'f' {\n            result = result + \"F\"\n        }\
    \ else if letter == 'g' {\n            result = result + \"G\"\n        } else\
    \ if letter == 'h' {\n            result = result + \"H\"\n        } else if letter\
    \ == 'i' {\n            result = result + \"I\"\n        } else if letter == 'j'\
    \ {\n            result = result + \"J\"\n        } else if letter == 'k' {\n\
    \            result = result + \"K\"\n        } else if letter == 'l' {\n    \
    \        result = result + \"L\"\n        } else if letter == 'm' {\n        \
    \    result = result + \"M\"\n        } else if letter == 'n' {\n            result\
    \ = result + \"N\"\n        } else if letter == 'o' {\n            result = result\
    \ + \"O\"\n        } else if letter == 'p' {\n            result = result + \"\
    P\"\n        } else if letter == 'q' {\n            result = result + \"Q\"\n\
    \        } else if letter == 'r' {\n            result = result + \"R\"\n    \
    \    } else if letter == 's' {\n            result = result + \"S\"\n        }\
    \ else if letter == 't' {\n            result = result + \"T\"\n        } else\
    \ if letter == 'u' {\n            result = result + \"U\"\n        } else if letter\
    \ == 'v' {\n            result = result + \"V\"\n        } else if letter == 'w'\
    \ {\n            result = result + \"W\"\n        } else if letter == 'x' {\n\
    \            result = result + \"X\"\n        } else if letter == 'y' {\n    \
    \        result = result + \"Y\"\n        } else if letter == 'z' {\n        \
    \    result = result + \"Z\"\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpik6kmrh5_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpik6kmrh5_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpik6kmrh5_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpik6kmrh5_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpik6kmrh5_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpik6kmrh5_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpik6kmrh5_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v)\n        } else {\n            result += string(v) + string(unicode.ToUpper(v))\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp307nke7c_test.go:20:42: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result += string(letter\
    \ + 32)\n        } else {\n            result += letter\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphz64s2h8_test.go:20:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n \
    \           letter = string(unicode.ToLower(letter))\n        }\n        if letter\
    \ == 'b' || letter == 'B' {\n            letter = string(unicode.ToUpper(letter))\n\
    \        }\n        result += letter\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3pbz7inp_test.go:18:29: undefined: unicode

    /tmp/tmp3pbz7inp_test.go:21:29: undefined: unicode

    /tmp/tmp3pbz7inp_test.go:23:9: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter))\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpriu3k8wx_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpriu3k8wx_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, letter := range s {\n        if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n            result = result\
    \ + string(letter) + string(letter)\n        } else {\n            result = result\
    \ + string(letter)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp4oujhwtc_test.go:46: expected 'aSdF', got 'AsDf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp4oujhwtc_test.go:46: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmp4oujhwtc_test.go:46: expected\
    \ 'AB', got 'aab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp4oujhwtc_test.go:46:\
    \ expected '#A@c', got '#aa@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n\
    \        tmp4oujhwtc_test.go:46: expected '#aSDFw^45', got '#AsdfW^45'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmp4oujhwtc_test.go:46: expected\
    \ '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmp4oujhwtc_test.go:46:\
    \ expected '#$A^d', got '#$aa^D'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmp4oujhwtc_test.go:46: expected '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a') + string(v - 'A')\n        } else {\n            result +=\
    \ v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjharsswb_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, letter := range s {\n        if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n            result = result\
    \ + string(letter) + string(letter)\n        } else {\n            result = result\
    \ + string(letter)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp4oujhwtc_test.go:46: expected 'aSdF', got 'AsDf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp4oujhwtc_test.go:46: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmp4oujhwtc_test.go:46: expected\
    \ 'AB', got 'aab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp4oujhwtc_test.go:46:\
    \ expected '#A@c', got '#aa@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n\
    \        tmp4oujhwtc_test.go:46: expected '#aSDFw^45', got '#AsdfW^45'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmp4oujhwtc_test.go:46: expected\
    \ '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmp4oujhwtc_test.go:46:\
    \ expected '#$A^d', got '#$aa^D'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmp4oujhwtc_test.go:46: expected '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    [letter]\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr6e7gu3d_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmpr6e7gu3d_test.go:20:13: invalid operation: result += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"[letter]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += string([]byte(letter))\
    \ + string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4icdh4st_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmp4icdh4st_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result += string(letter)\n\
    \        } else {\n            result += string(letter + 32)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp06zi1625_test.go:46: expected 'aSdF', got 'a\x93d\x86'\n    --- FAIL:\
    \ TestSolve/test_num__1 (0.00s)\n        tmp06zi1625_test.go:46: expected '4321',\
    \ got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmp06zi1625_test.go:46:\
    \ expected 'AB', got 'a\x82'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n  \
    \      tmp06zi1625_test.go:46: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4\
    \ (0.00s)\n        tmp06zi1625_test.go:46: expected '#aSDFw^45', got 'Ca\x93\x84\
    \x86w~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmp06zi1625_test.go:46:\
    \ expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n \
    \       tmp06zi1625_test.go:46: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7\
    \ (0.00s)\n        tmp06zi1625_test.go:46: expected '#CCC', got 'C\x83\x83\x83\
    '\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    [strings.Index(letter, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") + 1] + letter\n       \
    \ }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmfomx1k4_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmpmfomx1k4_test.go:20:23: invalid operation: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[strings.Index(letter,
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ") + 1] + letter (mismatched types byte and rune)

    /tmp/tmpmfomx1k4_test.go:20:52: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[26 - int(char)-65])\n        } else {\n  \
    \          result += string([]rune(char)[26 - int(char)])\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp789zm_zw_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp789zm_zw_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{byte(char)})\n        } else {\n            result\
    \ += string([]byte{byte(ord(char) - 32)})\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa3uqwylj_test.go:20:42: undefined: ord

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[int8(char)-int8('a')])\n        } else {\n\
    \            result += string([]rune(char)[int8(char)-int8('A')])\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqyl_a4kq_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpqyl_a4kq_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphbade4xy_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[int8(char)-int8('a')])\n        } else {\n\
    \            result += string([]rune(char)[int8(char)-int8('A')])\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqyl_a4kq_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpqyl_a4kq_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 32, char - 96})\n        } else {\n     \
    \       result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr1c6ze4b_test.go:18:37: cannot use char - 32 (value of type rune) as type
    byte in array or slice literal

    /tmp/tmpr1c6ze4b_test.go:18:48: cannot use char - 96 (value of type rune) as type
    byte in array or slice literal

    /tmp/tmpr1c6ze4b_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073586
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += \" \"\n        } else {\n            result += strings.ToUpper(letter) +\
    \ strings.ToLower(letter)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2z8qq2gq_test.go:20:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073586
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[26-int(char)-'a'])\n        } else {\n   \
    \         result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqpjf5jcn_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpqpjf5jcn_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplmtq6jxl_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:18:43: undefined: unicode

    /tmp/tmplmtq6jxl_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:20:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[int8(char) - 'a' + 1])\n        } else {\n\
    \            result += string([]rune(char)[int8(char) - 'a'])\n        }\n   \
    \ }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9tu9zi1o_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp9tu9zi1o_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result += string(letter)\
    \ + string(letter)\n        } else {\n            result += letter\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzwj7wlbd_test.go:20:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += \"A\" + string([]byte{letter})\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90ffumdp_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmp90ffumdp_test.go:20:43: cannot use letter (variable of type rune) as type
    byte in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result\
    \ += string(v - 'A')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkudznh7s_test.go:22:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result\
    \ += string(v - 'A')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkudznh7s_test.go:22:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v)\n        } else {\n            result += string(v + 32)\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpimtaplmw_test.go:46: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpimtaplmw_test.go:46: expected '4321', got 'QRST'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmpimtaplmw_test.go:46: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpimtaplmw_test.go:46:\
    \ expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmpimtaplmw_test.go:46: expected '#aSDFw^45', got 'Casdfw~TU'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmpimtaplmw_test.go:46: expected\
    \ '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpimtaplmw_test.go:46:\
    \ expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmpimtaplmw_test.go:46: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n \
    \           letter = string(unicode.ToLower(letter))\n        }\n        if letter\
    \ == 'b' || letter == 'B' {\n            letter = string(unicode.ToUpper(letter))\n\
    \        }\n        result += letter\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3pbz7inp_test.go:18:29: undefined: unicode

    /tmp/tmp3pbz7inp_test.go:21:29: undefined: unicode

    /tmp/tmp3pbz7inp_test.go:23:9: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpus8f8hyf_test.go:94: expected 'aSdF', got 'TE'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpus8f8hyf_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpus8f8hyf_test.go:94: expected 'AB',\
    \ got 'BA'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpus8f8hyf_test.go:94:\
    \ expected '#A@c', got 'B'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n    \
    \    tmpus8f8hyf_test.go:94: expected '#aSDFw^45', got 'TCE'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpus8f8hyf_test.go:94: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpus8f8hyf_test.go:94: expected '#$A^d',\
    \ got 'B'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpus8f8hyf_test.go:94:\
    \ expected '#CCC', got 'DDD'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[26-int(char)-'a'])\n        } else {\n   \
    \         result += string([]rune(char)[26-int(char)])\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfv8pnf2o_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpfv8pnf2o_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += \"A\" + letter\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpztg6bxmj_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmpztg6bxmj_test.go:20:23: invalid operation: "A" + letter (mismatched types
    untyped string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[1::-1])\n        } else {\n            result\
    \ += string([]rune(char)[1::-1])\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx3kh4nyy_test.go:18:44: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073586
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[26-int(char)-97])\n        } else {\n    \
    \        result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo8pl2bku_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpo8pl2bku_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a' + 'A')\n        } else {\n            result += v\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwwlqaef_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result = result + string([]byte(letter))\
    \ + string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplur2xugt_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmplur2xugt_test.go:20:45: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result = result + string([]byte(letter))\
    \ + string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplur2xugt_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmplur2xugt_test.go:20:45: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result = result + string([]byte{letter})\n\
    \        }\n    }\n    if result != \"\" {\n        result = result[:len(result)-1]\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbxwzly6d_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmpbxwzly6d_test.go:20:45: cannot use letter (variable of type rune) as type
    byte in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"a\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"c\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"e\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"g\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"i\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"k\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"m\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"o\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"s\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"u\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"w\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3sgic05o_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a', char - 'A'})\n        } else {\n   \
    \         result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkmol3eal_test.go:18:37: cannot use char - ''a'' (value of type rune) as
    type byte in array or slice literal

    /tmp/tmpkmol3eal_test.go:18:49: cannot use char - ''A'' (value of type rune) as
    type byte in array or slice literal

    /tmp/tmpkmol3eal_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result += string([]rune(letter)[0])\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi407ok8z_test.go:18:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmpi407ok8z_test.go:20:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpuu504gc1_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpuu504gc1_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpuu504gc1_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]rune(letter)...)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo6iu2mdh_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpo6iu2mdh_test.go:20:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result += string([]byte{char - 'a' + 'A'})\n        } else {\n       \
    \     result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvq2_onaw_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmpvq2_onaw_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpuu504gc1_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpuu504gc1_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpuu504gc1_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a') + string(v - 'A')\n        } else {\n            result +=\
    \ v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjharsswb_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[int8(char)-'a'+1])\n        } else {\n   \
    \         result += string([]rune(char)[int8(char)-'A'+1])\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpto67ynj9_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpto67ynj9_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    [letter]\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw6awudyi_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmpw6awudyi_test.go:20:13: invalid operation: result += "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[letter]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result += string([]rune(letter)...)\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkhk3t2rd_test.go:18:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmpkhk3t2rd_test.go:20:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += \"A\" + string([]byte{letter})\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90ffumdp_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmp90ffumdp_test.go:20:43: cannot use letter (variable of type rune) as type
    byte in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result += \"A\" + string([]byte{letter})\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90ffumdp_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmp90ffumdp_test.go:20:43: cannot use letter (variable of type rune) as type
    byte in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n \
    \           result += string([]rune(letter)[0])\n        } else {\n          \
    \  result += letter\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbigknwst_test.go:18:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmpbigknwst_test.go:20:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[26-int(char)-'a'])\n        } else {\n   \
    \         result += string([]rune(char)[int('a')+int(char)-'a'])\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuvql3le5_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpuvql3le5_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[1::-1])\n        } else {\n            result\
    \ += string([]rune(char)[1::-1])\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx3kh4nyy_test.go:18:44: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073586
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpuu504gc1_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpuu504gc1_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpuu504gc1_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i_m_46g_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplmtq6jxl_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:18:43: undefined: unicode

    /tmp/tmplmtq6jxl_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:20:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i_m_46g_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i_m_46g_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplmtq6jxl_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:18:43: undefined: unicode

    /tmp/tmplmtq6jxl_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:20:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result = result + string([]byte(letter))\
    \ + string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplur2xugt_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmplur2xugt_test.go:20:45: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result += string(letter)\n\
    \        } else {\n            result += string(letter + 32)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp06zi1625_test.go:46: expected 'aSdF', got 'a\x93d\x86'\n    --- FAIL:\
    \ TestSolve/test_num__1 (0.00s)\n        tmp06zi1625_test.go:46: expected '4321',\
    \ got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmp06zi1625_test.go:46:\
    \ expected 'AB', got 'a\x82'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n  \
    \      tmp06zi1625_test.go:46: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4\
    \ (0.00s)\n        tmp06zi1625_test.go:46: expected '#aSDFw^45', got 'Ca\x93\x84\
    \x86w~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmp06zi1625_test.go:46:\
    \ expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n \
    \       tmp06zi1625_test.go:46: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7\
    \ (0.00s)\n        tmp06zi1625_test.go:46: expected '#CCC', got 'C\x83\x83\x83\
    '\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n \
    \           result += \"A\"\n        } else if letter == 'b' || letter == 'B'\
    \ {\n            result += \"B\"\n        } else if letter == 'c' || letter ==\
    \ 'C' {\n            result += \"C\"\n        } else if letter == 'd' || letter\
    \ == 'D' {\n            result += \"D\"\n        } else if letter == 'e' || letter\
    \ == 'E' {\n            result += \"E\"\n        } else if letter == 'f' || letter\
    \ == 'F' {\n            result += \"F\"\n        } else if letter == 'g' || letter\
    \ == 'G' {\n            result += \"G\"\n        } else if letter == 'h' || letter\
    \ == 'H' {\n            result += \"H\"\n        } else if letter == 'i' || letter\
    \ == 'I' {\n            result += \"I\"\n        } else if letter == 'j' || letter\
    \ == 'J' {\n            result += \"J\"\n        } else if letter == 'k' || letter\
    \ == 'K' {\n            result += \"K\"\n        } else if letter == 'l' || letter\
    \ == 'L' {\n            result += \"L\"\n        } else if letter == 'm' || letter\
    \ == 'M' {\n            result += \"M\"\n        } else if letter == 'n' || letter\
    \ == 'N' {\n            result += \"N\"\n        } else if letter == 'o' || letter\
    \ == 'O' {\n            result += \"O\"\n        } else if letter == 'p' || letter\
    \ == 'P' {\n            result += \"P\"\n        } else if letter == 'q' || letter\
    \ == 'Q' {\n            result += \"Q\"\n        } else if letter == 'r' || letter\
    \ == 'R' {\n            result += \"R\"\n        } else if letter == 's' || letter\
    \ == 'S' {\n            result += \"S\"\n        } else if letter == 't' || letter\
    \ == 'T' {\n            result += \"T\"\n        } else if letter == 'u' || letter\
    \ == 'U' {\n            result += \"U\"\n        } else if letter == 'v' || letter\
    \ == 'V' {\n            result += \"V\"\n        } else if letter == 'w' || letter\
    \ == 'W' {\n            result += \"W\"\n        } else if letter == 'x' || letter\
    \ == 'X' {\n            result += \"X\"\n        } else if letter == 'y' || letter\
    \ == 'Y' {\n            result += \"Y\"\n        } else if letter == 'z' || letter\
    \ == 'Z' {\n            result += \"Z\"\n        } else {\n            result\
    \ += letter\n        }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9ycqmhob_test.go:73:6: expected ''('', found TestSolve

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073586
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]rune(letter)...)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo6iu2mdh_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpo6iu2mdh_test.go:20:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[1::-1])\n        } else {\n            result\
    \ += string([]rune(char)[:1])\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcb2wbgoe_test.go:18:44: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073586
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[26-int(char-97)])\n        } else {\n    \
    \        result += string([]rune(char)[26-int(char-65)])\n        }\n    }\n \
    \   return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkp7ag61w_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpkp7ag61w_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpuu504gc1_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpuu504gc1_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpuu504gc1_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[26-int(char)-97])\n        } else {\n    \
    \        result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo8pl2bku_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpo8pl2bku_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ = result + \"A\"\n        } else if letter == 'b' {\n            result = result\
    \ + \"B\"\n        } else if letter == 'c' {\n            result = result + \"\
    C\"\n        } else if letter == 'd' {\n            result = result + \"D\"\n\
    \        } else if letter == 'e' {\n            result = result + \"E\"\n    \
    \    } else if letter == 'f' {\n            result = result + \"F\"\n        }\
    \ else if letter == 'g' {\n            result = result + \"G\"\n        } else\
    \ if letter == 'h' {\n            result = result + \"H\"\n        } else if letter\
    \ == 'i' {\n            result = result + \"I\"\n        } else if letter == 'j'\
    \ {\n            result = result + \"J\"\n        } else if letter == 'k' {\n\
    \            result = result + \"K\"\n        } else if letter == 'l' {\n    \
    \        result = result + \"L\"\n        } else if letter == 'm' {\n        \
    \    result = result + \"M\"\n        } else if letter == 'n' {\n            result\
    \ = result + \"N\"\n        } else if letter == 'o' {\n            result = result\
    \ + \"O\"\n        } else if letter == 'p' {\n            result = result + \"\
    P\"\n        } else if letter == 'q' {\n            result = result + \"Q\"\n\
    \        } else if letter == 'r' {\n            result = result + \"R\"\n    \
    \    } else if letter == 's' {\n            result = result + \"S\"\n        }\
    \ else if letter == 't' {\n            result = result + \"T\"\n        } else\
    \ if letter == 'u' {\n            result = result + \"U\"\n        } else if letter\
    \ == 'v' {\n            result = result + \"V\"\n        } else if letter == 'w'\
    \ {\n            result = result + \"W\"\n        } else if letter == 'x' {\n\
    \            result = result + \"X\"\n        } else if letter == 'y' {\n    \
    \        result = result + \"Y\"\n        } else if letter == 'z' {\n        \
    \    result = result + \"Z\"\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpihve_gjr_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpihve_gjr_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpihve_gjr_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpihve_gjr_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpihve_gjr_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpihve_gjr_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpihve_gjr_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result += string(letter)\n\
    \        } else {\n            result += string(letter + 32)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp06zi1625_test.go:46: expected 'aSdF', got 'a\x93d\x86'\n    --- FAIL:\
    \ TestSolve/test_num__1 (0.00s)\n        tmp06zi1625_test.go:46: expected '4321',\
    \ got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmp06zi1625_test.go:46:\
    \ expected 'AB', got 'a\x82'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n  \
    \      tmp06zi1625_test.go:46: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4\
    \ (0.00s)\n        tmp06zi1625_test.go:46: expected '#aSDFw^45', got 'Ca\x93\x84\
    \x86w~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmp06zi1625_test.go:46:\
    \ expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n \
    \       tmp06zi1625_test.go:46: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7\
    \ (0.00s)\n        tmp06zi1625_test.go:46: expected '#CCC', got 'C\x83\x83\x83\
    '\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"a\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"c\"\n        } else if letter ==\
    \ 'e' {\n            result += \"f\"\n        } else if letter == 'f' {\n    \
    \        result += \"e\"\n        } else if letter == 'g' {\n            result\
    \ += \"h\"\n        } else if letter == 'h' {\n            result += \"g\"\n \
    \       } else if letter == 'i' {\n            result += \"j\"\n        } else\
    \ if letter == 'j' {\n            result += \"i\"\n        } else if letter ==\
    \ 'k' {\n            result += \"l\"\n        } else if letter == 'l' {\n    \
    \        result += \"k\"\n        } else if letter == 'm' {\n            result\
    \ += \"n\"\n        } else if letter == 'n' {\n            result += \"m\"\n \
    \       } else if letter == 'o' {\n            result += \"p\"\n        } else\
    \ if letter == 'p' {\n            result += \"o\"\n        } else if letter ==\
    \ 'q' {\n            result += \"r\"\n        } else if letter == 'r' {\n    \
    \        result += \"q\"\n        } else if letter == 's' {\n            result\
    \ += \"t\"\n        } else if letter == 't' {\n            result += \"s\"\n \
    \       } else if letter == 'u' {\n            result += \"v\"\n        } else\
    \ if letter == 'v' {\n            result += \"u\"\n        } else if letter ==\
    \ 'w' {\n            result += \"x\"\n        } else if letter == 'x' {\n    \
    \        result += \"w\"\n        } else if letter == 'y' {\n            result\
    \ += \"z\"\n        } else if letter == 'z' {\n            result += \"y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdu0a253e_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpuu504gc1_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpuu504gc1_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpuu504gc1_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplmtq6jxl_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:18:43: undefined: unicode

    /tmp/tmplmtq6jxl_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:20:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result = result + string(char - 'a') + string(char - 'A')\n        } else\
    \ {\n            result = result + string(char)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpcsqcfgs__test.go:46: expected 'aSdF', got 'A\x122D\x05%'\n    ---\
    \ FAIL: TestSolve/test_num__1 (0.00s)\n        tmpcsqcfgs__test.go:46: expected\
    \ '4321', got '1234'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmpcsqcfgs__test.go:46:\
    \ expected 'AB', got '\0 \x01!'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n\
    \        tmpcsqcfgs__test.go:46: expected '#A@c', got '#\0 @C'\n    --- FAIL:\
    \ TestSolve/test_num__4 (0.00s)\n        tmpcsqcfgs__test.go:46: expected '#aSDFw^45',\
    \ got '#A\x122\x03#\x05%W^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n \
    \       tmpcsqcfgs__test.go:46: expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpcsqcfgs__test.go:46: expected '#$A^d', got '#$\0 ^D'\n \
    \   --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpcsqcfgs__test.go:46: expected\
    \ '#CCC', got '#\x02\"\x02\"\x02\"'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_945ac9_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[char-'a'+1])\n        } else {\n         \
    \   result += string([]rune(char)[char-'A'+1])\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdqu0td8a_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpdqu0td8a_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073588
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ = result + \"A\"\n        } else if letter == 'b' {\n            result = result\
    \ + \"B\"\n        } else if letter == 'c' {\n            result = result + \"\
    C\"\n        } else if letter == 'd' {\n            result = result + \"D\"\n\
    \        } else if letter == 'e' {\n            result = result + \"E\"\n    \
    \    } else if letter == 'f' {\n            result = result + \"F\"\n        }\
    \ else if letter == 'g' {\n            result = result + \"G\"\n        } else\
    \ if letter == 'h' {\n            result = result + \"H\"\n        } else if letter\
    \ == 'i' {\n            result = result + \"I\"\n        } else if letter == 'j'\
    \ {\n            result = result + \"J\"\n        } else if letter == 'k' {\n\
    \            result = result + \"K\"\n        } else if letter == 'l' {\n    \
    \        result = result + \"L\"\n        } else if letter == 'm' {\n        \
    \    result = result + \"M\"\n        } else if letter == 'n' {\n            result\
    \ = result + \"N\"\n        } else if letter == 'o' {\n            result = result\
    \ + \"O\"\n        } else if letter == 'p' {\n            result = result + \"\
    P\"\n        } else if letter == 'q' {\n            result = result + \"Q\"\n\
    \        } else if letter == 'r' {\n            result = result + \"R\"\n    \
    \    } else if letter == 's' {\n            result = result + \"S\"\n        }\
    \ else if letter == 't' {\n            result = result + \"T\"\n        } else\
    \ if letter == 'u' {\n            result = result + \"U\"\n        } else if letter\
    \ == 'v' {\n            result = result + \"V\"\n        } else if letter == 'w'\
    \ {\n            result = result + \"W\"\n        } else if letter == 'x' {\n\
    \            result = result + \"X\"\n        } else if letter == 'y' {\n    \
    \        result = result + \"Y\"\n        } else if letter == 'z' {\n        \
    \    result = result + \"Z\"\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpik6kmrh5_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpik6kmrh5_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpik6kmrh5_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpik6kmrh5_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpik6kmrh5_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpik6kmrh5_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpik6kmrh5_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[char-'a'+1])\n        } else {\n         \
    \   result += string([]rune(char)[char-'a'+2])\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp95sjzlf0_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp95sjzlf0_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073588
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result += string([]rune(char)[26-int(char)-65])\n        } else {\n  \
    \          result += string([]rune(char)[26-int(char)])\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplr6uazhl_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplr6uazhl_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073588
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"A\"\n        } else if letter == 'b' {\n            result += \"B\"\n \
    \       } else if letter == 'c' {\n            result += \"C\"\n        } else\
    \ if letter == 'd' {\n            result += \"D\"\n        } else if letter ==\
    \ 'e' {\n            result += \"E\"\n        } else if letter == 'f' {\n    \
    \        result += \"F\"\n        } else if letter == 'g' {\n            result\
    \ += \"G\"\n        } else if letter == 'h' {\n            result += \"H\"\n \
    \       } else if letter == 'i' {\n            result += \"I\"\n        } else\
    \ if letter == 'j' {\n            result += \"J\"\n        } else if letter ==\
    \ 'k' {\n            result += \"K\"\n        } else if letter == 'l' {\n    \
    \        result += \"L\"\n        } else if letter == 'm' {\n            result\
    \ += \"M\"\n        } else if letter == 'n' {\n            result += \"N\"\n \
    \       } else if letter == 'o' {\n            result += \"O\"\n        } else\
    \ if letter == 'p' {\n            result += \"P\"\n        } else if letter ==\
    \ 'q' {\n            result += \"Q\"\n        } else if letter == 'r' {\n    \
    \        result += \"R\"\n        } else if letter == 's' {\n            result\
    \ += \"S\"\n        } else if letter == 't' {\n            result += \"T\"\n \
    \       } else if letter == 'u' {\n            result += \"U\"\n        } else\
    \ if letter == 'v' {\n            result += \"V\"\n        } else if letter ==\
    \ 'w' {\n            result += \"W\"\n        } else if letter == 'x' {\n    \
    \        result += \"X\"\n        } else if letter == 'y' {\n            result\
    \ += \"Y\"\n        } else if letter == 'z' {\n            result += \"Z\"\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpuu504gc1_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpuu504gc1_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpuu504gc1_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpuu504gc1_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpuu504gc1_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else {\n            result += letter\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpruaj528f_test.go:30:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073588
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result\
    \ += string(v - 'A')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkudznh7s_test.go:22:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ += \"B\"\n        } else if letter == 'b' {\n            result += \"A\"\n \
    \       } else if letter == 'c' {\n            result += \"D\"\n        } else\
    \ if letter == 'd' {\n            result += \"C\"\n        } else if letter ==\
    \ 'e' {\n            result += \"F\"\n        } else if letter == 'f' {\n    \
    \        result += \"E\"\n        } else if letter == 'g' {\n            result\
    \ += \"H\"\n        } else if letter == 'h' {\n            result += \"G\"\n \
    \       } else if letter == 'i' {\n            result += \"J\"\n        } else\
    \ if letter == 'j' {\n            result += \"I\"\n        } else if letter ==\
    \ 'k' {\n            result += \"L\"\n        } else if letter == 'l' {\n    \
    \        result += \"K\"\n        } else if letter == 'm' {\n            result\
    \ += \"N\"\n        } else if letter == 'n' {\n            result += \"M\"\n \
    \       } else if letter == 'o' {\n            result += \"P\"\n        } else\
    \ if letter == 'p' {\n            result += \"O\"\n        } else if letter ==\
    \ 'q' {\n            result += \"R\"\n        } else if letter == 'r' {\n    \
    \        result += \"Q\"\n        } else if letter == 's' {\n            result\
    \ += \"T\"\n        } else if letter == 't' {\n            result += \"S\"\n \
    \       } else if letter == 'u' {\n            result += \"V\"\n        } else\
    \ if letter == 'v' {\n            result += \"U\"\n        } else if letter ==\
    \ 'w' {\n            result += \"X\"\n        } else if letter == 'x' {\n    \
    \        result += \"W\"\n        } else if letter == 'y' {\n            result\
    \ += \"Z\"\n        } else if letter == 'z' {\n            result += \"Y\"\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnho7an8_test.go:70:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ = result + letter\n        } else {\n            result = result + string([]byte(letter))\
    \ + string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplur2xugt_test.go:18:22: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmplur2xugt_test.go:20:45: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else {\n            result += v\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i_m_46g_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[char-'a'+1:])\n        } else {\n        \
    \    result += string([]rune(char)[char-'a':])\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7lo9784s_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp7lo9784s_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073588
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter)) +\
    \ string([]byte(string([]byte(letter)) + string([]byte(letter))))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_13zeis_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpf_13zeis_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == ' ' {\n            result\
    \ += letter\n        } else {\n            result += string([]byte(letter))\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpriu3k8wx_test.go:18:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpriu3k8wx_test.go:20:37: cannot convert letter (variable of type rune)
    to type []byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            result\
    \ = result + \"A\"\n        } else if letter == 'b' {\n            result = result\
    \ + \"B\"\n        } else if letter == 'c' {\n            result = result + \"\
    C\"\n        } else if letter == 'd' {\n            result = result + \"D\"\n\
    \        } else if letter == 'e' {\n            result = result + \"E\"\n    \
    \    } else if letter == 'f' {\n            result = result + \"F\"\n        }\
    \ else if letter == 'g' {\n            result = result + \"G\"\n        } else\
    \ if letter == 'h' {\n            result = result + \"H\"\n        } else if letter\
    \ == 'i' {\n            result = result + \"I\"\n        } else if letter == 'j'\
    \ {\n            result = result + \"J\"\n        } else if letter == 'k' {\n\
    \            result = result + \"K\"\n        } else if letter == 'l' {\n    \
    \        result = result + \"L\"\n        } else if letter == 'm' {\n        \
    \    result = result + \"M\"\n        } else if letter == 'n' {\n            result\
    \ = result + \"N\"\n        } else if letter == 'o' {\n            result = result\
    \ + \"O\"\n        } else if letter == 'p' {\n            result = result + \"\
    P\"\n        } else if letter == 'q' {\n            result = result + \"Q\"\n\
    \        } else if letter == 'r' {\n            result = result + \"R\"\n    \
    \    } else if letter == 's' {\n            result = result + \"S\"\n        }\
    \ else if letter == 't' {\n            result = result + \"T\"\n        } else\
    \ if letter == 'u' {\n            result = result + \"U\"\n        } else if letter\
    \ == 'v' {\n            result = result + \"V\"\n        } else if letter == 'w'\
    \ {\n            result = result + \"W\"\n        } else if letter == 'x' {\n\
    \            result = result + \"X\"\n        } else if letter == 'y' {\n    \
    \        result = result + \"Y\"\n        } else if letter == 'z' {\n        \
    \    result = result + \"Z\"\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpik6kmrh5_test.go:94: expected 'aSdF', got 'SF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpik6kmrh5_test.go:94: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpik6kmrh5_test.go:94: expected '#A@c',\
    \ got 'A'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpik6kmrh5_test.go:94:\
    \ expected '#aSDFw^45', got 'SDF'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpik6kmrh5_test.go:94: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpik6kmrh5_test.go:94: expected '#$A^d', got 'A'\n    ---\
    \ FAIL: TestSolve/test_num__7 (0.00s)\n        tmpik6kmrh5_test.go:94: expected\
    \ '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[int8(char)-int8('a')])\n        } else {\n\
    \            result += string([]rune(char)[int8(char)-int8('A')])\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqyl_a4kq_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpqyl_a4kq_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    var result string\n\
    \    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n     \
    \       result += string(char - 'a' + 'A')\n        } else {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmcp3l6ob_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{byte(char)})\n        } else {\n            result\
    \ += string([]byte{byte(ord(char) - 32)})\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa3uqwylj_test.go:20:42: undefined: ord

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[int8(char)-'a'])\n        } else {\n     \
    \       result += string([]rune(char)[int8(char)-32])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8kiuwve6_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp8kiuwve6_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073588
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[int8(char)-int8('a')])\n        } else {\n\
    \            result += string([]rune(char)[int8(char)-int8('A')])\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqyl_a4kq_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpqyl_a4kq_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073585
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a' + 'A')\n        } else {\n            result += v\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwwlqaef_test.go:20:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplmtq6jxl_test.go:18:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:18:43: undefined: unicode

    /tmp/tmplmtq6jxl_test.go:20:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplmtq6jxl_test.go:20:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n       \
    \     result += string([]byte{char - 'a' + 'A'})\n        } else {\n         \
    \   result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q_3wxno_test.go:18:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmp_q_3wxno_test.go:20:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073582
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v)\n        } else {\n            result += string(v + 32)\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpimtaplmw_test.go:46: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpimtaplmw_test.go:46: expected '4321', got 'QRST'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmpimtaplmw_test.go:46: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpimtaplmw_test.go:46:\
    \ expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmpimtaplmw_test.go:46: expected '#aSDFw^45', got 'Casdfw~TU'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmpimtaplmw_test.go:46: expected\
    \ '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpimtaplmw_test.go:46:\
    \ expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmpimtaplmw_test.go:46: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073587
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' {\n            letter\
    \ = string(unicode.ToLower(letter))\n        }\n        if letter == 'A' {\n \
    \           letter = string(unicode.ToUpper(letter))\n        }\n        result\
    \ += letter\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n \
    \ candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9mfzf4o8_test.go:18:29: undefined: unicode

    /tmp/tmp9mfzf4o8_test.go:21:29: undefined: unicode

    /tmp/tmp9mfzf4o8_test.go:23:9: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073588
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result\
    \ += string(v - 'a')\n        } else {\n            result += string(v)\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmphz3uev_n_test.go:46: expected 'aSdF', got 'A\x12D\x05'\n    --- FAIL:\
    \ TestSolve/test_num__1 (0.00s)\n        tmphz3uev_n_test.go:46: expected '4321',\
    \ got '1234'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmphz3uev_n_test.go:46:\
    \ expected 'AB', got '\0\x01'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n \
    \       tmphz3uev_n_test.go:46: expected '#A@c', got '#\0@C'\n    --- FAIL: TestSolve/test_num__4\
    \ (0.00s)\n        tmphz3uev_n_test.go:46: expected '#aSDFw^45', got '#A\x12\x03\
    \x05W^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmphz3uev_n_test.go:46:\
    \ expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n \
    \       tmphz3uev_n_test.go:46: expected '#$A^d', got '#$\0^D'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmphz3uev_n_test.go:46: expected '#CCC',\
    \ got '#\x02\x02\x02'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073588
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\nfunc solve(s string) string {\n    result := \"\"\n  \
    \  for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n \
    \           result += string([]rune(letter)[0])\n        } else {\n          \
    \  result += string(letter)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt_pkm1ls_test.go:18:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073588
