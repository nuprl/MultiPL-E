language: go_test.go
name: HumanEval_46_fib4
results:
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 4\n\
    \    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for fib4(0) = 0\")\n   \
    \     return 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1\
    \ {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if\
    \ n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp8s4pl189_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp8s4pl189_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp8s4pl189_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp8s4pl189_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return 0\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp2l501pb0_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp2l501pb0_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp2l501pb0_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp2l501pb0_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 0\n    }\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpg5r_7on0_test.go:54: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpg5r_7on0_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpg5r_7on0_test.go:54: expected '%!s(int=104)', got '%!s(int=46)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpg5r_7on0_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbou76xry_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbou76xry_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbou76xry_test.go:50: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbou76xry_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return 0\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp0hr0aium_test.go:54: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp0hr0aium_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp0hr0aium_test.go:54: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp0hr0aium_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmb73f4xo_test.go:38: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmb73f4xo_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmb73f4xo_test.go:38: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmb73f4xo_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp8hnqq1k1_test.go:38: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp8hnqq1k1_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp8hnqq1k1_test.go:38: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp8hnqq1k1_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n    }\n   \
    \ if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n  \
    \  }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return\
    \ 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmph89ngr0i_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmph89ngr0i_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmph89ngr0i_test.go:53: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmph89ngr0i_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 4\n\
    \    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpiimihtww_test.go:54: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpiimihtww_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpiimihtww_test.go:54: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpiimihtww_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpiimihtww_test.go:54: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpiimihtww_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpiimihtww_test.go:54: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpiimihtww_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return 0\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) +\
    \ fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpkk9ksupd_test.go:38: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpkk9ksupd_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpkk9ksupd_test.go:38: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpkk9ksupd_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpj434l8nb_test.go:54: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpj434l8nb_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpj434l8nb_test.go:54: expected '%!s(int=104)', got '%!s(int=46)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpj434l8nb_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 2\n  \
    \  }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp4ojbcl3t_test.go:53: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp4ojbcl3t_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=32)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp4ojbcl3t_test.go:53: expected '%!s(int=104)', got '%!s(int=119)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp4ojbcl3t_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=442)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmphcmw8xya_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmphcmw8xya_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmphcmw8xya_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmphcmw8xya_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 4\n  \
    \  }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp15v8in9g_test.go:53: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp15v8in9g_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp15v8in9g_test.go:53: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp15v8in9g_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n        return\
    \ -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n     \
    \   return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpj_tx_0qe_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpj_tx_0qe_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpj_tx_0qe_test.go:54: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpj_tx_0qe_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 4\n\
    \    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpj434l8nb_test.go:54: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpj434l8nb_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpj434l8nb_test.go:54: expected '%!s(int=104)', got '%!s(int=46)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpj434l8nb_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n        return\
    \ -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n     \
    \   return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n    }\n   \
    \ if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n  \
    \  }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return\
    \ 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmph89ngr0i_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmph89ngr0i_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmph89ngr0i_test.go:53: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmph89ngr0i_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 4\n  \
    \  }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp15v8in9g_test.go:53: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp15v8in9g_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp15v8in9g_test.go:53: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp15v8in9g_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpuaob7y7i_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpuaob7y7i_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpuaob7y7i_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpuaob7y7i_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return n\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) +\
    \ fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return 0\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpjrplvrta_test.go:54: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpjrplvrta_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpjrplvrta_test.go:54: expected '%!s(int=104)', got '%!s(int=61)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpjrplvrta_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=226)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n >= 0\")\n        return\
    \ -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n     \
    \   return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpo7x5cclo_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpo7x5cclo_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpo7x5cclo_test.go:54: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpo7x5cclo_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpj2unw4_s_test.go:50: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpj2unw4_s_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpj2unw4_s_test.go:50: expected '%!s(int=104)', got '%!s(int=61)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpj2unw4_s_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=226)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp22y_zxih_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp22y_zxih_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp22y_zxih_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp22y_zxih_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmb73f4xo_test.go:38: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmb73f4xo_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmb73f4xo_test.go:38: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmb73f4xo_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 4\n\
    \    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return n\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) +\
    \ fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return n\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) +\
    \ fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 4\n\
    \    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined as fib4(0) -> 0\")\n   \
    \     return 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1\
    \ {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if\
    \ n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 0\n    }\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp9yg4n33o_test.go:54: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp9yg4n33o_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp9yg4n33o_test.go:54: expected '%!s(int=104)', got '%!s(int=61)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp9yg4n33o_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=226)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return n\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) +\
    \ fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbou76xry_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbou76xry_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbou76xry_test.go:50: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbou76xry_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmphcmw8xya_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmphcmw8xya_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmphcmw8xya_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmphcmw8xya_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbou76xry_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbou76xry_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbou76xry_test.go:50: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbou76xry_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 3\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpqzw3q93c_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpqzw3q93c_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpqzw3q93c_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpqzw3q93c_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp8hnqq1k1_test.go:38: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp8hnqq1k1_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp8hnqq1k1_test.go:38: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp8hnqq1k1_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpj2unw4_s_test.go:50: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpj2unw4_s_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpj2unw4_s_test.go:50: expected '%!s(int=104)', got '%!s(int=61)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpj2unw4_s_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=226)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return n\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) +\
    \ fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined only for positive integers\"\
    )\n        return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if\
    \ n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 0\n\
    \    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpzfc4yqa2_test.go:54: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpzfc4yqa2_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpzfc4yqa2_test.go:54: expected '%!s(int=104)', got '%!s(int=46)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpzfc4yqa2_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpj434l8nb_test.go:54: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpj434l8nb_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpj434l8nb_test.go:54: expected '%!s(int=104)', got '%!s(int=46)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpj434l8nb_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpo3s8w7hw_test.go:38: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpo3s8w7hw_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpo3s8w7hw_test.go:38: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpo3s8w7hw_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmb73f4xo_test.go:38: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmb73f4xo_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmb73f4xo_test.go:38: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmb73f4xo_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpj2unw4_s_test.go:50: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpj2unw4_s_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpj2unw4_s_test.go:50: expected '%!s(int=104)', got '%!s(int=61)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpj2unw4_s_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=226)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp22y_zxih_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp22y_zxih_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp22y_zxih_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp22y_zxih_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 1\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpokvlgfxo_test.go:50: expected '%!s(int=28)', got '%!s(int=24)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpokvlgfxo_test.go:50: expected\
    \ '%!s(int=104)', got '%!s(int=90)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpokvlgfxo_test.go:50: expected '%!s(int=386)', got '%!s(int=334)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 3\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpqzw3q93c_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpqzw3q93c_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpqzw3q93c_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpqzw3q93c_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpcu8ckba8_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpcu8ckba8_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpcu8ckba8_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpcu8ckba8_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpuaob7y7i_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpuaob7y7i_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpuaob7y7i_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpuaob7y7i_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpj434l8nb_test.go:54: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpj434l8nb_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpj434l8nb_test.go:54: expected '%!s(int=104)', got '%!s(int=46)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpj434l8nb_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n        return 4\n\
    \    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp3mmdu1cm_test.go:47: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp3mmdu1cm_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpcu8ckba8_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpcu8ckba8_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpcu8ckba8_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpcu8ckba8_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for fib4(0) = 0\")\n   \
    \     return 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1\
    \ {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if\
    \ n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp8s4pl189_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp8s4pl189_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp8s4pl189_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp8s4pl189_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpoozm_74q_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpoozm_74q_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpcu8ckba8_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpcu8ckba8_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpcu8ckba8_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpcu8ckba8_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n >= 0\")\n        return\
    \ -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n     \
    \   return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpo7x5cclo_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpo7x5cclo_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpo7x5cclo_test.go:54: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpo7x5cclo_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n        return\
    \ -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n     \
    \   return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpoumc9l3d_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpoumc9l3d_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpoumc9l3d_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpoumc9l3d_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return n\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) +\
    \ fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpqarm_fdo_test.go:38: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpqarm_fdo_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp73xtsd_w_test.go:50: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp73xtsd_w_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbdwrdee7_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbdwrdee7_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return n\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpgvphc7px_test.go:38: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpgvphc7px_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpgvphc7px_test.go:38: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpgvphc7px_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for positive integers only.\"\
    )\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmyz219v1_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmyz219v1_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmyz219v1_test.go:53: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmyz219v1_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 4 {\n \
    \       return 0\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) +\
    \ fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpkk9ksupd_test.go:38: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpkk9ksupd_test.go:38: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpkk9ksupd_test.go:38: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpkk9ksupd_test.go:38: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n    }\n   \
    \ if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n  \
    \  }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return\
    \ 0\n    }\n    if n == 4 {\n        return 0\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmppzksp482_test.go:53: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmppzksp482_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmppzksp482_test.go:53: expected '%!s(int=104)', got '%!s(int=46)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmppzksp482_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpiimihtww_test.go:54: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpiimihtww_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpiimihtww_test.go:54: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpiimihtww_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 number sequence is defined for n>=0\")\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpuaob7y7i_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpuaob7y7i_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpuaob7y7i_test.go:51: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpuaob7y7i_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmps_ppg9fn_test.go:15 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmps_ppg9fn_test.go:19 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmps_ppg9fn_test.go:19\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074137
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=4)', got '%!s(int=7)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=48)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpum8ocscg_test.go:50: expected '%!s(int=104)', got '%!s(int=177)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpum8ocscg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=658)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       return 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp22y_zxih_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp22y_zxih_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp22y_zxih_test.go:50: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp22y_zxih_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074138
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n <= 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n < 0 {\n \
    \       fmt.Println(\"fib4 called with negative number\")\n        return -1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    if n == 4 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpl6cbbktu_test.go:54: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpl6cbbktu_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpl6cbbktu_test.go:54: expected '%!s(int=104)', got '%!s(int=61)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpl6cbbktu_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=226)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074139
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 || n\
    \ == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    if n == 3 {\n        return 0\n    }\n    return fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\nfunc fib4(n int) int {\n    if n == 0 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n   \
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpx69so8s6_test.go:47: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpx69so8s6_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074135
