language: go_test.go
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \" \"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6pk62rv2_test.go:87:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_str = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups\
    \ = append(paren_groups, paren_str)\n        paren_groups = append(paren_groups,\
    \ separate_paren_groups(paren_str))\n    }\n    return paren_groups\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3z_c7ef__test.go:13:5: undefined: paren_groups

    /tmp/tmp3z_c7ef__test.go:14:5: undefined: paren_stack

    /tmp/tmp3z_c7ef__test.go:15:26: undefined: paren_stack

    /tmp/tmp3z_c7ef__test.go:16:27: undefined: paren_groups

    /tmp/tmp3z_c7ef__test.go:17:13: undefined: paren_stack

    /tmp/tmp3z_c7ef__test.go:18:9: undefined: paren_str

    /tmp/tmp3z_c7ef__test.go:18:21: undefined: paren_stack

    /tmp/tmp3z_c7ef__test.go:19:23: undefined: paren_stack

    /tmp/tmp3z_c7ef__test.go:20:31: undefined: paren_groups

    /tmp/tmp3z_c7ef__test.go:20:45: undefined: paren_str

    /tmp/tmp3z_c7ef__test.go:20:45: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    stack := append(stack,\
    \ paren_string)\n    depth := 0\n    for len(stack) > 0 {\n        depth += 1\n\
    \        stack := stack[:0]\n        for _, s := range stack {\n            stack\
    \ := append(stack, s[:len(s)-1])\n        }\n        stack := stack[:0]\n    \
    \    for _, s := range stack {\n            if s == \")\" {\n                depth\
    \ -= 1\n                if depth == 0 {\n                    result = append(result,\
    \ strings.Join(stack, \"(\"))\n                    stack = stack[:0]\n       \
    \         }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvxw7so1h_test.go:15:11: no new variables on left side of :=

    /tmp/tmpvxw7so1h_test.go:21:13: stack declared but not used

    /tmp/tmpvxw7so1h_test.go:23:15: no new variables on left side of :=

    /tmp/tmpvxw7so1h_test.go:28:45: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group := \"\"\n    paren_group_open\
    \ := false\n    paren_group_closed := false\n    paren_group_string := \"\"\n\
    \    paren_group_string_length := 0\n    paren_group_string_length := 0\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_string := \"\"\n    paren_group_string := \"\"\n  \
    \  paren_group_string := \"\"\n    paren_group_string := \"\"\n    paren_group_string\
    \ := \"\"\n    paren_group_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyy1bnry__test.go:77:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to store our results\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, c := range\
    \ paren_string {\n        // If the character is a left paren, add it to the list\n\
    \        if c == '(' {\n            result = append(result, c)\n        }\n\n\
    \        // If the character is a right paren, remove it from the list\n     \
    \   if c == ')' {\n            result = removeElement(result, c)\n        }\n\
    \    }\n\n    // Return the list of results\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6_w7hqp5_test.go:20:37: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmp6_w7hqp5_test.go:25:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to hold the separate groups\n    result := make([]string,\
    \ 0)\n\n    // Initialize a stack to keep track of open braces\n    stack := make([]int,\
    \ 0)\n\n    // Iterate through the input string\n    for _, char := range paren_string\
    \ {\n        // If the char is a left paren, push it to the stack\n        if\
    \ char == '(' {\n            stack = append(stack, char)\n        }\n\n      \
    \  // If the char is a right paren, pop it from the stack\n        if char ==\
    \ ')' {\n            stack = stack[:len(stack)-1]\n        }\n\n        // If\
    \ the stack is empty, we've found a group\n        if len(stack) == 0 {\n    \
    \        result = append(result, char)\n        }\n    }\n\n    // Return the\
    \ list of separate groups\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpplo8u7w6_test.go:23:35: cannot use char (variable of type rune) as type
    int in argument to append

    /tmp/tmpplo8u7w6_test.go:33:37: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a slice to hold our output\n    output := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, c := range\
    \ paren_string {\n        // If the character is a left paren, add it to the output\n\
    \        if c == '(' {\n            output = append(output, c)\n        }\n\n\
    \        // If the character is a right paren, remove it from the output\n   \
    \     if c == ')' {\n            output = append(output[:len(output)-1], c)\n\
    \        }\n    }\n\n    // Return the output\n    return output\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg4_8klif_test.go:20:37: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmpg4_8klif_test.go:25:53: cannot use c (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_count := 0\n    for _, character := range paren_string {\n   \
    \     if character == '(' {\n            paren_group_count++\n        } else if\
    \ character == ')' {\n            paren_group_count--\n        } else if paren_group_count\
    \ == 0 {\n            paren_group_string = paren_group_string+character\n    \
    \    } else {\n            paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \            paren_group_string = \"\"\n            paren_group_count = 0\n  \
    \      }\n    }\n    paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoejugnej_test.go:22:34: invalid operation: paren_group_string + character
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   paren_group_open := false\n    paren_group_closed := false\n    paren_group_string\
    \ += paren_string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_group_open\
    \ {\n            if paren_group_closed {\n                paren_group_string +=\
    \ paren_string[i]\n            } else {\n                paren_group_string +=\
    \ paren_string[i]\n                paren_group_open = false\n                paren_group_closed\
    \ = false\n            }\n        } else if paren_group_closed {\n           \
    \ if paren_string[i] == '{' {\n                paren_group_open = true\n     \
    \           paren_group_closed = true\n            } else {\n                paren_group_string\
    \ += paren_string[i]\n            }\n        } else if paren_string[i] == '}'\
    \ {\n            paren_group_open = true\n            paren_group_closed = true\n\
    \        } else {\n            paren_group_string += paren_string[i]\n       \
    \ }\n    }\n    paren_group_strings = append(paren_group_strings, paren_group_string)\n\
    \    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjxh54u_test.go:21:17: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmpxkjxh54u_test.go:23:17: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmpxkjxh54u_test.go:32:17: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    /tmp/tmpxkjxh54u_test.go:38:13: invalid operation: paren_group_string += paren_string[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups := []string{}\n    paren_group :=\
    \ \"\"\n    paren_group_is_open := false\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            if paren_group_is_open {\n        \
    \        fmt.Println(\"paren_group_is_open is true\")\n                fmt.Println(paren_group)\n\
    \                fmt.Println(paren_group_is_open)\n                fmt.Println(paren_group_is_open\
    \ == paren_group)\n                fmt.Println(paren_group_is_open == paren_group\
    \ == \"\")\n                fmt.Println(paren_group_is_open == paren_group ==\
    \ \" \")\n                fmt.Println(paren_group_is_open == paren_group == \"\
    (\")\n                fmt.Println(paren_group_is_open == paren_group == \"{\"\
    )\n                fmt.Println(paren_group_is_open == paren_group == \"[\")\n\
    \                fmt.Println(paren_group_is_open == paren_group == \"}\")\n  \
    \              fmt.Println(paren_group_is_open == paren_group == \"]\")\n    \
    \            fmt.Println(paren_group_is_open == paren_group == \"}\")\n      \
    \          fmt.Println(paren_group_is_open == paren_group == \"]\")\n        \
    \        fmt.Println(paren_group_is_open == paren_group == \")\")\n          \
    \      fmt.Println(paren_group_is_open == paren_group == \")\")\n            \
    \    fmt.Println(paren_group_is_open == paren_group == \")\")\n              \
    \  fmt.Println(paren_group_is_open == paren_group == \")\")\n                fmt.Println(paren_group_is_open\
    \ == paren_group == \")\")\n                fmt.Println(paren_group_is_open ==\
    \ paren_group == \")\")\n                fmt.Println(paren_group_is_open == paren_group\
    \ == \")\")\n                fmt.Println(paren_group_is_open == paren_group ==\
    \ \")\")\n                fmt.Println(paren_group_is_open == paren_group == \"\
    )\")\n                fmt.Println(paren_group_is_open == paren_group == \")\"\
    )\n                fmt.Println(paren_group_is_open == paren_group == \")\")\n\
    \                fmt.Println(paren_group_is_open == paren_group == \")\")\n  \
    \              fmt.Println(paren_group_is_open == paren_group == \")\")\n    \
    \            fmt.Println(paren_group_is_open == paren_group == \")\")\n      \
    \          fmt.Println(paren_group_is_open == paren_group == \")\")\n        \
    \        fmt.Println(paren_group_is_\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ttmx709_test.go:48:44: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups = make([]string, 0)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc082kyk7_test.go:54:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := []string{}\n    for _, char := range\
    \ paren_string {\n        if char == '(' {\n            stack = append(stack,\
    \ char)\n        } else if char == ')' {\n            if len(stack) == 0 {\n \
    \               fmt.Println(\"Stack is empty\")\n                return nil\n\
    \            }\n            stack = stack[:len(stack)-1]\n            result :=\
    \ append(result, string(stack))\n        } else {\n            stack = append(stack,\
    \ char)\n        }\n    }\n    if len(stack) != 0 {\n        fmt.Println(\"Stack\
    \ is not empty\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc7z9dhsg_test.go:17:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpc7z9dhsg_test.go:24:13: result declared but not used

    /tmp/tmpc7z9dhsg_test.go:24:45: cannot convert stack (variable of type []string)
    to type string

    /tmp/tmpc7z9dhsg_test.go:26:35: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups = make([]string, 0)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc082kyk7_test.go:54:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := make([]string, 0)\n    stack := make([]string, 0)\n    stack\
    \ = append(stack, paren_string)\n    for len(stack) > 0 {\n        length := len(stack)\n\
    \        result := append(result, stack[0:length]...)\n        stack = stack[length:]\n\
    \    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprlkq4tn8_test.go:18:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        n := len(stack)\n        result\
    \ := make([]string, 0, n)\n        for i := 0; i < n; i++ {\n            s :=\
    \ stack[i]\n            stack = stack[i+1:]\n            if s == \"\" {\n    \
    \            continue\n            }\n            if s[0] == '(' {\n         \
    \       stack = append(stack, s[1:])\n                continue\n            }\n\
    \            if s[0] == '{' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == '[' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '<' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == '>' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '.' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == ',' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '/' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == '>' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '<' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == '{' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '[' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == '<' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '.' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == ',' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '/' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == '>' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '<' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == '{' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '[' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == '<' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if s[0] == '.' {\n                stack = append(stack, s[1:])\n\
    \                continue\n            }\n            if s[0] == ',' {\n     \
    \           stack = append(stack, s[1:])\n                continue\n         \
    \   }\n            if \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpctsov0xx_test.go:118:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    stack := append(stack,\
    \ paren_string)\n    depth := 0\n    for len(stack) > 0 {\n        depth += 1\n\
    \        stack := stack[:0]\n        for _, s := range stack {\n            stack\
    \ = append(stack, s)\n            i := strings.IndexRune(s, '(')\n           \
    \ if i < 0 {\n                stack = append(stack, s)\n                continue\n\
    \            }\n            j := strings.IndexRune(s, ')')\n            if j <\
    \ 0 {\n                stack = append(stack, s)\n                continue\n  \
    \          }\n            stack = append(stack[:i], stack[i+1:j])\n          \
    \  stack = append(stack[:j], s[i+1:])\n        }\n        result := append(result,\
    \ strings.Join(stack, \"(\"))\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4z028cen_test.go:15:11: no new variables on left side of :=

    /tmp/tmp4z028cen_test.go:22:18: undefined: strings

    /tmp/tmp4z028cen_test.go:27:18: undefined: strings

    /tmp/tmp4z028cen_test.go:32:44: cannot use stack[i + 1:j] (value of type []string)
    as type string in argument to append

    /tmp/tmp4z028cen_test.go:35:9: result declared but not used

    /tmp/tmp4z028cen_test.go:35:34: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stacks = append(stacks,\
    \ []string{paren_string})\n    depth := 0\n    open_braces := 0\n    close_braces\
    \ := 0\n    for _, stack := range stacks {\n        depth += 1 // Increase the\
    \ depth of the stack by 1\n        for _, element := range stack {\n         \
    \   if element == \"{\" {\n                open_braces += 1\n            } else\
    \ if element == \"}\" {\n                close_braces += 1\n            } else\
    \ if element == \" \" {\n                // Ignore spaces in the stack\n     \
    \       } else {\n                // This element is a nested group\n        \
    \        if open_braces == close_braces {\n                    // This group is\
    \ balanced\n                    result = append(result, element)\n           \
    \     } else {\n                    // This group is unbalanced\n            \
    \        stacks = append(stacks[:depth], stacks[depth+1:]...)\n              \
    \      stacks = append(stacks, []string{element})\n                    depth -=\
    \ 1 // Decrease the depth of the stack by 1\n                }\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp8eg22uvx_test.go:61: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074171
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to hold all the separate groups\n    separate_groups\
    \ := make([]string, 0)\n\n    // Iterate over all the characters in the input\
    \ string\n    for _, c := range paren_string {\n        // If this character is\
    \ a left paren, add it to the list of separate groups\n        if c == '(' {\n\
    \            separate_groups = append(separate_groups, \"\")\n        }\n\n  \
    \      // If this character is a right paren, remove the last element of the list\
    \ of separate groups\n        if c == ')' {\n            separate_groups = separate_groups[:len(separate_groups)-1]\n\
    \        }\n\n        // If this character is a space, ignore it\n        if c\
    \ == ' ' {\n            continue\n        }\n\n        // If this character is\
    \ not a left paren, add it to the last element of the list of separate groups\n\
    \        if c != ')' {\n            separate_groups[len(separate_groups)-1] +=\
    \ string(c)\n        }\n    }\n\n    // Return the list of separate groups\n \
    \   return separate_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpjwc8esuy_test.go:59: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpjwc8esuy_test.go:59: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpjwc8esuy_test.go:59:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpjwc8esuy_test.go:59: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074171
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code goes here\n    result := []string{}\n    stack := []string{}\n\
    \    stack := append(stack, paren_string)\n    for len(stack) > 0 {\n        s\
    \ := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if s ==\
    \ \"\" {\n            continue\n        }\n        if s[0] == '(' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == ')' {\n            stack = append(stack[:len(stack)-1], s[1:])\n   \
    \         continue\n        }\n        if s[0] == ',' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == ' ' {\n        \
    \    continue\n        }\n        if s[0] == '{' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == '}' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '[' {\n            stack = append(stack, s[1:])\n  \
    \          continue\n        }\n        if s[0] == ']' {\n            stack =\
    \ append(stack[:len(stack)-1], s[1:])\n            continue\n        }\n     \
    \   if s[0] == '<' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '>' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '/' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '\\\\' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '\\'' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '\"' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '\\t' {\n            stack = append(stack, s[1:])\n            continue\n  \
    \      }\n        if s[0] == '\\n' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '\\r' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ ' ' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '\\t' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '\\n' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '\\r' {\n            stack = append(stack, s[1:])\n            continue\n  \
    \      }\n        if s[0] == '\\'' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '\"' {\n            stack\
    \ = append(stack, \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpry2ral_g_test.go:112:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    var open_braces int\n    var close_braces int\n\
    \    var open_parens int\n    var close_parens int\n    var open_brace bool\n\
    \    var close_brace bool\n    var open_paren bool\n    var close_paren bool\n\
    \    var open_brace_string string\n    var close_brace_string string\n    var\
    \ open_paren_string string\n    var close_paren_string string\n    var open_brace_count\
    \ int\n    var close_brace_count int\n    var open_paren_count int\n    var close_paren_count\
    \ int\n    var open_brace_string bool\n    var close_brace_string bool\n    var\
    \ open_paren_string bool\n    var close_paren_string bool\n    var open_brace_count\
    \ int\n    var close_brace_count int\n    var open_paren_count int\n    var close_paren_count\
    \ int\n    var open_brace_string bool\n    var close_brace_string bool\n    var\
    \ open_paren_string bool\n    var close_paren_string bool\n    var open_brace_count\
    \ int\n    var close_brace_count int\n    var open_paren_count int\n    var close_paren_count\
    \ int\n    var open_brace_string bool\n    var close_brace_string bool\n    var\
    \ open_paren_string bool\n    var close_paren_string bool\n    var open_brace_count\
    \ int\n    var close_brace_count int\n    var open_paren_count int\n    var close_paren_count\
    \ int\n    var open_brace_string bool\n    var close_brace_string bool\n    var\
    \ open_paren_string bool\n    var close_paren_string bool\n    var open_brace_count\
    \ int\n    var close_brace_count int\n    var open_paren_count int\n    var close_paren_count\
    \ int\n    var open_brace_string bool\n    var close_brace_string bool\n    var\
    \ open_paren_string bool\n    var close_paren_string bool\n    var open_brace_count\
    \ int\n    var close_brace_count int\n    var open_paren_count int\n    var close_paren_count\
    \ int\n    var open_brace_string bool\n    var close_brace_string bool\n    var\
    \ open_paren_string bool\n    var close_paren_string bool\n    var open_brace_count\
    \ int\n    var close_brace_count int\n    var open_paren_count int\n    var close_paren_count\
    \ int\n    var open_brace_string bool\n    var close_brace_string bool\n    var\
    \ open_paren_string bool\n    var close_paren_string bool\n    var open_brace_\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpstxjjwb__test.go:82:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to hold the groups of parentheses\n    result :=\
    \ make([]string, 0)\n\n    // Iterate through each character in the input string\n\
    \    for _, char := range paren_string {\n        // If the character is a left\
    \ paren, add it to the list\n        if char == '(' {\n            result = append(result,\
    \ char)\n        }\n\n        // If the character is a right paren, remove it\
    \ from the list\n        if char == ')' {\n            result = removeElement(result,\
    \ char)\n        }\n    }\n\n    // Return the list of parentheses\n    return\
    \ result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpymdq_z56_test.go:20:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpymdq_z56_test.go:25:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    open_braces :=\
    \ 0\n    close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n\
    \    brace_close_braces := 0\n    brace_open_braces_count := 0\n    brace_close_braces_count\
    \ := 0\n    brace_open_braces_count := 0\n    brace_close_braces_count := 0\n\
    \    brace_open_braces_count := 0\n    brace_close_braces_count := 0\n    brace_open_braces_count\
    \ := 0\n    brace_close_braces_count := 0\n    brace_open_braces_count := 0\n\
    \    brace_close_braces_count := 0\n    brace_open_braces_count := 0\n    brace_close_braces_count\
    \ := 0\n    brace_open_braces_count := 0\n    brace_close_braces_count := 0\n\
    \    brace_open_braces_count := 0\n    brace_close_braces_count := 0\n    brace_open_braces_count\
    \ := 0\n    brace_close_braces_count := 0\n    brace_open_braces_count := 0\n\
    \    brace_close_braces_count := 0\n    brace_open_braces_count := 0\n    brace_close_braces_count\
    \ := 0\n    brace_open_braces_count := 0\n    brace_close_braces_count := 0\n\
    \    brace_open_braces_count := 0\n    brace_close_braces_count := 0\n    brace_open_braces_count\
    \ := 0\n    brace_close_braces_count := 0\n    brace_open_braces_count := 0\n\
    \    brace_close_braces_count := 0\n    brace_open_braces_count := 0\n    brace_close_braces_count\
    \ := 0\n    brace_open_braces_count := 0\n    brace_close_braces_count := 0\n\
    \    brace_open_braces_count := 0\n    brace_close_braces_count := 0\n    brace_open_braces_count\
    \ := 0\n    brace_close_braces_count := 0\n    brace_open_braces_count := 0\n\
    \    brace_close_braces_count := 0\n    brace_open_braces_count := 0\n    bra\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpczoupsvq_test.go:62:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stacks = append(stacks,\
    \ []string{paren_string})\n    for len(stacks) > 0 {\n        stack := stacks[len(stacks)-1]\n\
    \        stacks = stacks[:len(stacks)-1]\n        result := append(result, stack[len(stack)-1])\n\
    \        for _, s := range stack {\n            stacks = append(stacks, []string{s})\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9igr0qu7_test.go:19:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_string := \"\"\n \
    \   brace_count := 0\n    brace_type := 0\n    brace_type := 0\n    for _, character\
    \ := range paren_string {\n        if character == \"{\" {\n            brace_type\
    \ = 1\n        }\n        if character == \"}\" {\n            brace_type = 0\n\
    \        }\n        if brace_type == 1 {\n            brace_count++\n        \
    \    if brace_count == 1 {\n                paren_group_string += character\n\
    \            } else {\n                paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n                paren_group_string = character\n      \
    \      }\n        }\n    }\n    paren_group_strings = append(paren_group_strings,\
    \ paren_group_string)\n    return paren_group_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr5s3fz8b_test.go:17:16: no new variables on left side of :=

    /tmp/tmpr5s3fz8b_test.go:19:25: invalid operation: character == "{" (mismatched
    types rune and untyped string)

    /tmp/tmpr5s3fz8b_test.go:22:25: invalid operation: character == "}" (mismatched
    types rune and untyped string)

    /tmp/tmpr5s3fz8b_test.go:28:17: invalid operation: paren_group_string += character
    (mismatched types string and rune)

    /tmp/tmpr5s3fz8b_test.go:31:38: cannot use character (variable of type rune) as
    type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a stack to keep track of which parenthesis are currently\
    \ open.\n    stack := make([]bool, len(paren_string))\n    // Initialize a result\
    \ list to hold the result\n    result := make([]string, 0)\n    // Iterate over\
    \ each character in the input string\n    for _, c := range paren_string {\n \
    \       // If the character is a left parenthesis, push it to the stack\n    \
    \    if c == '(' {\n            stack = append(stack, true)\n        // If the\
    \ character is a right parenthesis, pop it from the stack\n        } else if c\
    \ == ')' {\n            stack = stack[:len(stack)-1]\n        }\n        // If\
    \ the stack is empty, that means we have reached the end of the parenthesis group\n\
    \        // and we can append the character to the result list\n        if len(stack)\
    \ == 0 {\n            result = append(result, c)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpywi3ajip_test.go:29:37: cannot use c (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    var open_braces int\n    var close_braces int\n\
    \    var open_parens int\n    var close_parens int\n    var brace_count int\n\
    \    var paren_count int\n    var brace_count int\n    var paren_count int\n \
    \   var brace_count int\n    var paren_count int\n    var brace_count int\n  \
    \  var paren_count int\n    var brace_count int\n    var paren_count int\n   \
    \ var brace_count int\n    var paren_count int\n    var brace_count int\n    var\
    \ paren_count int\n    var brace_count int\n    var paren_count int\n    var brace_count\
    \ int\n    var paren_count int\n    var brace_count int\n    var paren_count int\n\
    \    var brace_count int\n    var paren_count int\n    var brace_count int\n \
    \   var paren_count int\n    var brace_count int\n    var paren_count int\n  \
    \  var brace_count int\n    var paren_count int\n    var brace_count int\n   \
    \ var paren_count int\n    var brace_count int\n    var paren_count int\n    var\
    \ brace_count int\n    var paren_count int\n    var brace_count int\n    var paren_count\
    \ int\n    var brace_count int\n    var paren_count int\n    var brace_count int\n\
    \    var paren_count int\n    var brace_count int\n    var paren_count int\n \
    \   var brace_count int\n    var paren_count int\n    var brace_count int\n  \
    \  var paren_count int\n    var brace_count int\n    var paren_count int\n   \
    \ var brace_count int\n    var paren_count int\n    var brace_count int\n    var\
    \ paren_count int\n    var brace_count int\n    var paren_count int\n    var brace_count\
    \ int\n    var paren_count int\n    var brace_count int\n    var paren_count int\n\
    \    var brace_count int\n    var paren_count int\n    var brace_count int\n \
    \   var paren_count int\n    var brace_count int\n    var paren_count int\n  \
    \  var brace_count int\n    var paren_count int\n    var brace_count int\n   \
    \ var paren_count int\n    var brace_count int\n    var paren_count int\n    var\
    \ brace_count int\n    var paren_count int\n    var brace_count int\n    var paren_count\
    \ int\n    var brace_count int\n    var paren_count int\n    var brace_count int\n\
    \    var paren_count int\n    var brace_count int\n    var paren_count int\n \
    \   var \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjw5eek7x_test.go:99:1: expected ''IDENT'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074171
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        s := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if s == \"\" {\n            continue\n\
    \        }\n        if s[0] == '(' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == ')' {\n            stack\
    \ = stack[:len(stack)-1]\n            continue\n        }\n        if s[0] ==\
    \ ' ' {\n            continue\n        }\n        if s[0] == '[' {\n         \
    \   stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == ']' {\n            stack = stack[:len(stack)-1]\n            continue\n\
    \        }\n        if s[0] == '{' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '}' {\n            stack\
    \ = stack[:len(stack)-1]\n            continue\n        }\n        if s[0] ==\
    \ '<' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '>' {\n            stack = stack[:len(stack)-1]\n \
    \           continue\n        }\n        if s[0] == '/' {\n            stack =\
    \ append(stack, s[1:])\n            continue\n        }\n        if s[0] == '\\\
    \\' {\n            stack = append(stack, s[1:])\n            continue\n      \
    \  }\n        if s[0] == '|' {\n            stack = append(stack, s[1:])\n   \
    \         continue\n        }\n        if s[0] == '!' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == '%' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '+' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '-' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '*' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '?' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '^' {\n            stack = append(stack, s[1:])\n \
    \           continue\n        }\n        if s[0] == '&' {\n            stack =\
    \ append(stack, s[1:])\n            continue\n        }\n        if s[0] == '|'\
    \ {\n            stack = append(stack, s[1:])\n            continue\n        }\n\
    \        if s[0] == '=' {\n            stack = append(stack, s[1:])\n        \
    \    continue\n        }\n        if s[0] == '>' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == '<' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1l9rvi2y_test.go:117:20: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074171
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a slice to hold the result\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, c := range\
    \ paren_string {\n        // If the character is a left paren, add it to the result\n\
    \        if c == '(' {\n            result = append(result, c)\n        }\n\n\
    \        // If the character is a right paren, remove it from the result\n   \
    \     if c == ')' {\n            result = remove(c, result)\n        }\n    }\n\
    \n    // Return the result\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmmbwf903_test.go:20:37: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmpmmbwf903_test.go:25:22: undefined: remove

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups = make([]string, 0)\n    paren_stack\
    \ = make([]int, 0)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    paren_stack = append(paren_stack, -1)\n    paren_stack\
    \ = append(paren_stack, -1)\n    \nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps9czwg_w_test.go:61:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074171
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    index := 0\n    for len(stack) > 0 {\n        index += 1\n\
    \        current := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\
    \        if current == \")\" {\n            stack = append(stack[:len(stack)-1],\
    \ \"\")\n            result := append(result, current)\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4zs2u8fo_test.go:15:11: no new variables on left side of :=

    /tmp/tmp4zs2u8fo_test.go:23:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph8xfnb8h_test.go:53:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074171
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups = make([]string, 0)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc082kyk7_test.go:54:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_count_stack := []int{}\n\
    \    brace_count_stack = append(brace_count_stack, 0)\n    for _, char := range\
    \ paren_string {\n        if char == '(' {\n            open_braces++\n      \
    \      brace_count_stack = append(brace_count_stack, open_braces)\n          \
    \  stack = append(stack, char)\n        } else if char == ')' {\n            close_braces++\n\
    \            brace_count_stack = append(brace_count_stack, close_braces)\n   \
    \         open_braces = brace_count_stack[len(brace_count_stack)-1]\n        \
    \    stack = stack[:len(stack)-1]\n        } else if char == ' ' {\n         \
    \   open_braces = 0\n            close_braces = 0\n            brace_count = 0\n\
    \            stack = []string{}\n        } else {\n            brace_count++\n\
    \        }\n    }\n    for _, char := range paren_string {\n        if char ==\
    \ ')' {\n            close_braces--\n            brace_count_stack = append(brace_count_stack,\
    \ close_braces)\n            open_braces = brace_count_stack[len(brace_count_stack)-1]\n\
    \            stack = stack[:len(stack)-1]\n        } else if char == ' ' {\n \
    \           open_braces = 0\n            close_braces = 0\n            brace_count\
    \ = 0\n            stack = []string{}\n        } else {\n            brace_count++\n\
    \        }\n    }\n    for _, char := range paren_string {\n        if char ==\
    \ ')' {\n            close_braces--\n            brace_count_stack = append(brace_count_stack,\
    \ close_braces)\n            open_braces = brace_count_stack[len(brace_count_stack)-1]\n\
    \            stack = stack[:len(stack)-1]\n        } else if char == ' ' {\n \
    \           open_braces = 0\n            close_braces = 0\n            brace_count\
    \ = 0\n            stack = []string{}\n        } else {\n            brace_count++\n\
    \        }\n    }\n    for _, char := range paren_string {\n        if char ==\
    \ ')' {\n            close_braces--\n            brace_count_stack = append(brace_count_stack,\
    \ close_braces)\n            open_braces = brace_count_stack[len(brace_count_stack)-1]\n\
    \            stack = stack[:len(stack)-1]\n        } else if char == ' ' {\n \
    \           open_braces = 0\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbw1mh9zb_test.go:77:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074171
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to store our results\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, character\
    \ := range paren_string {\n        // If the character is a left paren, add it\
    \ to the list\n        if character == '(' {\n            result = append(result,\
    \ character)\n        }\n\n        // If the character is a right paren, remove\
    \ it from the list\n        if character == ')' {\n            result = removeElement(result,\
    \ character)\n        }\n    }\n\n    // Return the list of results\n    return\
    \ result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0yall_8i_test.go:20:37: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmp0yall_8i_test.go:25:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvhekki28_test.go:87:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stacks := make(map[string]bool)\n    stack :=\
    \ make([]string, 0)\n    stacks[string(stack)] = true\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        paren_string := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if paren_string == \"\" {\n   \
    \         continue\n        }\n        if paren_string[len(paren_string)-1] ==\
    \ '{' {\n            stack = append(stack, paren_string[:len(paren_string)-1])\n\
    \            stacks[string(stack)] = true\n        }\n        if paren_string[len(paren_string)-1]\
    \ == '}' {\n            stack = append(stack, paren_string[:len(paren_string)-1])\n\
    \            if stacks[string(stack)] {\n                stacks[string(stack)]\
    \ = false\n            }\n        }\n    }\n    for _, stack := range stacks {\n\
    \        result = append(result, string(stack))\n    }\n    return result\n}\n\
    \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsgqd0bz__test.go:16:19: cannot convert stack (variable of type []string)
    to type string

    /tmp/tmpsgqd0bz__test.go:17:11: no new variables on left side of :=

    /tmp/tmpsgqd0bz__test.go:26:27: cannot convert stack (variable of type []string)
    to type string

    /tmp/tmpsgqd0bz__test.go:30:30: cannot convert stack (variable of type []string)
    to type string

    /tmp/tmpsgqd0bz__test.go:31:31: cannot convert stack (variable of type []string)
    to type string

    /tmp/tmpsgqd0bz__test.go:36:40: cannot convert stack (variable of type bool) to
    type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    stack := append(stack, paren_string)\n    for len(stack) > 0 {\n        index\
    \ := len(stack) - 1\n        result := append(result, stack[index])\n        stack\
    \ = stack[:index]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp8yj2ep0_test.go:16:11: no new variables on left side of :=

    /tmp/tmpp8yj2ep0_test.go:19:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_string = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups\
    \ = append(paren_groups, paren_string)\n    }\n    return paren_groups\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6wga2h7_test.go:13:5: undefined: paren_groups

    /tmp/tmpf6wga2h7_test.go:14:5: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:15:26: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:16:27: undefined: paren_groups

    /tmp/tmpf6wga2h7_test.go:17:13: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:18:24: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:19:23: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:20:31: undefined: paren_groups

    /tmp/tmpf6wga2h7_test.go:22:12: undefined: paren_groups

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    open_braces :=\
    \ 0\n    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpprrlo90o_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups = make([]string, 0)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc082kyk7_test.go:54:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]int, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        index := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        switch {\n        case index ==\
    \ '(':\n            stack = append(stack, ')')\n        case index == ')':\n \
    \           stack = append(stack, '(')\n        case index == ' ':\n         \
    \   continue\n        default:\n            result = append(result, index)\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnkm3sks__test.go:15:11: no new variables on left side of :=

    /tmp/tmpnkm3sks__test.go:15:28: cannot use paren_string (variable of type string)
    as type int in argument to append

    /tmp/tmpnkm3sks__test.go:27:37: cannot use index (variable of type int) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    for len(paren_stack)\
    \ > 0 {\n        paren_groups = append(paren_groups, paren_stack[len(paren_stack)-1])\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return paren_groups\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgan6p9q0_test.go:13:5: undefined: paren_groups

    /tmp/tmpgan6p9q0_test.go:14:5: undefined: paren_stack

    /tmp/tmpgan6p9q0_test.go:15:26: undefined: paren_stack

    /tmp/tmpgan6p9q0_test.go:16:13: undefined: paren_stack

    /tmp/tmpgan6p9q0_test.go:17:9: undefined: paren_groups

    /tmp/tmpgan6p9q0_test.go:17:31: undefined: paren_groups

    /tmp/tmpgan6p9q0_test.go:17:45: undefined: paren_stack

    /tmp/tmpgan6p9q0_test.go:18:23: undefined: paren_stack

    /tmp/tmpgan6p9q0_test.go:20:12: undefined: paren_groups

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_string = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups\
    \ = append(paren_groups, paren_string)\n        paren_stack = append(paren_stack,\
    \ paren_string)\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo279rpom_test.go:13:5: undefined: paren_groups

    /tmp/tmpo279rpom_test.go:14:5: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:15:26: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:16:27: undefined: paren_groups

    /tmp/tmpo279rpom_test.go:17:13: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:18:24: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:19:23: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:20:31: undefined: paren_groups

    /tmp/tmpo279rpom_test.go:21:30: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:23:12: undefined: paren_groups

    /tmp/tmpo279rpom_test.go:23:12: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_str = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups\
    \ = append(paren_groups, paren_str)\n        paren_group_str = paren_str\n   \
    \     paren_str = paren_str[:len(paren_str)-1]\n        paren_str = paren_str[:len(paren_str)-1]\n\
    \        paren_groups = append(paren_groups, paren_str)\n        for len(paren_str)\
    \ > 0 {\n            if paren_str[0] == '(' {\n                paren_stack = append(paren_stack,\
    \ paren_str[:len(paren_str)-1])\n                paren_str = paren_str[len(paren_str)-1:]\n\
    \            } else {\n                paren_str = paren_str[:len(paren_str)-1]\n\
    \            }\n        }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3w0utmmm_test.go:13:5: undefined: paren_groups

    /tmp/tmp3w0utmmm_test.go:14:5: undefined: paren_stack

    /tmp/tmp3w0utmmm_test.go:15:26: undefined: paren_stack

    /tmp/tmp3w0utmmm_test.go:16:27: undefined: paren_groups

    /tmp/tmp3w0utmmm_test.go:17:13: undefined: paren_stack

    /tmp/tmp3w0utmmm_test.go:18:9: undefined: paren_str

    /tmp/tmp3w0utmmm_test.go:18:21: undefined: paren_stack

    /tmp/tmp3w0utmmm_test.go:19:23: undefined: paren_stack

    /tmp/tmp3w0utmmm_test.go:20:31: undefined: paren_groups

    /tmp/tmp3w0utmmm_test.go:20:45: undefined: paren_str

    /tmp/tmp3w0utmmm_test.go:20:45: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph8xfnb8h_test.go:53:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074171
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    open_brace := false\n    close_brace\
    \ := false\n    brace_count := 0\n    for _, char := range paren_string {\n  \
    \      if char == '(' {\n            if open_braces == 0 {\n                open_braces\
    \ = brace_count\n                open_brace = true\n            }\n          \
    \  stack = append(stack, char)\n            brace_count++\n        } else if char\
    \ == ')' {\n            if close_braces == 0 {\n                close_braces =\
    \ brace_count\n                close_brace = true\n            }\n           \
    \ brace_count--\n            if brace_count == 0 {\n                if close_brace\
    \ {\n                    close_brace = false\n                    close_braces\
    \ = brace_count\n                }\n                if open_brace {\n        \
    \            open_brace = false\n                    open_braces = brace_count\n\
    \                }\n                stack = stack[:len(stack)-1]\n           \
    \     stack = append(stack, char)\n            }\n        } else if char == '\
    \ ' {\n            if open_brace {\n                open_brace = false\n     \
    \           open_braces = brace_count\n            }\n            if close_brace\
    \ {\n                close_brace = false\n                close_braces = brace_count\n\
    \            }\n        }\n    }\n    for _, char := range stack {\n        result\
    \ = append(result, char)\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3w4dx7v2_test.go:27:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp3w4dx7v2_test.go:45:39: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        current := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        switch current {\n        case\
    \ \"(\":\n            stack = append(stack, \")\")\n        case \"[\":\n    \
    \        stack = append(stack, \"]\")\n        case \"{\":\n            stack\
    \ = append(stack, \"}\")\n        default:\n            result = append(result,\
    \ current)\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0g_a0260_test.go:15:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxzsa1ov__test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    stack := append(stack, paren_string)\n    for len(stack) > 0 {\n        s\
    \ := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if s ==\
    \ \"\" {\n            continue\n        }\n        if s[0] == '(' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == ')' {\n            stack = append(stack[:len(stack)-1], s[1:])\n   \
    \         continue\n        }\n        if s[0] == ' ' {\n            continue\n\
    \        }\n        if s[0] == '{' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '}' {\n            stack\
    \ = append(stack[:len(stack)-1], s[1:])\n            continue\n        }\n   \
    \     if s[0] == '[' {\n            stack = append(stack, s[1:])\n           \
    \ continue\n        }\n        if s[0] == ']' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '<' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '>' {\n            stack = append(stack[:len(stack)-1], s[1:])\n   \
    \         continue\n        }\n        if s[0] == '/' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == '*' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '+' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '-' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '.' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '|' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '&' {\n            stack = append(stack, s[1:])\n \
    \           continue\n        }\n        if s[0] == '!' {\n            stack =\
    \ append(stack, s[1:])\n            continue\n        }\n        if s[0] == '%'\
    \ {\n            stack = append(stack, s[1:])\n            continue\n        }\n\
    \        if s[0] == '^' {\n            stack = append(stack, s[1:])\n        \
    \    continue\n        }\n        if s[0] == '~' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == '=' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '|' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '&' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8fagh9ix_test.go:115:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          open_braces++\n            stack = append(stack, char)\n        } else\
    \ if char == ')' {\n            close_braces++\n            if open_braces ==\
    \ close_braces {\n                brace_count++\n                if brace_count\
    \ == 1 {\n                    result = append(result, string(stack))\n       \
    \         } else {\n                    result = append(result, string(stack[:len(stack)-1]))\n\
    \                }\n                stack = stack[:len(stack)-1]\n           \
    \ }\n        } else if char == ' ' {\n            stack = append(stack, char)\n\
    \        }\n    }\n    if open_braces != close_braces {\n        fmt.Println(\"\
    Mismatched parentheses\")\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1x_rs62x_test.go:19:5: brace_type declared but not used

    /tmp/tmp1x_rs62x_test.go:23:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp1x_rs62x_test.go:29:52: cannot convert stack (variable of type []string)
    to type string

    /tmp/tmp1x_rs62x_test.go:31:57: cannot convert stack[:len(stack) - 1] (value of
    type []string) to type string

    /tmp/tmp1x_rs62x_test.go:36:35: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a slice to hold the resulting strings\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, c := range\
    \ paren_string {\n        // If the character is a left paren, add it to the result\n\
    \        if c == '(' {\n            result = append(result, c)\n        }\n\n\
    \        // If the character is a right paren, remove it from the result\n   \
    \     if c == ')' {\n            result = removeElement(result, c)\n        }\n\
    \    }\n\n    // Return the resulting string\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0rg4yk2b_test.go:20:37: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmp0rg4yk2b_test.go:25:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        current := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        switch current {\n        case\
    \ \"(\":\n            stack = append(stack, \")\")\n        case \"[\":\n    \
    \        stack = append(stack, \"]\")\n        case \"{\":\n            stack\
    \ = append(stack, \"}\")\n        default:\n            result = append(result,\
    \ current)\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp842ncn43_test.go:15:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_count_in_stack := 0\n\
    \    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := \nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpub0afxlk_test.go:71:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stacks = append(stacks,\
    \ []string{paren_string})\n    depth := 0\n    for _, stack := range stacks {\n\
    \        depth += 1 // Increment depth by one for each new stack\n        for\
    \ _, s := range stack {\n            if s == ')' {\n                depth -= 1\
    \ // Decrement depth by one for each closing brace\n                if depth ==\
    \ 0 {\n                    result = append(result, stack[:len(stack)-1])\n   \
    \             }\n            }\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkqrgp595_test.go:20:21: invalid operation: s == '')'' (mismatched types
    string and untyped rune)

    /tmp/tmpkqrgp595_test.go:23:50: cannot use stack[:len(stack) - 1] (value of type
    []string) as type string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        n := len(stack)\n        result\
    \ := make([]string, 0, n+1)\n        for i := 0; i < n; i++ {\n            s :=\
    \ stack[i]\n            if s[i] == '(' {\n                stack = append(stack[:i],\
    \ s[i+1:]...)\n                result := append(result, s)\n            } else\
    \ if s[i] == ')' {\n                stack = append(stack[:i], s[:i+1]...)\n  \
    \          }\n        }\n        if len(result) == n {\n            break\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkb2dqpj6_test.go:15:11: no new variables on left side of :=

    /tmp/tmpkb2dqpj6_test.go:22:44: cannot use s[i + 1:] (value of type string) as
    type []string in argument to append

    /tmp/tmpkb2dqpj6_test.go:23:17: result declared but not used

    /tmp/tmpkb2dqpj6_test.go:25:44: cannot use s[:i + 1] (value of type string) as
    type []string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxzsa1ov__test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a slice to store the result\n    result := make([]string,\
    \ 0)\n\n    // Iterate through each character in the input string\n    for _,\
    \ c := range paren_string {\n        // If the character is a left paren, push\
    \ it into the result slice\n        if c == '(' {\n            result = append(result,\
    \ c)\n        }\n\n        // If the character is a right paren, pop the last\
    \ element from the result slice\n        if c == ')' {\n            result = result[:len(result)-1]\n\
    \        }\n    }\n\n    // Return the result slice\n    return result\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4hqi87h4_test.go:20:37: cannot use c (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    brace_count := 0\n    open_count := 0\n   \
    \ close_count := 0\n    brace_count += count_open_braces(paren_string)\n    open_count\
    \ += count_open_parentheses(paren_string)\n    close_count += count_close_parentheses(paren_string)\n\
    \    if open_count != close_count {\n        fmt.Printf(\"Open count != close\
    \ count. Open count: %d Close count: %d\\n\", open_count, close_count)\n    }\n\
    \    if brace_count != open_count {\n        fmt.Printf(\"Brace count != open\
    \ count. Brace count: %d Open count: %d\\n\", brace_count, open_count)\n    }\n\
    \    if brace_count != 0 {\n        fmt.Printf(\"Brace count != 0. Brace count:\
    \ %d\\n\", brace_count)\n    }\n    if open_count != 0 {\n        fmt.Printf(\"\
    Open count != 0. Open count: %d\\n\", open_count)\n    }\n    if close_count !=\
    \ 0 {\n        fmt.Printf(\"Close count != 0. Close count: %d\\n\", close_count)\n\
    \    }\n    if brace_count != close_count {\n        fmt.Printf(\"Brace count\
    \ != close count. Brace count: %d Close count: %d\\n\", brace_count, close_count)\n\
    \    }\n    if brace_count != open_count {\n        fmt.Printf(\"Brace count !=\
    \ open count. Brace count: %d Open count: %d\\n\", brace_count, open_count)\n\
    \    }\n    if brace_count != 0 {\n        fmt.Printf(\"Brace count != 0. Brace\
    \ count: %d\\n\", brace_count)\n    }\n    if open_count != 0 {\n        fmt.Printf(\"\
    Open count != 0. Open count: %d\\n\", open_count)\n    }\n    if close_count !=\
    \ 0 {\n        fmt.Printf(\"Close count != 0. Close count: %d\\n\", close_count)\n\
    \    }\n    if brace_count != close_count {\n        fmt.Printf(\"Brace count\
    \ != close count. Brace count: %d Close count: %d\\n\", brace_count, close_count)\n\
    \    }\n    if brace_count != open_count {\n        fmt.Printf(\"Brace count !=\
    \ open count. Brace count: %d Open count: %d\\n\", brace_count, open_count)\n\
    \    }\n    if brace_count != 0 {\n        fmt.Printf(\"Brace count != 0. Brace\
    \ count: %d\\n\", brace_count)\n    }\n    if open_count != 0 {\n        fmt.Printf(\"\
    Open count != 0. Open count: %d\\n\", open_count)\n    }\n    if close_count !=\
    \ 0 {\n        fmt.Printf(\"Close count != 0. Close count: %d\\n\", close_count)\n\
    \    }\n    if brace_count != close_count {\n        fmt.\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwan55yls_test.go:67:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    stack := append(stack, paren_string)\n    for len(stack) > 0 {\n        s\
    \ := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if s ==\
    \ \"\" {\n            continue\n        }\n        if s[0] == '(' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == ')' {\n            stack = append(stack[:len(stack)-1], s[1:])\n   \
    \         continue\n        }\n        if s[0] == ' ' {\n            continue\n\
    \        }\n        if s[0] == '{' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '}' {\n            stack\
    \ = append(stack[:len(stack)-1], s[1:])\n            continue\n        }\n   \
    \     if s[0] == '[' {\n            stack = append(stack, s[1:])\n           \
    \ continue\n        }\n        if s[0] == ']' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '<' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '>' {\n            stack = append(stack[:len(stack)-1], s[1:])\n   \
    \         continue\n        }\n        if s[0] == '/' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == '\\\\' {\n     \
    \       stack = append(stack, s[1:])\n            continue\n        }\n      \
    \  if s[0] == '.' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '!' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '?' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '-' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '+' {\n            stack = append(stack, s[1:])\n \
    \           continue\n        }\n        if s[0] == '*' {\n            stack =\
    \ append(stack, s[1:])\n            continue\n        }\n        if s[0] == '|'\
    \ {\n            stack = append(stack, s[1:])\n            continue\n        }\n\
    \        if s[0] == '&' {\n            stack = append(stack, s[1:])\n        \
    \    continue\n        }\n        if s[0] == '^' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == '+' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '=' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '|' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0]\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8qit3vmj_test.go:115:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    open_braces :=\
    \ 0\n    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpprrlo90o_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups = make([]string, 0)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc082kyk7_test.go:54:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stacks := make([][]string, 0)\n    stacks =\
    \ append(stacks, []string{paren_string})\n    for _, stack := range stacks {\n\
    \        result := []string{}\n        for _, item := range stack {\n        \
    \    if item == \"{\" || item == \"}\" {\n                stacks = append(stacks,\
    \ []string{item})\n            } else {\n                stacks = append(stacks,\
    \ []string{item})\n                result := append(result, item)\n          \
    \  }\n        }\n        result = append(result, stack...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = append(result,\
    \ stacks...)\n        result = append(result, stacks...)\n        result = \n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp09q_zff_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var groups []string\n    var open_braces int\n    var close_braces int\n\
    \    var open_parens int\n    var close_parens int\n    var current_group string\n\
    \    var current_group_is_closed bool\n    var current_group_is_open bool\n  \
    \  var current_group_is_open_paren bool\n    var current_group_is_close_paren\
    \ bool\n    var current_group_is_open_paren_or_close bool\n    var current_group_is_close_paren_or_close\
    \ bool\n    var current_group_is_open_paren_or_close_paren bool\n    var current_group_is_close_paren_or_close_paren\
    \ bool\n    var current_group_is_open_paren_or_close_paren_or_close bool\n   \
    \ var current_group_is_close_paren_or_close_paren_or_close bool\n    var current_group_is_open_paren_or_close_paren_or_close_paren\
    \ bool\n    var current_group_is_close_paren_or_close_paren_or_close_paren bool\n\
    \    var current_group_is_open_paren_or_close_paren_or_close_paren_or_close bool\n\
    \    var current_group_is_close_paren_or_close_paren_or_close_paren_or_close bool\n\
    \    var current_group_is_open_paren_or_close_paren_or_close_paren_or_close_paren\
    \ bool\n    var current_group_is_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ bool\n    var current_group_is_open_paren_or_close_paren_or_close_paren_or_close_paren_or_close\
    \ bool\n    var current_group_is_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close\
    \ bool\n    var current_group_is_open_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ bool\n    var current_group_is_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ bool\n    var current_group_is_open_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close\
    \ bool\n    var current_group_is_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close\
    \ bool\n    var current_group_is_open_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ bool\n    var current_group_is_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ bool\n    var current_group_is_open_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ bool\n    var current_group_is_close_paren_or_close_paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzbxzbgy5_test.go:44:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    brace_is_open := false\n    brace_is_open := false\n    brace_is_open\
    \ := false\n    bra\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl5dfktc7_test.go:78:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_string = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups\
    \ = append(paren_groups, paren_string)\n    }\n    return paren_groups\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6wga2h7_test.go:13:5: undefined: paren_groups

    /tmp/tmpf6wga2h7_test.go:14:5: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:15:26: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:16:27: undefined: paren_groups

    /tmp/tmpf6wga2h7_test.go:17:13: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:18:24: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:19:23: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:20:31: undefined: paren_groups

    /tmp/tmpf6wga2h7_test.go:22:12: undefined: paren_groups

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_prz2s3j_test.go:78:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    for _,\
    \ char := range paren_string {\n        if char == '{' {\n            open_braces++\n\
    \            stack = append(stack, char)\n        } else if char == '}' {\n  \
    \          close_braces++\n            if open_braces == close_braces {\n    \
    \            open_braces--\n                close_braces--\n                brace_count--\n\
    \            }\n            stack = stack[:len(stack)-1]\n            if open_braces\
    \ == 0 {\n                result := append(result, string(stack))\n          \
    \      stack = nil\n            }\n        } else if char == ' ' {\n         \
    \   if open_braces == 0 && close_braces == 0 {\n                result := append(result,\
    \ string(stack))\n                stack = nil\n            }\n        }\n    }\n\
    \    if open_braces != close_braces {\n        fmt.Printf(\"%v\\n\", result)\n\
    \    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsrdc8m1r_test.go:22:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpsrdc8m1r_test.go:32:17: result declared but not used

    /tmp/tmpsrdc8m1r_test.go:32:49: cannot convert stack (variable of type []string)
    to type string

    /tmp/tmpsrdc8m1r_test.go:37:17: result declared but not used

    /tmp/tmpsrdc8m1r_test.go:37:49: cannot convert stack (variable of type []string)
    to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_prz2s3j_test.go:78:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_string = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups\
    \ = append(paren_groups, paren_string)\n    }\n    return paren_groups\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6wga2h7_test.go:13:5: undefined: paren_groups

    /tmp/tmpf6wga2h7_test.go:14:5: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:15:26: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:16:27: undefined: paren_groups

    /tmp/tmpf6wga2h7_test.go:17:13: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:18:24: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:19:23: undefined: paren_stack

    /tmp/tmpf6wga2h7_test.go:20:31: undefined: paren_groups

    /tmp/tmpf6wga2h7_test.go:22:12: undefined: paren_groups

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    for _, char := range paren_string\
    \ {\n        if char == '{' {\n            open_braces++\n            stack =\
    \ append(stack, char)\n        } else if char == '}' {\n            close_braces++\n\
    \            if open_braces == close_braces {\n                open_braces = 0\n\
    \                stack = stack[:len(stack)-1]\n                result := append(result,\
    \ string(stack))\n            }\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3nuluq6d_test.go:21:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp3nuluq6d_test.go:27:17: result declared but not used

    /tmp/tmp3nuluq6d_test.go:27:49: cannot convert stack (variable of type []string)
    to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_string := paren_string\n\
    \    paren_string := paren_string\n    paren_string := paren_string\n    paren_string\
    \ := paren_string\n    paren_string := paren_string\n    paren_\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_prz2s3j_test.go:78:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        current := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if current == \"\" {\n        \
    \    result = append(result, current)\n            continue\n        }\n     \
    \   i := strings.Index(current, \")\")\n        if i == -1 {\n            result\
    \ = append(result, current)\n            continue\n        }\n        j := strings.Index(current,\
    \ \")\")\n        result := append(result, current[:i+1])\n        stack = append(stack,\
    \ current[i+2:])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe4ikpani_test.go:15:11: no new variables on left side of :=

    /tmp/tmpe4ikpani_test.go:23:14: undefined: strings

    /tmp/tmpe4ikpani_test.go:28:14: undefined: strings

    /tmp/tmpe4ikpani_test.go:29:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        current := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if current == \"\" {\n        \
    \    continue\n        }\n        if current == \"(\" {\n            stack = append(stack,\
    \ \"\")\n            continue\n        }\n        if current == \")\" {\n    \
    \        stack = stack[:len(stack)-1]\n            continue\n        }\n     \
    \   if current == \"{\" {\n            stack = append(stack, \"\")\n         \
    \   continue\n        }\n        if current == \"}\" {\n            stack = stack[:len(stack)-1]\n\
    \            continue\n        }\n        if current == \"[\" {\n            stack\
    \ = append(stack, \"\")\n            continue\n        }\n        if current ==\
    \ \"]\" {\n            stack = stack[:len(stack)-1]\n            continue\n  \
    \      }\n        if current == \"<\" {\n            stack = append(stack, \"\"\
    )\n            continue\n        }\n        if current == \">\" {\n          \
    \  stack = stack[:len(stack)-1]\n            continue\n        }\n        if current\
    \ == \"+\" {\n            stack = append(stack, \"\")\n            continue\n\
    \        }\n        if current == \"-\" {\n            stack = append(stack, \"\
    \")\n            continue\n        }\n        if current == \"*\" {\n        \
    \    stack = append(stack, \"\")\n            continue\n        }\n        if\
    \ current == \"/\" {\n            stack = append(stack, \"\")\n            continue\n\
    \        }\n        if current == \"%\" {\n            stack = append(stack, \"\
    \")\n            continue\n        }\n        if current == \"=\" { // Ignore\
    \ this one\n            stack = append(stack, \"\")\n            continue\n  \
    \      }\n        if current == \"!\" {\n            stack = append(stack, \"\"\
    )\n            continue\n        }\n        if current == \"?\" {\n          \
    \  stack = append(stack, \"\")\n            continue\n        }\n        if current\
    \ == \"|\" {\n            stack = append(stack, \"\")\n            continue\n\
    \        }\n        if current == \"&\" {\n            stack = append(stack, \"\
    \")\n            continue\n        }\n        if current == \"^\" {\n        \
    \    stack = append(stack, \"\")\n            continue\n        }\n        if\
    \ current == \"~\" {\n            stack = append(stack, \"\")\n            continue\n\
    \        }\n        if current == \"@\" {\n            stack = append(stack, \"\
    \")\n            continue\n        }\n        if current == \"{\" {\n        \
    \    stack = append(stack, \"\")\n            continue\n        }\n        if\
    \ current == \"}\" {\n            stack = append(stack, \"\")\n            continue\n\
    \        }\n        if current == \"[\" {\n            stack = append(stack, \"\
    \")\n            continue\n        }\n        if current == \"]\" {\n        \
    \    stack\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1qhqjxg3_test.go:120:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxzsa1ov__test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := make([]string, 0)\n    stack := make([]string,\
    \ 0)\n    stack = append(stack, paren_string)\n    for len(stack) > 0 {\n    \
    \    s := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if\
    \ s == \"\" {\n            continue\n        }\n        if s[0] == '(' {\n   \
    \         stack = append(stack, s[1:])\n            continue\n        }\n    \
    \    if s[0] == ')' {\n            stack = append(stack[:len(stack)-1], s[1:])\n\
    \            continue\n        }\n        if s[0] == ' ' {\n            continue\n\
    \        }\n        if s[0] == '[' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == ']' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '{' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '}' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '<' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '>' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '/' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '\\\\' {\n     \
    \       stack = append(stack[:len(stack)-1], s[1:])\n            continue\n  \
    \      }\n        if s[0] == '.' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '!' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '~' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '*' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '?' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '|' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\n            continue\n     \
    \   }\n        if s[0] == '+' {\n            stack = append(stack[:len(stack)-1],\
    \ s[1:])\n            continue\n        }\n        if s[0] == '-' {\n        \
    \    stack = append(stack[:len(stack)-1], s[1:])\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmn4xzyj__test.go:96:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize result to an empty array\n    var result []string\n\n \
    \   // Iterate over each character in the input string\n    for _, c := range\
    \ paren_string {\n        // If the character is a left parenthesis, add it to\
    \ the result array\n        if c == '(' {\n            result = append(result,\
    \ c)\n        }\n\n        // If the character is a right parenthesis, remove\
    \ it from the result array\n        if c == ')' {\n            result = removeElement(result,\
    \ c)\n        }\n    }\n\n    // Return the result array\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe3_z9337_test.go:20:37: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmpe3_z9337_test.go:25:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_open := false\n    brace_close\
    \ := false\n    brace_count := 0\n    brace_open := false\n    brace_close :=\
    \ false\n    brace_count := 0\n    brace_open := false\n    brace_close := false\n\
    \    brace_count := 0\n    brace_open := false\n    brace_close := false\n   \
    \ brace_count := 0\n    brace_open := false\n    brace_close := false\n    brace_count\
    \ := 0\n    brace_open := false\n    brace_close := false\n    brace_count :=\
    \ 0\n    brace_open := false\n    brace_close := false\n    brace_count := 0\n\
    \    brace_open := false\n    brace_close := false\n    brace_count := 0\n   \
    \ brace_open := false\n    brace_close := false\n    brace_count := 0\n    brace_open\
    \ := false\n    brace_close := false\n    brace_count := 0\n    brace_open :=\
    \ false\n    brace_close := false\n    brace_count := 0\n    brace_open := false\n\
    \    brace_close := false\n    brace_count := 0\n    brace_open := false\n   \
    \ brace_close := false\n    brace_count := 0\n    brace_open := false\n    brace_close\
    \ := false\n    brace_count := 0\n    brace_open := false\n    brace_close :=\
    \ false\n    brace_count := 0\n    brace_open := false\n    brace_close := false\n\
    \    brace_count := 0\n    brace_open := false\n    brace_close := false\n   \
    \ brace_count := 0\n    brace_open := false\n    brace_close := false\n    brace_count\
    \ := 0\n    brace_open := false\n    brace_close := false\n    brace_count :=\
    \ 0\n    brace_open := false\n    brace_close := false\n    brace_count := 0\n\
    \    brace_open := false\n    brace_close := false\n    brace_count := 0\n   \
    \ brace_open := false\n    brace_close := false\n    brace_count := 0\n    brace_open\
    \ := false\n    brace_close := false\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3bnehz4a_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \" \"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6pk62rv2_test.go:87:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    paren_string += \"{}\"\n    paren_string\
    \ += \"{}\"\n    paren_string += \"{}\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvhekki28_test.go:87:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a stack to store open and closed parenthesis\n    stack\
    \ := make([]int, 0)\n\n    // Initialize a result list to store all groups of\
    \ parenthesis\n    result := make([]string, 0)\n\n    // Iterate over all characters\
    \ in the input string\n    for _, c := range paren_string {\n        // If current\
    \ character is a left parenthesis, push it to the stack\n        if c == '(' {\n\
    \            stack = append(stack, c)\n        }\n\n        // If current character\
    \ is a right parenthesis, pop all open parenthesis from the stack\n        if\
    \ c == ')' {\n            open_brace := stack[len(stack)-1]\n            stack\
    \ = stack[:len(stack)-1]\n\n            // If stack is empty, that means we have\
    \ reached the end of the group of parenthesis\n            if len(stack) == 0\
    \ {\n                // Append the group of parenthesis to the result list\n \
    \               result = append(result, string(open_brace))\n            }\n \
    \       }\n    }\n\n    // Return result list\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn5fy07e1_test.go:23:35: cannot use c (variable of type rune) as type int
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups := []string{}\n    paren_group :=\
    \ \"\"\n    paren_group_is_open := false\n    paren_group_is_closed := false\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   if paren_group_is_open {\n                fmt.Println(\"Error: unexpected\
    \ open paren group\")\n                return nil\n            }\n           \
    \ paren_group_is_open = true\n            paren_group = char\n        } else if\
    \ char == ')' {\n            if paren_group_is_closed {\n                fmt.Println(\"\
    Error: unexpected close paren group\")\n                return nil\n         \
    \   }\n            paren_group_is_closed = true\n            paren_groups = append(paren_groups,\
    \ paren_group)\n            paren_group = char\n        } else {\n           \
    \ paren_group += char\n        }\n    }\n    if paren_group_is_open {\n      \
    \  fmt.Println(\"Error: unexpected open paren group\")\n        return nil\n \
    \   }\n    if paren_group_is_closed {\n        fmt.Println(\"Error: unexpected\
    \ close paren group\")\n        return nil\n    }\n    return paren_groups\n}\n\
    \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphqr9md_h_test.go:25:27: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmphqr9md_h_test.go:33:27: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmphqr9md_h_test.go:35:13: invalid operation: paren_group += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\n   \
    \ brace_count := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\n   \
    \ brace_count := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\n   \
    \ brace_count := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\n   \
    \ brace_count := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\n   \
    \ brace_count := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\n   \
    \ brace_count := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\n   \
    \ brace_count := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\n   \
    \ brace_count := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\n   \
    \ brace_count := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    brace_count := 0\n    brace_count := 0\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxb9i79ur_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps4u9qv10_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups = make([]string, 0)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc082kyk7_test.go:54:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            open_braces++\n\
    \            stack = append(stack, char)\n        } else if char == ')' {\n  \
    \          close_braces++\n            if open_braces == close_braces {\n    \
    \            open_braces--\n                close_braces--\n                brace_count--\n\
    \            }\n            if close_braces == open_braces {\n               \
    \ open_braces--\n                close_braces--\n                brace_count--\n\
    \            }\n            if open_braces == 0 {\n                stack = stack[:len(stack)-1]\n\
    \                stack = append(stack, char)\n                result := append(result,\
    \ string(stack))\n            }\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbkz5mx1__test.go:22:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpbkz5mx1__test.go:37:39: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpbkz5mx1__test.go:38:17: result declared but not used

    /tmp/tmpbkz5mx1__test.go:38:49: cannot convert stack (variable of type []string)
    to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a slice to hold the result\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, char := range\
    \ paren_string {\n        // If the character is a left paren, add it to the result\n\
    \        if char == '(' {\n            result = append(result, char)\n       \
    \ }\n\n        // If the character is a right paren, remove it from the result\n\
    \        if char == ')' {\n            result = remove_brace(result)\n       \
    \ }\n    }\n\n    // Return the result\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc19hxdh8_test.go:20:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpc19hxdh8_test.go:25:22: undefined: remove_brace

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren_groups, paren_string)\n    paren_groups := append(paren_groups,\
    \ paren_string)\n    paren_groups := append(paren_groups, paren_string)\n    paren_groups\
    \ := append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcf0i5hcs_test.go:52:33: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   stack = append(stack, char)\n        } else if char == ')' {\n           \
    \ if len(stack) == 0 {\n                fmt.Println(\"Stack is empty\")\n    \
    \            return nil\n            }\n            result := append(result, stack)\n\
    \            stack = stack[:len(stack)-1]\n        } else {\n            stack\
    \ = append(stack, char)\n        }\n    }\n    if len(stack) > 0 {\n        result\
    \ := append(result, stack)\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3b1ze66n_test.go:18:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp3b1ze66n_test.go:24:13: result declared but not used

    /tmp/tmp3b1ze66n_test.go:24:38: cannot use stack (variable of type []string) as
    type string in argument to append

    /tmp/tmp3b1ze66n_test.go:27:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp3b1ze66n_test.go:31:9: result declared but not used

    /tmp/tmp3b1ze66n_test.go:31:34: cannot use stack (variable of type []string) as
    type string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_open_braces := 0\n   \
    \ brace_close_braces := 0\n    brace_open_braces_count := 0\n    brace_close_braces_count\
    \ := 0\n    brace_open_braces_count_in_stack := 0\n    brace_close_braces_count_in_stack\
    \ := 0\n    brace_open_braces_count_in_result := 0\n    brace_close_braces_count_in_result\
    \ := 0\n    brace_open_braces_count_in_result_in_stack := 0\n    brace_close_braces_count_in_result_in_stack\
    \ := 0\n    brace_open_braces_count_in_result_in_result := 0\n    brace_close_braces_count_in_result_in_result\
    \ := 0\n    brace_open_braces_count_in_result_in_result_in_stack := 0\n    brace_close_braces_count_in_result_in_result_in_stack\
    \ := 0\n    brace_open_braces_count_in_result_in_result_in_result := 0\n    brace_close_braces_count_in_result_in_result_in_result\
    \ := 0\n    brace_open_braces_count_in_result_in_result_in_result_in_stack :=\
    \ 0\n    brace_close_braces_count_in_result_in_result_in_result_in_stack := 0\n\
    \    brace_open_braces_count_in_result_in_result_in_result_in_result := 0\n  \
    \  brace_close_braces_count_in_result_in_result_in_result_in_result := 0\n   \
    \ brace_open_braces_count_in_result_in_result_in_result_in_result_in_stack :=\
    \ 0\n    brace_close_braces_count_in_result_in_result_in_result_in_result_in_stack\
    \ := 0\n    brace_open_braces_count_in_result_in_result_in_result_in_result_in_result\
    \ := 0\n    brace_close_braces_count_in_result_in_result_in_result_in_result_in_result\
    \ := 0\n    brace_open_braces_count_in_result_in_result_in_result_in_result_in_result_in_stack\
    \ := 0\n    brace_close_braces_count_in_result_in_result_in_result_in_result_in_stack\
    \ := 0\n    brace_open_braces_count_in_result_in_result_in_result_in_result_in_result_in_result\
    \ := 0\n    brace_close_braces_count_in_result_in_result_in_result_in_result_in_result_in_result\
    \ := 0\n    brace_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxi6q_5a9_test.go:47:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   stack = append(stack, char)\n        } else if char == ')' {\n           \
    \ if len(stack) == 0 {\n                fmt.Println(\"Stack is empty\")\n    \
    \            return nil\n            }\n            result := append(result, string(stack[len(stack)-1]))\n\
    \            stack = stack[:len(stack)-1]\n        } else {\n            stack\
    \ = append(stack, char)\n        }\n    }\n    if len(stack) > 0 {\n        fmt.Println(\"\
    Stack is empty\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpojm4tqk3_test.go:18:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpojm4tqk3_test.go:24:13: result declared but not used

    /tmp/tmpojm4tqk3_test.go:27:35: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a stack to keep track of which parenthesis are open\n \
    \   stack := make([]int, 0)\n\n    // Initialize a slice to hold the result\n\
    \    result := make([]string, 0)\n\n    // Iterate through each character in the\
    \ string\n    for _, char := range paren_string {\n        // If the character\
    \ is a left parenthesis, push it to the stack\n        if char == '(' {\n    \
    \        stack = append(stack, char)\n        }\n\n        // If the character\
    \ is a right parenthesis, pop it from the stack\n        if char == ')' {\n  \
    \          stack := stack[:len(stack)-1]\n        }\n\n        // If the stack\
    \ is empty, then the parenthesis is unbalanced\n        if len(stack) == 0 {\n\
    \            result = append(result, char)\n        }\n\n        // If the stack\
    \ is not empty, then the parenthesis is balanced\n        if len(stack) != 0 {\n\
    \            // If the stack is empty, then the parenthesis is unbalanced\n  \
    \          if stack[len(stack)-1] != ')' {\n                result = append(result,\
    \ char)\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyyfs1crm_test.go:23:35: cannot use char (variable of type rune) as type
    int in argument to append

    /tmp/tmpyyfs1crm_test.go:28:13: stack declared but not used

    /tmp/tmpyyfs1crm_test.go:33:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpyyfs1crm_test.go:40:41: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a slice to store the result\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, c := range\
    \ paren_string {\n        // If the character is a left paren, add it to the result\n\
    \        if c == '(' {\n            result = append(result, c)\n        }\n  \
    \      // If the character is a right paren, remove it from the result\n     \
    \   if c == ')' {\n            result = removeElement(result, c)\n        }\n\
    \    }\n\n    // Return the result\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptmzgrjml_test.go:20:37: cannot use c (variable of type rune) as type string
    in argument to append

    /tmp/tmptmzgrjml_test.go:24:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]int, 0)\n\
    \    paren_stack = append(paren_stack, -1)\n    paren_stack = append(paren_stack,\
    \ 0)\n\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, \"\")\n\n    for i := 0; i < len(paren_groups); i++ {\n\
    \        paren_stack = append(paren_stack, -1)\n        paren_stack = append(paren_stack,\
    \ 0)\n    }\n\n    paren_stack = append(paren_stack, 0)\n\n    for i := 0; i <\
    \ len(paren_groups); i++ {\n        if paren_stack[len(paren_stack)-1] == -1 &&\
    \ paren_groups[i] != \"\" {\n            paren_stack[len(paren_stack)-1] = i\n\
    \        }\n    }\n\n    paren_stack = append(paren_stack, 0)\n\n    for i :=\
    \ 0; i < len(paren_groups); i++ {\n        if paren_stack[len(paren_stack)-1]\
    \ == i && paren_groups[i] != \"\" {\n            paren_stack[len(paren_stack)-1]\
    \ = i\n        }\n    }\n\n    paren_stack = append(paren_stack, 0)\n\n    for\
    \ i := 0; i < len(paren_groups); i++ {\n        if paren_stack[len(paren_stack)-1]\
    \ == i && paren_groups[i] != \"\" {\n            paren_stack[len(paren_stack)-1]\
    \ = i\n        }\n    }\n\n    paren_stack = append(paren_stack, 0)\n\n    for\
    \ i := 0; i < len(paren_groups); i++ {\n        if paren_stack[len(paren_stack)-1]\
    \ == i && paren_groups[i] != \"\" {\n            paren_stack[len(paren_stack)-1]\
    \ = i\n        }\n    }\n\n    paren_stack = append(paren_stack, 0)\n\n    for\
    \ i := 0; i < len(paren_groups); i++ {\n        if paren_stack[len(paren_stack)-1]\
    \ == i && paren_groups[i] != \"\" {\n            paren_stack[len(paren_stack)-1]\
    \ = i\n        }\n    }\n\n    paren_stack = append(paren_stack, 0)\n\n    for\
    \ i := 0; i < len(paren_groups); i++ {\n        if paren_stack[len(paren_stack)-1]\
    \ == i && paren_groups[i] != \"\" {\n            paren_stack[len(paren_stack)-1]\
    \ = i\n        }\n    }\n\n    paren_stack = append(paren_stack, 0)\n\n    for\
    \ i := 0; i < len(paren_groups); i++ {\n        if paren_stack[len(paren_stack)-1]\
    \ == \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1f_71hdg_test.go:78:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stacks = append(stacks,\
    \ []string{paren_string})\n    for len(stacks) > 0 {\n        stack := stacks[len(stacks)-1]\n\
    \        stacks = stacks[:len(stacks)-1]\n        result := append(result, stack[len(stack)-1])\n\
    \        for _, s := range stack {\n            stacks = append(stacks, []string{s})\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9igr0qu7_test.go:19:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n \
    \   brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type\
    \ := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\
    \"\n    brace_type := \"\"\n    brace_type := \"\"\n    brace_type := \"\"\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps4u9qv10_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a stack to keep track of which parenthesis we are currently\
    \ in\n    stack := make([]string, 0)\n\n    // Initialize a result list to hold\
    \ the separate groups\n    result := make([]string, 0)\n\n    // Iterate over\
    \ each character in the input string\n    for _, c := range paren_string {\n \
    \       // If the character is a left parenthesis, push it onto the stack\n  \
    \      if c == '(' {\n            stack = append(stack, c) // Add it to the stack\n\
    \        }\n        // If the character is a right parenthesis, pop it from the\
    \ stack\n        if c == ')' {\n            stack := stack[:len(stack)-1] // Remove\
    \ it from the stack\n        }\n        // If the character is a space, ignore\
    \ it\n        if c == ' ' {\n            continue\n        }\n        // If the\
    \ character is a new line, ignore it\n        if c == '\\n' {\n            continue\n\
    \        }\n        // If the character is a comma, ignore it\n        if c ==\
    \ ',' {\n            continue\n        }\n        // If the character is a closing\
    \ brace, ignore it\n        if c == '}' {\n            continue\n        }\n \
    \       // If the character is a opening brace, ignore it\n        if c == '{'\
    \ {\n            continue\n        }\n        // If the character is a colon,\
    \ ignore it\n        if c == ':' {\n            continue\n        }\n        //\
    \ If the character is a semicolon, ignore it\n        if c == ';' {\n        \
    \    continue\n        }\n        // If the character is a period, ignore it\n\
    \        if c == '.' {\n            continue\n        }\n        // If the character\
    \ is a question mark, ignore it\n        if c == '?' {\n            continue\n\
    \        }\n        // If the character is a exclamation mark, ignore it\n   \
    \     if c == '!' {\n            continue\n        }\n        // If the character\
    \ is a colon, ignore it\n        if c == '<' {\n            continue\n       \
    \ }\n        // If the character is a pipe, ignore it\n        if c == '|' {\n\
    \            continue\n        }\n        // If the character is a semicolon,\
    \ ignore it\n        if c == '>' {\n            continue\n        }\n        //\
    \ If the character is a comma, ignore it\n        if c == ',' {\n            continue\n\
    \        }\n        // If the character is a closing brace, ignore it\n      \
    \  if c == '}' {\n            continue\n        }\n        // If the character\
    \ is a opening brace, ignore it\n        if c == '{' {\n            continue\n\
    \        }\n        // If the character is a colon, ignore it\n        if c ==\
    \ ':' {\n            continue\n        }\n        // If the character is a semicolon,\
    \ ignore it\n        if c == ';' {\n            continue\n        }\n        //\
    \ If the character is a period, ignore it\n        if c == '.' {\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_c10tu8u_test.go:104:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph8xfnb8h_test.go:53:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074171
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_count\
    \ += count_open_braces(paren_string)\n    brace_count += count_close_braces(paren_string)\n\
    \    open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    open_braces -= count_open_braces(paren_string)\n    close_braces -= count_close_braces(paren_string)\n\
    \    open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    open_braces -= count_open_braces(paren_string)\n    close_braces -= count_close_braces(paren_string)\n\
    \    open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    open_braces -= count_open_braces(paren_string)\n    close_braces -= count_close_braces(paren_string)\n\
    \    open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    open_braces -= count_open_braces(paren_string)\n    close_braces -= count_close_braces(paren_string)\n\
    \    open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    open_braces -= count_open_braces(paren_string)\n    close_braces -= count_close_braces(paren_string)\n\
    \    open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    open_braces -= count_open_braces(paren_string)\n    close_braces -= count_close_braces(paren_string)\n\
    \    open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    open_braces -= count_open_braces(paren_string)\n    close_braces -= count_close_braces(paren_string)\n\
    \    open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    open_brace\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_2no4crw_test.go:52:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_count\
    \ += count_open_braces(paren_string)\n    brace_count += count_close_braces(paren_string)\n\
    \    stacks = append(stacks, []string{paren_string})\n    for len(stacks) > 0\
    \ {\n        stack := stacks[len(stacks)-1]\n        stacks = stacks[:len(stacks)-1]\n\
    \        open_braces += count_open_braces(stack[len(stack)-1])\n        close_braces\
    \ += count_close_braces(stack[len(stack)-1])\n        brace_count += count_open_braces(stack[len(stack)-1])\n\
    \        brace_count += count_close_braces(stack[len(stack)-1])\n        if open_braces\
    \ > close_braces {\n            result := append(result, stack[len(stack)-1])\n\
    \            open_braces -= close_braces\n            close_braces = 0\n     \
    \   } else {\n            stacks = append(stacks, []string{stack[len(stack)-1]})\n\
    \            open_braces = 0\n            close_braces = 0\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplglcw8yj_test.go:15:5: stack declared but not used

    /tmp/tmplglcw8yj_test.go:19:20: undefined: count_open_braces

    /tmp/tmplglcw8yj_test.go:20:20: undefined: count_close_braces

    /tmp/tmplglcw8yj_test.go:25:24: undefined: count_open_braces

    /tmp/tmplglcw8yj_test.go:26:25: undefined: count_close_braces

    /tmp/tmplglcw8yj_test.go:27:24: undefined: count_open_braces

    /tmp/tmplglcw8yj_test.go:28:24: undefined: count_close_braces

    /tmp/tmplglcw8yj_test.go:30:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_string := paren_string\n    result := make([]string,\
    \ 0)\n    stack := make([]string, 0)\n    stack := append(stack, paren_string)\n\
    \    for len(stack) > 0 {\n        s := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\
    \        if s == \"\" {\n            continue\n        }\n        if s[0] == '('\
    \ {\n            stack = append(stack, s[1:])\n            continue\n        }\n\
    \        if s[0] == '{' {\n            stack = append(stack, s[1:])\n        \
    \    continue\n        }\n        if s[0] == '[' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == ')' {\n        \
    \    result := append(result, s)\n            continue\n        }\n        if\
    \ s[0] == '}' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == ']' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == ' ' {\n            continue\n\
    \        }\n        if s[0] == '\\t' {\n            continue\n        }\n    \
    \    if s[0] == '\\n' {\n            continue\n        }\n        if s[0] == '\\\
    r' {\n            continue\n        }\n        if s[0] == ',' {\n            continue\n\
    \        }\n        if s[0] == '.' {\n            continue\n        }\n      \
    \  if s[0] == '!' {\n            continue\n        }\n        if s[0] == '?' {\n\
    \            continue\n        }\n        if s[0] == ';' {\n            continue\n\
    \        }\n        if s[0] == '=' {\n            continue\n        }\n      \
    \  if s[0] == '-' {\n            continue\n        }\n        if s[0] == '+' {\n\
    \            continue\n        }\n        if s[0] == '*' {\n            continue\n\
    \        }\n        if s[0] == '/' {\n            continue\n        }\n      \
    \  if s[0] == '%' {\n            continue\n        }\n        if s[0] == '&' {\n\
    \            continue\n        }\n        if s[0] == '|' {\n            continue\n\
    \        }\n        if s[0] == '^' {\n            continue\n        }\n      \
    \  if s[0] == '~' {\n            continue\n        }\n        if s[0] == '`' {\n\
    \            continue\n        }\n        if s[0] == '\\'' {\n            continue\n\
    \        }\n        if s[0] == '\"' {\n            continue\n        }\n     \
    \   if s[0] == '<' {\n            continue\n        }\n        if s[0] == '>'\
    \ {\n            continue\n        }\n        if s[0] == '?' {\n            continue\n\
    \        }\n        if s[0] == '@' {\n            continue\n        }\n      \
    \  if s[0] == '^' {\n            continue\n        }\n        if s[0] == '_' {\n\
    \            continue\n        }\n        if s[0] == '|' {\n            continue\n\
    \        }\n        if s[0] == '~' {\n            continue\n        }\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeyj_pt50_test.go:138:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_group_strings := []string{}\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_strings\
    \ = append(paren_group_strings, paren_string)\n    paren_group_strings = append(paren_group_strings,\
    \ paren_string)\n    paren_group_strings = append(paren_group_strings, paren_string)\n\
    \    paren_group_strings = append(paren_group_strings, paren_string)\n    paren_group_string\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpntiqu8fm_test.go:46:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_count\
    \ += count_open_braces(paren_string)\n    brace_count += count_close_braces(paren_string)\n\
    \    open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    stacks = append(stacks, stack)\n    open_braces += count_open_braces(paren_string)\n\
    \    close_braces += count_close_braces(paren_string)\n    stacks = append(stacks,\
    \ stack)\n    open_braces += count_open_braces(paren_string)\n    close_braces\
    \ += count_close_braces(paren_string)\n    stacks = append(stacks, stack)\n  \
    \  open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    stacks = append(stacks, stack)\n    open_braces += count_open_braces(paren_string)\n\
    \    close_braces += count_close_braces(paren_string)\n    stacks = append(stacks,\
    \ stack)\n    open_braces += count_open_braces(paren_string)\n    close_braces\
    \ += count_close_braces(paren_string)\n    stacks = append(stacks, stack)\n  \
    \  open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    stacks = append(stacks, stack)\n    open_braces += count_open_braces(paren_string)\n\
    \    close_braces += count_close_braces(paren_string)\n    stacks = append(stacks,\
    \ stack)\n    open_braces += count_open_braces(paren_string)\n    close_braces\
    \ += count_close_braces(paren_string)\n    stacks = append(stacks, stack)\n  \
    \  open_braces += count_open_braces(paren_string)\n    close_braces += count_close_braces(paren_string)\n\
    \    stacks = append(stacks, stack)\n    open_braces += count_open_braces(paren_string)\n\
    \    close_braces += count_close_braces(paren_string)\n    stacks = append(stacks,\
    \ stack)\n    open_braces += count_open_braces(paren_string)\n    close_braces\
    \ += count_close_braces(paren_string)\n    stacks = \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpum0yblok_test.go:57:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    paren_groups := []string{}\n    paren_group :=\
    \ \"\"\n    paren_group_is_open := false\n    paren_group_is_closed := false\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   if paren_group_is_open {\n                fmt.Println(\"Error: unexpected\
    \ open paren group\")\n            }\n            paren_group_is_open = true\n\
    \            paren_group = char\n        } else if char == ')' {\n           \
    \ if paren_group_is_closed {\n                fmt.Println(\"Error: unexpected\
    \ close paren group\")\n            }\n            paren_group_is_closed = true\n\
    \            paren_group = paren_group + char\n        } else if char == ' ' {\n\
    \            if paren_group_is_open {\n                paren_group_is_open = false\n\
    \                paren_group = paren_group + char\n            } else if paren_group_is_closed\
    \ {\n                paren_group_is_closed = false\n                paren_groups\
    \ = append(paren_groups, paren_group)\n                paren_group = \"\"\n  \
    \          } else {\n                fmt.Println(\"Error: unexpected space in\
    \ paren group\")\n            }\n        } else {\n            paren_group = paren_group\
    \ + char\n        }\n    }\n    if paren_group_is_open {\n        fmt.Println(\"\
    Error: unexpected open paren group\")\n    }\n    if paren_group_is_closed {\n\
    \        fmt.Println(\"Error: unexpected close paren group\")\n    }\n    return\
    \ paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph1_r_f3y_test.go:24:27: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmph1_r_f3y_test.go:30:27: invalid operation: paren_group + char (mismatched
    types string and rune)

    /tmp/tmph1_r_f3y_test.go:34:31: invalid operation: paren_group + char (mismatched
    types string and rune)

    /tmp/tmph1_r_f3y_test.go:43:27: invalid operation: paren_group + char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_closed := false\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_closed := false\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_closed := false\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_closed := false\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_closed := false\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_closed := false\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_closed := false\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_closed := false\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    brace_is_open := false\n    brace_is_closed := false\n    brace_is_open\
    \ := false\n    brace_is_closed := false\n    brace_is_open := false\n    brace_is_closed\
    \ := false\n    bra\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvmgu1sdu_test.go:78:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_string += \" \"\n    paren_string += \"(\"\n    paren_string +=\
    \ \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    paren_string += \"(\"\n    paren_string\
    \ += \"(\"\n    paren_string += \"(\"\n    \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6pk62rv2_test.go:87:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    var brace_count int\n    var brace_open bool\n\
    \    var brace_closed bool\n    var brace_open_index int\n    var brace_close_index\
    \ int\n    var brace_open_brace bool\n    var brace_closed_brace bool\n    var\
    \ brace_open_brace_index int\n    var brace_closed_brace_index int\n    var brace_open_brace_count\
    \ int\n    var brace_closed_brace_count int\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_brace_string string\n    var brace_open_brace_string string\n\
    \    var brace_closed_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpezzbfrpi_test.go:66:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    stack := append(stack, paren_string)\n    for len(stack) > 0 {\n        s\
    \ := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if s ==\
    \ \"\" {\n            continue\n        }\n        if s[0] == '(' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '{' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '[' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '<' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '>' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == ' ' {\n            continue\n        }\n        if\
    \ s[0] == '\\n' {\n            continue\n        }\n        if s[0] == '\\t' {\n\
    \            continue\n        }\n        if s[0] == ',' {\n            continue\n\
    \        }\n        if s[0] == ']' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '}' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '.' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '/' {\n            stack = append(stack, s[1:])\n \
    \           continue\n        }\n        if s[0] == '*' {\n            stack =\
    \ append(stack, s[1:])\n            continue\n        }\n        if s[0] == '?'\
    \ {\n            stack = append(stack, s[1:])\n            continue\n        }\n\
    \        if s[0] == '|' {\n            stack = append(stack, s[1:])\n        \
    \    continue\n        }\n        if s[0] == '&' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == '!' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == '=' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '<' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '>' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '%' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '^' {\n            stack = append(stack, s[1:])\n \
    \           continue\n        }\n        if s[0] == '+' {\n            stack =\
    \ append(stack, s[1:])\n            continue\n        }\n        if s[0] == '-'\
    \ {\n            stack = append(stack, s[1:])\n            continue\n        }\n\
    \        if s[0] == '*' {\n            stack = append(\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplc1tyxve_test.go:121:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxzsa1ov__test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Your code here\n    result := []string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    for _, char := range paren_string\
    \ {\n        if char == '{' {\n            open_braces++\n            stack =\
    \ append(stack, char)\n        } else if char == '}' {\n            close_braces++\n\
    \            if open_braces == close_braces {\n                open_braces = 0\n\
    \                stack = stack[:len(stack)-1]\n                result := append(result,\
    \ string(stack))\n            }\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3nuluq6d_test.go:21:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp3nuluq6d_test.go:27:17: result declared but not used

    /tmp/tmp3nuluq6d_test.go:27:49: cannot convert stack (variable of type []string)
    to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to hold the groups of parentheses\n    paren_groups\
    \ := []string{}\n\n    // Iterate through the input string and add each group\
    \ of parentheses to the list\n    for _, paren := range paren_string {\n     \
    \   // If the current character is a left paren, add it to the list\n        if\
    \ paren == '(' {\n            paren_groups = append(paren_groups, paren)\n   \
    \     }\n\n        // If the current character is a right paren, remove it from\
    \ the list\n        if paren == ')' {\n            paren_groups = paren_groups[:len(paren_groups)-1]\n\
    \        }\n    }\n\n    // Return the list of parentheses\n    return paren_groups\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbdksiq4e_test.go:20:49: cannot use paren (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := make([]string, 0)\n    stack := make([]string, 0)\n    stack\
    \ := append(stack, paren_string)\n    index := 0\n    depth := 0\n    for len(stack)\
    \ > 0 {\n        index += 1\n        depth += 1\n        index := 0\n        paren_string\
    \ := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        if paren_string\
    \ == \"\" {\n            continue\n        }\n        if paren_string[0] == '('\
    \ {\n            stack = append(stack, paren_string)\n            continue\n \
    \       }\n        if paren_string[0] == '{' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '[' {\n            stack = append(stack, paren_string)\n            continue\n\
    \        }\n        if paren_string[0] == '<' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '>' {\n            stack = append(stack, paren_string)\n            continue\n\
    \        }\n        if paren_string[0] == '{' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '<' {\n            stack = append(stack, paren_string)\n            continue\n\
    \        }\n        if paren_string[0] == '>' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '{' {\n            stack = append(stack, paren_string)\n            continue\n\
    \        }\n        if paren_string[0] == '[' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '(' {\n            stack = append(stack, paren_string)\n            continue\n\
    \        }\n        if paren_string[0] == '<' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '>' {\n            stack = append(stack, paren_string)\n            continue\n\
    \        }\n        if paren_string[0] == '{' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '[' {\n            stack = append(stack, paren_string)\n            continue\n\
    \        }\n        if paren_string[0] == '<' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '>' {\n            stack = append(stack, paren_string)\n            continue\n\
    \        }\n        if paren_string[0] == '{' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '[' {\n            stack = append(stack, paren_string)\n            continue\n\
    \        }\n        if paren_string[0] == '(' {\n            stack = append(stack,\
    \ paren_string)\n            continue\n        }\n        if paren_string[0] ==\
    \ '<' {\n            stack\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n \
    \ candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprp9840s3_test.go:109:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a slice to hold the result\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the input string\n    for _, character\
    \ := range paren_string {\n        // If the character is a left paren, add it\
    \ to the result\n        if character == '(' {\n            result = append(result,\
    \ character)\n        }\n\n        // If the character is a right paren, remove\
    \ it from the result\n        if character == ')' {\n            result = removeElement(result,\
    \ character)\n        }\n    }\n\n    // Return the result\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkp9ypxt9_test.go:20:37: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpkp9ypxt9_test.go:25:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack, _ := make([]string, 0)\n    stack :=\
    \ append(stack, paren_string)\n    for len(stack) > 0 {\n        index := len(stack)\
    \ - 1\n        group := stack[index]\n        if index == 0 {\n            stack\
    \ = stack[:index]\n            continue\n        }\n        if group[len(group)-1]\
    \ == '{' {\n            stack = stack[:index]\n            stack = append(stack,\
    \ group[:len(group)-1])\n            stack = append(stack, group[len(group)-1:])\n\
    \            continue\n        }\n        if group[len(group)-1] == '}' {\n  \
    \          stack = stack[:index]\n            stack = append(stack, group[:len(group)-1])\n\
    \            stack = append(stack, group[:len(group)-1])\n            continue\n\
    \        }\n        if group[len(group)-1] == ')' {\n            stack = stack[:index]\n\
    \            stack = append(stack, group[:len(group)-1])\n            stack =\
    \ append(stack, group[:len(group)-1])\n            continue\n        }\n     \
    \   if group[len(group)-1] == ']' {\n            stack = stack[:index]\n     \
    \       stack = append(stack, group[:len(group)-1])\n            stack = append(stack,\
    \ group[:len(group)-1])\n            continue\n        }\n        if group[len(group)-1]\
    \ == ',' {\n            stack = stack[:index]\n            stack = append(stack,\
    \ group[:len(group)-1])\n            stack = append(stack, group[:len(group)-1])\n\
    \            continue\n        }\n        if group[len(group)-1] == ' ' {\n  \
    \          stack = stack[:index]\n            stack = append(stack, group[:len(group)-1])\n\
    \            stack = append(stack, group[:len(group)-1])\n            continue\n\
    \        }\n        if group[len(group)-1] == '[' {\n            stack = stack[:index]\n\
    \            stack = append(stack, group[:len(group)-1])\n            stack =\
    \ append(stack, group[:len(group)-1])\n            continue\n        }\n     \
    \   if group[len(group)-1] == '(' {\n            stack = stack[:index]\n     \
    \       stack = append(stack, group[:len(group)-1])\n            stack = append(stack,\
    \ group[:len(group)-1])\n            continue\n        }\n        if group[len(group)-1]\
    \ == '{' {\n            stack = stack[:index]\n            stack = append(stack,\
    \ group[:len(group)-1])\n            stack = append(stack, group[:len(group)-1])\n\
    \            continue\n        }\n        if group[len(group)-1] == '}' {\n  \
    \          stack = stack[:index]\n            stack = append(stack, group[:len(group)-1])\n\
    \            stack = append(stack, group[:len(group)-1])\n            continue\n\
    \        }\n        if group[len(group)-1] == ']' {\n            stack = stack[:index]\n\
    \            stack = append(stack, group[:len(group)\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvu05b2ov_test.go:85:52: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph8xfnb8h_test.go:53:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074171
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxzsa1ov__test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := make([]string, 0)\n    stacks := make([][]string, 0)\n    stacks\
    \ = append(stacks, []string{paren_string})\n    for _, stack := range stacks {\n\
    \        result := append(result, stack[0])\n        if len(stack) > 1 {\n   \
    \         stacks = append(stacks, []string{stack[1:]})\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgohdox7y_test.go:17:9: result declared but not used

    /tmp/tmpgohdox7y_test.go:19:51: cannot use stack[1:] (value of type []string)
    as type string in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    stack := append(stack,\
    \ paren_string)\n    for len(stack) > 0 {\n        s := stack[len(stack)-1]\n\
    \        stack = stack[:len(stack)-1]\n        if s == \"\" {\n            continue\n\
    \        }\n        if s[0] == '(' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '{' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '[' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '<' {\n            stack = append(stack, s[1:])\n \
    \           continue\n        }\n        if s[0] == '>' {\n            stack =\
    \ append(stack, s[1:])\n            continue\n        }\n        if s[0] == '\
    \ ' {\n            continue\n        }\n        if s[0] == '\\n' {\n         \
    \   continue\n        }\n        if s[0] == ',' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == ')' {\n        \
    \    stack = append(stack, s[1:])\n            continue\n        }\n        if\
    \ s[0] == ']' {\n            stack = append(stack, s[1:])\n            continue\n\
    \        }\n        if s[0] == '}' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == '>' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '<' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '{' {\n            stack = append(stack, s[1:])\n \
    \           continue\n        }\n        if s[0] == '[' {\n            stack =\
    \ append(stack, s[1:])\n            continue\n        }\n        if s[0] == '\
    \ ' {\n            continue\n        }\n        if s[0] == '.' {\n           \
    \ stack = append(stack, s[1:])\n            continue\n        }\n        if s[0]\
    \ == ',' {\n            stack = append(stack, s[1:])\n            continue\n \
    \       }\n        if s[0] == ')' {\n            stack = append(stack, s[1:])\n\
    \            continue\n        }\n        if s[0] == ']' {\n            stack\
    \ = append(stack, s[1:])\n            continue\n        }\n        if s[0] ==\
    \ '{' {\n            stack = append(stack, s[1:])\n            continue\n    \
    \    }\n        if s[0] == '<' {\n            stack = append(stack, s[1:])\n \
    \           continue\n        }\n        if s[0] == '>' {\n            stack =\
    \ append(stack, s[1:])\n            continue\n        }\n        if s[0] == '\
    \ ' {\n            continue\n        }\n        if s[0] == '\\n' {\n         \
    \   continue\n        }\n        if s[0] == ',' {\n            stack = append(stack,\
    \ s[1:])\n            continue\n        }\n        if s[0] == ')' \nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2cf95ym__test.go:122:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to store our results\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, char := range\
    \ paren_string {\n        // If the character is a left paren, add it to the list\n\
    \        if char == '(' {\n            result = append(result, char)\n       \
    \ }\n\n        // If the character is a right paren, remove it from the list\n\
    \        if char == ')' {\n            result = removeElement(result, char)\n\
    \        }\n    }\n\n    // Return the list of results\n    return result\n}\n\
    \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphc9aqtgv_test.go:20:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmphc9aqtgv_test.go:25:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stacks = append(stacks,\
    \ []string{paren_string})\n\n    for _, stack := range stacks {\n        result\
    \ := []string{}\n        for _, item := range stack {\n            if item ==\
    \ \"{\" || item == \"}\" {\n                stacks = append(stacks[:len(stacks)-1],\
    \ stacks[len(stacks)-1][:len(stacks[len(stacks)-1])-1])\n                stacks\
    \ = append(stacks, []string{item})\n            } else {\n                stacks\
    \ = append(stacks, []string{item})\n            }\n        }\n        result =\
    \ append(result, stacks[len(stacks)-1]...)\n    }\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp8oyq_0gv_test.go:48: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp8oyq_0gv_test.go:48: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp8oyq_0gv_test.go:48:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp8oyq_0gv_test.go:48: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074177
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stacks := [][]string{}\n    stack := []string{}\n\
    \    open_braces := 0\n    close_braces := 0\n    brace_count := 0\n    brace_count\
    \ := 0\n    brace_count := 0\n    for _, char := range paren_string {\n      \
    \  if char == '{' {\n            open_braces++\n            stack = append(stack,\
    \ char)\n        } else if char == '}' {\n            close_braces++\n       \
    \     stack = append(stack, char)\n        } else if char == ' ' {\n         \
    \   stack = append(stack, char)\n        } else if char == '(' {\n           \
    \ stacks = append(stacks, stack)\n            stack = []string{}\n           \
    \ open_braces = 0\n            close_braces = 0\n            brace_count = 0\n\
    \            brace_count = 0\n        } else {\n            brace_count++\n  \
    \          stack = append(stack, char)\n        }\n    }\n    stacks = append(stacks,\
    \ stack)\n    for _, stack := range stacks {\n        if len(stack) == 0 {\n \
    \           continue\n        }\n        open_braces -= len(stack)\n        close_braces\
    \ -= len(stack)\n        brace_count -= len(stack)\n        result := append(result,\
    \ string(stack))\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbnpj2uue_test.go:19:17: no new variables on left side of :=

    /tmp/tmpbnpj2uue_test.go:20:17: no new variables on left side of :=

    /tmp/tmpbnpj2uue_test.go:24:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpbnpj2uue_test.go:27:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpbnpj2uue_test.go:29:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpbnpj2uue_test.go:39:35: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpbnpj2uue_test.go:50:9: result declared but not used

    /tmp/tmpbnpj2uue_test.go:50:41: cannot convert stack (variable of type []string)
    to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_opening_count := 0\n \
    \   brace_opening_count_in_stack := 0\n    brace_opening_count_in_result := 0\n\
    \    brace_opening_count_in_result := 0\n    brace_opening_count_in_result :=\
    \ 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_opening_count_in_result := 0\n    brace_opening_count_in_result\
    \ := 0\n    brace_open\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcm8hblr6_test.go:62:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_stack = make([]string, 0)\n\
    \    paren_stack = append(paren_stack, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    for len(paren_stack) > 0 {\n        paren_string = paren_stack[len(paren_stack)-1]\n\
    \        paren_stack = paren_stack[:len(paren_stack)-1]\n        paren_groups\
    \ = append(paren_groups, paren_string)\n        paren_stack = append(paren_stack,\
    \ paren_string)\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo279rpom_test.go:13:5: undefined: paren_groups

    /tmp/tmpo279rpom_test.go:14:5: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:15:26: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:16:27: undefined: paren_groups

    /tmp/tmpo279rpom_test.go:17:13: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:18:24: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:19:23: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:20:31: undefined: paren_groups

    /tmp/tmpo279rpom_test.go:21:30: undefined: paren_stack

    /tmp/tmpo279rpom_test.go:23:12: undefined: paren_groups

    /tmp/tmpo279rpom_test.go:23:12: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    var result []string\n    stack := make([]string, 0)\n    stack := append(stack,\
    \ paren_string)\n    index := 0\n    for len(stack) > 0 {\n        index += 1\n\
    \        length := len(stack)\n        index += 1\n        index += 1\n      \
    \  index += 1\n        index += 1\n        index += 1\n        index += 1\n  \
    \      index += 1\n        index += 1\n        index += 1\n        index += 1\n\
    \        index += 1\n        index += 1\n        index += 1\n        index +=\
    \ 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\n        index\
    \ += 1\n        index += 1\n        index += 1\n        index += 1\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdr76bo5w_test.go:137:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    // Initialize a list to hold our results\n    result := make([]string,\
    \ 0)\n\n    // Iterate over each character in the string\n    for _, character\
    \ := range paren_string {\n        // If the character is a left paren, add it\
    \ to the list\n        if character == '(' {\n            result = append(result,\
    \ character)\n        }\n\n        // If the character is a right paren, remove\
    \ it from the list\n        if character == ')' {\n            result = removeElement(result,\
    \ character)\n        }\n    }\n\n    // Return the list of results\n    return\
    \ result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgirdg63s_test.go:20:37: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpgirdg63s_test.go:25:22: undefined: removeElement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_count_in_stack := 0\n\
    \    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := 0\n    brace_count_in_result := 0\n    brace_count_in_result\
    \ := 0\n    brace_count_in_result := \nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpub0afxlk_test.go:71:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    result := []string{}\n    stack := []string{}\n    open_braces := 0\n\
    \    close_braces := 0\n    brace_count := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type := 0\n    brace_type\
    \ := 0\n    brace_type := 0\n    brace_type := 0\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp9baffmu_test.go:86:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074169
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\nfunc separate_paren_groups(paren_string string) []string\
    \ {\n    paren_groups = make([]string, 0)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups,\
    \ paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups\
    \ = append(paren\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputre785v_test.go:52:32: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074170
