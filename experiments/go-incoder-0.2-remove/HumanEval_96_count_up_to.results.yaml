language: go_test.go
name: HumanEval_96_count_up_to
results:
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if prime[j] == i {\n                prime[i]\
    \ = prime[j] + 1\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpjniygx6__test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpjniygx6__test.go:37\
    \ +0x166\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if n%i == 0 {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp4hu7vboh_test.go:43: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i]\
    \ == 0 {\n            for j := 2; i*j < n; j++ {\n                if prime[i*j]\
    \ == 0 {\n                    prime[i*j] = i\n                    break\n    \
    \            }\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpbq29dqmd_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpbq29dqmd_test.go:39\
    \ +0x185\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        if\
    \ prime[i] == 0 {\n            continue\n        }\n        for j := 2; i*j <=\
    \ n; j++ {\n            if prime[i*j] == 0 {\n                prime[i*j] = i\n\
    \                break\n            }\n        }\n    }\n    return prime[:n]\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpf7r1cl6w_test.go:14\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpf7r1cl6w_test.go:40\
    \ +0x1ae\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            if j > n {\n\
    \                break\n            }\n            if prime[j] {\n           \
    \     continue\n            }\n            prime = append(prime, j)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq11sd6os_test.go:14:12: non-boolean condition in if statement

    /tmp/tmpq11sd6os_test.go:21:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            if j > n {\n\
    \                break\n            }\n            if prime[j] {\n           \
    \     continue\n            }\n            prime = append(prime, j)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq11sd6os_test.go:14:12: non-boolean condition in if statement

    /tmp/tmpq11sd6os_test.go:21:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i <= n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgg_38wvp_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn73bfdwa_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := 2; j < i; j++ {\n                if prime[j] == 0\
    \ {\n                    prime[i] = prime[j] = 1\n                    break\n\
    \                }\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf_asa7a8_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := 2; j < i; j++ {\n                if prime[j] == 0\
    \ {\n                    prime[i] = prime[j] = 1\n                    break\n\
    \                }\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf_asa7a8_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            if j > n {\n\
    \                break\n            }\n            prime[j] = true\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7mwo_0us_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp7mwo_0us_test.go:21:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] <= i {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[i] = j\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpjrpvpw8x_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpjrpvpw8x_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpjrpvpw8x_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpjrpvpw8x_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpjrpvpw8x_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpjrpvpw8x_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpjrpvpw8x_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpjrpvpw8x_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := 2; j < i; j++ {\n                if prime[j] == 0\
    \ {\n                    prime[i] = prime[j] = 1\n                    break\n\
    \                }\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf_asa7a8_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn73bfdwa_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 1 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ 0\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8s4y9kb8_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if prime[j] == 0 {\n                break\n\
    \            }\n            if i%prime[j] == 0 {\n                prime[i] = 0\n\
    \                break\n            }\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpmrf0ln9n_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpmrf0ln9n_test.go:40\
    \ +0x1b6\ntesting.tRunner(0xc000103380, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn73bfdwa_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] >= i {\n  \
    \              break\n            }\n            if i%prime[j] == 0 {\n      \
    \          prime[i] = 0\n                break\n            }\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: integer divide\
    \ by zero [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x503ba0, 0x5f39a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ba0, 0x5f39a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpe5cgqd0k_test.go:21\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpe5cgqd0k_test.go:38\
    \ +0xc38\ntesting.tRunner(0xc0001201a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 1; i < n;\
    \ i++ {\n        for j := 1; j < i; j++ {\n            if prime[j] <= i {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[j] += 1\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpc8pfnyej_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpc8pfnyej_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpc8pfnyej_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpc8pfnyej_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpc8pfnyej_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpc8pfnyej_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpc8pfnyej_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpc8pfnyej_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] >= i {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[j] = i\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp3p6vkpvg_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp3p6vkpvg_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp3p6vkpvg_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp3p6vkpvg_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i <= n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgg_38wvp_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 1; i < n;\
    \ i++ {\n        for j := i * i; j < n; j += i {\n            prime[j] = j\n \
    \       }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpcxfcaz6t_test.go:46: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpcxfcaz6t_test.go:46: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpcxfcaz6t_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpcxfcaz6t_test.go:46:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpcxfcaz6t_test.go:46:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpcxfcaz6t_test.go:46: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpcxfcaz6t_test.go:46:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpcxfcaz6t_test.go:46:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[prime[0]] == 0 {\n           \
    \ prime = append(prime, i)\n        }\n        for j := 2; j < i; j++ {\n    \
    \        if i%j == 0 {\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp5dsonxfy_test.go:14\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp5dsonxfy_test.go:33\
    \ +0xfd4\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i % j == 0 {\n                break\n            }\n        }\n        if i\
    \ == 2 {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpwkw74pwe_test.go:48: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=2)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpwkw74pwe_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=2)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpwkw74pwe_test.go:48:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__3 (0.00s)\n        tmpwkw74pwe_test.go:48: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=2)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpwkw74pwe_test.go:48: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[%!s(int=2)]'\n    --- FAIL: TestCount_Up_To/test_num__7\
    \ (0.00s)\n        tmpwkw74pwe_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=2)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpwkw74pwe_test.go:48: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[%!s(int=2)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n    \
    \    tmpwkw74pwe_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31)\
    \ %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61)\
    \ %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]',\
    \ got '[%!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] >= i {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[i] = j\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpponhc0l3_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpponhc0l3_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpponhc0l3_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpponhc0l3_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := i + 1; j < n; j++ {\n            if prime[j] >= i {\n\
    \                break\n            }\n            if prime[j] == i {\n      \
    \          prime[j] = j\n            }\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpkt8n8u8j_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpkt8n8u8j_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpkt8n8u8j_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpkt8n8u8j_test.go:51: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn73bfdwa_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    for i := 1; i < n; i++ {\n        for j := 2; j < i; j++ {\n\
    \            if i % j == 0 {\n                break\n            }\n        }\n\
    \        if i == j {\n            prime[i] = 1\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpude_mqju_test.go:20:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    prime := append(prime, 3)\n    prime := append(prime,\
    \ 5)\n    prime := append(prime, 7)\n    prime := append(prime, 11)\n    prime\
    \ := append(prime, 13)\n    prime := append(prime, 17)\n    prime := append(prime,\
    \ 19)\n    prime := append(prime, 23)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 43)\n    prime := append(prime, 49)\n    prime := append(prime, 57)\n    prime\
    \ := append(prime, 61)\n    prime := append(prime, 67)\n    prime := append(prime,\
    \ 73)\n    prime := append(prime, 79)\n    prime := append(prime, 83)\n    prime\
    \ := append(prime, 89)\n    prime := append(prime, 97)\n    prime := append(prime,\
    \ 101)\n    prime := append(prime, 103)\n    prime := append(prime, 107)\n   \
    \ prime := append(prime, 109)\n    prime := append(prime, 113)\n    prime := append(prime,\
    \ 127)\n    prime := append(prime, 131)\n    prime := append(prime, 137)\n   \
    \ prime := append(prime, 139)\n    prime := append(prime, 149)\n    prime := append(prime,\
    \ 151)\n    prime := append(prime, 157)\n    prime := append(prime, 163)\n   \
    \ prime := append(prime, 167)\n    prime := append(prime, 173)\n    prime := append(prime,\
    \ 179)\n    prime := append(prime, 181)\n    prime := append(prime, 191)\n   \
    \ prime := append(prime, 193)\n    prime := append(prime, 197)\n    prime := append(prime,\
    \ 199)\n    prime := append(prime, 211)\n    prime := append(prime, 223)\n   \
    \ prime := append(prime, 227)\n    prime := append(prime, 229)\n    prime := append(prime,\
    \ 233)\n    prime := append(prime, 239)\n    prime := append(prime, 241)\n   \
    \ prime := append(prime, 251)\n    prime := append(prime, 257)\n    prime := append(prime,\
    \ 263)\n    prime := append(prime, 269)\n    prime := append(prime, 271)\n   \
    \ prime := append(prime, 277)\n    prime := append(prime, 28\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyc7n6rir_test.go:69:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn73bfdwa_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    for i := 1; i < n; i++ {\n        for j := 2; j < i; j++ {\n\
    \            if prime[j] == 0 {\n                prime[j] = i\n              \
    \  break\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpypesyccj_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpypesyccj_test.go:36\
    \ +0x13b\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        if\
    \ prime[i] == 0 {\n            continue\n        }\n        for j := 2; j <= prime[i];\
    \ j++ {\n            if prime[i] % j == 0 {\n                prime[i] = 0\n  \
    \              break\n            }\n        }\n        if prime[i] != 0 {\n \
    \           prime[i+1] = prime[i]\n        }\n    }\n    return prime[:n]\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(0x0)\n\t/tmp/tmpo6qg0zex_test.go:14\
    \ +0x13c\ncommand-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpo6qg0zex_test.go:43\
    \ +0xf9\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 1; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              for k := i + 1; k < n; k++ {\n                    if prime[k] ==\
    \ 0 {\n                        prime[k] = i\n                        i = k\n \
    \                       break\n                    }\n                }\n    \
    \        }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp7fwp03mr_test.go:54: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp7fwp03mr_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp7fwp03mr_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp7fwp03mr_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp7fwp03mr_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp7fwp03mr_test.go:54: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp7fwp03mr_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp7fwp03mr_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if n%i == 0 {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp4hu7vboh_test.go:43: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    prime[2] = 5\n    prime[3] = 7\n    prime[4]\
    \ = 11\n    prime[5] = 13\n    prime[6] = 17\n    prime[7] = 19\n    prime[8]\
    \ = 23\n    prime[9] = 29\n    prime[10] = 31\n    prime[11] = 31\n    prime[12]\
    \ = 37\n    prime[13] = 39\n    prime[14] = 41\n    prime[15] = 43\n    prime[16]\
    \ = 47\n    prime[17] = 59\n    prime[18] = 61\n    prime[19] = 67\n    prime[20]\
    \ = 71\n    prime[21] = 73\n    prime[22] = 79\n    prime[23] = 83\n    prime[24]\
    \ = 89\n    prime[25] = 97\n    prime[26] = 101\n    prime[27] = 103\n    prime[28]\
    \ = 107\n    prime[29] = 109\n    prime[30] = 112\n    prime[31] = 116\n    prime[32]\
    \ = 120\n    prime[33] = 125\n    prime[34] = 129\n    prime[35] = 132\n    prime[36]\
    \ = 136\n    prime[37] = 139\n    prime[38] = 142\n    prime[39] = 147\n    prime[40]\
    \ = 151\n    prime[41] = 157\n    prime[42] = 163\n    prime[43] = 167\n    prime[44]\
    \ = 173\n    prime[45] = 179\n    prime[46] = 181\n    prime[47] = 191\n    prime[48]\
    \ = 193\n    prime[49] = 197\n    prime[50] = 201\n    prime[51] = 205\n    prime[52]\
    \ = 209\n    prime[53] = 213\n    prime[54] = 217\n    prime[55] = 223\n    prime[56]\
    \ = 229\n    prime[57] = 233\n    prime[58] = 239\n    prime[59] = 241\n    prime[60]\
    \ = 243\n    prime[61] = 247\n    prime[62] = 251\n    prime[63] = 257\n    prime[64]\
    \ = 263\n    prime[65] = 269\n    prime[66] = 271\n    prime[67] = 277\n    prime[68]\
    \ = 283\n    prime[69] = 289\n    prime[70] = 293\n    prime[71] = 307\n    prime[72]\
    \ = 3\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy839u_k6_test.go:86:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075265
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    for i := 1; i < n; i++ {\n        for j := 2; j < i; j++ {\n\
    \            if i % j == 0 {\n                break\n            }\n        }\n\
    \        if i == j {\n            prime[i] = i\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9go3lm4l_test.go:20:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[prime[0]-1] == 0 {\n         \
    \   prime = append(prime, i)\n        }\n        for j := 1; j < i; j++ {\n  \
    \          if i%prime[j] == 0 {\n                break\n            }\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp8xs1r4vm_test.go:14\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp8xs1r4vm_test.go:33\
    \ +0x10ce\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0398dmf_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%j == 0 {\n             \
    \   prime[j] = 0\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := i * i; j < n; j += i {\n            prime[j] = nil\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamygo8ap_test.go:18:24: cannot use nil as int value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i]\
    \ == 0 {\n            for j := 2; i*j < n; j++ {\n                if prime[i*j]\
    \ == 0 {\n                    prime[i*j] = i\n                    break\n    \
    \            }\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpbq29dqmd_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpbq29dqmd_test.go:39\
    \ +0x185\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%j == 0 {\n             \
    \   prime[i] = 0\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmph5gmptfk_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmph5gmptfk_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=0) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmph5gmptfk_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmph5gmptfk_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmph5gmptfk_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmph5gmptfk_test.go:52: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmph5gmptfk_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0)\
    \ %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmph5gmptfk_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n \
    \           }\n        }\n        if j > i {\n            prime[i] = i\n     \
    \   }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7bv0ujxg_test.go:21:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        if prime[i]\
    \ == 0 {\n            continue\n        }\n        for j := i * i; j < n; j +=\
    \ i {\n            prime[j] = 1\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmppas8tp7r_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmppas8tp7r_test.go:37\
    \ +0x191\ntesting.tRunner(0xc0001a0000, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := i + 1; j < n; j++ {\n            if prime[j] >= i {\n\
    \                break\n            }\n            if prime[j] == i {\n      \
    \          prime[j] = j\n            }\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpkt8n8u8j_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpkt8n8u8j_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpkt8n8u8j_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpkt8n8u8j_test.go:51: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%j == 0 {\n             \
    \   prime[j] = 0\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i%j == 0 {\n                break\n            }\n        }\n        if i ==\
    \ n {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpc2qpt336_test.go:48: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpc2qpt336_test.go:48:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpc2qpt336_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpc2qpt336_test.go:48:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpc2qpt336_test.go:48: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpc2qpt336_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpc2qpt336_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpc2qpt336_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn73bfdwa_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if prime[j] >= i {\n                break\n\
    \            }\n            if i%prime[j] == 0 {\n                prime[i] = prime[j]\
    \ + 1\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: integer divide\
    \ by zero [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpj64ok3o8_test.go:20\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpj64ok3o8_test.go:36\
    \ +0x28f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 1; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%prime[j] == 0 {\n      \
    \          prime[i] = 0\n                break\n            }\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpu7z7smur_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpu7z7smur_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpu7z7smur_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpu7z7smur_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpu7z7smur_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpu7z7smur_test.go:52: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpu7z7smur_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpu7z7smur_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := 2; i*j < n; j++ {\n                if prime[i*j] ==\
    \ 0 {\n                    prime[i*j] = i\n                    break\n       \
    \         }\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps1xx3n7a_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    for i := 3; i < n; i++ {\n        if prime[i]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := i\
    \ * i; j < n; j += i {\n            prime = append(prime, j)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqiksps1e_test.go:13:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    for i := 1; i < n; i++ {\n        for j := 2; j < i; j++ {\n\
    \            if i % j == 0 {\n                break\n            }\n        }\n\
    \        if i == j {\n            prime[i] = i\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9go3lm4l_test.go:20:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              for k := i + 1; k < n; k++ {\n                    if prime[k] ==\
    \ 0 {\n                        prime[k] = i\n                        i = k\n \
    \                       break\n                    }\n                }\n    \
    \        }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpj5qkz4ml_test.go:54: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpj5qkz4ml_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpj5qkz4ml_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpj5qkz4ml_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpj5qkz4ml_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpj5qkz4ml_test.go:54: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpj5qkz4ml_test.go:54:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpj5qkz4ml_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%prime[j] == 0 {\n      \
    \          prime[i] = 0\n                break\n            }\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp1r4e283v_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=0) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=0) %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=11) %!s(int=0) %!s(int=13) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=17)\
    \ %!s(int=0) %!s(int=19) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=11)\
    \ %!s(int=0) %!s(int=13) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=17)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp1r4e283v_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(in"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if n%i == 0 {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp4hu7vboh_test.go:43: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        if prime[i] == 0 {\n            prime[i] =\
    \ 1\n            for j := i + 1; j < n; j++ {\n                if prime[j] ==\
    \ 0 {\n                    prime[j] = 1\n                    break\n         \
    \       }\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp1ggjvi7n_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp1ggjvi7n_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp1ggjvi7n_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp1ggjvi7n_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp1ggjvi7n_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp1ggjvi7n_test.go:49: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp1ggjvi7n_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp1ggjvi7n_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if prime[j] >= i {\n                break\n\
    \            }\n            if prime[j] == i {\n                prime[i] = j\n\
    \                break\n            }\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpqjqymr_j_test.go:14\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpqjqymr_j_test.go:40\
    \ +0x14b\ntesting.tRunner(0xc000184ea0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        if prime[i]\
    \ == 0 {\n            for j := i * i; j < n; j += i {\n                prime[j]\
    \ = i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpiwa8p00__test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpiwa8p00__test.go:36\
    \ +0x185\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    for i := 3; i < n; i++ {\n        for _, j :=\
    \ range prime {\n            if i%j == 0 {\n                break\n          \
    \  }\n        }\n        if i == n {\n            prime = append(prime, i)\n \
    \       }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5a8wh3im_test.go:13:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] >= i {\n  \
    \              break\n            }\n            if i%prime[j] == 0 {\n      \
    \          prime[i] = 0\n                break\n            }\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: integer divide\
    \ by zero [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x503ba0, 0x5f39a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ba0, 0x5f39a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpe5cgqd0k_test.go:21\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpe5cgqd0k_test.go:38\
    \ +0xc38\ntesting.tRunner(0xc0001201a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] >= i {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[i] = j\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpponhc0l3_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpponhc0l3_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpponhc0l3_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpponhc0l3_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == i {\n  \
    \              prime[j] = 0\n                break\n            }\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp3w9zvllp_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp3w9zvllp_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp3w9zvllp_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp3w9zvllp_test.go:49: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if n%i == 0 {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp4hu7vboh_test.go:43: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0398dmf_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n \
    \           }\n        }\n        if j == i {\n            prime[i] = i\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1bn4o35g_test.go:21:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%j == 0 {\n             \
    \   prime[j] = 0\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = prime[1] = 1\n    for i := 2; i <= n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i%j == 0 {\n                break\n           \
    \ }\n        }\n        if i == j {\n            prime[i] = 1\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp81d3ugkj_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] >= i {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[j] = i\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp3p6vkpvg_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp3p6vkpvg_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp3p6vkpvg_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp3p6vkpvg_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if n%i == 0 {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp4hu7vboh_test.go:43: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[j] = 0\n                prime[i] = j\n                break\n \
    \           }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmppb5npws5_test.go:53: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmppb5npws5_test.go:53: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmppb5npws5_test.go:53: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmppb5npws5_test.go:53:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmppb5npws5_test.go:53:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmppb5npws5_test.go:53: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmppb5npws5_test.go:53:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmppb5npws5_test.go:53:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075269
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    for i := 3; i < n; i++ {\n        if prime[prime[len(prime)-1]-1]\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        for j := 2;\
    \ j < i; j++ {\n            if i%j == 0 {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmlfr6u9m_test.go:13:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 1 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ 1\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphasst89y_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: null
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        if prime[i] == 0 {\n            prime[i] =\
    \ 1\n            for j := 2; i*j < n; j++ {\n                if prime[i*j] ==\
    \ 0 {\n                    prime[i*j] = 1\n                    break\n       \
    \         }\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075282
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i\
    \ % j == 0 {\n                break\n            }\n        }\n        if i ==\
    \ 2 {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpbdx197md_test.go:48: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=2)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpbdx197md_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=2)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpbdx197md_test.go:48:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__3 (0.00s)\n        tmpbdx197md_test.go:48: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=2)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpbdx197md_test.go:48: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[%!s(int=2)]'\n    --- FAIL: TestCount_Up_To/test_num__7\
    \ (0.00s)\n        tmpbdx197md_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=2)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpbdx197md_test.go:48: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[%!s(int=2)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n    \
    \    tmpbdx197md_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31)\
    \ %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61)\
    \ %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]',\
    \ got '[%!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075269
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if prime[j] == i {\n                prime[i]\
    \ = prime[j] + 1\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpjniygx6__test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpjniygx6__test.go:37\
    \ +0x166\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    for i := 1; i < n; i++ {\n        for j := 2; j < i; j++ {\n\
    \            if i%j == 0 {\n                break\n            }\n        }\n\
    \        if i == j {\n            prime[i] = 1\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph7qlws11_test.go:20:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    for i := 1; i < n; i++ {\n        for j := 2; j < i; j++ {\n\
    \            if i%j == 0 {\n                break\n            }\n        }\n\
    \        if i == j {\n            prime[i] = 1\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph7qlws11_test.go:20:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = prime[1] = 1\n    for i := 2; i <= n; i++ {\n        if prime[i]\
    \ == 0 {\n            for j := i * i; j < n; j += i {\n                prime[j]\
    \ = i\n            }\n        }\n    }\n    return prime[:n]\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw2am_pmz_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%prime[j] == 0 {\n      \
    \          prime[i] = 0\n                break\n            }\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp1r4e283v_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=0) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=0) %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=11) %!s(int=0) %!s(int=13) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=17)\
    \ %!s(int=0) %!s(int=19) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=11)\
    \ %!s(int=0) %!s(int=13) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=17)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp1r4e283v_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(in"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0398dmf_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        for j := 2; j\
    \ < i; j++ {\n            if prime[j] == 0 {\n                prime[j] = i\n \
    \               break\n            }\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxbp9bkgb_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] >= i {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[j] = i\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp3p6vkpvg_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp3p6vkpvg_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp3p6vkpvg_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp3p6vkpvg_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp3p6vkpvg_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    prime[1] = 2\n    for i := 2; i < n; i++ {\n        if prime[i]\
    \ == 0 {\n            for j := i * i; j < n; j += i {\n                prime[j]\
    \ = prime[j/2]\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp5eoxb8h8_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp5eoxb8h8_test.go:36\
    \ +0x1af\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075269
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if n%i == 0 {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmp4hu7vboh_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp4hu7vboh_test.go:43: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp4hu7vboh_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        if prime[i]\
    \ == 0 {\n            for j := i + i; j < n; j += i {\n                prime[j]\
    \ = 0\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpbt69cx9i_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpbt69cx9i_test.go:36\
    \ +0x171\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075269
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        if prime[i]\
    \ == 0 {\n            for j := 2; j < i; j++ {\n                if prime[j] ==\
    \ 0 {\n                    prime[i] = prime[j] + 1\n                    break\n\
    \                }\n            }\n        }\n    }\n    return prime[:n]\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpqg6wf5er_test.go:14\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpqg6wf5er_test.go:39\
    \ +0x17a\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075270
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    for i := 3; i < n; i++ {\n        if prime[i\
    \ / 2] {\n            prime[i / 2--] = false\n        } else {\n            prime[i\
    \ / 2] = true\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptpjimk2g_test.go:16:24: expected '']'', found ''--''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%prime[j] == 0 {\n      \
    \          prime[i] = 0\n                break\n            }\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp1r4e283v_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=0) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=0) %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=11) %!s(int=0) %!s(int=13) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=17)\
    \ %!s(int=0) %!s(int=19) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=11)\
    \ %!s(int=0) %!s(int=13) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=17)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp1r4e283v_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(in"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ prime[j-1] + 1\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4lbom6rn_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n \
    \           }\n        }\n        if j == i {\n            prime[i] = i\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1bn4o35g_test.go:21:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := 2; i*j < n; j++ {\n                if prime[i*j] ==\
    \ 0 {\n                    prime[i*j] = i\n                    break\n       \
    \         }\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps1xx3n7a_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ prime[j-1] + 1\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4lbom6rn_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    for i := 1; i < n; i++ {\n        if prime[i] == 0 {\n   \
    \         for j := 2; i*j <= n; j++ {\n                if n%i == 0 {\n       \
    \             prime[i] = 0\n                    break\n                }\n   \
    \         }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpgywj2fdz_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpgywj2fdz_test.go:38\
    \ +0x16f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075270
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := i + 1; j < n; j++ {\n            if prime[j] >= i {\n\
    \                break\n            }\n            if prime[j] == i {\n      \
    \          prime[j] += 1\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpv52710ct_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpv52710ct_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpv52710ct_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpv52710ct_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpv52710ct_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpv52710ct_test.go:51: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpv52710ct_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpv52710ct_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075270
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = prime[1] = 1\n    for i := 2; i <= n; i++ {\n        if prime[i]\
    \ == 0 {\n            for j := i * i; j < n; j += i {\n                prime[j]\
    \ = i\n            }\n        }\n    }\n    return prime[:n]\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw2am_pmz_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            if j > n {\n\
    \                break\n            }\n            prime[i / 2] = (j > n) ? false\
    \ : true\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt5x0rhb5_test.go:21:36: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        if prime[i] == 0 {\n            for j := i + 1; j < n; j++ {\n\
    \                if prime[j] == 0 {\n                    prime[j] = 1\n      \
    \              break\n                }\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpulh8vozs_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpulh8vozs_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpulh8vozs_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpulh8vozs_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpulh8vozs_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpulh8vozs_test.go:51: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpulh8vozs_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpulh8vozs_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075270
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i] == 0 {\n            for j :=\
    \ 2; j < i; j++ {\n                if i%j == 0 {\n                    prime[i]\
    \ = 0\n                    break\n                }\n            }\n         \
    \   if prime[i] != 0 {\n                prime = append(prime, i)\n           \
    \ }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 0 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 0\n\ngoroutine 19 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpd5g6hin5_test.go:14\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpd5g6hin5_test.go:36\
    \ +0xf85\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075270
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := i + 1; j < n; j++ {\n            if prime[j] >= i {\n\
    \                break\n            }\n            if prime[j] == i {\n      \
    \          prime[j] = j\n            }\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpkt8n8u8j_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpkt8n8u8j_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpkt8n8u8j_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpkt8n8u8j_test.go:51: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpkt8n8u8j_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        if\
    \ prime[i] == 0 {\n            continue\n        }\n        for j := 2; j < prime[i];\
    \ j++ {\n            if prime[i] % j == 0 {\n                prime[i] = 0\n  \
    \              break\n            }\n        }\n        if prime[i] != 0 {\n \
    \           prime[i+1] = prime[i]\n        }\n    }\n    return prime[:n]\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(0x0)\n\t/tmp/tmp4ryp_gc5_test.go:14\
    \ +0x13c\ncommand-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp4ryp_gc5_test.go:43\
    \ +0xf9\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    for i := 3; i < n; i++ {\n        if isPrime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4imjb7ok_test.go:13:11: no new variables on left side of :=

    /tmp/tmp4imjb7ok_test.go:15:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    for i := 3; i <= n; i++ {\n        if i%2 ==\
    \ 0 {\n            continue\n        }\n        for j := 3; j < i; j++ {\n   \
    \         if i%j == 0 {\n                break\n            }\n            if\
    \ j%i == 0 {\n                prime = append(prime, j)\n                break\n\
    \            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe7vftiq__test.go:13:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i]\
    \ == 0 {\n            for j := 2; j < i; j++ {\n                if prime[j] ==\
    \ 0 {\n                    prime[i] = prime[i] + 1\n                    break\n\
    \                }\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpf6uecd3m_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpf6uecd3m_test.go:39\
    \ +0x16f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn73bfdwa_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n \
    \           }\n        }\n        if j == i {\n            prime[i] = i\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1bn4o35g_test.go:21:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ prime[j-1] + 1\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4lbom6rn_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 1; i < n;\
    \ i++ {\n        for j := 1; j < i; j++ {\n            if prime[j] == i {\n  \
    \              break\n            }\n            if i%prime[j] == 0 {\n      \
    \          prime[i] = 0\n                break\n            }\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpfy4k6m58_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpfy4k6m58_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpfy4k6m58_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpfy4k6m58_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpfy4k6m58_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpfy4k6m58_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpfy4k6m58_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpfy4k6m58_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn73bfdwa_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] >= i {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[i] = j\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpponhc0l3_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpponhc0l3_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpponhc0l3_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpponhc0l3_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpponhc0l3_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == i {\n  \
    \              prime[j] = 0\n                break\n            }\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp3w9zvllp_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp3w9zvllp_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp3w9zvllp_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp3w9zvllp_test.go:49: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == i {\n  \
    \              prime[j] = 0\n                break\n            }\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp3w9zvllp_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp3w9zvllp_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp3w9zvllp_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp3w9zvllp_test.go:49: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp3w9zvllp_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := 2; i*j < n; j++ {\n                if prime[i*j] ==\
    \ 0 {\n                    prime[i*j] = i\n                    break\n       \
    \         }\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps1xx3n7a_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := i + 1; j < n; j++ {\n            if prime[j] >= i {\n\
    \                break\n            }\n            if prime[j] == i {\n      \
    \          prime[j] += 1\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpv52710ct_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpv52710ct_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpv52710ct_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpv52710ct_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpv52710ct_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpv52710ct_test.go:51: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpv52710ct_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpv52710ct_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpctyb4vat_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i\
    \ % j == 0 {\n                break\n            }\n        }\n        if i ==\
    \ j {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwkg1iqwx_test.go:19:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        if isprime(i) {\n            prime[i] = i\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmporexidsj_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075270
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%j == 0 {\n             \
    \   prime[j] = 0\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        for j := 2; j\
    \ < i; j++ {\n            if prime[j] == 0 {\n                for k := j; k <\
    \ i; k++ {\n                    prime[k] = i\n                }\n            \
    \    break\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpht57diu6_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075270
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    for i := 1; i < n; i++ {\n        for j := 2; j < i; j++ {\n\
    \            if prime[j] == 0 {\n                for k := j; k < i; k++ {\n  \
    \                  prime[k] = 0\n                }\n                break\n  \
    \          }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpjctlh780_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpjctlh780_test.go:38\
    \ +0x130\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075271
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0398dmf_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if prime[j] == i {\n                prime[i]\
    \ = prime[j] + 1\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpjniygx6__test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpjniygx6__test.go:37\
    \ +0x166\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 1\n    prime[1] = 1\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if prime[j] == 0 {\n                for k :=\
    \ j; k < i; k++ {\n                    if prime[k] == 0 {\n                  \
    \      prime[j] = prime[k] + 1\n                        break\n              \
    \      }\n                }\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpb7jvcaej_test.go:13\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpb7jvcaej_test.go:41\
    \ +0x165\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075271
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0398dmf_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0398dmf_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[j] = i\n                prime[i] = j\n            }\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpylh81q2o_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpylh81q2o_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpylh81q2o_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpylh81q2o_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpylh81q2o_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpylh81q2o_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpylh81q2o_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpylh81q2o_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075271
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        for j := 2; j\
    \ < i; j++ {\n            if prime[j] == 0 {\n                prime[j] = i\n \
    \           }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuwbns982_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n \
    \           }\n        }\n        if j == i {\n            prime[i] = i\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1bn4o35g_test.go:21:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        if\
    \ prime[i] == 0 {\n            for j := i * i; j < n; j += i {\n             \
    \   prime[j] = nil\n            }\n        }\n    }\n    return prime[:n]\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8pai958u_test.go:18:28: cannot use nil as int value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075271
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n \
    \           }\n        }\n        if j == i {\n            prime[i] = i\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1bn4o35g_test.go:21:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i <= n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n \
    \           }\n        }\n        if j == i {\n            prime[i] = i\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1bn4o35g_test.go:21:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075268
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ prime[j-1] + 1\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4lbom6rn_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    prime[2] = 5\n    for i := 3; i <= n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n     \
    \           break\n            }\n        }\n        if j == i {\n           \
    \ prime[i] = i\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvrpx9k1i_test.go:22:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075271
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn73bfdwa_test.go:14:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i] == 0 {\n            for j :=\
    \ 2; j < i; j++ {\n                if i%j == 0 {\n                    prime[i]\
    \ = 0\n                    break\n                }\n            }\n         \
    \   if prime[i] == 0 {\n                prime = append(prime, i)\n           \
    \ }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 0 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpyugfw0jy_test.go:14\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpyugfw0jy_test.go:36\
    \ +0xf85\ntesting.tRunner(0xc0001031e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075271
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%j == 0 {\n             \
    \   prime[j] = 0\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp5uemhmw1_test.go:52: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp5uemhmw1_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp5uemhmw1_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i*prime[j] <= n {\n      \
    \          prime[j]++\n                break\n            }\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp_w4wjvz0_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp_w4wjvz0_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=3)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp_w4wjvz0_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp_w4wjvz0_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp_w4wjvz0_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=5) %!s(int=4)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp_w4wjvz0_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp_w4wjvz0_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp_w4wjvz0_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075271
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if prime[j] == i {\n                prime[i]\
    \ = prime[j] + 1\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpq5i_9fh0_test.go:14\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpq5i_9fh0_test.go:37\
    \ +0x173\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075271
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ prime[j-1] + 1\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4lbom6rn_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    for i := 3; i < n; i++ {\n        if prime[i\
    \ / 2] {\n            prime[i / 2] = false\n        } else {\n            prime[i\
    \ / 2] = true\n            for j := i * i; j < n; j += i {\n                prime[j]\
    \ = false\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp62m40l2o_test.go:13:11: no new variables on left side of :=

    /tmp/tmp62m40l2o_test.go:15:12: non-boolean condition in if statement

    /tmp/tmp62m40l2o_test.go:16:28: cannot use false (untyped bool constant) as int
    value in assignment

    /tmp/tmp62m40l2o_test.go:18:28: cannot use true (untyped bool constant) as int
    value in assignment

    /tmp/tmp62m40l2o_test.go:20:28: cannot use false (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075271
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0398dmf_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%prime[j] == 0 {\n      \
    \          prime[i] = 0\n                break\n            }\n        }\n   \
    \ }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmp1r4e283v_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=0) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=0) %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=11) %!s(int=0) %!s(int=13) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=17)\
    \ %!s(int=0) %!s(int=19) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp1r4e283v_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp1r4e283v_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=5) %!s(int=0) %!s(int=7) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=11)\
    \ %!s(int=0) %!s(int=13) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=17)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp1r4e283v_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(in"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0398dmf_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075266
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := i + 1; j < n; j++ {\n            if prime[j] <= i {\n\
    \                break\n            }\n            if prime[j] == i {\n      \
    \          prime[j]++\n            }\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpruuaqqjc_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpruuaqqjc_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpruuaqqjc_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpruuaqqjc_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpruuaqqjc_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpruuaqqjc_test.go:51: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpruuaqqjc_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpruuaqqjc_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075271
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := i * i; j < n; j += i {\n            prime[j] = nil\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamygo8ap_test.go:18:24: cannot use nil as int value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075267
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    for i := 3; i <= n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n        if i == j {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8jclc4i8_test.go:13:11: no new variables on left side of :=

    /tmp/tmp8jclc4i8_test.go:20:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075271
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = 2\n    prime[1] = 3\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if prime[j] == 0 {\n                for k :=\
    \ j; k < i; k++ {\n                    if prime[k] == 0 {\n                  \
    \      prime[j] = prime[k]\n                        prime[j+1]++\n           \
    \             break\n                    }\n                }\n            }\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(0x0)\n\t/tmp/tmp2ncmi6jp_test.go:13\
    \ +0xd6\ncommand-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp2ncmi6jp_test.go:42\
    \ +0xf9\ntesting.tRunner(0xc000199040, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660075271
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n+1)\n \
    \   prime[0] = 2\n    prime[1] = 3\n    prime[2] = 5\n    prime[3] = 7\n    prime[4]\
    \ = 11\n    prime[5] = 13\n    prime[6] = 17\n    prime[7] = 19\n    prime[8]\
    \ = 23\n    prime[9] = 29\n    prime[10] = 31\n    prime[11] = 31\n    prime[12]\
    \ = 37\n    prime[13] = 39\n    prime[14] = 41\n    prime[15] = 43\n    prime[16]\
    \ = 47\n    prime[17] = 53\n    prime[18] = 59\n    prime[19] = 61\n    prime[20]\
    \ = 67\n    prime[21] = 71\n    prime[22] = 73\n    prime[23] = 79\n    prime[24]\
    \ = 83\n    prime[25] = 89\n    prime[26] = 97\n    prime[27] = 101\n    prime[28]\
    \ = 103\n    prime[29] = 107\n    prime[30] = 103\n    prime[31] = 110\n    prime[32]\
    \ = 115\n    prime[33] = 121\n    prime[34] = 127\n    prime[35] = 131\n    prime[36]\
    \ = 137\n    prime[37] = 139\n    prime[38] = 147\n    prime[39] = 151\n    prime[40]\
    \ = 157\n    prime[41] = 163\n    prime[42] = 173\n    prime[43] = 179\n    prime[44]\
    \ = 181\n    prime[45] = 191\n    prime[46] = 193\n    prime[47] = 197\n    prime[48]\
    \ = 199\n    prime[49] = 211\n    prime[50] = 223\n    prime[51] = 229\n    prime[52]\
    \ = 233\n    prime[53] = 239\n    prime[54] = 241\n    prime[55] = 251\n    prime[56]\
    \ = 253\n    prime[57] = 257\n    prime[58] = 263\n    prime[59] = 269\n    prime[60]\
    \ = 271\n    prime[61] = 277\n    prime[62] = 281\n    prime[63] = 283\n    prime[64]\
    \ = 293\n    prime[65] = 307\n    prime[66] = 311\n    prime[67] = 313\n    prime[68]\
    \ = 317\n    prime[69] = 319\n    prime[70] = 329\n    prime[71]\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdra7hfem_test.go:85:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075271
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = 1\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] == 0 {\n  \
    \              break\n            }\n            if i%j == 0 {\n             \
    \   prime[i] = 0\n                break\n            }\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmph5gmptfk_test.go:52: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmph5gmptfk_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=0) %!s(int=1)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmph5gmptfk_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmph5gmptfk_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmph5gmptfk_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmph5gmptfk_test.go:52: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmph5gmptfk_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0)\
    \ %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmph5gmptfk_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %"
  timestamp: 1660075267
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ prime[j-1] + 1\n            }\n        }\n    }\n    return prime\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4lbom6rn_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075269
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if prime[i / 2] {\n            continue\n\
    \        }\n        for j := i * i; j < n; j += i {\n            prime[j] = true\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0itjeo98_test.go:14:12: non-boolean condition in if statement

    /tmp/tmp0itjeo98_test.go:18:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i\
    \ % j == 0 {\n                break\n            }\n        }\n        if i ==\
    \ j {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwkg1iqwx_test.go:19:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075270
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ prime := append(prime, 2)\n    for i := 3; i < n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n        if i == j {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_8oz_md7_test.go:13:11: no new variables on left side of :=

    /tmp/tmp_8oz_md7_test.go:20:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075271
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, 0)\n   \
    \ for i := 2; i <= n; i++ {\n        if isprime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgg_38wvp_test.go:14:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075264
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        prime[i] = i\n    }\n    for i := 2; i < n;\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if prime[j] >= i {\n  \
    \              break\n            }\n            if prime[j] == i {\n        \
    \        prime[j] += 1\n            }\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpp80kjg1q_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpp80kjg1q_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpp80kjg1q_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpp80kjg1q_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpp80kjg1q_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpp80kjg1q_test.go:51: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpp80kjg1q_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpp80kjg1q_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(i"
  timestamp: 1660075271
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns an array\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\nfunc count_up_to(n int) []int {\n    prime := make([]int, n)\n   \
    \ prime[0] = prime[1] = 1\n    for i := 2; i < n; i++ {\n        if prime[i] ==\
    \ 0 {\n            for j := i * i; j < n; j += i {\n                prime[j] =\
    \ i\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ojrrqid_test.go:13:25: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075263
