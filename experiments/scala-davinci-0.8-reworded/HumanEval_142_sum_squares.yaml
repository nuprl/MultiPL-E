name: HumanEval_142_sum_squares
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // \"\n    // This function will take a list of integers. For all entries in\
  \ the list, the function shall square the integer entry if its index is a \n   \
  \ // multiple of 3 and will cube the integer entry if its index is a multiple of\
  \ 4 and not a multiple of 3. The function will not \n    // change the entries in\
  \ the list whose indexes are not a multiple of 3 or 4. The function shall then return\
  \ the sum of all entries. \n    // Examples:\n    // >>> lst\n    // List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)\n    // >>> lst\n    // List[Long]()\n    // >>> lst\n \
  \   // List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)\n \
  \   def sumSquares(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong))) == (6l));\n    assert(sumSquares((List[Long](1l.toLong,\
  \ 4l.toLong, 9l.toLong))) == (14l));\n    assert(sumSquares((List[Long]())) == (0l));\n\
  \    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));\n    assert(sumSquares((List[Long](-1l.toLong,\
  \ -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong,\
  \ -1l.toLong))) == (-3l));\n    assert(sumSquares((List[Long](0l.toLong))) == (0l));\n\
  \    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong,\
  \ -5l.toLong))) == (-126l));\n    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong,\
  \ 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));\n    assert(sumSquares((List[Long](-1l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong)))\
  \ == (0l));\n    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong,\
  \ 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong,\
  \ -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));\n\
  \    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong,\
  \ -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong,\
  \ 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong,\
  \ 4l.toLong, 10l.toLong))) == (-1448l));\n    }\n\n}\n"
completions: ["        def innerSumSquares(lst : List[Long], sum : Long, index : Int)\
    \ : Long = {\n            if (lst.isEmpty) sum\n            else if (index % 3\
    \ == 0) innerSumSquares(lst.tail, sum + lst.head * lst.head, index + 1)\n    \
    \        else if (index % 4 == 0) innerSumSquares(lst.tail, sum + lst.head * lst.head\
    \ * lst.head, index + 1)\n            else innerSumSquares(lst.tail, sum + lst.head,\
    \ index + 1)\n        }\n        innerSumSquares(lst, 0, 0)", "        var sum\
    \ : Long = 0\n        for (i <- 0 until lst.length) {\n            if (i % 3 ==\
    \ 0) {\n                sum += lst(i) * lst(i)\n            } else if (i % 4 ==\
    \ 0) {\n                sum += lst(i) * lst(i) * lst(i)\n            } else {\n\
    \                sum += lst(i)\n            }\n        }\n        return sum",
  "        var sum : Long = 0\n        for (i <- 0 until lst.length) {\n         \
    \   if (i % 3 == 0) {\n                sum += lst(i) * lst(i)\n            } else\
    \ if (i % 4 == 0) {\n                sum += lst(i) * lst(i) * lst(i)\n       \
    \     } else {\n                sum += lst(i)\n            }\n        }\n    \
    \    return sum", "        // Your code goes here\n        // Return the sum\n\
    \        var sum : Long = 0\n        for(x <- lst) {\n            sum += x\n \
    \       }\n        return sum", "        var total : Long = 0\n        var i :\
    \ Int = 0\n        for (i <- 0 until lst.length) {\n            if (i % 3 == 0)\
    \ {\n                total += lst(i) * lst(i)\n            } else if (i % 4 ==\
    \ 0) {\n                total += lst(i) * lst(i) * lst(i)\n            } else\
    \ {\n                total += lst(i)\n            }\n        }\n        return\
    \ total", '    // "', "      val x = ListBuffer[Long]()\n      var i = 0\n   \
    \   while (i < lst.length) {\n        if (i % 3 == 0) x += lst(i) * lst(i)\n \
    \       else if (i % 4 == 0) x += lst(i) * lst(i) * lst(i)\n        else x +=\
    \ lst(i)\n        i += 1\n      }\n      x.sum", "        // Your code goes here\n\
    \        return lst.map(getSquareOrCube).sum", "        var sum = 0l\n       \
    \ for (i <- 0 until lst.length) {\n            if (i % 3 == 0) {\n           \
    \     sum += lst(i) * lst(i)\n            } else if (i % 4 == 0) {\n         \
    \       sum += lst(i) * lst(i) * lst(i)\n            } else {\n              \
    \  sum += lst(i)\n            }\n        }\n        return sum", "        // Your\
    \ code goes here.\n        lst.zipWithIndex.map{case (x, i) => \n            if\
    \ (i % 3 == 0) x * x\n            else if (i % 4 == 0) x * x * x\n           \
    \ else x\n        }.sum", "    \tvar sum = 0L\n    \tfor (i <- 0 until lst.length)\
    \ {\n    \t\tif (i % 3 == 0) sum += lst(i) * lst(i)\n    \t\telse if (i % 4 ==\
    \ 0) sum += lst(i) * lst(i) * lst(i)\n    \t\telse sum += lst(i)\n    \t}\n  \
    \  \tsum", '        return lst.zipWithIndex.map(x => if (x._2 % 3 == 0) x._1 *
    x._1 else if (x._2 % 4 == 0 && x._2 % 3 != 0) x._1 * x._1 * x._1 else x._1).sum',
  "        var sum = 0l\n        for (i <- 0 until lst.length) {\n            val\
    \ entry = lst(i)\n            if (i % 3 == 0) {\n                sum += pow(entry,\
    \ 2).toLong\n            } else if (i % 4 == 0 && i % 3 != 0) {\n            \
    \    sum += pow(entry, 3).toLong\n            } else {\n                sum +=\
    \ entry\n            }\n        }\n        return sum", "        var answer :\
    \ Long = 0l\n        var i : Int = 0\n        while (i < lst.length) {\n     \
    \       if (i % 3 == 0) {\n                answer += lst(i) * lst(i)\n       \
    \     }\n            else if (i % 4 == 0) {\n                answer += lst(i)\
    \ * lst(i) * lst(i)\n            }\n            else {\n                answer\
    \ += lst(i)\n            }\n            i += 1\n        }\n        return answer",
  "        var out = 0l\n        var i = 0\n        while (i < lst.length) {\n   \
    \         if (i % 3 == 0) out += lst(i) * lst(i)\n            else if (i % 4 ==\
    \ 0) out += lst(i) * lst(i) * lst(i)\n            else out += lst(i)\n       \
    \     i += 1\n        }\n        out", "        var s = 0l\n        for (i <-\
    \ 0 until lst.length) {\n            s += lst(i) * lst(i)\n        }\n       \
    \ s", "        var i : Int = 0\n        var sum : Long = 0\n        while (i <\
    \ lst.length) {\n            if (i % 3 == 0) {\n                sum += lst(i)\
    \ * lst(i)\n            } else if (i % 4 == 0) {\n                sum += lst(i)\
    \ * lst(i) * lst(i)\n            } else {\n                sum += lst(i)\n   \
    \         }\n            i += 1\n        }\n        return sum", "        lst.zipWithIndex.map(pair\
    \ => pair._1 * (if (pair._2 % 3 == 0) {\n            val t = if (pair._2 % 4 ==\
    \ 0) 1 else 0\n            2 - t\n        } else 1)).sum", "        return lst.zipWithIndex.map(entry\
    \ => {\n            if (entry._2 % 3 == 0) {\n                return pow(entry._1,\
    \ 2).toLong\n            } else if (entry._2 % 4 == 0 && entry._2 % 3 != 0) {\n\
    \                return pow(entry._1, 3).toLong\n            } else {\n      \
    \          return entry._1\n            }\n        }).sum", "    var i = 0;\n\
    \    var num = 0l;\n    for (i <- 0 to lst.length-1) {\n    \tif (i % 3 == 0)\
    \ {\n    \t\tnum += lst(i) * lst(i);\n    \t}\n    \telse if (i % 4 == 0 && i\
    \ % 3 != 0) {\n    \t\tnum += lst(i) * lst(i) * lst(i);\n    \t}\n    \telse {\n\
    \    \t\tnum += lst(i);\n    \t}", "        lst.indices.foldLeft(0l)((acc, i)\
    \ => acc + lst(i) * (i % 3 match {\n            case 0 => i % 4 match {\n    \
    \            case 0 => 3\n                case _ => 2\n            }\n       \
    \     case _ => 1\n        }))", "        // Your solution here\n        0", " \
    \       var i = 0\n        var sum = 0l\n        while (i < lst.length) {\n  \
    \          if (i % 3 == 0) sum += lst(i) * lst(i)\n            else if (i % 4\
    \ == 0) sum += lst(i) * lst(i) * lst(i)\n            else sum += lst(i)\n    \
    \        i += 1\n        }\n        sum", "        var sum = 0l.toLong\n     \
    \   for (i <- 0 until lst.length) {\n            if (i % 3 == 0) {\n         \
    \       sum += lst(i) * lst(i)\n            } else if (i % 4 == 0) {\n       \
    \         sum += lst(i) * lst(i) * lst(i)\n            } else {\n            \
    \    sum += lst(i)\n            }\n        }\n        return sum", "        //\
    \ Given a List[Long], return a Long\n        var result : Long = 0\n        for\
    \ (i <- lst.indices) {\n            if (i % 3 == 0) {\n                result\
    \ += pow(lst(i), 2).toLong\n            } else if (i % 4 == 0 && i % 3 != 0) {\n\
    \                result += pow(lst(i), 3).toLong\n            } else {\n     \
    \           result += lst(i)\n            }\n        }\n        return result",
  "\t\tvar sum = 0l.toLong\n\t\tvar i = 0\n\t\tlst.foreach(i => {\n\t\t\tif (i % 3\
    \ == 0) {\n\t\t\t\tsum += i * i\n\t\t\t} else if (i % 4 == 0) {\n\t\t\t\tsum +=\
    \ i * i * i\n\t\t\t} else {\n\t\t\t\tsum += i\n\t\t\t}\n\t\t})\n\t\tsum", "  \
    \      var sum = 0l\n        for (i <- 0 until lst.length) {\n            if (i\
    \ % 3 == 0) {\n                sum += lst(i) * lst(i)\n            } else if (i\
    \ % 4 == 0) {\n                sum += lst(i) * lst(i) * lst(i)\n            }\
    \ else {\n                sum += lst(i)\n            }\n        }\n        return\
    \ sum", "        return lst.zipWithIndex.map(x => {\n            val index = x._2;\
    \ val value = x._1\n            if (index % 3 == 0) value * value\n          \
    \  else if (index % 4 == 0) value * value * value\n            else value\n  \
    \      }).sum", "        if (lst.length == 0) 0\n        else {\n            var\
    \ n = lst.length\n            var result = 0l\n            var i = 0\n       \
    \     while (i < n) {\n                val val1 = lst(i)\n                if (i\
    \ % 3 == 0) result += val1 * val1\n                else if (i % 4 == 0) result\
    \ += val1 * val1 * val1\n                else result += val1\n               \
    \ i += 1\n            }\n            result\n        }", "        if (lst.isEmpty)\
    \ return 0\n        val total = (0 until lst.length).map(i => {\n            val\
    \ x = lst(i)\n            if (i % 3 == 0 && i % 4 != 0) x * x\n            else\
    \ if (i % 4 == 0) x * x * x\n            else x\n        }).sum\n        return\
    \ total", "        var total = 0L\n        for (i <- 0 until lst.length) {\n \
    \           if (i % 3 == 0) total += lst(i) * lst(i)\n            else if (i %\
    \ 4 == 0) total += lst(i) * lst(i) * lst(i)\n            else total += lst(i)\n\
    \        }\n        return total", "        var sum = 0L\n        for (i <- lst.indices)\n\
    \            if (i % 3 == 0)\n                sum += lst(i) * lst(i)\n       \
    \     else if (i % 4 == 0)\n                sum += lst(i) * lst(i) * lst(i)\n\
    \            else\n                sum += lst(i)\n        return sum", "     \
    \   var sum : Long = 0\n        for (i <- 0 until lst.length) {\n            if\
    \ (i % 3 == 0) sum += lst(i) * lst(i)\n            else if (i % 4 == 0) sum +=\
    \ lst(i) * lst(i) * lst(i)\n            else sum += lst(i)\n        }\n      \
    \  return sum", "        lst.zipWithIndex.map{case (x,i) => {\n            if\
    \ (i % 3 == 0) x * x\n            else if (i % 4 == 0) x * x * x\n           \
    \ else x\n        }}.sum", "        if (lst.isEmpty) {\n            0\n      \
    \  } else {\n            val head = lst.head\n            val tail = lst.tail\n\
    \            val head_index = lst.indexOf(head)\n            head_index match\
    \ {\n                case x if x % 3 == 0 && x % 4 == 0 => sumSquares(head * head\
    \ * head :: tail)\n                case x if x % 3 == 0 => sumSquares(head * head\
    \ :: tail)\n                case x if x % 4 == 0 => sumSquares(head * head * head\
    \ :: tail)\n                case _ => sumSquares(head :: tail)\n            }\n\
    \        }", "        (1l.toLong /: lst.zipWithIndex) ((total,value) => total\
    \ + ((value._2 + 1) match {\n            case a if a % 3 == 0 => value._1 * value._1\n\
    \            case b if b % 4 == 0 && b % 3 != 0 => value._1 * value._1 * value._1\n\
    \            case _ => value._1\n        }))", "        // TODO\n        0", " \
    \       var z = 0l.toLong\n        for (x <- 0 until lst.length) {\n         \
    \   if (x % 3 == 0) z += pow(lst(x), 2).toLong\n            else if (x % 4 ==\
    \ 0) z += pow(lst(x), 3).toLong\n            else z += lst(x)\n        }\n   \
    \     return z", "        // your solution here\n        0", "        // WRITE\
    \ CODE HERE\n        return 0;", "        //this is the functional way.\n    \
    \    //lst.zipWithIndex.map{case (x, i) => if (i % 3 == 0) x * x else if (i %\
    \ 4 == 0) x * x * x else x}.sum\n\n        //this is the imperative way\n    \
    \    var sum = 0l\n        var i = 0\n        while (i < lst.length) {\n     \
    \       if (i % 3 == 0) sum += lst(i) * lst(i)\n            else if (i % 4 ==\
    \ 0) sum += lst(i) * lst(i) * lst(i)\n            else sum += lst(i)\n       \
    \     i += 1\n        }\n        sum", "        def recurse(lst : List[Long],\
    \ index : Int, acc : Long) : Long = {\n            if (lst.isEmpty) acc\n    \
    \        else {\n                val value = \n                    if (index %\
    \ 3 == 0 && index % 4 == 0) {\n                        lst.head * lst.head * lst.head\n\
    \                    } else if (index % 3 == 0) {\n                        lst.head\
    \ * lst.head\n                    } else if (index % 4 == 0) {\n             \
    \           lst.head * lst.head * lst.head\n                    } else {\n   \
    \                     lst.head\n                    }\n                recurse(lst.tail,\
    \ index + 1, acc + value)\n            }\n        }\n        recurse(lst, 0, 0)",
  "        var sum = 0L\n        for (i <- 0 until lst.length) {\n            var\
    \ x = lst(i)\n            if (i % 3 == 0) {\n                x = x * x\n     \
    \       }\n            if (i % 4 == 0 && i % 3 != 0) {\n                x = x\
    \ * x * x\n            }\n            sum += x\n        }\n        return sum",
  '        return 0l.toLong', "        var sum = 0L\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 3 == 0) {\n                sum += lst(i) * lst(i)\n \
    \           } else if (i % 4 == 0) {\n                sum += lst(i) * lst(i) *\
    \ lst(i)\n            } else {\n                sum += lst(i)\n            }\n\
    \        }\n        return sum", "        // uses the fact that scala.math._ is\
    \ implicitly imported\n        lst.zipWithIndex.map(elem => {\n            elem._2\
    \ match {\n                case e if e % 4 == 0 && e % 3 != 0 => pow(elem._1,\
    \ 3).toLong\n                case e if e % 3 == 0 => pow(elem._1, 2).toLong\n\
    \                case _ => elem._1\n            }\n        }).foldLeft(0l.toLong)(_\
    \ + _)", '        lst.indices.foldLeft(0L)((accum, index) => accum + (if (index
    % 3 == 0) pow(lst(index), 2).toLong else if (index % 4 == 0) pow(lst(index), 3).toLong
    else lst(index)))', "        // Your code here\n        return 0l", '        lst.zipWithIndex.map(x
    => x._1 * x._1 * (x._2 % 3 == 0) + x._1 * x._1 * x._1 * (x._2 % 4 == 0 && x._2
    % 3 != 0)).sum', "        var sum = 0l\n        var i = 0\n        while (i <\
    \ lst.length) {\n            if (i % 3 == 0) {\n                sum += lst(i)\
    \ * lst(i)\n            } else if (i % 4 == 0) {\n                sum += lst(i)\
    \ * lst(i) * lst(i)\n            } else {\n                sum += lst(i)\n   \
    \         }\n            i += 1\n        }\n        return sum", "        var\
    \ sum = 0l.toLong\n        var i = 0\n        for (i <- 0 until lst.length) {\n\
    \            if (i % 3 == 0) {\n                sum += lst(i) * lst(i)\n     \
    \       } else if (i % 4 == 0) {\n                sum += lst(i) * lst(i) * lst(i)\n\
    \            } else {\n                sum += lst(i)\n            }\n        }\n\
    \        return sum", "        val result = lst.zipWithIndex.map(m => if (m._2\
    \ % 3 == 0) m._1 * m._1 else if (m._2 % 4 == 0 && m._2 % 3 != 0) m._1 * m._1 *\
    \ m._1 else m._1).sum\n        result", "        val squares = lst.zipWithIndex.map\
    \ {case (v, i) => if (i % 3 == 0) v * v else v}\n        val cubes = squares.zipWithIndex.map\
    \ {case (v, i) => if (i % 4 == 0 && i % 3 != 0) v * v * v else v}\n        cubes.sum",
  "        var sum : Long = 0;\n        for (i <- 0 until lst.length) {\n        \
    \    if (i % 3 == 0) {\n                sum += pow(lst(i), 2).toLong;\n      \
    \      } else if (i % 4 == 0) {\n                sum += pow(lst(i), 3).toLong;\n\
    \            } else {\n                sum += lst(i);\n            }\n       \
    \ }\n        return sum;", "        var sum = 0l\n        for(i <- 0 until lst.length)\
    \ {\n            val entry = lst(i)\n            val index = i + 1\n         \
    \   if(index % 4 == 0 && index % 3 != 0) {\n                sum += pow(entry,\
    \ 3).toLong\n            } else if(index % 3 == 0) {\n                sum += pow(entry,\
    \ 2).toLong\n            } else {\n                sum += entry\n            }\n\
    \        }\n        return sum", '        0', '        lst.zipWithIndex.map(x
    => if (x._2 % 3 == 0) pow(x._1, 2) else if (x._2 % 4 == 0 && x._2 % 3 != 0) pow(x._1,
    3) else x._1).sum.toLong', "        // ADD YOUR CODE HERE\n        var a = lst.zipWithIndex\n\
    \        var b = a.map(t => {\n            if (t._2 % 3 == 0) {\n            \
    \    t._1 * t._1\n            } else if (t._2 % 4 == 0 && t._2 % 3 != 0) {\n \
    \               t._1 * t._1 * t._1\n            } else {\n                t._1\n\
    \            }\n        })\n        return b.sum", "        var sum : Long = 0l\n\
    \        for (i <- 0 until lst.length) {\n            val num = lst(i)\n     \
    \       if (i % 3 == 0) sum += num * num\n            else if (i % 4 == 0) sum\
    \ += num * num * num\n            else sum += num\n        }\n        return sum",
  "    \tlst.zipWithIndex.map(x => \n    \t\tif (x._2 % 3 == 0) x._1 * x._1 \n   \
    \ \t\telse if (x._2 % 4 == 0) x._1 * x._1 * x._1 \n    \t\telse x._1).sum", " \
    \       def helper(lst : List[Long], index : Int) : Long = {\n            if (lst.isEmpty)\
    \ 0\n            else if (index % 4 == 0 && index % 3 != 0) helper(lst.tail, index\
    \ + 1) + pow(lst.head, 3).toLong\n            else if (index % 3 == 0) helper(lst.tail,\
    \ index + 1) + pow(lst.head, 2).toLong\n            else helper(lst.tail, index\
    \ + 1) + lst.head\n        }\n        helper(lst, 1)", "        var sum = 0L\n\
    \        lst.zipWithIndex.foreach(x => sum += if (x._2 % 3 == 0) x._1 * x._1 else\
    \ if (x._2 % 4 == 0) x._1 * x._1 * x._1 else x._1)\n        sum", "        //\
    \ TODO\n        return 0", "        var sum : Long = 0\n        var i : Int =\
    \ 0\n        while (i < lst.length) {\n            if (i % 3 == 0) sum += lst(i)\
    \ * lst(i)\n            else if (i % 4 == 0) sum += lst(i) * lst(i) * lst(i)\n\
    \            else sum += lst(i)\n            i += 1\n        }\n        return\
    \ sum", "        var sum : Long = 0\n        for(i <- 0 until lst.length) {\n\
    \            if (i % 3 == 0) {\n                sum += lst(i) * lst(i)\n     \
    \       } else if (i % 4 == 0) {\n                sum += lst(i) * lst(i) * lst(i)\n\
    \            } else {\n                sum += lst(i)\n            }\n        }\n\
    \        return sum", '        return lst.zipWithIndex.map(x => if (x._2 % 3 ==
    0) pow(x._1, 2).toLong else if (x._2 % 4 == 0 && x._2 % 3 != 0) pow(x._1, 3).toLong
    else x._1).sum', "        var sum = 0l\n        var index = 0\n        for (l\
    \ <- lst) {\n            if (index % 3 == 0) sum += l * l\n            else if\
    \ (index % 4 == 0) sum += l * l * l\n            else sum += l\n            index\
    \ += 1\n        }\n        sum", "        val squares = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var sum = 0L\n        var current = 0\n        while (current < lst.length)\
    \ {\n            if (current % 3 == 0) squares += (lst(current) * lst(current))\n\
    \            else if (current % 4 == 0) squares += (lst(current) * lst(current)\
    \ * lst(current))\n            else squares += lst(current)\n            current\
    \ += 1\n        }\n        squares.toList.foreach(x => sum += x)\n        sum",
  "        var sum : Long = 0\n        for (x <- 0 until lst.length) {\n         \
    \   if (x % 3 == 0) sum += lst(x) * lst(x)\n            else if (x % 4 == 0) sum\
    \ += lst(x) * lst(x) * lst(x)\n            else sum += lst(x)\n        }\n   \
    \     return sum", "        var result = 0l\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 3 == 0) result += lst(i) * lst(i)\n            else if\
    \ (i % 4 == 0) result += lst(i) * lst(i) * lst(i)\n            else result +=\
    \ lst(i)\n        }\n        return result", '        return lst.zipWithIndex.map(x
    => if (x._2 % 3 == 0) x._1 * x._1 else if (x._2 % 4 == 0 && x._2 % 3 != 0) x._1
    * x._1 * x._1 else x._1).sum', "        // Your code goes here...\n        lst.zipWithIndex.map(x\
    \ => \n            if (x._2 % 3 == 0) x._1 * x._1\n            else if (x._2 %\
    \ 4 == 0 && x._2 % 3 != 0) x._1 * x._1 * x._1\n            else x._1\n       \
    \ ).sum", "        var sum = 0l\n        for (i <- lst.indices) {\n          \
    \  if (i % 3 == 0) sum += lst(i) * lst(i)\n            else if (i % 4 == 0) sum\
    \ += lst(i) * lst(i) * lst(i)\n            else sum += lst(i)\n        }\n   \
    \     sum", "        def cube(x : Long) : Long = x * x * x\n        def square(x\
    \ : Long) : Long = x * x\n        var result = 0l\n        var counter = 0\n \
    \       for (i <- lst) {\n            if (counter % 3 == 0 && counter % 4 != 0)\
    \ {\n                result += square(i)\n            } else if (counter % 4 ==\
    \ 0) {\n                result += cube(i)\n            } else {\n            \
    \    result += i\n            }\n            counter += 1\n        }\n       \
    \ result", "        // Initialize our sum to 0.0\n        var sum = 0l\n     \
    \   // We want to make sure that we do not go beyond the limit of our list\n \
    \       for (i <- 0 until lst.length) {\n            // If the index of the entry\
    \ is a multiple of 3 and a multiple of 4, we square its value\n            if\
    \ (i % 3 == 0 && i % 4 == 0) {\n                sum += pow(lst(i), 2.0).toLong\n\
    \            }\n            // If the index of the entry is a multiple of 3 and\
    \ not a multiple of 4, we cube its value\n            else if (i % 3 == 0 && i\
    \ % 4 != 0) {\n                sum += pow(lst(i), 3.0).toLong\n            }\n\
    \            // Otherwise, if the index of the entry is not a multiple of 3 or\
    \ 4, we leave the value as is\n            else {\n                sum += lst(i)\n\
    \            }\n        }\n        // Return the sum\n        sum", "        var\
    \ sq = 0L\n        var sqs = 0L\n        for (i <- lst.indices) {\n          \
    \  if (i % 3 == 0) {\n                sq = lst(i) * lst(i)\n                sqs\
    \ += sq\n            }\n            else if (i % 4 == 0 && i % 3 != 0) {\n   \
    \             sq = lst(i) * lst(i) * lst(i)\n                sqs += sq\n     \
    \       }\n            else {\n                sqs += lst(i)\n            }\n\
    \        }\n        return sqs", "        var ret : Long = 0;\n        for (i\
    \ <- 0 until lst.length) {\n            if (i % 3 == 0) {\n                ret\
    \ += lst(i) * lst(i);\n            } else if (i % 4 == 0) {\n                ret\
    \ += lst(i) * lst(i) * lst(i);\n            } else {\n                ret += lst(i);\n\
    \            }\n        }\n        return ret;", "        var result = 0l.toLong\n\
    \        for (i <- 0 until lst.length) {\n            if (i % 3 == 0) result +=\
    \ lst(i) * lst(i)\n            else if (i % 4 == 0) result += lst(i) * lst(i)\
    \ * lst(i)\n            else result += lst(i)\n        }\n        return result",
  "        var ans = 0l\n        lst.zipWithIndex.foreach(x => {\n            val\
    \ e = x._1\n            val i = x._2\n            if (i % 3 == 0) ans += e * e\n\
    \            else if (i % 4 == 0) ans += e * e * e\n            else ans += e\n\
    \        })\n        ans", "    \tlst.zipWithIndex.map(x => if (x._2 % 3 == 0)\
    \ x._1 * x._1\n    \t\t\t\t\t\t\t  else if (x._2 % 4 == 0 && x._2 % 3 != 0) x._1\
    \ * x._1 * x._1\n    \t\t\t\t\t\t\t  else x._1).sum", '        ???', "       \
    \ if (lst.isEmpty) 0l\n        else {\n            val n = lst.size\n        \
    \    val ret = (0 until n).map(i => {\n                if (i % 3 == 0 && i % 4\
    \ == 0) lst(i) * lst(i) * lst(i)\n                else if (i % 3 == 0) lst(i)\
    \ * lst(i)\n                else if (i % 4 == 0) lst(i) * lst(i) * lst(i)\n  \
    \              else lst(i)\n            }).sum\n            ret\n        }", " \
    \       var result : Long = 0;\n        for (i <- lst.indices) {\n           \
    \ if (i % 3 == 0) result += lst(i) * lst(i);\n            else if (i % 4 == 0)\
    \ result += lst(i) * lst(i) * lst(i);\n            else result += lst(i);\n  \
    \      }\n        return result;", '      lst.zipWithIndex.map(x => if (x._2 %
    3 == 0) x._1 * x._1 else x._1).zipWithIndex.map(x => if (x._2 % 4 == 0 && x._2
    % 3 != 0) x._1 * x._1 * x._1 else x._1).foldLeft(0l.toLong)(_ + _)', "       \
    \ var ret : Long = 0l\n        var index : Int = 0\n        while (index < lst.length)\
    \ {\n            if (index % 3 == 0) ret += lst(index) * lst(index)\n        \
    \    else if (index % 4 == 0) ret += lst(index) * lst(index) * lst(index)\n  \
    \          else ret += lst(index)\n            index += 1\n        }\n       \
    \ return ret", '      // INSERT YOUR CODE HERE', '        return lst.zipWithIndex.map(x
    => if (x._2 % 3 == 0) pow(x._1, 2).toLong else if (x._2 % 4 == 0 && x._2 % 3 !=
    0) pow(x._1, 3).toLong else x._1).sum', "    \tvar ret : Long = 0\n    \tfor (i\
    \ <- 0 until lst.length) {\n    \t\tval entry = lst(i)\n    \t\tif (i % 3 == 0)\
    \ ret += entry * entry\n    \t\telse if (i % 4 == 0) ret += entry * entry * entry\n\
    \    \t\telse ret += entry\n    \t}\n    \tret", "        var sum : Long = 0l.toLong\n\
    \        for (i <- 0 until lst.length) {\n            if (i % 3 == 0) {\n    \
    \            sum += lst(i) * lst(i)\n            } else if (i % 4 == 0) {\n  \
    \              sum += lst(i) * lst(i) * lst(i)\n            } else {\n       \
    \         sum += lst(i)\n            }\n        }\n        return sum", "    \
    \    def sqrCube(input : Long, index : Int) : Long = {\n            if (index\
    \ % 3 == 0 && index % 4 == 0) pow(input, 3).toLong\n            else if (index\
    \ % 3 == 0) pow(input, 2).toLong\n            else if (index % 4 == 0) pow(input,\
    \ 3).toLong\n            else input\n        }\n        lst.zipWithIndex.map(x\
    \ => sqrCube(x._1, x._2)).sum", "        var total : Long = 0\n        for (i\
    \ <- 0 until lst.length) {\n            if (i % 3 == 0) {\n                total\
    \ += lst(i) * lst(i)\n            } else if (i % 4 == 0) {\n                total\
    \ += lst(i) * lst(i) * lst(i)\n            } else {\n                total +=\
    \ lst(i)\n            }\n        }\n        return total", '        lst.zipWithIndex.map(p
    => if (p._2 % 3 == 0) p._1 * p._1 else if (p._2 % 4 == 0 && p._2 % 3 != 0) p._1
    * p._1 * p._1 else p._1).sum', "        lst.zipWithIndex.map(x => {\n        \
    \    val number = x._1\n            val index = x._2\n            val cube = pow(number,\
    \ 3)\n            val square = pow(number, 2)\n            if (index % 4 == 0\
    \ && index % 3 != 0) cube\n            else if (index % 3 == 0) square\n     \
    \       else number\n        }).sum.toLong", "    \tvar sum : Long = 0l\n    \t\
    for (i <- 0 until lst.length) {\n    \t\tif (i % 3 == 0) {\n    \t\t\tsum += lst(i)\
    \ * lst(i)\n    \t\t} else if (i % 4 == 0 && i % 3 != 0) {\n    \t\t\tsum += lst(i)\
    \ * lst(i) * lst(i)\n    \t\t} else {\n    \t\t\tsum += lst(i)\n    \t\t}\n  \
    \  \t}\n    \treturn sum", "        return lst.zipWithIndex.map(x => x._1 * x._1\
    \ * (if (x._2 % 3 == 0) 1 else 0) * (if (x._2 % 4 == 0) 1 else 0) + \n       \
    \                                         x._1 * x._1 * x._1 * (if (x._2 % 4 ==\
    \ 0) 1 else 0) * (if (x._2 % 3 == 0) 0 else 1) + \n                          \
    \                      x._1 * (if (x._2 % 3 != 0 && x._2 % 4 != 0) 1 else 0)).sum",
  '        lst.zipWithIndex.map(x => x._1 * pow(x._1, ((x._2 % 3) + (x._2 % 4) * (1
    - (x._2 % 3))))).sum.toLong', "        var l = List[Long]()\n        var i = 0\n\
    \        while (i < lst.length) {\n            if (i % 3 == 0) l = lst(i).toLong\
    \ * lst(i).toLong :: l\n            else if (i % 4 == 0 && i % 3 != 0) l = lst(i).toLong\
    \ * lst(i).toLong * lst(i).toLong :: l\n            else l = lst(i).toLong ::\
    \ l\n            i += 1\n        }\n        return l.sum", '        // Write your
    code here', "        var s = 0\n        for (i <- 0 until lst.length) {\n    \
    \        if (i % 3 == 0) {\n                s += lst(i) * lst(i)\n           \
    \ } else if (i % 4 == 0) {\n                s += lst(i) * lst(i) * lst(i)\n  \
    \          } else {\n                s += lst(i)\n            }\n        }\n \
    \       return s", "        //Replace \"None\" with your code below\n        None",
  "      //\n      var sum = 0.toLong\n      for(i <- 0 until lst.length) {\n    \
    \    val entry = lst(i)\n        if(i % 3 == 0) sum += entry * entry\n       \
    \ else if(i % 4 == 0) sum += entry * entry * entry\n        else sum += entry\n\
    \      }\n      sum", "        // Your code here\n        return 0", "       \
    \ var sum = 0l.toLong\n        for (i <- 0 until lst.length) {\n            if\
    \ (i % 3 == 0) {\n                sum += pow(lst(i), 2).toLong\n            }\
    \ else if (i % 4 == 0) {\n                sum += pow(lst(i), 3).toLong\n     \
    \       } else {\n                sum += lst(i)\n            }\n        }\n  \
    \      return sum", "    \treturn lst.zipWithIndex.map(x => (if(x._2 % 3 == 0)\
    \ x._1 * x._1 else if(x._2 % 4 == 0 && x._2 % 3 != 0) x._1 * x._1 * x._1 else\
    \ x._1)).sum", "        lst.zipWithIndex.map(p => {\n            if (p._2 % 3\
    \ == 0) p._1 * p._1\n            else if (p._2 % 4 == 0) p._1 * p._1 * p._1\n\
    \            else p._1\n        }).sum", "        var sum : Long = 0\n       \
    \ for(i <- 0 until lst.length) {\n            if(i % 3 == 0) {\n             \
    \   sum += lst(i) * lst(i)\n            } else if(i % 4 == 0 && i % 3 != 0) {\n\
    \                sum += lst(i) * lst(i) * lst(i)\n            } else {\n     \
    \           sum += lst(i)\n            }\n        }\n        return sum", "  \
    \  \tlst.zipWithIndex.map{case (e, i) => if (i % 3 == 0) e * e else if (i % 4\
    \ == 0 && i % 3 != 0) e * e * e else e}.sum", '        lst.zipWithIndex.map(x
    => if (x._2 % 3 == 0) pow(x._1, 2).toLong else if (x._2 % 4 == 0 && x._2 % 3 !=
    0) pow(x._1, 3).toLong else x._1).sum', "        var sum = 0l\n        for (i\
    \ <- 0 until lst.length) {\n            if (i % 3 == 0) sum += lst(i) * lst(i)\n\
    \            else if (i % 4 == 0) sum += lst(i) * lst(i) * lst(i)\n          \
    \  else sum += lst(i)\n        }\n        return sum", "        if (lst.isEmpty)\
    \ return 0\n        val newLst = lst.zipWithIndex.map(pair => {\n            val\
    \ (value, index) = pair\n            if (index % 3 == 0) value * value\n     \
    \       else if (index % 4 == 0) value * value * value\n            else value\n\
    \        })\n        newLst.sum", "        // BEGIN SOLUTION\n        var sum\
    \ = 0l\n        var mult3 = 3\n        var mult4 = 4\n        for (elem <- lst)\
    \ {\n            if (lst.indexOf(elem) % mult3 == 0 && lst.indexOf(elem) % mult4\
    \ != 0) {\n                sum += pow(elem, 2).toLong\n            } else if (lst.indexOf(elem)\
    \ % mult4 == 0) {\n                sum += pow(elem, 3).toLong\n            } else\
    \ {\n                sum += elem\n            }\n        }\n        sum\n    \
    \    // END SOLUTION", "        var sum = 0l\n        for (i <- lst.indices) {\n\
    \            if (i % 3 == 0) {\n                sum += lst(i) * lst(i)\n     \
    \       } else if (i % 4 == 0) {\n                sum += lst(i) * lst(i) * lst(i)\n\
    \            } else {\n                sum += lst(i)\n            }\n        }\n\
    \        return sum", "\t\tvar sum : Long = 0\n\t\tvar i : Int = 0\n\t\tfor (x\
    \ <- lst) {\n\t\t\tif (i % 3 == 0) {\n\t\t\t\tsum += x * x\n\t\t\t} else if (i\
    \ % 4 == 0 && i % 3 != 0) {\n\t\t\t\tsum += x * x * x\n\t\t\t} else {\n\t\t\t\t\
    sum += x\n\t\t\t}\n\t\t\ti += 1\n\t\t}\n\t\treturn sum", "        if (lst.length\
    \ == 0) return 0\n        var arr = Array.fill(lst.length)(0L)\n        for (i\
    \ <- 0 until lst.length) {\n            if (i % 3 == 0) arr(i) = lst(i) * lst(i)\n\
    \            else if (i % 4 == 0) arr(i) = lst(i) * lst(i) * lst(i)\n        \
    \    else arr(i) = lst(i)\n        }\n        arr.sum", '        return lst.zipWithIndex.map(e
    => if (e._2 % 3 == 0) e._1 * e._1 else if (e._2 % 4 == 0 && e._2 % 3 != 0) e._1
    * e._1 * e._1 else e._1).sum', "        // This function shall be recursive. The\
    \ function shall also be tail recursive.\n        // This function is tail recursive.\n\
    \        // This function is recursive.\n        // The return type of this function\
    \ shall be a long.\n        // The complexity of this function shall be linear.\n\
    \        // The best case running time of this function shall be O(n).\n     \
    \   // The worst case running time of this function shall be O(n).\n        lst\
    \ match {\n            case _ if lst.length == 0 =>\n                0l.toLong\n\
    \            case _ =>\n                val x : Long = lst.head\n            \
    \    if (lst.length % 3 == 0 && lst.length % 4 != 0)\n                    sumSquares(lst.tail)\
    \ + x*x\n                else if (lst.length % 4 == 0)\n                    sumSquares(lst.tail)\
    \ + x*x*x\n                else\n                    sumSquares(lst.tail) + x\n\
    \        }", "        val d = new Array[Boolean](lst.length)\n        var s =\
    \ 0l\n        for (i <- 0 until lst.length) d(i) = false\n        for (i <- 0\
    \ until lst.length) {\n            if (i % 3 == 0) {\n                d(i) = true\n\
    \                s += lst(i) * lst(i)\n            }\n            if (i % 4 ==\
    \ 0 && i % 3 != 0) {\n                d(i) = true\n                s += lst(i)\
    \ * lst(i) * lst(i)\n            }\n        }\n        for (i <- 0 until lst.length)\
    \ if (!d(i)) s += lst(i)\n        s", "        var res = 0l\n        var i = 0\n\
    \        for (n <- lst) {\n            if (i % 3 == 0) res += n * n\n        \
    \    else if (i % 4 == 0) res += n * n * n\n            else res += n\n      \
    \      i += 1\n        }\n        res", "        var sum = 0l\n        for (i\
    \ <- 0 until lst.length) {\n            if (i % 3 == 0) sum += lst(i) * lst(i)\n\
    \            else if (i % 4 == 0) sum += lst(i) * lst(i) * lst(i)\n          \
    \  else sum += lst(i)\n        }\n        return sum", "        def func(sum :\
    \ Long, it : Iterator[Long], func_code : Int) : Long = {\n            if (!it.hasNext)\
    \ sum\n            else {\n                var v = it.next()\n               \
    \ if (func_code == 0) {\n                    v = v * v\n                } else\
    \ if (func_code == 1) {\n                    v = v * v * v\n                }\n\
    \                func(sum + v, it, 0)\n            }\n        }\n        var lst2\
    \ = lst.toIterator\n        var sum = 0l\n        var i = 0\n        while (lst2.hasNext)\
    \ {\n            val x = lst2.next()\n            if (i % 3 == 0) {\n        \
    \        sum = func(sum, List(x).toIterator, 0)\n            } else if (i % 4\
    \ == 0) {\n                sum = func(sum, List(x).toIterator, 1)\n          \
    \  } else {\n                sum += x\n            }\n            i += 1\n   \
    \     }\n        sum", "        var i = 0\n        var counter = 0\n        var\
    \ lst2 = ListBuffer[Long]()\n        for (i <- lst) {\n            counter +=\
    \ 1\n            if (counter % 3 == 0) {\n                lst2 += i * i\n    \
    \        } else if (counter % 4 == 0) {\n                lst2 += i * i * i\n \
    \           } else {\n                lst2 += i\n            }\n        }\n  \
    \      return lst2.sum", "        // Your Code Here\n        return 0", "    \
    \    var sum = 0L\n        for (i <- 0 until lst.length) {\n            var elem\
    \ = lst(i)\n            if (i % 3 == 0) {\n                sum += elem * elem\n\
    \            } else if (i % 4 == 0) {\n                sum += elem * elem * elem\n\
    \            } else {\n                sum += elem\n            }\n        }\n\
    \        return sum", "        var sum = 0L\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 3 == 0) {\n                sum += lst(i) * lst(i)\n \
    \           } else if (i % 4 == 0) {\n                sum += lst(i) * lst(i) *\
    \ lst(i)\n            } else {\n                sum += lst(i)\n            }\n\
    \        }\n        return sum", '        // Write your code here.', "       \
    \ if (lst.length == 0) 0\n        else {\n            var ret = 0L\n         \
    \   for (i <- 0 until lst.length) {\n                if (i % 3 == 0) ret += lst(i)\
    \ * lst(i)\n                else if (i % 4 == 0) ret += lst(i) * lst(i) * lst(i)\n\
    \                else ret += lst(i)\n            }\n            ret\n        }",
  "        var total : Long = 0\n        for (i <- 0 until lst.length) {\n       \
    \     val entry : Long = lst(i)\n            if (i % 3 == 0) {\n             \
    \   total += entry * entry\n            } else if (i % 4 == 0) {\n           \
    \     total += entry * entry * entry\n            } else {\n                total\
    \ += entry\n            }\n        }\n        return total", "        var sum\
    \ : Long = 0\n        for (i <- 0 until lst.length) {\n            if (i % 3 ==\
    \ 0) sum += lst(i) * lst(i)\n            else if (i % 4 == 0) sum += lst(i) *\
    \ lst(i) * lst(i)\n            else sum += lst(i)\n        }\n        return sum",
  '        return -1', "        var result = 0l\n        for(i <- 0 until lst.length)\
    \ {\n            var value = lst(i)\n            if(i % 3 == 0) {\n          \
    \      value = value * value\n            }\n            if(i % 4 == 0 && i %\
    \ 3 != 0) {\n                value = value * value * value\n            }\n  \
    \          result += value\n        }\n        return result", '        return
    -1;', "      // This function is naive. The square is computed and stored in memory,\
    \ then the cubed value is computed and stored in memory, then the \n      // value\
    \ is stored into the output list. This can all be done in place, with only one\
    \ operation.\n      lst.zipWithIndex.map(el => {\n        if (el._2 % 3 == 0)\
    \ pow(el._1, 2).toLong\n        else if (el._2 % 4 == 0 && el._2 % 3 != 0) pow(el._1,\
    \ 3).toLong\n        else el._1\n      }).sum", "        val sums = lst.zipWithIndex.map(t\
    \ => {\n            val i = t._2\n            val n = t._1\n            val n1\
    \ = if (i % 3 == 0) n * n else n\n            val n2 = if (i % 4 == 0 && i % 3\
    \ != 0) n1 * n1 * n1 else n1\n            n2\n        })\n        sums.sum", " \
    \       var total : Long = 0\n        for (i <- 0 until lst.length) {\n      \
    \      if (i % 3 == 0) {\n                total += pow(lst(i), 2).toLong\n   \
    \         } else if (i % 4 == 0) {\n                total += pow(lst(i), 3).toLong\n\
    \            } else {\n                total += lst(i)\n            }\n      \
    \  }\n        return total", "        def S(index : Int, sum : Long) : Long =\
    \ {\n            if (index == lst.length) return sum\n            var e = lst(index)\n\
    \            if (index % 3 == 0) e = e * e\n            if (index % 4 == 0 &&\
    \ index % 3 != 0) e = e * e * e\n            return S(index + 1, sum + e)\n  \
    \      }\n        return S(0, 0)", "        // Your code goes here.\n        //\
    \ Return -1 to denote invalid input.\n        -1", "        def recur(lst : List[Long],\
    \ mult : Long) : Long = {\n            lst match {\n                case Nil =>\
    \ 0\n                case e :: t => pow(e, mult).toLong + recur(t, mult)\n   \
    \         }\n        }\n        var ans = 0.toLong\n        ans += recur(lst,\
    \ 2)\n        ans += recur(lst, 3)\n        ans", "        var index = 0\n   \
    \     var result = 0\n        for (i <- lst) {\n            result += if (index\
    \ % 3 == 0) i * i else if (index % 4 == 0) i * i * i else i\n            index\
    \ += 1\n        }\n        result", '        lst.map((x, i) => x + 1).sum', '        //
    Your code here...', "      val n = lst.length\n      val sqrt = (1 to n).map(i\
    \ => if (i % 3 == 0) lst(i - 1) * lst(i - 1) else lst(i - 1))\n      val sqrtSqrt\
    \ = (1 to n).map(i => if (i % 4 == 0 && i % 3 != 0) sqrt(i - 1) * sqrt(i - 1)\
    \ else sqrt(i - 1))\n      var ans = 0l\n      for (i <- 1 to n) ans += sqrtSqrt(i\
    \ - 1)\n      ans", "        var total : Long = 0l\n        for (i <- 0 until\
    \ lst.length) {\n            if (i % 3 == 0) {\n                total += lst(i)\
    \ * lst(i)\n            } else if (i % 4 == 0) {\n                total += lst(i)\
    \ * lst(i) * lst(i)\n            } else {\n                total += lst(i)\n \
    \           }\n        }\n        return total", "        // Your code goes here!\n\
    \        var n = 0\n        var sum = 0\n        var total = 0\n        for (i\
    \ <- lst) {\n            if (n%3 == 0) {\n                sum = i*i\n        \
    \        total += sum\n            }\n            else if (n%4 == 0 && n%3 !=\
    \ 0) {\n                sum = i*i*i\n                total += sum\n          \
    \  }\n            else {\n                total += i\n            }\n        \
    \    n += 1\n        }\n        return total", '        ???', "        var sum\
    \ : Long = 0\n        for (i <- 0 until lst.length) {\n            if (i % 3 ==\
    \ 0) sum += lst(i) * lst(i)\n            else if (i % 4 == 0) sum += lst(i) *\
    \ lst(i) * lst(i)\n            else sum += lst(i)\n        }\n        return sum",
  "        // Fill in the solution\n        lst.zipWithIndex.map(e => e._1 match {\n\
    \            case x if e._2 % 3 == 0 && e._2 % 4 == 0 => x*x*x\n            case\
    \ x if e._2 % 3 == 0 => x*x\n            case x if e._2 % 4 == 0 => x*x*x\n  \
    \          case x => x\n        }).sum", "        // error check\n        if (lst\
    \ == null) return -1\n        // check for empty list\n        if (lst.isEmpty)\
    \ return 0\n        // lets transform the list by applying the rules\n       \
    \ // since we are going to return the sum, lets just sum it after we square and\
    \ cube the values\n        // square those whose index is a multiple of 3, cube\
    \ those whose index is a multiple of 4 but not a multiple of 3\n        var sum\
    \ : Long = 0\n        for (i <- 0 until lst.length) {\n            if (i % 3 ==\
    \ 0) {\n                sum += lst(i) * lst(i)\n            } else if (i % 4 ==\
    \ 0) {\n                sum += lst(i) * lst(i) * lst(i)\n            } else {\n\
    \                sum += lst(i)\n            }\n        }\n        sum", '        //
    Write your code here', "        lst.zipWithIndex.map(x => {\n            if (x._2\
    \ % 3 == 0) x._1 * x._1\n            else if (x._2 % 4 == 0 && x._2 % 3 != 0)\
    \ x._1 * x._1 * x._1\n            else x._1\n        }).sum", "        // NOTE:\
    \ Please write in the comment above \n        //   \"your implementation\"\n \
    \       // and implement this function\n        0", "        var sum : Long =\
    \ 0\n        for (i <- 0 until lst.length) {\n            if (i % 3 == 0) {\n\
    \                sum += lst(i) * lst(i)\n            } else if (i % 4 == 0) {\n\
    \                sum += lst(i) * lst(i) * lst(i)\n            } else {\n     \
    \           sum += lst(i)\n            }\n        }\n        return sum", "  \
    \      if (lst.isEmpty)\n            0\n        else {\n            val sum =\
    \ lst.zipWithIndex.map(x => if (x._2 % 3 == 0) x._1 * x._1 else if (x._2 % 4 ==\
    \ 0 && x._2 % 3 != 0) x._1 * x._1 * x._1 else x._1).sum\n            sum\n   \
    \     }", "      var sum = 0l.toLong\n      for (i <- 0 until lst.length) {\n\
    \        var num = lst(i)\n        if (i % 3 == 0) num = pow(num, 2).toLong\n\
    \        else if (i % 4 == 0) num = pow(num, 3).toLong\n        sum += num\n \
    \     }\n      sum", '        return lst.zipWithIndex.map(x => if (x._2 % 3 ==
    0) x._1 * x._1 else if (x._2 % 4 == 0 && x._2 % 3 != 0) pow(x._1, 3).toLong else
    x._1).sum', "        var sum = 0l\n        var index = 0\n        while (index\
    \ < lst.length) {\n            if (index % 3 == 0) {\n                sum += pow(lst(index),\
    \ 2).toLong\n            }\n            else if (index % 4 == 0) {\n         \
    \       sum += pow(lst(index), 3).toLong\n            }\n            else {\n\
    \                sum += lst(index)\n            }\n            index += 1\n  \
    \      }\n        return sum", "        // TODO\n        return 0", "        var\
    \ sum = 0l.toLong\n        for (i <- 0 until lst.length) {\n            if (i\
    \ % 3 == 0) {\n                sum += lst(i) * lst(i)\n            } else if (i\
    \ % 4 == 0) {\n                sum += lst(i) * lst(i) * lst(i)\n            }\
    \ else {\n                sum += lst(i)\n            }\n        }\n        return\
    \ sum", "        lst.zipWithIndex.map(p => (p._1, p._2 + 1)).map(p => {\n    \
    \        val (x, idx) = p\n            if (idx % 3 == 0 && idx % 4 == 0)\n   \
    \             x * x * x\n            else if (idx % 3 == 0)\n                x\
    \ * x\n            else if (idx % 4 == 0)\n                x * x * x\n       \
    \     else\n                x\n        }).sum", "        var sum = 0l\n      \
    \  for (i <- 0 until lst.length) {\n            val x = if (i % 3 == 0) {\n  \
    \              pow(lst(i), 2).toLong\n            } else if (i % 4 == 0) {\n \
    \               pow(lst(i), 3).toLong\n            } else {\n                lst(i)\n\
    \            }\n            sum += x\n        }\n        sum", '        lst.zipWithIndex.map(e
    => if (e._2 % 3 == 0) e._1 * e._1 else if (e._2 % 4 == 0 && e._2 % 3 != 0) e._1
    * e._1 * e._1 else e._1).sum', "        val squares = for(i <- lst.indices) yield\
    \ \n            if(i % 3 == 0) lst(i) * lst(i)\n            else if (i % 4 ==\
    \ 0 && i % 3 != 0) lst(i) * lst(i) * lst(i)\n            else lst(i)\n       \
    \ return squares.sum", "        var sum = 0l\n        for (i <- 0 until lst.length)\
    \ {\n            val entry = lst(i)\n            if (i % 3 == 0) sum += entry\
    \ * entry\n            else if (i % 4 == 0) sum += entry * entry * entry\n   \
    \         else sum += entry\n        }\n        sum", '        lst.zipWithIndex.map(x
    => if (x._2 % 3 == 0) x._1 * x._1 else if (x._2 % 4 == 0 && x._2 % 3 != 0) x._1
    * x._1 * x._1 else x._1).sum', "    \tvar sum = 0l.toLong\n    \tfor (i <- 0 until\
    \ lst.length) {\n    \t\tif (i % 3 == 0) sum += lst(i) * lst(i)\n    \t\telse\
    \ if (i % 4 == 0) sum += lst(i) * lst(i) * lst(i)\n    \t\telse sum += lst(i)\n\
    \    \t}\n    \tsum", "    }\n    // \"\n    // This function will take a list\
    \ of integers. For all entries in the list, the function shall square the integer\
    \ entry if its index is a \n    // multiple of 3 and will cube the integer entry\
    \ if its index is a multiple of 4 and not a multiple of 3. The function will not\
    \ \n    // change the entries in the list whose indexes are not a multiple of\
    \ 3 or 4. The function shall then return the sum of all entries. \n    // Examples:\n\
    \    // >>> (1l.toLong, 2l.toLong, 3l.toLong)\n    // List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong)\n    // >>> (1l.toLong, 2l.toLong, 3l.toLong)\n    // List[Long]()\n\
    \    // >>> (1l.toLong, 2l.toLong, 3l.toLong)\n    // List[Long](-1l.toLong, -5l.toLong,\
    \ 2l.toLong, -1l.toLong, -5l.toLong)\n    def sumSquares(lst : Tuple2[Long, Tuple2[Long,\
    \ Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long,\
    \ Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long,\
    \ Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long,\
    \ Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long,\
    \ Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long,\
    \ Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long,\
    \ Tuple2[Long, Tuple2[Long, Tuple2[Long, Tuple2[Long", "        val n = lst.length\n\
    \        (0 until n).map(i => if (i % 3 == 0) pow(lst(i), 2).toLong else if (i\
    \ % 4 == 0) pow(lst(i), 3).toLong else lst(i)).sum", '        lst.zipWithIndex.map(x
    => if (x._2 % 3 == 0) x._1 * x._1 else if (x._2 % 4 == 0 && x._2 % 3 != 0) x._1
    * x._1 * x._1 else x._1).sum', "        def func(lst : List[Long], index : Int,\
    \ acc : Long) : Long = lst match {\n            case Nil => acc\n            case\
    \ x :: xs => if (index % 3 == 0) func(xs, index + 1, acc + x * x) else if (index\
    \ % 4 == 0) func(xs, index + 1, acc + x * x * x) else func(xs, index + 1, acc\
    \ + x)\n        }\n        func(lst, 0, 0)", "      var sum = 0l\n      for (i\
    \ <- 0 until lst.length) {\n        sum += if (i % 3 == 0) {\n          lst(i)\
    \ * lst(i)\n        } else if (i % 4 == 0) {\n          lst(i) * lst(i) * lst(i)\n\
    \        } else {\n          lst(i)\n        }\n      }\n      sum", "       \
    \ var result : Long = 0\n        for (i <- 0 until lst.length) {\n           \
    \ result += if (i % 3 == 0) lst(i) * lst(i)\n            else if (i % 4 == 0)\
    \ lst(i) * lst(i) * lst(i)\n            else lst(i)\n        }\n        return\
    \ result", '        lst.map((d : Long) => (d.toLong, lst.indexOf(d))).map(p =>
    if (p._2 % 3 == 0) p._1 * p._1 else if (p._2 % 4 == 0 && p._2 % 3 != 0) p._1 *
    p._1 * p._1 else p._1).sum', "        val multiples = List(3, 4)\n        val\
    \ powers = Map(3 -> 2, 4 -> 3)\n        var sum = 0L\n        val len = lst.length\n\
    \        for (i <- 0 until len) {\n            var isMultiple = false\n      \
    \      for (j <- 0 until multiples.length) {\n                if (i % multiples(j)\
    \ == 0) {\n                    if (i % (multiples(j) * multiples(j)) != 0) {\n\
    \                        sum += pow(lst(i), powers(multiples(j))).toLong\n   \
    \                     isMultiple = true\n                    }\n             \
    \   }\n            }\n            if (!isMultiple) {\n                sum += lst(i)\n\
    \            }\n        }\n        sum", "        var result : Long = 0\n    \
    \    for (i <- 0 until lst.length) {\n            if (i % 3 == 0) result += lst(i)\
    \ * lst(i)\n            else if (i % 4 == 0) result += lst(i) * lst(i) * lst(i)\n\
    \            else result += lst(i)\n        }\n        return result", "     \
    \   lst.zipWithIndex.map(x => {\n            if (x._2 % 3 == 0)\n            \
    \    x._1 * x._1\n            else if (x._2 % 4 == 0)\n                x._1 *\
    \ x._1 * x._1\n            else\n                x._1\n        }).sum", "    \
    \    return lst.zipWithIndex.map(x => {\n            if (x._2 % 3 == 0)\n    \
    \            pow(x._1, 2).toLong\n            else if (x._2 % 4 == 0 && x._2 %\
    \ 3 != 0)\n                pow(x._1, 3).toLong\n            else\n           \
    \     x._1\n        }).sum", "        var sum = 0l\n        for (i <- 0 until\
    \ lst.length) {\n            if (i % 3 == 0) sum += lst(i) * lst(i)\n        \
    \    else if (i % 4 == 0) sum += lst(i) * lst(i) * lst(i)\n            else sum\
    \ += lst(i)\n        }\n        return sum", '        // Please implement the
    function here.', "        var sum : Long = 0\n        for (entry <- lst.zipWithIndex)\
    \ {\n            if (entry._2 % 3 == 0) {\n                sum += pow(entry._1,\
    \ 2).toLong\n            } else if (entry._2 % 4 == 0 && entry._2 % 3 != 0) {\n\
    \                sum += pow(entry._1, 3).toLong\n            } else {\n      \
    \          sum += entry._1\n            }\n        }\n        return sum", '        lst.zipWithIndex.map{case
    (e, i) => if (i % 3 == 0) e * e else if (i % 4 == 0 && i % 3 != 0) e * e * e else
    e}.sum', "        var sum = 0l.toLong\n        for (i <- 0 until lst.length) {\n\
    \            val v = lst(i)\n            if (i % 3 == 0) {\n                sum\
    \ += v * v\n            } else if (i % 4 == 0) {\n                sum += v * v\
    \ * v\n            } else {\n                sum += v\n            }\n       \
    \ }\n        return sum", "        var sum = 0l\n        for (i <- lst.indices)\
    \ {\n            if (i % 3 == 0) sum += lst(i) * lst(i)\n            else if (i\
    \ % 4 == 0) sum += lst(i) * lst(i) * lst(i)\n            else sum += lst(i)\n\
    \        }\n        sum", '        // Your solution here', "      var total :\
    \ Long = 0\n      for (i <- 0 until lst.length) {\n        if (i % 3 == 0) {\n\
    \          total += lst(i) * lst(i)\n        } else if (i % 4 == 0) {\n      \
    \    total += lst(i) * lst(i) * lst(i)\n        } else {\n          total += lst(i)\n\
    \        }\n      }\n      return total", '        lst.zipWithIndex.map(x => if
    (x._2 % 3 == 0) x._1 * x._1 else if (x._2 % 4 == 0 && x._2 % 3 != 0) x._1 * x._1
    * x._1 else x._1).sum', "      var sum = 0L\n      for (i <- 0 until lst.length)\
    \ {\n        var v = lst(i)\n        if (i % 3 == 0) v = v * v\n        if (i\
    \ % 4 == 0 && i % 3 != 0) v = v * v * v\n        sum += v\n      }\n      sum",
  "        var sum = 0l\n        for (i <- 0 until lst.length) {\n            val\
    \ num = lst(i)\n            if (i % 3 == 0) sum += num * num\n            else\
    \ if (i % 4 == 0) sum += num * num * num\n            else sum += num\n      \
    \  }\n        sum", "        val x = lst.zipWithIndex.map(x => if(x._2 % 3 ==\
    \ 0) pow(x._1, 2).toLong\n                                           else if(x._2\
    \ % 4 == 0 && x._2 % 3 != 0) pow(x._1, 3).toLong\n                           \
    \                else x._1).sum\n        return x", "        var sum : Long =\
    \ 0;\n        var i : Int = 0;\n        for (i <- 0 to lst.length - 1) {\n   \
    \         var elem : Long = lst(i);\n            if (i % 3 == 0) {\n         \
    \       sum += elem * elem;\n            } else if (i % 4 == 0) {\n          \
    \      sum += elem * elem * elem;\n            } else {\n                sum +=\
    \ elem;\n            }\n        }\n        return sum;", "        lst.zipWithIndex.map(v\
    \ => v._2 match {\n            case i if i % 3 == 0 => v._1 * v._1\n         \
    \   case i if i % 4 == 0 => v._1 * v._1 * v._1\n            case _ => v._1\n \
    \       }).sum", "        var sum = 0l\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 3 == 0) sum += lst(i) * lst(i)\n            else if (i\
    \ % 4 == 0) sum += lst(i) * lst(i) * lst(i)\n            else sum += lst(i)\n\
    \        }\n        return sum", "        var sum = 0l\n        for (i <- 0 until\
    \ lst.length) {\n            if (i % 3 == 0) sum += lst(i) * lst(i)\n        \
    \    else if (i % 4 == 0) sum += lst(i) * lst(i) * lst(i)\n            else sum\
    \ += lst(i)\n        }\n        return sum", "        // TODO:\n        lst.zipWithIndex.map{case\
    \ (i,j) => \n          if (j % 3 == 0 && j % 4 != 0)\n            i * i\n    \
    \      else if (j % 4 == 0)\n            i * i * i\n          else\n         \
    \   i}.sum", "      var sum = 0l\n      for (i <- 0 until lst.length) {\n    \
    \    var num = lst(i)\n        if (i % 3 == 0) num = num * num\n        if (i\
    \ % 4 == 0 && i % 3 != 0) num = num * num * num\n        sum += num\n      }\n\
    \      sum", "        var total : Long = 0\n        for (n <- lst.indices) {\n\
    \            if (n % 3 == 0) total += lst(n) * lst(n)\n            else if (n\
    \ % 4 == 0) total += lst(n) * lst(n) * lst(n)\n            else total += lst(n)\n\
    \        }\n        return total", "        return lst.map(i => (i, lst.indexOf(i))).map(i\
    \ => {\n            val (valu, index) = i\n            val mult3 = index % 3 ==\
    \ 0\n            val mult4 = index % 4 == 0\n            valu match {\n      \
    \          case x if mult3 && !mult4 => x * x\n                case x if mult4\
    \ && !mult3 => x * x * x\n                case x => x\n            }\n       \
    \ }).sum", "      if (lst.isEmpty)\n        0\n      else\n        if (lst.length\
    \ >= 3 && lst.length % 3 == 0)\n          (lst.head * lst.head) + sumSquares(lst.tail)\n\
    \        else if (lst.length >= 4 && lst.length % 4 == 0 && lst.length % 3 !=\
    \ 0)\n          (lst.head * lst.head * lst.head) + sumSquares(lst.tail)\n    \
    \    else\n          lst.head + sumSquares(lst.tail)", "        var sum : Long\
    \ = 0\n        for (i <- 0 until lst.length) {\n            val index = i + 1\n\
    \            if (index % 3 == 0 && index % 4 == 0) {\n                sum += pow(lst(i),\
    \ 3).toLong\n            } else if (index % 3 == 0) {\n                sum +=\
    \ pow(lst(i), 2).toLong\n            } else if (index % 4 == 0) {\n          \
    \      sum += pow(lst(i), 3).toLong\n            } else {\n                sum\
    \ += lst(i)\n            }\n        }\n        return sum", "        // TODO:\
    \ Implement this function.\n        var sum = 0l.toLong\n        for(i <- 0 until\
    \ lst.length) {\n            if (i % 3 == 0) {\n                sum += lst(i)\
    \ * lst(i)\n            } else if (i % 4 == 0 && i % 3 != 0) {\n             \
    \   sum += lst(i) * lst(i) * lst(i)\n            } else {\n                sum\
    \ += lst(i)\n            }\n        }\n        return sum", "        lst.zipWithIndex.map(x\
    \ => {\n            val (item, index) = x\n            if (index % 3 == 0) item\
    \ * item\n            else if (index % 4 == 0) item * item * item\n          \
    \  else item\n        }).sum", "        var sum = 0l\n        for (i <- 0 until\
    \ lst.length) {\n            if (i % 3 == 0) {\n                sum += pow(lst(i),\
    \ 2).toLong\n            } else if (i % 4 == 0) {\n                sum += pow(lst(i),\
    \ 3).toLong\n            } else {\n                sum += lst(i)\n           \
    \ }\n        }\n        return sum"]
stop_tokens:
- "\n    }\n"
