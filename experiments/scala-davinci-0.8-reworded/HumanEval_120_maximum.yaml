name: HumanEval_120_maximum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list arr of integers and a positive integer k, return a sorted list\
  \ \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n \
  \   // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    //\
  \ (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>>\
  \ maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong,\
  \ 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n\
  \    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n\
  \    // 2. The elements in the list will be in the range of [-1000, 1000].\n   \
  \ // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
  \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
  \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
  \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
  \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
  \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
  \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
  \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
  \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong,\
  \ 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong,\
  \ -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
  \ -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong,\
  \ 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["        // your code here\n        Nil", '        arr.sorted.slice(arr.length
    - k.toInt, arr.length)', '        arr.sorted.takeRight(k.toInt)', "        //\
    \ Algorithm:\n        // Start with a sorted list.\n        // Initialize the\
    \ first k elements to be the maximum k elements.\n        // Now iterate through\
    \ the list.\n        // For each element,\n        // 1. If it is less than the\
    \ last element of the sorted list,\n        //    skip it.\n        // 2. If it\
    \ is greater than the last element of the sorted list,\n        //    remove the\
    \ last element and append the new one to the list.\n        // 3. If it is equal\
    \ to the last element of the sorted list,\n        //    append the new one to\
    \ the list.\n        var sortedList = new Array[Long](k.toInt)\n        for (i\
    \ <- 0 to k.toInt - 1) {\n            sortedList(i) = arr(i)\n        }\n    \
    \    scala.util.Sorting.quickSort(sortedList)\n        for (i <- k.toInt to arr.length\
    \ - 1) {\n            if (arr(i) > sortedList(k.toInt - 1)) {\n              \
    \  sortedList(k.toInt - 1) = arr(i)\n                scala.util.Sorting.quickSort(sortedList)\n\
    \            }\n        }\n        return sortedList.toList", "        // Fill\
    \ this\n        null", "        var res : List[Long] = Nil\n        var max_heap\
    \ : scala.collection.mutable.PriorityQueue[Long] = new scala.collection.mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            max_heap.enqueue(i)\n            if (max_heap.size\
    \ > k) {\n                max_heap.dequeue\n            }\n        }\n       \
    \ while (max_heap.nonEmpty) {\n            res = max_heap.dequeue :: res\n   \
    \     }\n        res", "        // Given an unsorted list and a positive integer\
    \ k, return a sorted list of \n        // length k with the maximum k numbers\
    \ in arr.\n        def maximum0(list : List[Long], k : Long) : List[Long] = {\n\
    \            val (neg, pos) = list.partition((i : Long) => i < 0)\n          \
    \  // Build a list containing the max k negative numbers.\n            def negMax(list\
    \ : List[Long], k : Long) : List[Long] = {\n                if (k == 0) List()\n\
    \                else list.foldLeft(List((0l, 0l) : (Long, Long)))((a : List[(Long,\
    \ Long)], b : Long) => a.head match {\n                    case (count, i) =>\
    \ {\n                        if (count < k) (count + 1, b) :: a\n            \
    \            else if (i < b) (count, b) :: a.tail\n                        else\
    \ a\n                    }\n                }).reverse.map((t : (Long, Long))\
    \ => t._2)\n            }\n            // Build a list containing the max k positive\
    \ numbers.\n            def posMax(list : List[Long], k : Long) : List[Long] =\
    \ {\n                if (k == 0) List()\n                else list.foldLeft(List((0l,\
    \ 0l) : (Long, Long)))((a : List[(Long, Long)], b : Long) => a.head match {\n\
    \                    case (count, i) => {\n                        if (count <\
    \ k) (count + 1, b) :: a\n                        else if (i > b) (count, b) ::\
    \ a.tail\n                        else a\n                    }\n            \
    \    }).reverse.map((t : (Long, Long)) => t._2)\n            }\n            def\
    \ insert(list : List[Long], i : Long) : List[Long] = {\n                list.foldLeft(List((0l,\
    \ 0l) : (Long, Long)))((a : List[(Long, Long)], b : Long) => a.head match {\n\
    \                    case (count, item) => {\n                        if (count\
    \ < k) {\n                            if (item < i) (count + 1, i) :: a\n", " \
    \       // Fill up this function body\n        // // // // // // // // // // //\
    \ // // // // // // // // // // // // // // // // // // // // // // // // // //\
    \ // \n        arr.sorted.reverse.take(k.toInt)\n        // // // // // // //\
    \ // // // // // // // // // // // // // // // // // // // // // // // // // //\
    \ // // // // // ", "        def extract(list : List[Long], n : Long) : List[Long]\
    \ = n match {\n            case 0 => list\n            case _ => list match {\n\
    \                case h :: t => extract(t, n - 1)\n                case _ => Nil\n\
    \            }\n        }\n        def helper(list : List[Long], k : Long) : List[Long]\
    \ = {\n            if (k == 0) Nil\n            else {\n                val (left,\
    \ right) = list.partition(_ > list.head)\n                (list.head :: helper(left,\
    \ k - 1)) ::: helper(right, k - left.length - 1)\n            }\n        }\n \
    \       extract(helper(arr, k), k)", "        // Your code goes here\n       \
    \ ???", "        val set = arr.map(x => (x, true)).toMap\n        val heap = Heap.empty(Ordering.by(t\
    \ => (t._1)))\n        for ((v, b) <- set) {\n            heap.enqueue((v, b))\n\
    \            if (heap.size > k) heap.dequeue()\n        }\n        (for ((v, b)\
    \ <- heap) yield v).toList", "        // val arr : List[Long] = List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)\n        // val k : Long = 3l\n        def itr(arr :\
    \ List[Long], k : Long, result : List[Long]) : List[Long] = {\n            if\
    \ (k == 0l) {\n                result\n            } else {\n                itr(arr.tail,\
    \ k - 1l, result.filter(_ > arr.head) :+ arr.head)\n            }\n        }\n\
    \        itr(arr, k, List[Long]())", "        // Fill up this function body\n\
    \        // `k` is the maximum numbers in `arr` to be returned\n        // Be\
    \ careful with the upper bound of your loop\n        // For example, if `k = 5`,\
    \ `arr = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)`, only `(6, 7, 8, 9, 10)` should be returned.\n\
    \        \n        // If you want to use sorted, this is the easiest way but it's\
    \ slow.\n        //arr.sorted.takeRight(k.toInt)\n        \n        // This is\
    \ a good way to do. It's fast.\n        var heap = new Heap\n        heap.build(arr)\n\
    \        var result = List[Long]()\n        for (i <- 0 to k.toInt - 1) {\n  \
    \          result = heap.heapSort() :: result\n        }\n        result.reverse",
  '        arr.sorted.slice(arr.length - k.toInt, arr.length)', "        if (k ==\
    \ 0) {\n            List[Long]()\n        } else {\n            arr.sortWith(_\
    \ > _).slice(0, k.toInt)\n        }", '        return arr.sortWith(_ > _).take(k.toInt)',
  "        val orderedSet = new SortedSet[Long]()\n        for (v <- arr) {\n    \
    \        orderedSet += v\n            if (orderedSet.size > k) orderedSet -= orderedSet.firstKey\n\
    \        }\n        orderedSet.toList", "        // TODO: Insert your solution\
    \ here\n        arr.sorted.reverse.take(k.toInt)", "        var a = arr.sorted\n\
    \        var b = List[Long]()\n        for (i <- (a.length - k.toInt) until a.length)\
    \ b = b :+ a(i)\n        return b", "        if (k <= 0) List[Long]()\n      \
    \  else {\n            val comp = (x : Long, y : Long) => x > y\n            var\
    \ heap = Heap(comp, new ListBuffer[Long]())\n            heap = arr.foldLeft(heap)((acc,\
    \ elem) => {\n                if (acc.heapSize < k) acc.insert(elem)\n       \
    \         else {\n                    if (comp(elem, acc.peek())) {\n        \
    \                acc.remove().insert(elem)\n                    }\n          \
    \          else acc\n                }\n            })\n            heap.toList()\n\
    \        }", "        // This is the recursive solution.\n        // arr.sorted.takeRight(k.toInt)\n\
    \        // This is the iterative solution.\n        var sorted = arr.sorted\n\
    \        var answer = ListBuffer[Long]()\n        for (i <- 1 to k.toInt) {\n\
    \            answer += sorted.last\n            sorted = sorted.dropRight(1)\n\
    \        }\n        answer.toList", "        if (k == 0l) {\n            return\
    \ List()\n        }\n        val sorted = arr.sorted\n        val res = for (i\
    \ <- 0l.toLong until k) yield sorted(arr.length - 1 - i.toInt)\n        res.toList",
  '        arr.sortWith((x, y) => x > y).take(k.toInt)', "        val n = arr.length\n\
    \        val queue = new PriorityQueue[Long]()(Ordering.by(- _))\n        (0 until\
    \ n).foreach(i => {\n            if (queue.size == k) {\n                if (arr(i)\
    \ > queue.head) {\n                    queue.dequeue\n                    queue.enqueue(arr(i))\n\
    \                }\n            } else {\n                queue.enqueue(arr(i))\n\
    \            }\n        })\n        queue.toList.sorted", '        null', "  \
    \      // Fill up this function body\n        // `return` is for Scala functions,\
    \ use `res` for Methods\n        val res : List[Long] = List[Long]()\n       \
    \ return res", '        return arr.sorted.takeRight(k.toInt).reverse', "     \
    \   // Given n = len(arr), time complexity is O(n) and space complexity is O(k).\n\
    \        val n = arr.length\n        var k = k\n        var (result, q) = (List[Long](),\
    \ new scala.collection.mutable.PriorityQueue[Long]()(Ordering.by(-_)))\n     \
    \   for (i <- 0 until n) {\n            if (q.length < k) q.+=(arr(i))\n     \
    \       else {\n                if (q.head < arr(i)) {\n                    q.dequeue\n\
    \                    q.+=(arr(i))\n                }\n            }\n        }\n\
    \        for (i <- 0 until k.toInt) result = q.dequeue :: result\n        result.reverse",
  "        if (k == 0) return List[Long]()\n        var maxHeap = new MaxHeap(arr)\n\
    \        var result = new ListBuffer[Long]()\n        var count = 1l\n       \
    \ while (count <= k) {\n            result += maxHeap.pop()\n            count\
    \ += 1\n        }\n        return result.toList", "        // Most optimal: O(k*n)\n\
    \        // Iterate through arr and get the max k elements.\n        // Add the\
    \ max k elements to the head of the list.\n        // Will not mutate arr.\n \
    \       var r = new ListBuffer[Long]()\n        for (i <- 0 until k.toInt) {\n\
    \            var max = Long.MinValue\n            var index = -1\n           \
    \ for (j <- 0 until arr.length) {\n                if (arr(j) > max) {\n     \
    \               max = arr(j)\n                    index = j\n                }\n\
    \            }\n            if (index != -1) {\n                r += max\n   \
    \             arr = arr.filter(_ != max)\n            }\n        }\n        r.toList",
  "        val heap = new collection.mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        val result = new ArrayBuffer[Long]()\n        for (element <- arr) {\n\
    \            heap.enqueue(element)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        for (i <- 0 until k) result += heap.dequeue\n        result.toList",
  '        arr.sorted.takeRight(k.toInt)', "        (List[Long]() /: (arr, k)) {\n\
    \            case ((result, 0), _) => result\n            case ((result, k), (elem,\
    \ i)) => \n                result.indexWhere((elem1) => (elem1 >= elem)) match\
    \ {\n                    case -1 => result :+ elem\n                    case j\
    \ => (result.slice(0, j) :+ elem) ++ result.slice(j, result.length)\n        \
    \        }\n        }", "        val sorted = arr.sorted\n        val head = arr.head\n\
    \        val tail = arr.tail\n        if (head > 0) {\n            val r = sorted.take(k.toInt)\n\
    \            r\n        } else {\n            val min = sorted.takeRight(k.toInt)\n\
    \            min.reverse\n        }", '        return arr.sorted.takeRight(k.toInt)',
  "        val sorted_arr = arr.sorted\n        sorted_arr.takeRight(k.toInt)", " \
    \       // In math, the sorted list is [x0, x1, ..., xk], where x0 > x1 > ...\
    \ > xk. \n        // In this problem, the elements in the sorted list will be\
    \ positive, thus \n        // we can write this sorted list as [x0-xk, x1-xk,\
    \ ..., xk-xk] = [x0-xk, x1-xk, ..., 0].\n        // Hence, we can find the sorted\
    \ list by finding the k numbers in arr that \n        // have the minimum sum.\n\
    \        // Linear time. \n        // Calculate sum of all numbers in arr.\n \
    \       var sum = 0l\n        for (i <- 0 until arr.length) {\n            sum\
    \ += arr(i)\n        }\n        // Sum of the k numbers in arr we are looking\
    \ for.\n        var target = sum - k\n        // Set target to the sum of the\
    \ k numbers in arr that have minimum sum.\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) > 0) {\n                // If any of the k numbers\
    \ is positive, set target to 0.\n                target = 0\n                break\n\
    \            }\n            // If target is negative, set target to arr(i).\n\
    \            if (target < arr(i)) target = arr(i)\n        }\n        // The k\
    \ numbers in arr that have the minimum sum.\n        var nums = new ListBuffer[Long]\n\
    \        // Indexes of the k numbers in arr that have the minimum sum.\n     \
    \   var indexes = new ListBuffer[Int]\n        // This is a reference to the best\
    \ nums we have found so far.\n        var bestNums = new ListBuffer[Long]\n  \
    \      // This is a reference to the best indexes we have found so far.\n    \
    \    var bestIndexes = new ListBuffer[Int]\n        // Start from the first number\
    \ in arr.\n        var start = 0\n        // Find the k numbers in arr that have\
    \ the minimum sum.\n        for (i <- 0 until arr.length) {\n            // Remove\
    \ the i-1th number from nums.\n            if (i - start > 0) {\n            \
    \    nums -= arr(i - 1)\n                indexes -= (i", '        arr.sortWith(_
    > _).slice(0, k.toInt)', "        val sorted = arr.sorted\n        val res = new\
    \ Array[Long](k.toInt)\n        for (i <- 0 to k.toInt - 1) {\n            res(i)\
    \ = sorted(i)\n        }\n        res.toList", "        // The answer is (List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))\n        // The answer is (List[Long](4l.toLong, 4l.toLong))\n\
    \        // The answer is (List[Long](2l.toLong))\n        null", "        if\
    \ (k > arr.length) {\n            arr.sortWith(_ > _)\n        } else {\n    \
    \        arr.filter(_ > arr.min).sortWith(_ > _).slice(0, k.toInt)\n        }",
  "      var list : Array[Long] = new Array[Long]((k).toInt)\n      var max : Long\
    \ = 0\n      for (i <- 0 to (k).toInt - 1) {\n        max = Long.MinValue\n  \
    \      for (j <- 0 to arr.length - 1) {\n          if (arr(j) > max) {\n     \
    \       max = arr(j)\n          }\n        }\n        list(i) = max\n        for\
    \ (j <- 0 to arr.length - 1) {\n          if (arr(j) == max) {\n            arr(j)\
    \ = 0\n          }\n        }\n      }\n      list.toList", "        // actually,\
    \ it doesn't matter if we use min heap or max heap as long as we are consistent.\n\
    \        // it doesn't matter if we use priority queue or k-heap.\n        //\
    \ we use priority queue here for simplicity.\n        // we can do better than\
    \ this by using binary search.\n        def buildHeap(s : List[Long], acc : List[Long])\
    \ : List[Long] = {\n            if (s.isEmpty) acc\n            else {\n     \
    \           val root = s.head\n                val (left, right) = s.tail.splitAt(2)\n\
    \                var cacc = List[Long]()\n                if (left.length > 0)\
    \ {\n                    cacc = cacc :+ left.head\n                    if (left.head\
    \ > root) {\n                        cacc = List[Long](left.head) ::: List[Long](root)\
    \ ::: left.tail\n                    }\n                }\n                if\
    \ (right.length > 0) {\n                    cacc = cacc :+ right.head\n      \
    \              if (right.head > root) {\n                        cacc = List[Long](right.head)\
    \ ::: List[Long](root) ::: right.tail\n                    }\n               \
    \ }\n                buildHeap(cacc, acc :+ root)\n            }\n        }\n\
    \        def heapSort(s : List[Long], acc : List[Long]) : List[Long] = {\n   \
    \         val (root, rest) = (s.head, s.tail)\n            if (rest.isEmpty) acc\
    \ :+ root\n            else {\n                val (left, right) = rest.splitAt(2)\n\
    \                var cacc = List[Long]()\n                if (left.length > 0)\
    \ {\n                    cacc = cacc :+ left.head\n                    if (left.head\
    \ > root) {\n                        cacc = List[Long](left.head) ::: List[Long](root)\
    \ ::: left.tail\n                    }\n                }\n                if\
    \ (right.length > 0) {\n                    cacc = cacc :+ right.head\n      \
    \              if (right.head > root) {\n                        cacc = List[Long](right.head)\
    \ ::: List[Long](root) ::: right.tail\n                    }", "        // Fill\
    \ up this function body\n        // `scala-compile-time-error`\n        return\
    \ List[Long]()", "        val length = arr.length\n        val priorityQueue =\
    \ new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- 0 until\
    \ length) {\n            priorityQueue.enqueue(arr(i))\n            if (priorityQueue.length\
    \ > k) priorityQueue.dequeue\n        }\n        val result = new Array[Long](priorityQueue.length)\n\
    \        for (i <- 0 until priorityQueue.length) result(i) = priorityQueue.dequeue\n\
    \        result.toList", "        val a = arr.sortWith((a, b) => a > b)\n    \
    \    a.take(k.toInt)", "        // Given a list arr of integers and a positive\
    \ integer k, return a sorted list of length k with the maximum k numbers in arr.\n\
    \        //\n        // - Arr is the list of integers.\n        // - K is the\
    \ integer.\n        // -------\n        // Returns a list of length k with the\
    \ maximum k numbers in arr.\n        //\n        // Example 1:\n        // Input:\n\
    \        // [3, 4, 5]\n        // 3\n        // Output:\n        // [4, 5, 5]\n\
    \        // Explanation:\n        // - The 3 maximum integers in the array are\
    \ 4, 5, and 5.\n        // \n        // Example 2:\n        // Input:\n      \
    \  // [4, 4, 4]\n        // 2\n        // Output:\n        // [4, 4]\n       \
    \ // Explanation:\n        // - The 2 maximum integers in the array are 4 and\
    \ 4.\n        //\n        // Note:\n        // - 1 <= k <= len(arr)\n        //\
    \ - -1000 <= arr[i] <= 1000\n        // - arr has length in range [1, 1000]\n\
    \        //\n        val max = TreeSet[Long]()\n        var i = 0l\n        var\
    \ j = i\n        var l = arr.length\n        for (i <- 0l to (arr.length - 1l))\
    \ {\n            if (max.size < k) {\n                max.add(arr(i.toInt))\n\
    \            } else {\n                max.add(arr(i.toInt))\n               \
    \ if (max.last < arr(i.toInt)) {\n                    max.remove(max.last)\n \
    \               }\n            }\n        }\n        val result = new ArrayBuffer[Long]()\n\
    \        i = 0l\n        while (i < k) {\n            result.append(max.last)\n\
    \            max.remove(max.last)\n            i = i + 1l\n        }\n       \
    \ result.toList", "        if (k == 0) List[Long]()\n        else {\n        \
    \    val heap = new MaxHeap[Long](arr)\n            val result = ListBuffer[Long]()\n\
    \            for (i <- 0 until k.toInt) {\n                result += heap.pop()\n\
    \            }\n            result.toList\n        }", "        val arrBuffer\
    \ = arr.sorted\n        (arrBuffer.slice(arrBuffer.length - k.toInt, arrBuffer.length)).reverse",
  '        arr.sortWith(_ > _).take(k.toInt)', "        val n = arr.length\n     \
    \   val maxHeap = new MaxHeap(k.toInt)\n        maxHeap.heapify(arr.take(k.toInt))\n\
    \        for (i <- k.toInt until n) {\n            if (arr(i) > maxHeap.heap(0))\
    \ {\n                maxHeap.heap(0) = arr(i)\n                maxHeap.heapify(maxHeap.heap)\n\
    \            }\n        }\n        maxHeap.heap.reverse", "        val buffer\
    \ = new ListBuffer[Long]\n        val longBuffer = new ListBuffer[Long]\n    \
    \    var i = 0\n        var i2 = 0\n        var length = 0\n        var temp =\
    \ 0l\n        var temp2 = 0l\n        var result = 0l\n        var result2 = 0l\n\
    \        for (i <- 0 to arr.length - 1) {\n            buffer += arr(i)\n    \
    \    }\n        for (i <- 0 to arr.length - 1) {\n            temp = buffer(i)\n\
    \            if (longBuffer.isEmpty) {\n                longBuffer += temp\n \
    \           } else {\n                length = longBuffer.length\n           \
    \     i2 = 0\n                while (i2 < length) {\n                    temp2\
    \ = longBuffer(i2)\n                    if (temp < temp2) {\n                \
    \        longBuffer.insert(i2, temp)\n                        i2 = length\n  \
    \                  } else if (i2 == length - 1) {\n                        longBuffer\
    \ += temp\n                    }\n                    i2 += 1\n              \
    \  }\n            }\n        }\n        i = 0\n        while (i < k) {\n     \
    \       result = longBuffer(i)\n            longBuffer -= result\n           \
    \ longBuffer.insert(0, result)\n            i += 1\n        }\n        longBuffer.toList",
  "        val (ans, _) = maximum(arr, k, true)\n        ans", "        var count\
    \ = 0l.toLong\n        var numbers = new ListBuffer[Long]()\n        for (number\
    \ <- arr) {\n            if (count < k) {\n                numbers += number\n\
    \                count += 1l.toLong\n            } else {\n                for\
    \ (i <- 0 until numbers.length) {\n                    if (numbers(i) < number)\
    \ {\n                        numbers -= numbers(i)\n                        numbers\
    \ += number\n                        break\n                    }\n          \
    \      }\n            }\n        }\n        numbers.toList.sorted.reverse", " \
    \       // Write your code here\n        var pq = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            pq.enqueue(i)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList.sorted", "        require(1 <=\
    \ arr.length && arr.length <= 1000)\n        for (i <- arr) require(-1000 <= i\
    \ && i <= 1000)\n        require(0 <= k && k <= arr.length)\n        arr.sorted.reverse.take(k.toInt)",
  '        arr.sorted.slice(arr.length - k.toInt, arr.length)', "        // We can\
    \ use a TreeMap to keep track of the k maximum numbers.\n        // Alternatively,\
    \ we can use a heap, but the implementation is more convoluted.\n        // To\
    \ do this, we keep track of the negative of the numbers.\n        val map = new\
    \ TreeMap[Long, Boolean]()\n        for (num <- arr) {\n            map.put(num,\
    \ true)\n            if (map.size() > k) map.remove(map.firstKey())\n        }\n\
    \        return map.keySet().toList().sorted(Ordering[Long].reverse)", "     \
    \ var result = new ListBuffer[Long]()\n      var kth : Long = 0\n      var iter\
    \ : Long = 0\n      while (iter < k) {\n        var max = -10000\n        var\
    \ index = 0\n        var j : Long = 0\n        while (j < arr.length) {\n    \
    \      if (arr(j.toInt) > max) {\n            max = arr(j.toInt)\n           \
    \ index = j.toInt\n          }\n          j += 1\n        }\n        arr(index)\
    \ = -10000\n        result += max\n        iter += 1\n      }\n      result.toList",
  "        def helper(list : List[Long], max : List[Long]) : List[Long] = {\n    \
    \        if (list.length == k) max\n            else {\n                var q\
    \ = new ListBuffer[Long]()\n                var maxx = Long.MinValue\n       \
    \         var maxPos = -1\n                for (i <- 0 until max.length) {\n \
    \                   if (max(i) > maxx) {\n                        maxx = max(i)\n\
    \                        maxPos = i\n                    }\n                }\n\
    \                for (i <- 0 until max.length) {\n                    if (i ==\
    \ maxPos) q += list(0)\n                    else q += max(i)\n               \
    \ }\n                helper(list.tail, q.toList)\n            }\n        }\n \
    \       helper(arr, arr.take(k.toInt))", "        var queue = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (value <- arr) {\n            queue.enqueue(value)\n            if\
    \ (queue.size > k) queue.dequeue\n        }\n        return queue.dequeueAll.toList",
  "        var list = arr.toArray\n        val comparator = new java.util.Comparator[Long]()\
    \ {\n            override def compare(o1 : Long, o2 : Long) : Int = {\n      \
    \          if (o1 > o2) return -1 else if (o1 < o2) return 1 else return 0\n \
    \           }\n        }\n        java.util.Arrays.sort(list, comparator)\n  \
    \      list.take(k.toInt).toList", "        // Define a function to convert array\
    \ to list\n        def list(arr : Array[Long]) : List[Long] = {\n            arr.toList\n\
    \        }\n        // Define a function to compare two numbers and get their\
    \ maximum\n        def compare(a : Long, b : Long) : Long = {\n            if\
    \ (a > b) a else b\n        }\n        // Define a function to get the maximum\
    \ k numbers\n        def maximum(arr : Array[Long], k : Long) : Array[Long] =\
    \ {\n            // Declare an accumulator\n            var acc = new Array[Long](k.toInt)\n\
    \            // Declare a string to record the process of finding maximum\n  \
    \          var process = \"\"\n            // Iterate k times and store the maximum\
    \ numbers in the accumulator\n            for (i <- 0l until k) {\n          \
    \      var max = arr(0)\n                var index = 0\n                for (j\
    \ <- 1l until arr.length) {\n                    if (arr(j.toInt) > max) {\n \
    \                       max = arr(j.toInt)\n                        index = j.toInt\n\
    \                    }\n                }\n                process += (max + \"\
    \ \")\n                acc(i.toInt) = max\n                arr.update(index, Long.MinValue)\n\
    \            }\n            // Print the process\n            println(process)\n\
    \            // Return the accumulator\n            acc\n        }\n        //\
    \ Return the result\n        list(maximum(arr.toArray, k))", "        // Let's\
    \ start with a simple approach first.\n        // The easiest way to do this would\
    \ be to sort the list, then return the first k elements.\n        // The time\
    \ complexity would be O(n log n), since scala's quick sort is used.\n        return\
    \ arr.sorted.reverse.take(k.toInt);", '        arr.sorted.slice(arr.length - k.toInt,
    arr.length)', "        if (k == 0) Nil\n        else {\n            val max =\
    \ arr.max\n            val index = arr.indexOf(max)\n            max :: maximum(arr.take(index)\
    \ ++ arr.drop(index + 1), k - 1)\n        }", '        null', "        // Note:\n\
    \        // 1. If the length of the list is less than or equal to k, just return\
    \ the list.\n        // 2. Otherwise, pick a maximum number, remove it from the\
    \ list, and repeat.\n        // 3. To pick a maximum number, select the last number\
    \ in the list,\n        //    and then check if it is the maximum. If not, do\
    \ a linear scan to find the maximum.\n        if (arr.length <= k) arr\n     \
    \   else {\n            var (maximum, index) = ((Long.MinValue, -1l.toLong))\n\
    \            for (i <- 0 until arr.length) {\n                if (arr(i) > maximum)\
    \ {\n                    maximum = arr(i)\n                    index = i\n   \
    \             }\n            }\n            maximum::maximum(arr.slice(0, index.toInt)\
    \ ::: arr.slice(index.toInt + 1, arr.length), k - 1)\n        }", "\t\tvar heap\
    \ = new Array[Long](k.toInt + 1)\n\t\tvar i = 0\n\t\tfor (i <- 0 to k.toInt -\
    \ 1) {\n\t\t\theap(i) = arr(i)\n\t\t}\n\t\theap(k.toInt) = Long.MinValue\n\t\t\
    for (i <- k.toInt + 1 to arr.length - 1) {\n\t\t\tif (arr(i) > heap(0)) {\n\t\t\
    \t\theap(0) = arr(i)\n\t\t\t\tmaxHeapify(heap, 0, k.toInt)\n\t\t\t}\n\t\t}\n\t\
    \theap.toList.sortBy(x => x)\n\t}\n\tdef maxHeapify(heap : Array[Long], i : Int,\
    \ n : Int) : Unit = {\n\t\tval a = i\n\t\tval b = 2 * i + 1\n\t\tval c = 2 * i\
    \ + 2\n\t\tvar largest = a\n\t\tif (b < n && heap(b) > heap(largest)) largest\
    \ = b\n\t\tif (c < n && heap(c) > heap(largest)) largest = c\n\t\tif (largest\
    \ != a) {\n\t\t\tval temp = heap(a)\n\t\t\theap(a) = heap(largest)\n\t\t\theap(largest)\
    \ = temp\n\t\t\tmaxHeapify(heap, largest, n)\n\t\t}\n\t}\n}", "        // Write\
    \ your code here\n        return List[Long]()", "        val heap = new PriorityQueue[Long]()(Ordering.by((x\
    \ : Long) => -x))\n        var a = arr\n        while (a.length > 0) {\n     \
    \       heap.enqueue(a.head)\n            a = a.tail\n        }\n        var b\
    \ = List[Long]()\n        var i = k\n        while (i > 0) {\n            b =\
    \ b :+ heap.dequeue\n            i = i - 1\n        }\n        return b", '        arr.sortWith(_
    > _).slice(0, k.toInt)', "        val arr2 = arr.toArray\n        var indices\
    \ = (0 until arr2.length).toArray\n        var min = 0\n        var max = arr2.length\
    \ - 1\n        while (min <= max) {\n            var pivot = (min + max) / 2\n\
    \            if (arr2(pivot) > arr2(k)) {\n                max = pivot - 1\n \
    \           } else {\n                min = pivot + 1\n            }\n       \
    \ }\n        var sorted = indices.slice(0, min).toList\n        sorted.foreach(i\
    \ => print(arr2(i) + \" \"))\n        sorted.map(i => arr2(i))", '        arr.sorted.reverse.take(k.toInt)',
  "        if (k == 1) return List(arr.max)\n        var result = List[Long]()\n \
    \       var queue = new Queue[Long]()\n        for (i <- 0 to k.toInt - 1) {\n\
    \            queue.enqueue(arr(i))\n        }\n        for (i <- k.toInt to arr.length\
    \ - 1) {\n            var top = queue.dequeue\n            if (arr(i) >= top)\
    \ {\n                queue.enqueue(arr(i))\n            } else {\n           \
    \     queue.enqueue(top)\n            }\n        }\n        while (!queue.isEmpty)\
    \ {\n            result = queue.dequeue :: result\n        }\n        return result",
  "        // Define the method here\n        def maximumHelper(acc : List[Long],\
    \ arr : List[Long], k : Long) : List[Long] = {\n            // Define the method\
    \ here\n            val list : List[Long] = arr.filter((num : Long) => num > k)\n\
    \            list.map((num : Long) => (List[Long](num)))\n        }\n        maximumHelper(List[Long](),\
    \ arr, k)", "        if (k == 0l) return List[Long]()\n        if (k >= arr.length)\
    \ return arr.sorted\n        val n = arr.length\n        var left = new Array[Long](n)\n\
    \        var right = new Array[Long](n)\n        val stack = new Stack[Int]\n\
    \        var r = 0\n        while (r < n) {\n            while (!stack.isEmpty\
    \ && arr(stack.top) < arr(r)) {\n                right(stack.top) = r - 1\n  \
    \              stack.pop\n            }\n            left(r) = if (stack.isEmpty)\
    \ -1 else stack.top\n            stack.push(r)\n            r += 1\n        }\n\
    \        while (!stack.isEmpty) {\n            right(stack.top) = n - 1\n    \
    \        stack.pop\n        }\n        val res = ListBuffer[Long]()\n        val\
    \ indices = new Queue[Int]\n        var kk = k\n        var i = 0\n        while\
    \ (i < n) {\n            if (res.length < k) {\n                indices.enqueue(i)\n\
    \                res += arr(i)\n            } else {\n                if (arr(i)\
    \ > res.min) {\n                    val index = indices.dequeue\n            \
    \        res -= arr(index)\n                    res += arr(i)\n              \
    \      indices.enqueue(i)\n                }\n            }\n            i +=\
    \ 1\n        }\n        return res.toList.sorted", "        // Fill up this function\
    \ body\n        // `for` is Scala's version of the `for-loop`\n        // The\
    \ general form is: for (pattern <- expression) command\n        val sortedArray\
    \ = for (elem <- arr.sorted) yield elem\n        val topkElements = for (i <-\
    \ sortedArray.length - k.toInt until sortedArray.length) yield sortedArray(i)\n\
    \        return topkElements.toList", '        return arr.sortWith((a, b) => a
    > b).take(k.toInt)', "        val heap = new Heap[Long]((x : Long, y : Long) =>\
    \ x > y)\n        arr.foreach(x => {\n            heap.push(x)\n            if\
    \ (heap.length > k) heap.pop\n        })\n        heap.popAll", "        var head\
    \ = 0;\n        var tail = head + k.toInt - 1;\n        while (tail < arr.length)\
    \ {\n            var i = head;\n            var j = i + 1;\n            while\
    \ (j <= tail) {\n                if (arr(i) > arr(j)) {\n                    var\
    \ swap = arr(i);\n                    arr(i) = arr(j);\n                    arr(j)\
    \ = swap;\n                }\n                i += 1;\n                j += 1;\n\
    \            }\n            head += 1;\n            tail += 1;\n        }\n  \
    \      var result = List[Long]();\n        for (i <- (arr.length - k.toInt) until\
    \ arr.length) {\n            result = result :+ arr(i);\n        }\n        return\
    \ result;", "        val list = arr.toArray\n        var l = 0; var r = list.length\
    \ - 1\n        while (r >= 0 && l < k) {\n            val index = partition(list,\
    \ l, r)\n            if (index == k - 1) r = index - 1\n            else l = index\
    \ + 1\n        }\n        list.slice(0, k.toInt).toList", "        // Return a\
    \ sorted list of length k with the maximum k numbers in arr.\n        arr.sorted(Ordering[Long].reverse).take(k.toInt)",
  "        val sorted = new scala.collection.mutable.TreeSet[Long]()\n        arr.foreach(x\
    \ => sorted.add(x))\n        sorted.iterator.take(k.toInt).toList", "        var\
    \ f = for (i <- 0 until k.toInt) yield arr(i)\n        f.toList.sorted.reverse",
  "        require(arr.size > 0 && arr.size <= 1000)\n        require(arr.forall(a\
    \ => a >= -1000 && a <= 1000))\n        require(k >= 0 && k <= arr.size)\n   \
    \     val heap = MinHeap()\n        for (a <- arr) {\n            if (heap.size\
    \ < k) heap.insert(a)\n            else if (a > heap.min) {\n                heap.deleteMin\n\
    \                heap.insert(a)\n            }\n        }\n        heap.toList",
  "        var heap = new BinaryHeap[Long]()\n        var l = List[Long]()\n     \
    \   for (i <- arr) {\n            if (heap.size < k) {\n                heap.add(i)\n\
    \            } else {\n                if (i > heap.peek) {\n                \
    \    heap.remove\n                    heap.add(i)\n                }\n       \
    \     }\n        }\n        for (i <- 0 until heap.size) {\n            l = heap.remove\
    \ :: l\n        }\n        l.reverse", "        // This is where I put my actual\
    \ implementation of solution.\n        // I think this algorithm is right.\n \
    \       // The main idea of this solution is to use k times the maximum function.\n\
    \        // The first is using the maximum function to find out the largest number\
    \ in the list.\n        // The second is using the maximum function to find out\
    \ the second largest number in the list.\n        // ...\n        // The k-th\
    \ is using the maximum function to find out the k-th largest number in the list.\n\
    \        // After that, I just put the n largest numbers from the list into a\
    \ new sorted list.\n        arr.foldLeft(arr)((list, number) => {\n          \
    \  // Use k times the maximum function.\n            val (max, index) = maximum(list)\n\
    \            list.patch(index, Nil, 1)\n        }).take(k.toInt).sorted", "  \
    \      val l = new LinkedList[Long]\n        for (x <- arr) {\n            l.add(x)\n\
    \            l.sortBy(math.abs(_))\n            while (l.size > k) l.remove(0)\n\
    \        }\n        l.sortBy(math.abs(_))\n        if (k % 2 == 0) {\n       \
    \     var s = 0\n            while (s < l.size / 2) {\n                val temp\
    \ = l.get(s)\n                l.set(s, l.get(l.size - 1 - s))\n              \
    \  l.set(l.size - 1 - s, temp)\n                s += 1\n            }\n      \
    \  }\n        l.toList", "        val l = arr.sortWith((l, r) => l > r)\n    \
    \    l.slice(0, k.toInt)", "        // your code here\n        return arr", '        arr.sortWith((x,
    y) => x > y).take(k.toInt)', "        if (k == 1) {\n            return List(arr.max)\n\
    \        }\n        else {\n            val sortedArr = arr.sorted\n         \
    \   val sortedArrLen = sortedArr.length\n            if (k == sortedArrLen) {\n\
    \                return sortedArr\n            }\n            else {\n       \
    \         val result = sortedArr.slice(sortedArrLen - k.toInt, sortedArrLen)\n\
    \                return result\n            }\n        }", "        // Since k\
    \ <= arr.length, k must be positive.\n        if (k < 1) {\n            return\
    \ List[Long]()\n        }\n        // Since 1 <= k <= arr.length, the size of\
    \ resulting list must be equal to k.\n        val list = new ListBuffer[Long]()\n\
    \        // Add the largest numbers in arr to list, keep the list sorted in ascending\
    \ order.\n        for (i <- 0 until k) {\n            var j = 0\n            //\
    \ Skip the numbers already added to list.\n            while (j < list.length\
    \ && list(j) < arr(i)) {\n                j += 1\n            }\n            list.insert(j,\
    \ arr(i))\n        }\n        // For the remaining arr[k], add the new number\
    \ to list if the new number is larger than the smallest\n        // number in\
    \ list.\n        for (i <- k until arr.length) {\n            if (arr(i) > list(0))\
    \ {\n                list.remove(0)\n                var j = 0\n             \
    \   while (j < list.length && list(j) < arr(i)) {\n                    j += 1\n\
    \                }\n                list.insert(j, arr(i))\n            }\n  \
    \      }\n        return list.toList", '        return arr.sortWith(_ > _).take(k.toInt)',
  "        var priorityQueue : PriorityQueue[Long] = new PriorityQueue[Long]()(Ordering[Long].reverse)\n\
    \        for (i <- arr) {\n            priorityQueue.enqueue(i)\n            if\
    \ (priorityQueue.length > k) priorityQueue.dequeue\n        }\n        var result\
    \ : List[Long] = List[Long]()\n        for (i <- priorityQueue) result = i ::\
    \ result\n        result.reverse", "        // Given a list arr of integers and\
    \ a positive integer k, return a sorted list \n        // of length k with the\
    \ maximum k numbers in arr.\n        // Apply the following steps:\n        //\
    \ 1. Create a list list1 of length k with the initial k numbers in arr.\n    \
    \    val list1 : List[Long] = arr.take(k.toInt)\n        // 2. Sort list1.\n \
    \       val list2 : List[Long] = list1.sorted\n        // 3. For each of the remaining\
    \ numbers in arr, insert the number into list2 if\n        //    the number is\
    \ less than or equal to the first number in list2.\n        val list3 : List[Long]\
    \ = arr.foldLeft(list2)((list2, element) => {\n            if (element <= list2.head)\
    \ list2.tail :+ element else list2\n        })\n        // 4. Sort list3.\n  \
    \      list3.sorted", "      // Fill up this function body\n      // You can add\
    \ another function as well, if required\n      null", '        arr.sortWith((a,
    b) => a > b).take(k.toInt)', "        if (k == 0l) {\n            List()\n   \
    \     } else {\n            val max : Long = arr.max\n            val index :\
    \ Int = arr.indexOf(max)\n            max :: maximum(arr.slice(0, index) ::: arr.slice(index\
    \ + 1, arr.length), k - 1l)\n        }", "        val sorted = arr.sorted\n  \
    \      val reversed = sorted.reverse\n        reversed.take(k.toInt)", '        return
    List[Long]()', "        if (k == 0l) return List[Long]()\n        if (k == 1l)\
    \ return List[Long](arr.max)\n        val n = arr.length\n        var max = List[Long]()\n\
    \        max :+= arr(0)\n        for (i <- 1 until n) {\n            if (max.length\
    \ == k) {\n                if (arr(i) > max.min) {\n                    max =\
    \ max.filterNot(x => x == max.min)\n                    max :+= arr(i)\n     \
    \           }\n            } else {\n                max :+= arr(i)\n        \
    \    }\n        }\n        return max.sorted", "        // Given a list arr, return\
    \ a sorted list of length k with the maximum k numbers in arr.\n        def maximum0(arr\
    \ : List[Long], k : Long, acc : List[Long]) : List[Long] = {\n            if (k\
    \ == 0l) acc\n            else if (arr.isEmpty) {\n                var temp :\
    \ List[Long] = acc\n                var a : Long = 0l\n                while (a\
    \ < k) {\n                    temp = 0l :: temp\n                    a = a + 1l\n\
    \                }\n                temp\n            }\n            else {\n\
    \                val x = arr.head\n                val y = arr.tail\n        \
    \        val j = acc.indexWhere((a : Long) => a > x)\n                val acc1\
    \ = if (j == -1) acc else acc.patch(j, (x :: Nil), 0)\n                val acc2\
    \ = if (acc1.length > k) acc1.takeRight(k.toInt) else acc1\n                maximum0(y,\
    \ k, acc2)\n            }\n        }\n        maximum0(arr, k, Nil)", "      \
    \  var res : List[Long] = List()\n        var list : List[Long] = arr\n      \
    \  var i : Long = 0l\n        while (i < k) {\n            list = list.sortWith((x,\
    \ y) => {x > y})\n            res = res :+ list.head\n            list = list.tail\n\
    \            i = i + 1\n        }\n        return res", "        require(arr.size\
    \ >= 1 && arr.size <= 1000)\n        require(arr.forall(v => v >= -1000 && v <=\
    \ 1000))\n        require(k >= 0 && k <= arr.size)\n        val result = new ListBuffer[Long]\n\
    \        var max = -1001l\n        val value = new Array[Int](1000 * 2 + 1)\n\
    \        arr.foreach(v => value(v + 1000) += 1)\n        for (i <- (0 to (arr.size\
    \ - k.toInt)).reverse) {\n            for (j <- 0 to 1999) {\n               \
    \ if (value(j) > 0) {\n                    value(j) -= 1\n                   \
    \ if (j > max) {\n                        max = j\n                    }\n   \
    \             }\n            }\n            result.append(max - 1000)\n      \
    \      value(max) += 1\n            max = -1001\n        }\n        result.toList",
  "        // Your Code Here\n        val r = null\n        return r", "        //val\
    \ list = arr.sorted\n        //list.takeRight(k.toInt)\n        val list = arr.sorted\n\
    \        list.takeRight(k.toInt)", "        // Implement this placeholder.\n \
    \       arr", '        arr.sorted.takeRight(k.toInt)', "        // Implemented\
    \ with a heap that is heapified for every\n        // insertion into it.\n   \
    \     val heap = new mutable.PriorityQueue[Long]()(Ordering.Long.reverse)\n  \
    \      for (x <- arr) {\n            heap.enqueue(x)\n            heap.dequeue()\n\
    \        }\n        heap.toList", "        // Given a list arr of integers and\
    \ a positive integer k,\n        // return a sorted list of length k with the\
    \ maximum k numbers in arr.\n        // >>> maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n\
    \        arr.distinct.sorted.takeRight(k.toInt)", "        var queue = new ListBuffer[Long]()\n\
    \        for (i <- arr) {\n            queue += i\n            queue = queue.sortWith((a,\
    \ b) => a < b)\n            if (queue.length > k) {\n                queue.remove(0)\n\
    \            }\n        }\n        queue.toList", "        val t = arr.sorted\n\
    \        t.slice(t.length - k.toInt, t.length)", "        // We define a stack\
    \ data structure based on a \n        // mutable array. \n        val stack =\
    \ new ArrayStack[Long]()\n        // The last element in the stack will be the\n\
    \        // top of the stack.\n        // We iterate over arr and fill the stack\
    \ with\n        // the largest k elements. \n        for (e <- arr) {\n      \
    \      // If the stack is empty or the current element \n            // is larger\
    \ than the top element of the stack\n            // we add the current element\
    \ to the stack.\n            if (stack.isEmpty || e >= stack.top) stack.push(e)\n\
    \            // If the stack has already k elements and the\n            // current\
    \ element is less than the top element\n            // of the stack we continue\
    \ iteration.\n            else if (stack.size == k) continue\n            // Otherwise,\
    \ we pop the top element of the stack.\n            else stack.pop\n        }\n\
    \        // We return the stack as a list in reversed order.\n        stack.toList.reverse",
  '        arr.sortWith(_ > _).take(k.toInt)', "        val b = new ListBuffer[Long]\n\
    \        for (i <- 0 until k.toInt) b += arr(i)\n        b.toList.sorted", " \
    \       // EXAMPLE:\n        // If the list is (5, 2, 1, 4, 3)\n        // Then\
    \ the array will be (1, 2, 3, 4, 5)\n        // If the list is (2, 3, 4, 1, 5)\n\
    \        // Then the array will be (1, 2, 3, 4, 5)\n        val array = arr.sorted\n\
    \        // return the reversed first k elements of the array\n        array.reverse.take(k.toInt)",
  "        var result : List[Long] = List()\n        var result_map : Map[Long, Boolean]\
    \ = Map()\n        var max_num : Long = Long.MinValue\n        for (i <- 0l to\
    \ k - 1l) {\n            max_num = Long.MinValue\n            for (j <- 0l to\
    \ arr.length - 1l) {\n                if (arr(j.toInt) > max_num && !result_map.contains(arr(j.toInt)))\
    \ {\n                    max_num = arr(j.toInt)\n                }\n         \
    \   }\n            result = result :+ max_num\n            result_map(max_num)\
    \ = true\n        }\n        return result", '        arr.sorted.slice(arr.length
    - k.toInt, arr.length)', "        if (k == 0l) Nil\n        else if (k > 0l &&\
    \ k <= arr.length) arr.sortWith(_ > _).take(k.toInt)\n        else throw new IllegalArgumentException(\"\
    k must be within range of array length\")", "        val arrSorted = arr.sorted\n\
    \        arrSorted.slice(arrSorted.length - k.toInt, arrSorted.length)", "   \
    \     // Iterate arr\n        // While heap size is less than k, add elements\
    \ to max heap\n        // When heap size is equal to k, add elements to max heap\
    \ and the current maximum element to min heap\n        // When heap size is greater\
    \ than k, compare the current element to the minimum element\n        // If greater,\
    \ remove the minimum element, add current element to min heap\n        // If less,\
    \ do nothing\n        // After iterating through arr, return elements from min\
    \ heap\n        val compare = (x : Long, y : Long) => -x.compareTo(y)\n      \
    \  val heap = new BinaryHeap[Long](compare)\n        for (x <- arr) {\n      \
    \      if (heap.size < k) heap.add(x)\n            else {\n                val\
    \ min = heap.peek\n                if (x > min) {\n                    heap.remove()\n\
    \                    heap.add(x)\n                }\n            }\n        }\n\
    \        heap.toArray.toList", "        // Implementation\n        var heap =\
    \ new BinaryHeap[Long]()\n        for (x <- arr) {\n            heap.insert(x)\n\
    \            if (heap.size > k) heap.extract_max()\n        }\n        heap.to_list()",
  '        arr.sorted.takeRight(k.toInt)', "        val heap = new Heap(arr)\n   \
    \     var retList = List[Long]()\n        for (i <- 0 until k.toInt) {\n     \
    \       retList = heap.pop() :: retList\n        }\n        retList.reverse",
  "        val list = arr.sorted\n        list.slice(list.length - k.toInt, list.length)",
  "        // The solution using Max-Heap.\n        // Since the range of each element\
    \ of the list arr is [-1000, 1000],\n        // 1000 is the maximum value, so\
    \ it can be used as the initial value.\n        // Therefore, the Min-Heap can\
    \ be used.\n        val heap = new ArrayBuffer[Long]()\n        for (element <-\
    \ arr) {\n            if (heap.length < k) {\n                heap += element\n\
    \                if (heap.length == k) heap.sortWith(_ > _)\n            } else\
    \ {\n                if (element > heap(0)) {\n                    heap.remove(0)\n\
    \                    heap += element\n                    heap.sortWith(_ > _)\n\
    \                }\n            }\n        }\n        heap.toList", "        val\
    \ sorted = arr.sorted\n        return sorted.drop((arr.length - k).toInt)", " \
    \       // max heap (k-element priority queue) with implicit ordering\n      \
    \  val pq = PriorityQueue[Long]()(Ordering[Long].reverse)\n        // add elements\
    \ to pq until pq has k elements.\n        arr.foreach(x => if (pq.size < k) pq.enqueue(x)\
    \ else if (x > pq.head) {pq.dequeue; pq.enqueue(x)})\n        // convert pq to\
    \ list\n        pq.toList", "        val list : List[Long] = (arr :\\ List[Long]())((a,\
    \ b) => b.drop(1) :+ a).sortWith((a, b) => a > b).slice(0, k.toInt)\n        return\
    \ list", '        arr.sorted.takeRight(k.toInt)', '        arr.sortWith((a, b)
    => a > b).take(k.toInt)', "        val priorityQueue = new Array[Long](k.toInt\
    \ + 1)\n        for (i <- 0 until k.toInt) priorityQueue(i + 1) = arr(i)\n   \
    \     val heap = new Heap(priorityQueue)\n        for (i <- k.toInt until arr.length)\
    \ {\n            if (arr(i) > heap.minimum) {\n                heap.delete\n \
    \               heap.insert(arr(i))\n            }\n        }\n        heap.priorityQueue.toList.tail",
  "        //def sort(xs : List[Long]) : List[Long] = xs match {\n        //    case\
    \ Nil => Nil\n        //    case head :: Nil => List(head)\n        //    case\
    \ head :: ys => {\n        //        val pivot = head\n        //        val(less,\
    \ greater) = sort(ys).partition(_ < pivot)\n        //        less ::: (pivot\
    \ :: greater)\n        //    }\n        //}\n        //sort(arr).take(k.toInt)\n\
    \        val x = Array.fill(arr.length)(0l)\n        for (i <- 0 until arr.length)\
    \ x(i) = arr(i)\n        scala.util.Sorting.quickSort(x)\n        var result =\
    \ List[Long]()\n        for (i <- 0 until k.toInt) result = x(arr.length - i -\
    \ 1) :: result\n        result", "        val pq = new PriorityQueue[Long]()(Ordering.by[Long,\
    \ Long](-_))\n        for (i <- arr) {\n            pq.enqueue(i)\n          \
    \  if (pq.size > k) pq.dequeue\n        }\n        val list = new ListBuffer[Long]()\n\
    \        while (pq.nonEmpty) list.append(pq.dequeue)\n        list.reverse.toList",
  "        // Reversing the list would make it so that the\n        // returned list\
    \ was not descending order when \n        // sorted. \n        arr.sorted.takeRight(k.toInt)",
  "        // Brute force method\n        // Time complexity: O(N log N), Space complexity:\
    \ O(N)\n        def maximumRec(arr : List[Long], index : Int, k : Long, result\
    \ : List[Long]) : List[Long] = {\n            if (k == 0l) result\n          \
    \  else {\n                if (index == arr.length) result\n                else\
    \ {\n                    val updatedResult = if (result.length < k) result :+\
    \ arr(index)\n                    else {\n                        var min = (Long.MaxValue,\
    \ -1)\n                        for (i <- 0 until result.length) {\n          \
    \                  if (result(i) < min._1) min = (result(i), i)\n            \
    \            }\n                        result.patch(min._2, List(arr(index)),\
    \ 1)\n                    }\n                    maximumRec(arr, index + 1, k,\
    \ updatedResult)\n                }\n            }\n        }\n        arr.sorted.slice(arr.length\
    \ - k.toInt, arr.length)", "        // We use a heapsort to first sort the list\
    \ in descending order. Then, we just return the first k values.\n        val h\
    \ = new Heap[Long](arr.length, false, arr.toArray)\n        val result = new Array[Long](k.toInt)\n\
    \        for (i <- 0 until k.toInt) {\n            result(i) = h.removeFirst()\n\
    \        }\n        result.toList", "        // Define the variable\n        var\
    \ list : List[Long] = List[Long]()\n        // Filter the number of indexes\n\
    \        for (index <- arr.indices) {\n            if (index < k) {\n        \
    \        list = list :+ arr(index)\n            }\n        }\n        // Sort\
    \ the list\n        return list.sorted", "        // k distinct values\n     \
    \   val queue = Queue[Long]()\n        for (value <- arr) {\n            if (queue.size\
    \ < k) {\n                queue.enqueue(value)\n            } else {\n       \
    \         if (queue.min > value) {\n                    queue.dequeue\n      \
    \              queue.enqueue(value)\n                }\n            }\n      \
    \  }\n        queue.dequeueAll.toList.sorted", '        arr.sorted.takeRight(k.toInt)',
  "        val sorted = arr.sorted\n        sorted.slice(sorted.length - k.toInt,\
    \ sorted.length)", "        // We use a heap of len arr.length to track the numbers\
    \ in arr.\n        val heap = new scala.collection.mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        // We push all of the numbers in arr into the heap.\n        arr.foreach(x\
    \ => heap.enqueue(x))\n        // We use a list to track the results.\n      \
    \  val results = new ListBuffer[Long]()\n        // Since we want the k maximum\
    \ elements, the maximum element will be the first\n        // element, followed\
    \ by the second maximum element, and so on.\n        for (i <- 0 until k.toInt)\
    \ {\n            // We dequeue from the heap, which removes the maximum element.\n\
    \            val m = heap.dequeue\n            // Add the element to the results.\n\
    \            results += m\n        }\n        results.toList", "        // your\
    \ code here\n        (arr.sortWith((a, b) => a > b)).slice(0, k.toInt)", "   \
    \     val a = arr.sorted.reverse\n        a.take(k.toInt)", "        // Instead\
    \ of removing the smallest element, we actually need to keep the maximum\n   \
    \     // element for the subproblem in the range [0, j - k]\n        val minimums\
    \ = Array.fill(arr.length)(0l)\n        var m : Long = 0l\n        // This is\
    \ actually argmin.\n        var mIdx : Int = 0\n        // This gives the actual\
    \ minimums.\n        val actualMinimums = Array.fill(arr.length)(0l)\n       \
    \ for (i <- 0 until arr.length) {\n            // If i >= k, then we need to keep\
    \ track of minimums.\n            if (i >= k) {\n                if (arr(i) >\
    \ m) {\n                    m = arr(i)\n                    mIdx = i\n       \
    \         }\n                minimums(i) = m\n                actualMinimums(i)\
    \ = arr(mIdx)\n            }\n        }\n        // From here, we have the minimums\
    \ and all we need to do is create a heap to find the\n        // maximum k elements.\
    \ We can do this backwards for speed.\n        // This is the size of the heap,\
    \ but we need the array to be 0-indexed.\n        var heapSize = k - 1\n     \
    \   val heap = Array.fill(arr.length)(Long.MinValue)\n        // The heap is min-heap,\
    \ so we need to set the 1st element to 0.\n        heap(0) = 0l\n        // Iterate\
    \ backwards through the array.\n        for (i <- arr.length - 1 to 0 by -1) {\n\
    \            // If i >= k, then we only care about elements that are larger than\
    \ the minimums.\n            if (i >= k) {\n                // If the current\
    \ element is greater than the minimum for the subproblem, then\n             \
    \   // add it to the heap.\n                if (arr(i) > actualMinimums(i - 1))\
    \ {\n                    // Attempt to add the new value to the heap.\n      \
    \              heap(heapSize) = arr(i)\n                    // Iterate until we\
    \ reach the root or the value of the current node is less\n                  \
    \  // than the value of its parent.\n                    var j = heapSize\n  \
    \                  while (j > 0 && heap(j) < heap((j -", "        // Given arr\
    \ and k, return an ordered tuple\n        def maximum_helper(arr : List[Long],\
    \ k : Long, ordered : List[Long]) : List[Long] = {\n            // Compute the\
    \ result\n            if (k == 0l) ordered\n            else {\n             \
    \   val max = arr.max\n                val index = arr.indexOf(max)\n        \
    \        val updatedArr = arr.take(index) ++ arr.drop(index + 1)\n           \
    \     maximum_helper(updatedArr, k - 1, ordered :+ max)\n            }\n     \
    \   }\n        // Implement maximum_helper function\n        maximum_helper(arr,\
    \ k, List())", '        ???', "\tvar _arr = new ArrayBuffer[Long]()\n\t_arr ++=\
    \ arr\n\t_arr.sortWith((a, b) => a > b)\n\t_arr.slice(0, k.toInt).toList", " \
    \       var result : List[Long] = List[Long]()\n        for (i <- arr.indices)\
    \ {\n            if (result.length == k) {\n                var j = result.length\
    \ - 1\n                while (j >= 0 && result(j) < arr(i)) {\n              \
    \      result = result.updated(j, result(j - 1))\n                    j -= 1\n\
    \                }\n                result = result.updated(j + 1, arr(i))\n \
    \           } else result = result :+ arr(i)\n        }\n        result", "  \
    \      val arr_max = arr.sortWith((x, y) => (x > y))\n        (arr_max.take(k.toInt)).sortWith((x,\
    \ y) => (x < y))", "        // We can use Quick Select, the algorithm that finds\
    \ the kth smallest element \n        // in O(n) time. (https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/)\n\
    \        def quickSelect(arr : List[Long], low : Int, high : Int, k : Int) : List[Long]\
    \ = {\n            val pivot = arr(high)\n            var i = low\n          \
    \  var j = low\n            while (j < high) {\n                if (arr(j) > pivot)\
    \ {\n                    val tmp = arr(i)\n                    arr(i) = arr(j)\n\
    \                    arr(j) = tmp\n                    i += 1\n              \
    \  }\n                j += 1\n            }\n            val tmp = arr(i)\n  \
    \          arr(i) = arr(high)\n            arr(high) = tmp\n            if (i\
    \ == k - 1) arr.slice(0, k.toInt)\n            else if (i > k - 1) quickSelect(arr,\
    \ low, i - 1, k)\n            else quickSelect(arr, i + 1, high, k)\n        }\n\
    \        if (k == arr.length) arr.sorted.reverse\n        else quickSelect(arr,\
    \ 0, arr.length - 1, k.toInt)", "        val maxHeap = new PriorityQueue[Long]()(Ordering[Long].reverse)\n\
    \        for (x <- arr) {\n            maxHeap.enqueue(x)\n            if (maxHeap.size\
    \ > k) maxHeap.dequeue\n        }\n        var result = new ListBuffer[Long]()\n\
    \        while (maxHeap.nonEmpty) result += maxHeap.dequeue\n        result.toList",
  "        // the length of arr must be greater than 0\n        if (arr.length ==\
    \ 0) {\n            List[Long]()\n        } else {\n            val sort = arr.sorted\n\
    \            val length = sort.length\n            sort.take(length - k.toInt).reverse\n\
    \        }", "        // Heap.\n        val minHeap = new scala.collection.mutable.PriorityQueue[Long]()(Ordering.by(abs(_)))\n\
    \        // Collect all positive numbers.\n        for (x <- arr) {\n        \
    \    if (x > 0) {\n                if (minHeap.size < k) minHeap.enqueue(x)\n\
    \                else if (minHeap.head < x) {\n                    minHeap.dequeue\n\
    \                    minHeap.enqueue(x)\n                }\n            }\n  \
    \      }\n        // At least k elements are positive.\n        if (minHeap.size\
    \ == k) return minHeap.toList.sorted.reverse\n        // Collect all negative\
    \ numbers.\n        val maxHeap = new scala.collection.mutable.PriorityQueue[Long]()(Ordering.by(-abs(_)))\n\
    \        for (x <- arr) {\n            if (x < 0) {\n                if (maxHeap.size\
    \ < k - minHeap.size) maxHeap.enqueue(x)\n                else if (maxHeap.head\
    \ > x) {\n                    maxHeap.dequeue\n                    maxHeap.enqueue(x)\n\
    \                }\n            }\n        }\n        // The rest numbers are\
    \ zero.\n        minHeap.enqueueAll(maxHeap)\n        minHeap.toList.sorted.reverse",
  '        arr.sorted.slice(arr.length - k.toInt, arr.length)', "        val indexes\
    \ = new Array[Int](k.toInt)\n        for (i <- 0 until k.toInt) indexes(i) = i\n\
    \        for (i <- 0 until k.toInt - 1) {\n            for (j <- i + 1 until k.toInt)\
    \ {\n                if (arr(indexes(i)) < arr(indexes(j))) {\n              \
    \      val temp = indexes(i)\n                    indexes(i) = indexes(j)\n  \
    \                  indexes(j) = temp\n                }\n            }\n     \
    \   }\n        for (i <- k.toInt until arr.length) {\n            var min = indexes(0)\n\
    \            for (j <- 1 until k.toInt) if (arr(indexes(j)) < arr(min)) min =\
    \ indexes(j)\n            if (arr(i) > arr(min)) {\n                indexes(0)\
    \ = i\n                for (j <- 1 until k.toInt) {\n                    if (arr(indexes(j))\
    \ < arr(indexes(j - 1))) {\n                        val temp = indexes(j)\n  \
    \                      indexes(j) = indexes(j - 1)\n                        indexes(j\
    \ - 1) = temp\n                    }\n                }\n            }\n     \
    \   }\n        val result = new Array[Long](k.toInt)\n        for (i <- 0 until\
    \ k.toInt) result(i) = arr(indexes(i))\n        result.toList", "        // We\
    \ can use a priority queue (heap) to get the maximum k numbers in arr.\n     \
    \   val queue = PriorityQueue[Long]()(Ordering.by(-_))\n        for (v <- arr)\
    \ {\n            queue.enqueue(v)\n            if (queue.size > k) {\n       \
    \         queue.dequeue\n            }\n        }\n        queue.toList.sorted",
  "        var set = new TreeSet[Long]()\n        var k1 = k\n        var t = new\
    \ ArrayBuffer[Long]()\n        for (i <- arr) {\n            if (k1 > 0) {\n \
    \               set += i\n                k1 -= 1\n            } else {\n    \
    \            val a = set.head\n                if (i > a) {\n                \
    \    set -= a\n                    set += i\n                }\n            }\n\
    \        }\n        for (e <- set) t += e\n        t.toList", "        var rv\
    \ = new PriorityQueue[Long]()(Ordering[Long].reverse)\n        for (e <- arr)\
    \ {\n            rv.enqueue(e)\n            if (rv.size > k) rv.dequeue\n    \
    \    }\n        rv.toList.sorted", "        // get the maximum k elements from\
    \ a sorted list\n        def getMaxFromSorted(sorted : List[Long], k : Long) :\
    \ List[Long] = {\n            if (k == 0) sorted\n            else {\n       \
    \         val rest = sorted.length - k.toInt\n                sorted.slice(rest,\
    \ sorted.length)\n            }\n        }\n        // get the maximum k elements\
    \ from an unsorted list\n        def getMaxFromUnsorted(unsorted : List[Long],\
    \ k : Long) : List[Long] = {\n            if (k == 0) unsorted\n            else\
    \ {\n                val sorted = unsorted.sorted\n                getMaxFromSorted(sorted,\
    \ k)\n            }\n        }\n        // first solution\n        def getMaxFromUnsorted1(unsorted\
    \ : List[Long], k : Long) : List[Long] = {\n            val heap = new MaxHeap[Long]\n\
    \            unsorted.foreach(i => heap.add(i))\n            val sorted = new\
    \ ListBuffer[Long]\n            for (i <- 0 until k.toInt) {\n               \
    \ val m = heap.removeMax\n                sorted += m\n            }\n       \
    \     sorted.toList\n        }\n        // second solution\n        def getMaxFromUnsorted2(unsorted\
    \ : List[Long], k : Long) : List[Long] = {\n            val heap = new MaxHeap[Long]\n\
    \            unsorted.foreach(i => heap.add(i))\n            val sorted = new\
    \ ListBuffer[Long]\n            for (i <- 0 until min(k, unsorted.length).toInt)\
    \ {\n                val m = heap.removeMax\n                sorted += m\n   \
    \         }\n            sorted.toList\n        }\n        getMaxFromUnsorted(arr,\
    \ k)", "\t\tvar max : List[Long] = List()\n\t\tif (k < 1) {\n\t\t\tmax\n\t\t}\
    \ else {\n\t\t\tvar size : Long = arr.length.toLong\n\t\t\tvar left : Long = 0l\n\
    \t\t\tvar right : Long = 0l\n\t\t\tfor (i <- 0l to size - 1l) {\n\t\t\t\tleft\
    \ = i\n\t\t\t\tright = size - 1l\n\t\t\t\twhile (left < right) {\n\t\t\t\t\tvar\
    \ middle : Long = (left + right) / 2l\n\t\t\t\t\tif (arr(middle.toInt) <= arr(i.toInt))\
    \ {\n\t\t\t\t\t\tleft = middle + 1l\n\t\t\t\t\t} else {\n\t\t\t\t\t\tright = middle\n\
    \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (right < k) {\n\t\t\t\t\tif (max.length ==\
    \ 0) {\n\t\t\t\t\t\tmax = List(arr(i.toInt))\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\
    var tmp = arr(i.toInt)\n\t\t\t\t\t\tvar index : Long = 0l\n\t\t\t\t\t\tvar position\
    \ : Long = 0l\n\t\t\t\t\t\tfor (j <- 0l to max.length - 1l) {\n\t\t\t\t\t\t\t\
    if (max(j.toInt) > tmp) {\n\t\t\t\t\t\t\t\tposition = j\n\t\t\t\t\t\t\t\tbreak\n\
    \t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (position == 0l) {\n\t\t\t\t\t\t\
    \tmax = max :+ tmp\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmax = max.slice(0, position.toInt)\
    \ :+ tmp ::: max.slice(position.toInt, max.length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\
    if (max.length > k) {\n\t\t\t\t\t\t\tmax = max.slice(0, k.toInt)\n", '        arr.sorted.takeRight(k.toInt)',
  "        val length = arr.length\n        if (k == 0) {\n            return List[Long]()\n\
    \        }\n        if (k == length) {\n            return arr.sorted\n      \
    \  }\n        val result = new ListBuffer[Long]()\n        val chosen = new ListBuffer[Long]()\n\
    \        val tooSmall = new ListBuffer[Long]()\n        val a = arr.sorted\n \
    \       val b = arr.sorted\n        val c = arr.sorted\n        val map = new\
    \ HashMap[Long, Int]()\n        for (i <- 0 until length) {\n            map.put(a(i),\
    \ i)\n        }\n        for (i <- 0 until length) {\n            for (j <- 0\
    \ until length) {\n                if (i != j) {\n                    var diff\
    \ = abs(a(i) - a(j))\n                    if (map.contains(diff)) {\n        \
    \                var list = map.get(diff).get\n                        if (list\
    \ == i || list == j) {\n                            diff = diff + 1\n        \
    \                }\n                        if (map.contains(diff)) {\n      \
    \                      list = map.get(diff).get\n                            if\
    \ (list == i || list == j) {\n                                diff = diff + 1\n\
    \                            }\n                            if (map.contains(diff))\
    \ {\n                                list = map.get(diff).get\n              \
    \                  if (list == i || list == j) {\n                           \
    \         diff = diff + 1\n                                }\n               \
    \                 if (map.contains(diff)) {\n                                \
    \    chosen += a(i)\n                                    chosen += a(j)\n    \
    \                                chosen += map.get(diff).get\n               \
    \                 }\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n        chosen.foreach(n\
    \ => map.remove(n))\n        map.foreach(kv => tooSmall += kv._1)\n        if\
    \ (chosen.length == k) {\n            return chosen.sorted\n        }\n      \
    \  if (chosen.length > k) {\n            val sorted = chosen.sorted\n        \
    \    for (i <- 0 until k.toInt) {\n                result += sorted(i)\n", " \
    \       val l = arr.length\n        arr.sortWith(_ > _).take(k.toInt)", '        arr.sorted.takeRight(k.toInt)',
  "        //val bottom = -(pow(2, 31).toInt)\n        //val top = pow(2, 31).toInt\
    \ - 1\n        val h = scala.collection.mutable.PriorityQueue[Long]() ++ arr\n\
    \        val result = new ArrayBuffer[Long]()\n        for (i <- 0 until k.toInt)\
    \ {\n            result += h.dequeue\n        }\n        result.toList", '        arr.sortWith(_
    > _).take(k.toInt)', "        var out = new Array[Long](k.toInt)\n        for\
    \ (i <- 0 until k.toInt) out(i) = -1001l\n        for (i <- 0 until arr.length)\
    \ {\n            for (j <- k.toInt - 1 to 0 by -1) {\n                if (arr(i)\
    \ > out(j)) {\n                    out(j) = arr(i)\n                    break\n\
    \                }\n            }\n        }\n        return out.toList", "  \
    \      //val dp = Array.ofDim[Long](arr.length + 1, k + 1)\n        //for (i <-\
    \ 0 to arr.length) dp(i)(0) = 0l\n        //for (j <- 0 to k) dp(0)(j) = 0l\n\
    \        //for (i <- 1 to arr.length) {\n        //    for (j <- 1 to k) {\n \
    \       //        val t = max(arr(i - 1) + dp(i - 1)(j - 1), dp(i - 1)(j))\n \
    \       //        dp(i)(j) = max(dp(i - 1)(j), t)\n        //    }\n        //}\n\
    \        //dp(arr.length)(k)\n        val l = SortedSet[Long]()\n        for (i\
    \ <- arr) {\n            l += i\n            if (l.size > k) l -= l.firstKey\n\
    \        }\n        l.toList", "        var heap = Heap((x : Long, y : Long) =>\
    \ (x > y))\n        for (element <- arr) {\n            heap.enqueue(element)\n\
    \            if (heap.size > k) heap.dequeue\n        }\n        heap.dequeueAll",
  "        // Your Code Here\n        if (k == 0) {\n            return List[Long]()\n\
    \        }\n        return arr.sorted.takeRight(k.toInt)", "        if (k == 0)\
    \ List()\n        else {\n            val arr2 = arr.sortWith((x, y) => (x > y))\n\
    \            arr2.slice(0, k.toInt)\n        }", "        val set : Set[Long]\
    \ = Set[Long]()\n        for (x <- arr) set += x\n        val list : List[Long]\
    \ = set.toList.sorted\n        val result : List[Long] = list.takeRight(k.toInt)\n\
    \        return result", "        val maxHeap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        val res = new mutable.ArrayBuffer[Long]()\n        for (i <- arr) {\n\
    \            maxHeap.enqueue(i)\n            if (maxHeap.size > k) {\n       \
    \         maxHeap.dequeue()\n            }\n        }\n        res ++= maxHeap\n\
    \        res.sorted.toList", "        if (k == 0l) return List[Long]()\n     \
    \   val queue = new mutable.PriorityQueue[Long]()(Ordering.by((i : Long) => -i))\n\
    \        arr.foreach(i => queue.enqueue(i))\n        queue.dequeueAll.take(k.toInt).toList",
  "        // Create a HashMap with key: the number of occurrences of an element in\
    \ arr, value: List[Long] of elements with this number of occurrences\n       \
    \ var map : HashMap[Long, List[Long]] = new HashMap[Long, List[Long]]()\n    \
    \    for (x <- arr) {\n            if (map.contains(1l)) {\n                var\
    \ temp : List[Long] = map(1l)\n                map.put(1l, x :: temp)\n      \
    \      }\n            else {\n                map.put(1l, List[Long](x))\n   \
    \         }\n        }\n        var i : Long = 1l\n        while (i < k) {\n \
    \           i += 1\n            var map1 : HashMap[Long, List[Long]] = new HashMap[Long,\
    \ List[Long]]()\n            for (key <- map.keys) {\n                val elem\
    \ = map(key)\n                for (x <- elem) {\n                    if (map1.contains(key\
    \ + 1)) {\n                        var temp : List[Long] = map1(key + 1)\n   \
    \                     map1.put(key + 1, x :: temp)\n                    }\n  \
    \                  else {\n                        map1.put(key + 1, List[Long](x))\n\
    \                    }\n                }\n            }\n            map = map1\n\
    \        }\n        // Find all the possible number of occurrences of elements\
    \ in arr\n        var max : Long = Long.MinValue\n        for (key <- map.keys)\
    \ {\n            if (key > max) {\n                max = key\n            }\n\
    \        }\n        // Create a list for the final answer\n        var result\
    \ : List[Long] = List[Long]()\n        // Iterate through the elements of the\
    \ maximum number of occurrences\n        for (x <- map(max)) {\n            //\
    \ Add the element to the result if it hasn't been added before\n            if\
    \ (!result.contains(x)) {\n                result = x :: result\n            }\n\
    \        }\n        // Reverse the result\n        result = result.reverse\n \
    \       return result", "        var list = new ListBuffer[Long]()\n        var\
    \ max = Long.MinValue\n        var min = Long.MaxValue\n        for (x <- arr)\
    \ {\n            if (x > max) max = x\n            if (x < min) min = x\n    \
    \    }\n        list += min\n        for (i <- 0l until k - 1l) {\n          \
    \  var m = Long.MinValue\n            for (x <- arr) {\n                if (x\
    \ > m && x < max) m = x\n            }\n            list += m\n            max\
    \ = m\n        }\n        list.toList", "      // Fill up this function body\n\
    \      // You can add another function as well, if required\n      var pq = new\
    \ PriorityQueue[Long]()(Ordering.by(x => -x))\n      for (i <- arr) {\n      \
    \  pq.enqueue(i)\n        if (pq.size > k) pq.dequeue\n      }\n      pq.dequeueAll.toList",
  "        val asSorted = arr.sorted\n        if (asSorted.length < k) List()\n  \
    \      else asSorted.takeRight(k.toInt)", "\t\tval heap = Heap[Long]()\n\t\tfor\
    \ (i <- arr) {\n\t\t\theap.insert(i)\n\t\t\tif (heap.size > k) heap.deleteMin\n\
    \t\t}\n\t\theap.toList.reverse", "        var res = List[Long]()\n        if (k\
    \ < 0 || k > arr.length) return res\n        var length = arr.length\n       \
    \ while (length > 0) {\n            var max_value = arr.head\n            var\
    \ idx = 0\n            for (i <- 0 until length) {\n                if (arr(i)\
    \ > max_value) {\n                    max_value = arr(i)\n                   \
    \ idx = i\n                }\n            }\n            arr = arr.take(idx) ++\
    \ arr.drop(idx + 1)\n            res = max_value :: res\n            length -=\
    \ 1\n        }\n        res", "        val heap = (new mutable.PriorityQueue[Long]()(Ordering.Long.reverse))\n\
    \        for (e <- arr) {\n            heap.enqueue(e)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val inits\
    \ = arr.init\n        val lasts = arr.last :: Nil\n        // println(\"inits:\
    \ \" + inits)\n        // println(\"lasts: \" + lasts)\n        val initsMax =\
    \ maximumHelper(inits)\n        val lastsMax = maximumHelper(lasts)\n        //\
    \ println(\"initsMax: \" + initsMax)\n        // println(\"lastsMax: \" + lastsMax)\n\
    \        initsMax ::: lastsMax", "        var result : List[Long] = List[Long]()\n\
    \        var counter : Long = 0\n        while (counter < k) {\n            if\
    \ (arr.isEmpty) {\n                return result\n            }\n            val\
    \ max = arr.max\n            arr.filter(_ != max)\n            result = result\
    \ :+ max\n            counter += 1\n        }\n        return result", "     \
    \   val pq = PriorityQueue.empty[Long](new Ordering[Long]() {\n            override\
    \ def compare(x : Long, y : Long) = y.compareTo(x)\n        })\n        for (v\
    \ <- arr) {\n            pq.enqueue(v)\n            if (pq.size > k) pq.dequeue\n\
    \        }\n        pq.dequeueAll.toList", '        null', "        // We might\
    \ try just sorting and taking the first k elements. \n        // This is O(n log\
    \ n) time. \n        // Can we do better?\n        // We could use a priority\
    \ queue to select k elements in O(n log k) time.\n        def maximum(arr : List[Long],\
    \ k : Long, result : List[Long]) : List[Long] = {\n            if (k == 0) result\
    \ else {\n                val q = Queue(arr:_*)\n                var max = q.dequeue\n\
    \                while (!q.isEmpty) {\n                    val n = q.dequeue\n\
    \                    if (n > max) max = n\n                }\n               \
    \ maximum(arr.filter(_ != max), k - 1, max :: result)\n            }\n       \
    \ }\n        maximum(arr, k, List[Long]())", "        if (k == 1) {\n        \
    \    return List(arr.max)\n        }\n        if (k == arr.length) {\n       \
    \     return arr.sorted\n        }\n        val maxHeap = new mutable.PriorityQueue[Long]()(Ordering.by((x\
    \ : Long) => x))\n        arr.foreach(x => maxHeap.enqueue(x))\n        val results\
    \ = new ListBuffer[Long]()\n        for (i <- 1 to k.toInt) {\n            results\
    \ += maxHeap.dequeue\n        }\n        results.toList", "        // Fill up\
    \ this function body\n        // 'maximum' accepts the following parameters:\n\
    \        // arr : List[Long] = List of integers\n        // k : Long = k number\
    \ of items in List\n        // Returns a sorted list with the maximum k numbers\
    \ in arr\n        //arr.sorted.drop(arr.length - k.toInt)\n        maximumIter(arr,\
    \ List[Long](), k)", "        // Note: Python and JS solutions don't use a heap.\n\
    \        var heap = (new PriorityQueue[Long])\n        for (n <- arr) {\n    \
    \        heap.enqueue(n)\n            if (heap.length > k) heap.dequeue\n    \
    \    }\n        return heap.toList.sorted.reverse", "        val heap = new PriorityQueue[Long]()(Ordering.by((l\
    \ : Long) => -l))\n        for (n <- arr) {\n            heap.enqueue(n)\n   \
    \         if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted",
  "        if (k <= 0) return List()\n        if (k == 1) return List(arr.max)\n \
    \       var maximums = ListBuffer[Long]()\n        var negatives = ListBuffer[Long]()\n\
    \        var positives = ListBuffer[Long]()\n        for (i <- arr) {\n      \
    \      if (i >= 0) positives += i\n            else negatives += i\n        }\n\
    \        if (k == 2) {\n            if (negatives.length < 2) {\n            \
    \    if (positives.length == 0) return negatives.toList\n                maximums\
    \ += positives.min\n                maximums += positives.max\n            }\n\
    \            else {\n                if (positives.length == 0) return negatives.toList\n\
    \                maximums += negatives.min\n                maximums += negatives.max\n\
    \            }\n            return maximums.toList\n        }\n        positives\
    \ = positives.sortWith(_ > _)\n        negatives = negatives.sortWith(_ < _)\n\
    \        var i = 0\n        while (i < k) {\n            if (negatives.length\
    \ <= 0) {\n                maximums += positives.remove(0)\n                i\
    \ += 1\n            }\n            else if (positives.length <= 0) {\n       \
    \         maximums += negatives.remove(0)\n                i += 1\n          \
    \  }\n            else if (negatives.head < -positives.head) {\n             \
    \   maximums += negatives.remove(0)\n                i += 1\n            }\n \
    \           else {\n                maximums += positives.remove(0)\n        \
    \        i += 1\n            }\n        }\n        return maximums.toList", " \
    \       // Create a new list with the maximum k numbers from the given list arr.\n\
    \        // A comparator based on the absolute value of the numbers is used.\n\
    \        val res = new ListBuffer[Long]()\n        val heap = new HeapSort[Long]((x\
    \ : Long, y : Long) => x.abs < y.abs)\n        for (i <- arr) {\n            heap.insert(i)\n\
    \            if (heap.size > k) heap.remove()\n        }\n        while (heap.size\
    \ > 0) res += heap.remove()\n        res.toList", "        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)", "        // If k equals 1, then return only\
    \ the maximum.\n        if (k == 1) {\n            List(arr.max)\n        } else\
    \ {\n            val head = arr.head\n            val tail = arr.tail\n      \
    \      // If k is greater than the length of the list, return the same list.\n\
    \            if (k > arr.length) {\n                arr\n            } else {\n\
    \                // Otherwise, if the head is greater than the tail, add the head\
    \ \n                // to the beginning of the list returned by maximum(tail,\
    \ k).\n                if (head > maximum(tail, k).head) {\n                 \
    \   head :: maximum(tail, k)\n                } else {\n                    //\
    \ Otherwise, return the list returned by maximum(tail, k).\n                 \
    \   maximum(tail, k)\n                }\n            }\n        }", '        arr.sorted.takeRight(k.toInt)',
  '        arr.sortWith(_ < _).takeRight(k.toInt)', "        // iterative algorithm\n\
    \        var topk = List[Long]()\n        for (x <- arr) {\n            if (topk.length\
    \ < k) {\n                topk = insert(topk, x)\n            } else {\n     \
    \           if (x > topk.last) {\n                    topk = insert(topk.init,\
    \ x)\n                }\n            }\n        }\n        topk"]
stop_tokens:
- "\n    }\n"
