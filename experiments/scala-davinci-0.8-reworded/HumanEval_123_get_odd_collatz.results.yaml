language: scala
name: HumanEval_123_get_odd_collatz
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1l)\n        var result = new\
    \ ListBuffer[Long]\n        result += 1l\n        var m = n\n        while (m\
    \ != 1) {\n            if (m % 2 == 1) result += m\n            m = if (m % 2\
    \ == 0) m / 2 else 3 * m + 1\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbbqi2agg.scala:29)\n\tat Problem.main(tmpbbqi2agg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = List[Long]()\n        var current = n\n\
    \        while (current != 1) {\n            if (current % 2 == 1) result = current\
    \ :: result\n            current = if (current % 2 == 0) current / 2 else current\
    \ * 3 + 1\n        }\n        result.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkord718r.scala:27)\n\tat Problem.main(tmpkord718r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val seq = ArrayBuffer[Long]()\n        var num = n\n\
    \        while (num != 1) {\n            seq += num\n            if (num % 2 ==\
    \ 0) num /= 2\n            else num = num * 3 + 1\n        }\n        seq += 1\n\
    \        seq.toList.filter(x => x % 2 == 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz1aqvpn5.scala:29)\n\tat Problem.main(tmpz1aqvpn5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        val lst = ListBuffer(n)\n\
    \        var x = n\n        while (x != 1) {\n            if (x % 2 == 0) x /=\
    \ 2\n            else x = 3 * x + 1\n            lst += x\n        }\n       \
    \ lst.filter(x => x % 2 == 1).toList.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var x = n\n        var result = List[Long]()\n     \
    \   while (x != 1) {\n            result = if (x % 2 == 1) x :: result else result\n\
    \            x = if (x % 2 == 0) x / 2 else x * 3 + 1\n        }\n        result\
    \ = 1l :: result\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpflibszk9.scala:28)\n\tat Problem.main(tmpflibszk9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def loop(n : Long, acc : List[Long]) : List[Long] =\
    \ {\n            if (n <= 1) acc.reverse\n            else if (n % 2 == 0) loop(n\
    \ / 2, acc)\n            else loop(3 * n + 1, n :: acc)\n        }\n        loop(n,\
    \ List[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy4rsrs5x.scala:26)\n\tat Problem.main(tmpy4rsrs5x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def helper(l : List[Long], x : Long) : List[Long] =\
    \ {\n            if (x == 1) l else if (x % 2 == 0) helper(l, x / 2) else helper(x\
    \ :: l, 3 * x + 1)\n        }\n        helper(List(), n).reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphoz6id4e.scala:24)\n\tat Problem.main(tmphoz6id4e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Once a number is seen, it is always seen.\n     \
    \   val known_numbers = new HashMap[Long, Boolean]\n        def collatz_helper(m\
    \ : Long) : List[Long] = {\n            if (m == 1) {\n                List[Long](1)\n\
    \            } else if (m % 2 == 0) {\n                val next = m / 2\n    \
    \            if (known_numbers.contains(next)) {\n                    List[Long](next)\n\
    \                } else {\n                    known_numbers += (next -> true)\n\
    \                    next :: collatz_helper(next)\n                }\n       \
    \     } else {\n                val next = 3 * m + 1\n                if (known_numbers.contains(next))\
    \ {\n                    List[Long](next)\n                } else {\n        \
    \            known_numbers += (next -> true)\n                    next :: collatz_helper(next)\n\
    \                }\n            }\n        }\n        known_numbers += (n -> true)\n\
    \        n :: collatz_helper(n)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl_hplz8.scala:45)\n\tat Problem.main(tmpcl_hplz8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009197
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val p = new Problem()\n        p.getOddCollatz(n, new\
    \ ListBuffer[Long]()).toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_o5cjzj9.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = \e[33mnew\e[0m\
    \ \e[35mProblem\e[0m()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Not found: type Problem\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        var seq = new ListBuffer[Long]()\n\
    \        var temp = n\n        while (temp != 1) {\n            if (temp % 2 ==\
    \ 1) seq += temp\n            temp = collatz(temp)\n        }\n        seq +=\
    \ 1\n        seq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwu67f2m2.scala:23:19 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            temp = collatz(temp)\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ collatz\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var seq = ListBuffer[Long]()\n        var m = n\n  \
    \      while (m != 1) {\n            seq += m\n            if (m % 2 == 0) m /=\
    \ 2\n            else m = 3 * m + 1\n        }\n        seq += 1\n        return\
    \ seq.filter(_ % 2 == 1).toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmponl8g40d.scala:29)\n\tat Problem.main(tmponl8g40d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var odd = List[Long]()\n        var cur = n\n      \
    \  while (cur != 1) {\n            odd = odd :+ cur\n            if (cur % 2 ==\
    \ 0) cur /= 2\n            else cur = cur * 3 + 1\n        }\n        odd\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpidzaim14.scala:28)\n\tat Problem.main(tmpidzaim14.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val s = Stack[Long]()\n        var count = 0\n     \
    \   var x = n\n        s.push(x)\n        while (x != 1) {\n            if (x\
    \ % 2 == 0) x = x / 2\n            else x = 3 * x + 1\n            s.push(x)\n\
    \        }\n        s.toList.filter(_ % 2 == 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3boh1z5t.scala:30)\n\tat Problem.main(tmp3boh1z5t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n      val ls = n :: getCollatz(n)\n      val result = ls.filter(i\
    \ => i % 2 == 1)\n      result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnqb7yy4t.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      \e[33mval\e[0m \e[36mls\e[0m = n :: getCollatz(n)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                Not found: getCollatz\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        val buff = new ArrayBuffer[Long]\n\
    \        buff += n\n        var m = n\n        var c = 0\n        do {\n     \
    \       if (m % 2 == 0) m /= 2\n            else m = 3 * m + 1\n            if\
    \ (m % 2 == 1) buff += m\n            c += 1\n        } while (m != 1)\n     \
    \   buff.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmianaihw.scala:23:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mdo\e[0m {\n\e[31m\e[31m   |\e[0m      \
    \  ^^\e[0m\n\e[31m   |\e[0m        end of statement expected but 'do' found\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // For example:\n        // Given n = 5:\n        //\
    \ after one round: 5 -> 16 -> 8 -> 4 -> 2 -> 1\n        // then, odd numbers:\
    \ 5, 1\n        // keep repeated numbers\n        var res = ListBuffer[Long]()\n\
    \        var temp = n\n        res += temp\n        while (temp != 1) {\n    \
    \        if (temp % 2 == 0) temp /= 2\n            else temp = 3 * temp + 1\n\
    \            res += temp\n        }\n        // println(res)\n        var oddRes\
    \ = ListBuffer[Long]()\n        var cnt = 0\n        while (cnt < res.length)\
    \ {\n            if (res(cnt) % 2 == 1) oddRes += res(cnt)\n            cnt +=\
    \ 1\n        }\n        oddRes.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8srhqh2g.scala:41)\n\tat Problem.main(tmp8srhqh2g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var oddCollatz = scala.collection.mutable.Set[Long]()\n\
    \        def helper(n : Long) : Unit = {\n            if (n == 1) {\n        \
    \        oddCollatz += 1\n                return\n            }\n            if\
    \ (n % 2 == 1) oddCollatz += n\n            helper(if (n % 2 == 0) n / 2 else\
    \ 3 * n + 1)\n        }\n        helper(n)\n        oddCollatz.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def iter(x : Long, acc : List[Long]) : List[Long] =\
    \ x match {\n            case x if x == 1 => acc.reverse\n            case x if\
    \ x % 2 == 0 => iter(x / 2, acc)\n            case x if x % 2 == 1 => iter(3 *\
    \ x + 1, x :: acc)\n        }\n        iter(n, List[Long]())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeqowntfv.scala:26)\n\tat Problem.main(tmpeqowntfv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n <= 0) throw new IllegalArgumentException(\"n must\
    \ be greater than zero\")\n        var result = ListBuffer[Long]()\n        var\
    \ number = n\n        while (number != 1) {\n            if (number % 2 == 1)\
    \ result += number\n            number = if (number % 2 == 0) number / 2 else\
    \ 3 * number + 1\n        }\n        result += 1\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbi7hak3l.scala:29)\n\tat Problem.main(tmpbi7hak3l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val numbers = ListBuffer[Long]()\n        var i = n\n\
    \        while (i != 1) {\n            if (i % 2 == 1) numbers += i\n        \
    \    i = getNextCollatz(i)\n        }\n        numbers += 1\n        numbers.sorted.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzkhgtp0s.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            i = getNextCollatz(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found:\
    \ getNextCollatz\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val table = scala.collection.mutable.Map[Long, Long]()\n\
    \        table += (1l -> 1l)\n        def helper(n : Long) : Long = {\n      \
    \      table.get(n) match {\n                case Some(num) => num\n         \
    \       case None => {\n                    val rst = if (n % 2 == 0) helper(n\
    \ / 2) else helper(3 * n + 1)\n                    table += (n -> rst)\n     \
    \               rst\n                }\n            }\n        }\n        val\
    \ collatz = helper(n)\n        var rst = List[Long]()\n        for (i <- collatz\
    \ to 1 by -1) {\n            if (i % 2 == 1) rst ::= i\n        }\n        rst\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4bktviyp.scala:38)\n\tat Problem.main(tmp4bktviyp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009197
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        var cur = n\n  \
    \      var result = List[Long]()\n        while (cur != 1) {\n            if (cur\
    \ % 2 == 1) result = result :+ cur\n            cur = if (cur % 2 == 0) cur /\
    \ 2 else cur * 3 + 1\n        }\n        result = result :+ 1\n        result.sortWith(_\
    \ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var l = ArrayBuffer[Long]()\n        l += n\n      \
    \  while (n != 1) {\n            n = if (n % 2 == 0) n / 2 else 3 * n + 1\n  \
    \          l += n\n        }\n        l.reverse.filter(x => x % 2 == 1).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp58b6vs3a.scala:21:14 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            n = \e[33mif\e[0m (n % \e[31m2\e[0m == \e\
    [31m0\e[0m) n / \e[31m2\e[0m \e[33melse\e[0m \e[31m3\e[0m * n + \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val n\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n <= 0) return List[Long]()\n        var l = new\
    \ ListBuffer[Long]()\n        def helper(x : Long) : Unit = {\n            l +=\
    \ x\n            if (x != 1) {\n                if (x % 2 == 0) helper(x / 2)\n\
    \                else helper(3 * x + 1)\n            }\n        }\n        helper(n)\n\
    \        l.toList.distinct.sorted\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzqqf974b.scala:31)\n\tat Problem.main(tmpzqqf974b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = new ListBuffer[Long]\n        var i = n\n\
    \        while (i > 1) {\n            if (i % 2 == 1) result += i\n          \
    \  i = if (i % 2 == 0) i / 2 else 3 * i + 1\n        }\n        result += 1\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5oehxii8.scala:28)\n\tat Problem.main(tmp5oehxii8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def recur(n : Long, lst : List[Long]) : List[Long] =\
    \ n match {\n            case n if n == 1 => lst\n            case n if n % 2\
    \ == 0 => recur(n / 2, lst)\n            case n if n % 2 == 1 => recur(3 * n +\
    \ 1, n :: lst)\n        }\n        recur(n, List()).sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpru8t2sm6.scala:26)\n\tat Problem.main(tmpru8t2sm6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val bf = ListBuffer[Long]()\n        var current : Long\
    \ = n\n        while (current != 1) {\n            if (current % 2 == 1) bf +=\
    \ current\n            current = (if (current % 2 == 0) current / 2 else current\
    \ * 3 + 1)\n        }\n        bf += 1\n        bf.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg8y1fy6z.scala:28)\n\tat Problem.main(tmpg8y1fy6z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatzList = ListBuffer[Long]()\n        collatzList\
    \ += n\n        var i = n\n        while (i != 1) {\n            if (i % 2 ==\
    \ 0) i /= 2\n            else i = i * 3 + 1\n            collatzList += i\n  \
    \      }\n        collatzList.toList.filter(_ % 2 == 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0kh9dq9m.scala:29)\n\tat Problem.main(tmp0kh9dq9m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Write your code here\n        return null;\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.getOddCollatz(long)\" is null\n\tat Problem$.main(tmprnpaey01.scala:22)\n\
    \tat Problem.main(tmprnpaey01.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) {\n            return List(1)\n        }\n\
    \        val lst = new ListBuffer[Long]()\n        lst += n\n        val x = getCollatz(n)\n\
    \        x.map(v => if (v % 2 == 1) lst += v)\n        lst.toList.sorted\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2fc15xpc.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mx\e[0m = getCollatz(n)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \        Not found: getCollatz\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var oddNumbers = new ListBuffer[Long]\n        var current\
    \ = n\n        while (current != 1) {\n            oddNumbers += current\n   \
    \         if (current % 2 == 0) current /= 2\n            else current = 3 * current\
    \ + 1\n        }\n        oddNumbers += 1\n        oddNumbers.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_suugauz.scala:29)\n\tat Problem.main(tmp_suugauz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        require(n > 0)\n        var result = ListBuffer[Long]()\n\
    \        result += n\n        while (n != 1) {\n            if (n % 2 == 0) n\
    \ /= 2\n            else n = 3 * n + 1\n            if (n % 2 == 1) result +=\
    \ n\n        }\n        result.sorted.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdh2h_khd.scala:22:30 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e\
    [0m) n /= \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^\e\
    [0m\n\e[31m   |\e[0m                   value /= is not a member of Long - did\
    \ you mean n.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdh2h_khd.scala:23:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e\
    [0m n = \e[31m3\e[0m * n + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m               \
    \  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 Reassignment to val n\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009205
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val oddList = new ListBuffer[Long]\n        if (n ==\
    \ 1) {\n            oddList += 1\n            return oddList.toList\n        }\n\
    \        var tempN = n\n        while (tempN != 1) {\n            if (tempN %\
    \ 2 == 1) {\n                oddList += tempN\n            }\n            tempN\
    \ = if (tempN % 2 == 0) tempN / 2 else tempN * 3 + 1\n        }\n        oddList\
    \ += 1\n        oddList.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq6ogy1m4.scala:34)\n\tat Problem.main(tmpq6ogy1m4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val m = new HashMap[Long, List[Long]]\n        m.put(1l,\
    \ List(1l))\n        def getCollatz(x : Long) : List[Long] = {\n            if\
    \ (m.contains(x)) m(x)\n            else {\n                val collatz = if (x\
    \ % 2 == 0) x / 2 else 3 * x + 1\n                m.put(x, x :: getCollatz(collatz))\n\
    \                m(x)\n            }\n        }\n        val collatzList = getCollatz(n)\n\
    \        collatzList.filter(x => x % 2 == 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf152ai1l.scala:32)\n\tat Problem.main(tmpf152ai1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009207
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) {\n            List(1)\n        } else {\n\
    \            var list = ListBuffer[Long]()\n            var next = if (n % 2 ==\
    \ 0) {\n                n / 2\n            } else {\n                3 * n + 1\n\
    \            }\n            while (next != 1) {\n                if (next % 2\
    \ == 1) {\n                    list += next\n                }\n             \
    \   next = if (next % 2 == 0) {\n                    next / 2\n              \
    \  } else {\n                    3 * next + 1\n                }\n           \
    \ }\n            list += 1\n            list.toList.sorted\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1iv045sk.scala:43)\n\tat Problem.main(tmp1iv045sk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009207
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = new ListBuffer[Long]\n        var next\
    \ = n\n        while (next != 1) {\n            if (next % 2 == 1) result += next\n\
    \            next = if (next % 2 == 0) next / 2 else 3 * next + 1\n        }\n\
    \        result += 1\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk0nosi_q.scala:28)\n\tat Problem.main(tmpk0nosi_q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var q = n\n        var result = List[Long]()\n     \
    \   while (q != 1) {\n            if (q % 2 == 1) result = result :+ q\n     \
    \       q = if (q % 2 == 0) q / 2 else 3 * q + 1\n        }\n        result =\
    \ result :+ 1\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3gsic47l.scala:28)\n\tat Problem.main(tmp3gsic47l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = ListBuffer[Long]()\n        var m = n\n\
    \        while (m != 1) {\n            if (m % 2 == 1) {\n                result\
    \ += m\n            }\n            m = if (m % 2 == 0) m / 2 else m * 3 + 1\n\
    \        }\n        result += 1\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp793x_8_a.scala:30)\n\tat Problem.main(tmp793x_8_a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009207
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1l)\n        val m = if (n %\
    \ 2 == 0) n / 2 else 3 * n + 1\n        getOddCollatz(m) :+ n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1mlycf73.scala:23)\n\tat Problem.main(tmp1mlycf73.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009207
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var x = n\n        var oddList = List[Long]()\n    \
    \    while (x != 1) {\n            if (x % 2 == 1) {\n                oddList\
    \ = oddList :+ x\n            }\n            x = if (x % 2 == 0) x / 2 else x\
    \ * 3 + 1\n        }\n        oddList :+ 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp817ianp6.scala:29)\n\tat Problem.main(tmp817ianp6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009207
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var list = new ListBuffer[Long]()\n        def rec(num\
    \ : Long) : Unit = {\n            if (num == 1) return\n            if (num %\
    \ 2 == 1) list += num\n            if (num % 2 == 0) rec(num / 2)\n          \
    \  else rec(num * 3 + 1)\n        }\n        rec(n)\n        list.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3dj41fuy.scala:29)\n\tat Problem.main(tmp3dj41fuy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009207
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        var res = new ListBuffer[Long]\n\
    \        var curr = n\n        while (curr != 1) {\n            if (curr % 2 ==\
    \ 1) res += curr\n            curr = curr / 2\n        }\n        return (1 ::\
    \ res.toList).sorted\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp65ct9v2a.scala:25:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mreturn\e[0m (\e[31m1\e[0m :: res.toList).sorted\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0mNo implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:\
    \    B is a type variable with constraint >: AnyVal\n\e[31m   |\e[0m..\n\e[31m\
    \   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mB\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[B]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[B].\n1 error found\n"
  stdout: ''
  timestamp: 1660009206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Fill up this function body\n        // 'n' is the\
    \ input argument\n        var x = n\n        var result = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        while (x > 1) {\n            if (x % 2 == 1) {\n                result\
    \ += x\n            }\n            x = if (x % 2 == 0) {\n                x /\
    \ 2\n            } else {\n                3 * x + 1\n            }\n        }\n\
    \        result += 1\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptuu2mfqb.scala:36)\n\tat Problem.main(tmptuu2mfqb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009207
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n    \tval path = HashMap[Long, List[Long]]()\n    \tdef t(x\
    \ : Long) : List[Long] = path.get(x) match {\n    \t\tcase Some(v) => v\n    \t\
    \tcase None => {\n    \t\t\tval v = if (x % 2 == 0) t(x / 2) else t(3 * x + 1)\n\
    \    \t\t\tpath += (x -> (x :: v))\n    \t\t\tv\n    \t\t}\n    \t}\n    \tt(n).reverse.filter(x\
    \ => x % 2 == 1)\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.runtime.Statics.anyHashNumber(Statics.java:132)\n\
    \tat scala.runtime.Statics.anyHash(Statics.java:124)\n\tat scala.collection.mutable.HashMap.get(HashMap.scala:78)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:19)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\tat Problem$.t$1(tmpc8vcs4hq.scala:22)\n\
    \tat Problem$.t$1(tmpc8vcs4hq."
  stdout: ''
  timestamp: 1660009207
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var list = ListBuffer[Long]()\n        var x = n\n \
    \       while (x != 1) {\n            list += x\n            if (x % 2 == 0) x\
    \ /= 2\n            else x = 3 * x + 1\n        }\n        list += 1\n       \
    \ list.toList.filter(_ % 2 == 1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0mjlaupm.scala:29)\n\tat Problem.main(tmp0mjlaupm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009207
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val set = new HashSet[Long]\n        var x = n\n   \
    \     while (x != 1) {\n            if (x % 2 == 1) {\n                set +=\
    \ x\n            }\n            x = x match {\n                case x if x % 2\
    \ == 0 => x / 2\n                case x if x % 2 == 1 => 3 * x + 1\n         \
    \   }\n        }\n        set.toList.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdz17l_u4.scala:32)\n\tat Problem.main(tmpdz17l_u4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009208
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        var s : MutableList[Long]\
    \ = MutableList()\n        var m : Long = n\n        while (m != 1) {\n      \
    \      if (m % 2 == 1) s += m\n            m = if (m % 2 == 0) m / 2 else 3 *\
    \ m + 1\n        }\n        s += 1\n        s.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv09nw0v_.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36ms\e[0m : \e[35mMutableList\e\
    [0m[\e[35mLong\e[0m] = MutableList()\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: type MutableList\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv09nw0v_.scala:19:36 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36ms\e[0m : \e[35mMutableList\e\
    [0m[\e[35mLong\e[0m] = MutableList()\n\e[31m\e[31m   |\e[0m                  \
    \                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \           Not found: MutableList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009209
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val lst = ListBuffer[Long]()\n        var result = n\n\
    \        while (result != 1) {\n            if (result % 2 == 1) {\n         \
    \       lst += result\n            }\n            result = if (result % 2 == 0)\
    \ result / 2 else 3 * result + 1\n        }\n        lst += 1\n        lst.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpopyzi2cw.scala:30)\n\tat Problem.main(tmpopyzi2cw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def collatz(n : Long) : Stream[Long] = n #:: {\n   \
    \         if (n == 1) Stream.empty\n            else if (n % 2 == 0) collatz(n\
    \ / 2)\n            else collatz(3 * n + 1)\n        }\n        collatz(n).filter(x\
    \ => x % 2 == 1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt0ql_rf7.scala:26)\n\tat Problem.main(tmpt0ql_rf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n      val result = ListBuffer[Long]()\n      def aux(m : Long)\
    \ : Unit = {\n        result += m\n        if (m == 1) return\n        else if\
    \ (m % 2 == 0) aux(m / 2)\n        else aux(3 * m + 1)\n      }\n      aux(n)\n\
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg52wfb3y.scala:29)\n\tat Problem.main(tmpg52wfb3y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var list = List[Long]()\n        list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe06q837k.scala:22)\n\tat Problem.main(tmpe06q837k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        require(n > 0)\n        val list = ListBuffer[Long]()\n\
    \        list += n\n        var cur = n\n        while (cur != 1) {\n        \
    \    if (cur % 2 == 0) cur /= 2\n            else cur = cur * 3 + 1\n        \
    \    if (cur % 2 == 1) list += cur\n        }\n        list.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcmwj_xge.scala:30)\n\tat Problem.main(tmpcmwj_xge.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var k = n\n        var odds = List[Long]()\n       \
    \ while (k != 1) {\n            if (k % 2 == 1) odds = k :: odds\n           \
    \ k = if (k % 2 == 0) k / 2 else 3 * k + 1\n        }\n        odds.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu89ozhch.scala:27)\n\tat Problem.main(tmpu89ozhch.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009215
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatz : List[Long] = List(n)\n        while (collatz.last\
    \ != 1) {\n            if (collatz.last % 2 == 0) collatz = collatz.init :+ (collatz.last\
    \ / 2)\n            else collatz = collatz.init :+ (3 * collatz.last + 1)\n  \
    \      }\n        collatz.filter(_ % 2 == 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_o_d_b5c.scala:26)\n\tat Problem.main(tmp_o_d_b5c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009216
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def collatz(n : Long) : List[Long] = {\n           \
    \ if (n == 1) List(1)\n            else if (n % 2 == 0) n :: collatz(n / 2)\n\
    \            else n :: collatz(3 * n + 1)\n        }\n        collatz(n).filter(_\
    \ % 2 == 1).distinct.sorted\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val cache = HashMap[Long, List[Long]]()\n        val\
    \ collatz = ListBuffer[Long]()\n        cache += (1L -> List(1L))\n        def\
    \ collatzToOne(n : Long) : List[Long] = {\n            if (cache.contains(n))\
    \ return cache(n)\n            if (n % 2 == 0) {\n                val prev = collatzToOne(n\
    \ / 2)\n                cache += (n -> (n :: prev))\n                return n\
    \ :: prev\n            }\n            else {\n                val prev = collatzToOne(3\
    \ * n + 1)\n                cache += (n -> (n :: prev))\n                return\
    \ n :: prev\n            }\n        }\n        collatzToOne(n).reverse.filter(_\
    \ % 2 == 1)\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbjwkd82t.scala:37)\n\tat Problem.main(tmpbjwkd82t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val l = new ListBuffer[Long]\n        if (n == 1) l\
    \ += 1\n        else {\n            var m = n\n            while (m != 1) {\n\
    \                if (m % 2 == 1) l += m\n                m = if (m % 2 == 0) m\
    \ / 2 else 3 * m + 1\n            }\n            l += 1\n        }\n        l.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp89am2qzh.scala:31)\n\tat Problem.main(tmp89am2qzh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var memo = scala.collection.mutable.Map[Long, Boolean]()\n\
    \        def collatz(n : Long) : Long = {\n            val seq = ArrayBuffer[Long]()\n\
    \            seq += n\n            def helper(n : Long) : Long = {\n         \
    \       if (n == 1) 1\n                else if (n % 2 == 0) {\n              \
    \      val next = n / 2\n                    seq += next\n                   \
    \ if (memo.contains(next)) {\n                        next\n                 \
    \   } else {\n                        helper(next)\n                    }\n  \
    \              } else {\n                    val next = n * 3 + 1\n          \
    \          seq += next\n                    if (memo.contains(next)) {\n     \
    \                   next\n                    } else {\n                     \
    \   helper(next)\n                    }\n                }\n            }\n  \
    \          val m = helper(n)\n            for (i <- 0 until seq.length) {\n  \
    \              memo += (seq(i) -> true)\n            }\n            m\n      \
    \  }\n        collatz(n)\n        var result = List[Long]()\n        for (n <-\
    \ 1 to n.toInt) {\n            if (memo.contains(n)) {\n                result\
    \ = n :: result\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwviwkawj.scala:58)\n\tat Problem.main(tmpwviwkawj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def getCollatzSeq(n : Long) : List[Long] = {\n     \
    \       var ret = List[Long]()\n            var num = n\n            while (num\
    \ != 1) {\n                ret = num :: ret\n                if (num % 2 == 0)\
    \ num /= 2\n                else num = num * 3 + 1\n            }\n          \
    \  num :: ret\n        }\n        getCollatzSeq(n).filter(x => x % 2 == 1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqis9m1ie.scala:31)\n\tat Problem.main(tmpqis9m1ie.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def getCollatzList(m : Long) : List[Long] = {\n    \
    \        m match {\n                case 1 => List(1)\n                case _\
    \ => {\n                    val newValue = if (m % 2 == 0) m / 2 else 3 * m +\
    \ 1\n                    m :: getCollatzList(newValue)\n                }\n  \
    \          }\n        }\n        getCollatzList(n).filter(_ % 2 == 1).distinct.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) List(1)\n        else {\n            val\
    \ m = if (n % 2 == 0) n / 2 else 3 * n + 1\n            getOddCollatz(m) :+ n\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoll1yjc1.scala:25)\n\tat Problem.main(tmpoll1yjc1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        var numbers = new\
    \ ListBuffer[Long]()\n        numbers += n\n        while (numbers.last != 1)\
    \ {\n            if (numbers.last % 2 == 0) numbers += numbers.last / 2\n    \
    \        else numbers += 3 * numbers.last + 1\n        }\n        numbers.filter(x\
    \ => x % 2 == 1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvc7ystrd.scala:28)\n\tat Problem.main(tmpvc7ystrd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def getOddCollatzHelper(n : Long, list : List[Long])\
    \ : List[Long] = {\n            if (n == 1) {\n                if (list.last ==\
    \ 1) list\n                else list :+ 1\n            }\n            else if\
    \ (n % 2 == 0) getOddCollatzHelper(n / 2, list)\n            else getOddCollatzHelper(3\
    \ * n + 1, list :+ n)\n        }\n        getOddCollatzHelper(n, List())\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ne_xxe7.scala:29)\n\tat Problem.main(tmp0ne_xxe7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009218
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var ans = List[Long]()\n        var cur = n\n      \
    \  while (cur != 1) {\n            if (cur % 2 == 1) {\n                ans =\
    \ cur :: ans\n            }\n            cur = nextCollatz(cur)\n        }\n \
    \       ans = 1l :: ans\n        ans.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd52f2q6y.scala:24:18 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            cur = nextCollatz(cur)\n\e[31m\e[31m   |\e\
    [0m                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found:\
    \ nextCollatz\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var oddNumbers = List[Long]()\n        if (n <= 0) return\
    \ oddNumbers\n        oddNumbers +:= n\n        var temp = n\n        while (temp\
    \ != 1) {\n            temp = if (temp % 2 == 0) {\n                temp / 2\n\
    \            } else {\n                3 * temp + 1\n            }\n         \
    \   if (temp % 2 != 0) {\n                oddNumbers +:= temp\n            }\n\
    \        }\n        oddNumbers.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpackj0mk8.scala:35)\n\tat Problem.main(tmpackj0mk8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def iter(m : Long, res : List[Long]) : List[Long] =\
    \ {\n            if (m == 1) return res\n            else if (m % 2 == 0) iter(m\
    \ / 2, res)\n            else iter(3 * m + 1, m :: res)\n        }\n        iter(n,\
    \ List[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgt3rp6ye.scala:26)\n\tat Problem.main(tmpgt3rp6ye.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val m = scala.collection.mutable.Map[Long, List[Long]]()\n\
    \        def get(n : Long) : List[Long] = {\n            if (n == 1) {\n     \
    \           m += (n -> List(1))\n                return List(1)\n            }\n\
    \            else if (m.contains(n)) {\n                return m(n)\n        \
    \    }\n            else {\n                var l : List[Long] = Nil\n       \
    \         if (n % 2 == 0) {\n                    l = n :: get(n / 2)\n       \
    \         }\n                else {\n                    l = n :: get(3 * n +\
    \ 1)\n                }\n                m += (n -> l)\n                return\
    \ l\n            }\n        }\n        get(n).filter(v => v % 2 == 1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcvgra708.scala:42)\n\tat Problem.main(tmpcvgra708.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009218
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var sequence = ListBuffer[Long]()\n        var current\
    \ = n\n        while (current != 1) {\n            sequence += current\n     \
    \       if (current % 2 == 0) current /= 2\n            else current = current\
    \ * 3 + 1\n        }\n        sequence += 1\n        val odd_sequence = sequence.filter(x\
    \ => x % 2 == 1)\n        odd_sequence.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn0wjsw_n.scala:30)\n\tat Problem.main(tmpn0wjsw_n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009218
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // TODO: find/merge duplicates\n        val list = ListBuffer[Long]()\n\
    \        var num = n\n        while (num != 1) {\n            list += num\n  \
    \          if (num % 2 == 0) {\n                num /= 2\n            } else {\n\
    \                num = num * 3 + 1\n            }\n        }\n        list +=\
    \ 1\n        list.toList.filter(x => x % 2 == 1).sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n <= 0) {\n            return List[Long]()\n   \
    \     }\n        val result = new ListBuffer[Long]()\n        var num = n\n  \
    \      while (num != 1) {\n            if (num % 2 == 1) {\n                result\
    \ += num\n            }\n            num = collatz(num)\n        }\n        result\
    \ += 1\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphgj9b9w2.scala:27:18 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            num = collatz(num)\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: collatz\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009216
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val l = ListBuffer[Long]()\n        var i = n\n    \
    \    while (i != 1) {\n            if (i % 2 == 1) {\n                l += i\n\
    \            }\n            i = if (i % 2 == 0) i / 2 else 3 * i + 1\n       \
    \ }\n        l += 1\n        l.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdw33lnxk.scala:30)\n\tat Problem.main(tmpdw33lnxk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009223
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = List[Long]()\n        var m = n\n     \
    \   while (m != 1) {\n            if (m % 2 == 1) result ::= m\n            m\
    \ = (if (m % 2 == 0) m / 2 else 3 * m + 1)\n        }\n        result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyfmcttf_.scala:27)\n\tat Problem.main(tmpyfmcttf_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var i = n\n        var result = new ListBuffer[Long]()\n\
    \        while (i != 1) {\n            if (i % 2 == 1) {\n                result\
    \ += i\n            }\n            i = if (i % 2 == 0) { i / 2 } else { 3 * i\
    \ + 1 }\n        }\n        result += 1\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz5qos28s.scala:30)\n\tat Problem.main(tmpz5qos28s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def getCollatz(n : Long) : List[Long] = {\n        \
    \    if (n == 1) {\n                List(1)\n            } else {\n          \
    \      var result = List[Long]()\n                var n1 = n\n               \
    \ while (n1 != 1) {\n                    result = n1 :: result\n             \
    \       if (n1 % 2 == 0) {\n                        n1 = n1 / 2\n            \
    \        } else {\n                        n1 = 3 * n1 + 1\n                 \
    \   }\n                }\n                result = 1 :: result\n             \
    \   result\n            }\n        }\n        getCollatz(n).filter(_ % 2 == 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptrq70a8z.scala:39)\n\tat Problem.main(tmptrq70a8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var res = new ListBuffer[Long]\n        var c = n\n\
    \        res += c\n        while (c != 1) {\n            c = if (c % 2 == 0) {\n\
    \                c / 2\n            } else {\n                3 * c + 1\n    \
    \        }\n            if (c % 2 == 1) {\n                res += c\n        \
    \    }\n        }\n        return res.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2zayvmbh.scala:34)\n\tat Problem.main(tmp2zayvmbh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var map = new HashMap[Long, Long]\n        def collatz(n\
    \ : Long) : Long = {\n            if (n == 1) return 1\n            if (map.contains(n))\
    \ return map(n)\n            if (n % 2 == 0) return collatz(n / 2)\n         \
    \   else {\n                val m = collatz(3 * n + 1)\n                map +=\
    \ n -> m\n                return m\n            }\n        }\n        var nn =\
    \ n\n        var count = 0\n        while (nn != 1) {\n            count += 1\n\
    \            nn = collatz(nn)\n        }\n        var result = new ListBuffer[Long]\n\
    \        nn = n\n        while (nn != 1) {\n            result += nn\n       \
    \     nn = collatz(nn)\n        }\n        result += 1\n        return result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_6c4oe60.scala:45)\n\tat Problem.main(tmp_6c4oe60.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        var answer = new\
    \ ListBuffer[Long]()\n        var num = n\n        while (num != 1) {\n      \
    \      if (num % 2 == 1) answer += num\n            num = if (num % 2 == 0) num\
    \ / 2 else num * 3 + 1\n        }\n        answer += 1\n        answer.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaykdzbyg.scala:29)\n\tat Problem.main(tmpaykdzbyg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // First, we can use the following algorithm to output\
    \ the collatz sequence of any given integer n:\n        // If n is 1, then return\
    \ 1.\n        // while n > 1,\n        //     if n is even:\n        //      \
    \   Print n\n        //         n = n / 2\n        //     else:\n        //  \
    \       Print n\n        //         n = 3n + 1\n        // Return n\n        //\
    \ Then, we can use another recursive function to get the odd numbers in the sequence.\n\
    \        def getOddCollatzRecursive(n : Long, odd : List[Long]) : List[Long] =\
    \ {\n            if (n <= 1) return 1 :: odd\n            if (n % 2 == 0) getOddCollatzRecursive(n\
    \ / 2, odd)\n            else getOddCollatzRecursive(3 * n + 1, n :: odd)\n  \
    \      }\n        getOddCollatzRecursive(n, Nil).sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = ListBuffer[Long]()\n        var cur = n\n\
    \        while (cur != 1) {\n            result += cur\n            if (cur %\
    \ 2 == 0) cur /= 2\n            else cur = cur * 3 + 1\n        }\n        result\
    \ += 1\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpms5e2fu_.scala:29)\n\tat Problem.main(tmpms5e2fu_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def helper(n : Long, result : List[Long]) : List[Long]\
    \ = {\n            if (n == 1) {\n                result\n            } else {\n\
    \                val next = if (n % 2 == 0) n / 2 else n * 3 + 1\n           \
    \     if (next % 2 == 1) helper(next, next :: result) else helper(next, result)\n\
    \            }\n        }\n        helper(n, List(n)).reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkthw_wk1.scala:29)\n\tat Problem.main(tmpkthw_wk1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var ans = List[Long]()\n        var num = n\n      \
    \  while (num != 1) {\n            if (num % 2 == 1) ans = num :: ans\n      \
    \      num = if (num % 2 == 0) num / 2 else num * 3 + 1\n        }\n        ans\
    \ = 1l :: ans\n        ans\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6m_bigzv.scala:28)\n\tat Problem.main(tmp6m_bigzv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val map = Map[Long, List[Long]]().withDefaultValue(List[Long]())\n\
    \        val result = ListBuffer[Long]()\n        def recur(x : Long) : Unit =\
    \ {\n            val cache = map(x)\n            if (cache.isEmpty) {\n      \
    \          if (x == 1) {\n                    result += 1\n                  \
    \  map(x) = result.toList\n                } else {\n                    if (x\
    \ % 2 == 0) {\n                        recur(x / 2)\n                    } else\
    \ {\n                        result += x\n                        recur(3 * x\
    \ + 1)\n                    }\n                    map(x) = result.toList\n  \
    \              }\n            } else result ++= cache\n        }\n        recur(n)\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp402eu8ul.scala:41)\n\tat Problem.main(tmp402eu8ul.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Given a positive integer n, return the next term\
    \ in collatz sequence.\n        def getNextCollatz(n : Long) : Long = {\n    \
    \        if (n == 1) 1 else\n            if (n % 2 == 0) n / 2 else\n        \
    \    3 * n + 1\n        }\n        // Given a positive integer n, return true\
    \ if n is odd, otherwise false.\n        def isOdd(n : Long) : Boolean = {\n \
    \           n % 2 == 1\n        }\n        var result = new ListBuffer[Long]\n\
    \        var n1 = n\n        while (n1 != 1) {\n            n1 = getNextCollatz(n1)\n\
    \            if (isOdd(n1)) result += n1\n        }\n        result += 1\n   \
    \     result.toList.sorted\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgpo1w0cf.scala:38)\n\tat Problem.main(tmpgpo1w0cf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var l = List[Long]()\n        var num = n\n        while\
    \ (num != 1) {\n            if (num % 2 == 1) l = num :: l\n            num =\
    \ if (num % 2 == 0) num / 2 else num * 3 + 1\n        }\n        1 :: l\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp95im9oat.scala:27)\n\tat Problem.main(tmp95im9oat.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = List[Long]()\n        val map = new HashMap[Long,\
    \ Long]()\n        for (i <- 1l to n) {\n            var s = i\n            var\
    \ temp = List[Long]()\n            while (s != 1) {\n                if (map.contains(s))\
    \ {\n                    s = map(s)\n                } else {\n              \
    \      if (s % 2 == 0) s /= 2\n                    else s = 3 * s + 1\n      \
    \              temp = s :: temp\n                }\n            }\n          \
    \  temp = temp.reverse\n            var temp2 = List[Long]()\n            for\
    \ (j <- temp.indices) {\n                if (j % 2 == 0) {\n                 \
    \   temp2 = temp(j) :: temp2\n                }\n                map += temp(j)\
    \ -> temp2(0)\n            }\n            result = (temp2 ::: result).sorted\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009232
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var number = n\n        var collatzSequence = ListBuffer[Long]()\n\
    \        while (number != 1) {\n            collatzSequence += number\n      \
    \      if (number % 2 == 0) number /= 2\n            else number = 3 * number\
    \ + 1\n        }\n        collatzSequence += 1\n        return collatzSequence.filter(number\
    \ => number % 2 == 1).toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxj7xyxl.scala:29)\n\tat Problem.main(tmpaxj7xyxl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var oddNumbers = new ListBuffer[Long]\n        def getOddCollatz0(n\
    \ : Long) : Unit = {\n            if (n == 1) {\n                return\n    \
    \        }\n            if (n % 2 == 1) {\n                oddNumbers += n\n \
    \           }\n            getOddCollatz0(if (n % 2 == 0) n / 2 else 3 * n + 1)\n\
    \        }\n        getOddCollatz0(n)\n        oddNumbers.toList.sortWith(_ <\
    \ _)\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpye8itnx3.scala:32)\n\tat Problem.main(tmpye8itnx3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatz = List[Long]()\n        var odd = List[Long]()\n\
    \        var temp = n\n        collatz = collatz.+:(temp)\n        while (temp\
    \ != 1) {\n            if (temp % 2 == 0) temp = temp / 2\n            else temp\
    \ = 3 * temp + 1\n            collatz = collatz.+:(temp)\n        }\n        for\
    \ (e <- collatz) {\n            if (e % 2 == 1) odd = odd.+:(e)\n        }\n \
    \       return odd\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkca8j6fr.scala:33)\n\tat Problem.main(tmpkca8j6fr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var oddCollatz = new ListBuffer[Long]()\n        var\
    \ current = n\n        while (current != 1) {\n            if (current % 2 ==\
    \ 1) oddCollatz += current\n            current = current % 2 match {\n      \
    \          case 0 => current / 2\n                case 1 => 3 * current + 1\n\
    \            }\n        }\n        oddCollatz += 1\n        oddCollatz.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzaq3ctd1.scala:31)\n\tat Problem.main(tmpzaq3ctd1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var seq = n :: List()\n        var m = n\n        while\
    \ (m != 1) {\n            if (m % 2 == 0) m /= 2\n            else m = 3 * m +\
    \ 1\n            seq = seq :+ m\n        }\n        var result = List[Long]()\n\
    \        for (i <- seq.indices) {\n            if (seq(i) % 2 == 1) result = result\
    \ :+ seq(i)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp2ny2r6x.scala:32)\n\tat Problem.main(tmpp2ny2r6x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var m = n\n        var ans = List[Long]()\n        while\
    \ (m != 1) {\n            if (m % 2 == 1) ans = m :: ans\n            m = if (m\
    \ % 2 == 0) m / 2 else 3 * m + 1\n        }\n        ans = 1 :: ans\n        ans\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpij13oui4.scala:28)\n\tat Problem.main(tmpij13oui4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Since the input is positive, and the Collatz sequence\
    \ will always reach 1, so the sequence length is\n        // at most 100,000,000.\n\
    \        val collatz = new Array[Long](100000000)\n        collatz(0) = 1\n  \
    \      var tmp : Long = n\n        var oddCollatz : List[Long] = List()\n    \
    \    while (tmp != 1) {\n            if (tmp % 2 == 1) {\n                oddCollatz\
    \ = tmp :: oddCollatz\n            }\n            tmp = if (tmp % 2 == 0) tmp\
    \ / 2 else 3 * tmp + 1\n        }\n        oddCollatz\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqkc7vxny.scala:33)\n\tat Problem.main(tmpqkc7vxny.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var h = HashMap[Long, Long]()\n        var b = ListBuffer[Long]()\n\
    \        h(1) = 1\n        val f = (i : Long) => {\n            h(i) = i\n   \
    \         if (i % 2 == 0) i / 2 else 3 * i + 1\n        }\n        def g(i : Long)\
    \ : List[Long] = {\n            if (h.contains(i)) {\n                var x =\
    \ i\n                var l = List[Long]()\n                while (x != 1) {\n\
    \                    l = x :: l\n                    x = h(x)\n              \
    \  }\n                return l\n            }\n            else {\n          \
    \      var c = i\n                while (h.contains(c) == false) {\n         \
    \           c = f(c)\n                }\n                var l = List[Long]()\n\
    \                var p = i\n                while (p != c) {\n               \
    \     l = p :: l\n                    p = f(p)\n                }\n          \
    \      g(c) ::: l\n            }\n        }\n        var x = n\n        var l\
    \ = List[Long]()\n        while (x != 1) {\n            l = x :: l\n         \
    \   x = f(x)\n        }\n        l.filter(x => x % 2 == 1).sorted\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt42rk7j1.scala:58)\n\tat Problem.main(tmpt42rk7j1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009231
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Recursively go through the collatz sequence of n,\
    \ and return the odds.\n        // TODO: optimize\n        var result = ListBuffer[Long]()\n\
    \        def getOddCollatzHelper(n : Long) : List[Long] = {\n            if (n\
    \ != 1l) {\n                if (n % 2 == 1) {\n                    result += n\n\
    \                    getOddCollatzHelper((3l * n + 1l) / 2l)\n               \
    \ } else {\n                    getOddCollatzHelper(n / 2l)\n                }\n\
    \            } else {\n                result += 1l\n                result.toList\n\
    \            }\n        }\n        if (n == 1l) List(1l) else getOddCollatzHelper(n)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpivz5yetq.scala:37)\n\tat Problem.main(tmpivz5yetq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009234
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatz : List[Long] = List(n)\n        var current\
    \ = n\n        while (current != 1) {\n            current = if (current % 2 ==\
    \ 0) current / 2 else 3 * current + 1\n            collatz :+= current\n     \
    \   }\n        collatz.filter(x => x % 2 == 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx1_2ez62.scala:27)\n\tat Problem.main(tmpx1_2ez62.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009235
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n <= 0) return List()\n        var lst = List(n)\n\
    \        while (lst.last != 1) {\n            val current = lst.last\n       \
    \     lst = if (current % 2 == 0) current / 2 :: lst else (current * 3 + 1) ::\
    \ lst\n        }\n        return lst.filter(a => a % 2 == 1).sorted\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var lst = List[Long]()\n        while (n != 1) {\n \
    \           if (n % 2 == 1) {\n                lst = n :: lst\n            }\n\
    \            n = if (n % 2 == 0) n / 2 else n * 3 + 1\n        }\n        lst\
    \ = 1 :: lst\n        lst\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp2i771e85.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            n = \e[33mif\e[0m (n % \e[31m2\e[0m == \e\
    [31m0\e[0m) n / \e[31m2\e[0m \e[33melse\e[0m n * \e[31m3\e[0m + \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val n\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009230
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // We first precompute the collatz sequence for 1 ~\
    \ 1000000\n        val collatzMap = new HashMap[Long, List[Long]]\n        val\
    \ oddCollatzMap = new HashMap[Long, List[Long]]\n        for (i <- 1 to 1000000)\
    \ {\n            var temp = i\n            var collatzList = List[Long]()\n  \
    \          while (temp != 1) {\n                collatzList = collatzList :+ temp\n\
    \                if (temp % 2 == 0) temp /= 2\n                else temp = 3 *\
    \ temp + 1\n            }\n            collatzList = collatzList :+ 1\n      \
    \      collatzMap(i) = collatzList\n            oddCollatzMap(i) = collatzList.filter(x\
    \ => x % 2 == 1)\n        }\n        // Now we compute the odd collatz sequence\
    \ for n\n        val oddCollatz = ListBuffer[Long]()\n        var temp = n\n \
    \       while (temp != 1) {\n            oddCollatz += temp\n            if (temp\
    \ % 2 == 0) temp /= 2\n            else temp = 3 * temp + 1\n        }\n     \
    \   oddCollatz += 1\n        oddCollatz.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009238
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n <= 0) throw new IllegalArgumentException(\"n must\
    \ be positive\");\n        val seq = new ListBuffer[Long]();\n        var x =\
    \ n;\n        while (x != 1) {\n            seq += x;\n            if (x % 2 ==\
    \ 0) x /= 2;\n            else x = 3 * x + 1;\n        }\n        seq += 1;\n\
    \        seq.toList.filter(k => k % 2 == 1);\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdr4hnwp_.scala:30)\n\tat Problem.main(tmpdr4hnwp_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009235
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatz = ArrayBuffer(n)\n        var last = n\n\
    \        var stop = false\n        while(!stop) {\n            val newItem = last\
    \ match {\n                case x if x % 2 == 0 => x / 2\n                case\
    \ _ => 3 * last + 1\n            }\n            collatz += newItem\n         \
    \   if (newItem == 1) stop = true\n            last = newItem\n        }\n   \
    \     collatz.toList.sorted.filter(x => x % 2 == 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps67djkc0.scala:36)\n\tat Problem.main(tmps67djkc0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // We need to generate the collatz sequence.\n     \
    \   // We must solve the problem for all the lower cases, and then build the solution\
    \ for the new case.\n        // This is a dynamic programming technique, in which\
    \ we will build the solution with memoization.\n        // Since we need to build\
    \ the solution for any lower case and for any case, we will put them all in a\
    \ map.\n        // The map will have key as the number, and the value as the list\
    \ of odd collatz numbers.\n        // There will be two functions. One will start\
    \ the search and the other will be a recursive function that will build the solution.\n\
    \        val map = new HashMap[Long, List[Long]]\n        val oddCollatzFinder\
    \ = (n : Long) => {\n            // This function will check the map and see if\
    \ the solution exists. If it does, it will be returned.\n            // Else,\
    \ the recursion will start and the solution will be saved in the map.\n      \
    \      if (map.contains(n)) {\n                map(n)\n            } else {\n\
    \                val list = getOddCollatzRecursive(n, map)\n                map\
    \ += (n -> list)\n                list\n            }\n        }\n        oddCollatzFinder(n)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmbtdlz8a.scala:31:27 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mval\e[0m \e[36mlist\e[0m = getOddCollatzRecursive(n,\
    \ map)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: getOddCollatzRecursive\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009233
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val collatz = new HashMap[Long, List[Long]]\n      \
    \  def collatzHelper(n : Long) : List[Long] = {\n            val result = collatz.get(n)\n\
    \            if (result != None) result.get\n            else {\n            \
    \    if (n == 1) List(1)\n                else if (n % 2 == 0) n :: collatzHelper(n\
    \ / 2)\n                else n :: collatzHelper(3 * n + 1)\n            }\n  \
    \      }\n        collatzHelper(n).filter(_ % 2 == 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7gi71ccp.scala:31)\n\tat Problem.main(tmp7gi71ccp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        return recurOddCollatz(n, List(n))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpitk3wjtm.scala:18:15 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mreturn\e[0m recurOddCollatz(n, List(n))\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \           Not found: recurOddCollatz\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009232
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var lst = List[Long]()\n        if (n <= 0) return lst\n\
    \        var m = n\n        while (m != 1) {\n            if (m % 2 == 1) lst\
    \ = m :: lst\n            m = if (m % 2 == 0) m / 2 else 3 * m + 1\n        }\n\
    \        lst = 1 :: lst\n        lst\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpicvioul3.scala:29)\n\tat Problem.main(tmpicvioul3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009237
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def h(n : Long, acc : List[Long]) : List[Long] = {\n\
    \            if (n == 1) acc\n            else if (n % 2 == 0) h(n / 2, acc)\n\
    \            else h(3 * n + 1, n :: acc)\n        }\n        h(n, List()).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi6lpn5a4.scala:26)\n\tat Problem.main(tmpi6lpn5a4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009238
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val stack = new Stack[Long]\n        stack.push(n)\n\
    \        var current = n\n        var next = 0L\n        while (current != 1)\
    \ {\n            if (current % 2 == 0) next = current / 2\n            else next\
    \ = 3 * current + 1\n            stack.push(next)\n            current = next\n\
    \        }\n        stack.toList.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp48l0b05a.scala:31)\n\tat Problem.main(tmp48l0b05a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009238
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def tail(n : Long, l : List[Long]) : List[Long] = {\n\
    \            val next = if (n % 2 == 0) n / 2 else 3 * n + 1\n            if (next\
    \ == 1) l\n            else tail(next, l :+ next)\n        }\n        tail(n,\
    \ List(n)).filter(x => x % 2 == 1)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmploq0659_.scala:26)\n\tat Problem.main(tmploq0659_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009238
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var list = ListBuffer[Long]()\n        var curr = n\n\
    \        while (curr != 1) {\n            list += curr\n            if (curr %\
    \ 2 == 0) curr /= 2\n            else curr = 3 * curr + 1\n        }\n       \
    \ list += 1\n        list.toList.filter(x => x % 2 == 1).sorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009238
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var list = new ListBuffer[Long]()\n        list += n\n\
    \        var i = n\n        while (i != 1) {\n            if (i % 2 == 0) i /=\
    \ 2\n            else i = i * 3 + 1\n            if (i % 2 == 1) list += i\n \
    \       }\n        list.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp67j11fzl.scala:29)\n\tat Problem.main(tmp67j11fzl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009238
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def getOddCollatz(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (n == 1) acc\n            else if (n % 2 == 0) getOddCollatz(n\
    \ / 2, acc)\n            else getOddCollatz(3 * n + 1, n :: acc)\n        }\n\
    \        getOddCollatz(n, List())\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpanl2xw0k.scala:26)\n\tat Problem.main(tmpanl2xw0k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009238
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def isOdd(n : Long) : Boolean = n % 2 == 1\n       \
    \ def getCollatz(n : Long) : Long = {\n            if (n == 1) return 1l\n   \
    \         if (isOdd(n)) 3 * n + 1 else n / 2\n        }\n        def getCollatzSeq(n\
    \ : Long) : List[Long] = {\n            def getCollatzSeq(n : Long, seq : List[Long])\
    \ : List[Long] = {\n                if (n == 1) return seq\n                getCollatzSeq(getCollatz(n),\
    \ n :: seq)\n            }\n            getCollatzSeq(n, List())\n        }\n\
    \        getCollatzSeq(n).filter(isOdd).distinct.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7y_7xftv.scala:33)\n\tat Problem.main(tmp7y_7xftv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009240
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n      val collatz = new ListBuffer[Long]()\n      collatz +=\
    \ n\n      def helper(n : Long) : List[Long] = {\n        collatz += n\n     \
    \   if (n == 1) collatz.toList\n        else {\n          if (n % 2 == 0) helper(n\
    \ / 2)\n          else helper(3 * n + 1)\n        }\n      }\n      helper(n)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfyd31k8r.scala:31)\n\tat Problem.main(tmpfyd31k8r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009238
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var l = List[Long]()\n        var m = n\n        while\
    \ (m != 1) {\n            if (m % 2 == 1) l = m :: l\n            m = (if (m %\
    \ 2 == 0) m / 2 else 3 * m + 1)\n        }\n        l = 1 :: l\n        l.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009240
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def f(l : List[Long], c : Long) : List[Long] = {\n \
    \           if (c == 1) {\n                l\n            } else {\n         \
    \       if (c % 2 == 0) {\n                    f(l, c / 2)\n                }\
    \ else {\n                    f(c :: l, (3 * c + 1) / 2)\n                }\n\
    \            }\n        }\n        f(List(n), n).sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuwbgu_t9.scala:32)\n\tat Problem.main(tmpuwbgu_t9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009241
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val ret = ListBuffer[Long]()\n        var x = n\n  \
    \      while (x != 1) {\n            ret += x\n            if (x % 2 == 0) x /=\
    \ 2\n            else x = 3 * x + 1\n        }\n        ret += 1\n        return\
    \ ret.toList.filter(x => x % 2 == 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzy2sk28q.scala:29)\n\tat Problem.main(tmpzy2sk28q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val list = MutableList[Long]()\n        var a = n\n\
    \        while (a != 1) {\n            if (a % 2 == 1) list += a\n           \
    \ a = if (a % 2 == 0) a / 2 else 3 * a + 1\n        }\n        list += 1\n   \
    \     list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_1azxm1f.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = MutableList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                   Not found: MutableList\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n    \tif (n == 1) return List(1l)\n    \tvar collatz : List[Long]\
    \ = new ListBuffer[Long]() += n\n    \twhile (collatz.last != 1) {\n    \t\tif\
    \ (collatz.last % 2 == 0) collatz += collatz.last / 2\n    \t\telse collatz +=\
    \ collatz.last * 3 + 1\n    \t}\n    \tcollatz.filter(_ % 2 == 1).toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw7plcdkp.scala:19:35\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \t\e[33mvar\e[0m \e[36mcollatz\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e\
    [35mLong\e[0m]() += n\n\e[31m\e[31m   |\e[0m    \t                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpw7plcdkp.scala:21:43 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    \t\t\e[33mif\e[0m (collatz.last % \e[31m2\e[0m ==\
    \ \e[31m0\e[0m) collatz += collatz.last / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m\
    \    \t\t                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ += is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpw7plcdkp.scala:22:21 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m    \t\t\e[33melse\e[0m collatz += collatz.last * \e\
    [31m3\e[0m + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m    \t\t     ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009242
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def helper(n : Long, result : List[Long]) : List[Long]\
    \ = {\n            if (n == 1) {\n                result.reverse\n           \
    \ } else {\n                val next = if (n % 2 == 0) {\n                   \
    \ n / 2\n                } else {\n                    n * 3 + 1\n           \
    \     }\n                helper(next, (if (n % 2 == 1) n else -1) :: result)\n\
    \            }\n        }\n        helper(n, List[Long]()).filter(_ > 0)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcy_b4hs0.scala:33)\n\tat Problem.main(tmpcy_b4hs0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009243
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val map = Map[Long, List[Long]]()\n        val oddNumbers\
    \ = new ListBuffer[Long]()\n        def getOddCollatz(n : Long) : List[Long] =\
    \ {\n            if (n == 1) List(1)\n            else if (map.contains(n)) {\n\
    \                oddNumbers ++= map(n).filter(_ % 2 == 1)\n                map(n)\n\
    \            }\n            else {\n                val result = if (n % 2 ==\
    \ 0) getOddCollatz(n / 2)\n                else getOddCollatz(3 * n + 1)\n   \
    \             map += (n -> result)\n                oddNumbers ++= result.filter(_\
    \ % 2 == 1)\n                result\n            }\n        }\n        getOddCollatz(n)\n\
    \        oddNumbers.toList.sorted\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiextn9ss.scala:38)\n\tat Problem.main(tmpiextn9ss.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009245
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatz = List[Long]()\n        var current = n\n\
    \        if (current == 1) collatz ::= 1\n        while (current != 1) {\n   \
    \         if (current % 2 == 1) collatz ::= current\n            current = if\
    \ (current % 2 == 0) current / 2 else current * 3 + 1\n        }\n        collatz.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfw8hzttm.scala:28)\n\tat Problem.main(tmpfw8hzttm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009245
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def loop(n : Long, res : List[Long]) : List[Long] =\
    \ {\n            if (n == 1)\n                return res\n            val next\
    \ = if (n % 2 == 0) (n / 2) else (3 * n + 1)\n            loop(next, if (next\
    \ % 2 == 1) next :: res else res)\n        }\n        loop(n, List[Long]())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbvprtmf6.scala:27)\n\tat Problem.main(tmpbvprtmf6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009245
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatzN : Long = n\n        var collatzSequence\
    \ : List[Long] = List()\n        if (n == 1) return List(1)\n        while (collatzN\
    \ != 1) {\n            if (collatzN % 2 == 0) collatzN /= 2\n            else\
    \ collatzN = collatzN * 3 + 1\n            collatzSequence = collatzN :: collatzSequence\n\
    \        }\n        collatzSequence.filter(x => x % 2 == 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5_hzzkmo.scala:29)\n\tat Problem.main(tmp5_hzzkmo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009247
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var sequence = new ListBuffer[Long]()\n        var number\
    \ = n\n        while (number != 1) {\n            if (number % 2 == 1) {\n   \
    \             sequence += number\n            }\n            number = if (number\
    \ % 2 == 0) number / 2 else 3 * number + 1\n        }\n        sequence += 1\n\
    \        sequence.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ukmzybo.scala:30)\n\tat Problem.main(tmp7ukmzybo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009247
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var l = new ListBuffer[Long]()\n        l += n\n   \
    \     var m = n\n        while (m != 1) {\n            if (m % 2 == 0) {\n   \
    \             m = m / 2\n            } else {\n                m = 3 * m + 1\n\
    \            }\n            l += m\n        }\n        l.filter(_ % 2 == 1).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7a7bc3dx.scala:32)\n\tat Problem.main(tmp7a7bc3dx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009248
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var odds = ArrayBuffer[Long]()\n        var current\
    \ = n\n        while (current != 1) {\n            odds += current\n         \
    \   current = if (current % 2 == 0) current / 2 else current * 3 + 1\n       \
    \ }\n        odds += 1\n        return odds.filter(_ % 2 == 1).toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaqkuudjf.scala:28)\n\tat Problem.main(tmpaqkuudjf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009248
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = ListBuffer[Long]()\n        var t = n\n\
    \        while (t != 1) {\n            if (t % 2 == 1) result += t\n         \
    \   t = if (t % 2 == 0) t / 2 else t * 3 + 1\n        }\n        result += 1\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp32ucxclx.scala:28)\n\tat Problem.main(tmp32ucxclx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009249
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatz : List[Long] = List(n)\n        var n_acc\
    \ = n\n        while (n_acc != 1) {\n            if (n_acc % 2 == 0) {\n     \
    \           n_acc = n_acc / 2\n            } else {\n                n_acc = 3\
    \ * n_acc + 1\n            }\n            collatz = collatz :+ n_acc\n       \
    \ }\n        collatz = collatz.filter((x : Long) => x % 2 == 1)\n        collatz\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppo2iwt3j.scala:32)\n\tat Problem.main(tmppo2iwt3j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Solution 1: dp.\n        // Calc collatz sequence\
    \ up to the limit and keep track of the odd numbers.\n        // Time: O(n)\n\
    \        // Space: O(n)\n        def dp() : List[Long] = {\n            val dp\
    \ = new Array[Long]((1e9).toInt)\n            dp(1) = 1\n            val odds\
    \ = new ListBuffer[Long]\n            odds += 1\n            var i = 2\n     \
    \       while (i < dp.length) {\n                var n = i\n                val\
    \ seq = new ListBuffer[Long]\n                while (n > 1 && n < dp.length &&\
    \ dp(n) == 0) {\n                    seq += n\n                    if (n % 2 ==\
    \ 0) n /= 2\n                    else n = 3 * n + 1\n                }\n     \
    \           val k = if (n < dp.length) dp(n) else dp(seq.last / 2)\n         \
    \       for (j <- seq.length - 1 to 0 by -1) {\n                    dp(seq(j))\
    \ = k + seq.length - j\n                    if (seq(j) % 2 == 1) odds += seq(j)\n\
    \                }\n                i += 1\n            }\n            odds.toList.sorted\n\
    \        }\n        // Solution 2: dp.\n        // Calc collatz sequence.\n  \
    \      // Time: O(n)\n        // Space: O(n)\n        def dp2() : List[Long] =\
    \ {\n            val seq = new ListBuffer[Long]\n            var n = n\n     \
    \       while (n > 1) {\n                seq += n\n                if (n % 2 ==\
    \ 0) n /= 2\n                else n = 3 * n + 1\n            }\n            seq\
    \ += 1\n            seq.toList.filter(_ % 2 == 1)\n        }\n        // Solution\
    \ 3: recursion.\n        // Calc collatz sequence.\n        // Time: O(n)\n  \
    \      // Space: O(n)\n        def recursion() : List[Long] = {\n            def\
    \ calc(n : Long) : List[Long] = {\n                if (n == 1) return List(1)\n\
    \                val\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpg71xkk7d.scala:67:19 ---------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m                \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m\
    \                   ^\e[0m\n\e[31m   |\e[0m                   pattern expected\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg71xkk7d.scala:77:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpg71xkk7d.scala:36:57 --------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m                \e[33mval\e[0m \e[36mk\e[0m = \e[33mif\e[0m (n\
    \ < dp.length) dp(n) \e[33melse\e[0m dp(seq.last / \e[31m2\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                                         ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                         Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg71xkk7d.scala:38:26\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    dp(seq(j))\
    \ = k + seq.length - j\n\e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    Long\n\e[31m   |\e[0m        \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpg71xkk7d.scala:51:20 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m            \e[33mvar\e[0m \e[36mn\e[0m = n\n\e[31m\e[31m   |\e[0m   \
    \                 ^\e[0m\n\e[31m   |\e[0m                    Recursive \e[33mvariable\e\
    [0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpg71xkk7d.scala:68:5 ---------------------\e[0m\e[0m\n\e[31m68\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Re"
  stdout: ''
  timestamp: 1660009250
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Algorithm:\n        // Just run till you hit 1.\n\
    \        // Because of this sequence property (odds), it is guaranteed to hit\
    \ 1.\n        var current = n\n        var collatz : List[Long] = Nil\n      \
    \  while (current != 1) {\n            collatz = current :: collatz\n        \
    \    if (current % 2 == 0) current /= 2\n            else current = current *\
    \ 3 + 1\n        }\n        return collatz\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw3bnld9p.scala:31)\n\tat Problem.main(tmpw3bnld9p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009250
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = List[Long]()\n        var tmp = n\n   \
    \     while (tmp != 1) {\n            if (tmp % 2 == 1) {\n                result\
    \ = result :+ tmp\n            }\n            tmp = (if (tmp % 2 == 0) tmp / 2\
    \ else 3 * tmp + 1)\n        }\n        result = result :+ 1\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzsl4r9c2.scala:30)\n\tat Problem.main(tmpzsl4r9c2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009249
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Fill up this function body\n        // 'result' is\
    \ a list of the odd numbers in collatz sequence.\n        // 'result' should be\
    \ in sorted order.\n        var result = List[Long]()\n        var temp = n\n\
    \        while (temp != 1) {\n            result = result :+ temp\n          \
    \  if (temp % 2 == 0) {\n                temp = temp / 2\n            } else {\n\
    \                temp = 3 * temp + 1\n            }\n        }\n        result\
    \ = result :+ 1\n        result.distinct.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4nubzzeq.scala:35)\n\tat Problem.main(tmp4nubzzeq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009250
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def getCollatz(num : Long) : List[Long] = {\n      \
    \      def helper(n : Long, acc : List[Long]) : List[Long] = {\n             \
    \   if (n == 1) acc\n                else if (n % 2 == 0) helper(n / 2, n :: acc)\n\
    \                else helper(3 * n + 1, n :: acc)\n            }\n           \
    \ helper(num, List())\n        }\n        getCollatz(n).filter(p => p % 2 == 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbq0gezr9.scala:29)\n\tat Problem.main(tmpbq0gezr9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009250
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def helper(num : Long, list : List[Long]) : List[Long]\
    \ = {\n            val x = if (num % 2 == 0) num / 2 else num * 3 + 1\n      \
    \      if (x == 1) list :+ x\n            else helper(x, list :+ x)\n        }\n\
    \        helper(n, List()).filter(_ % 2 == 1).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp35pmemr3.scala:26)\n\tat Problem.main(tmp35pmemr3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009250
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def getOddCollatz0(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (n == 1) acc\n            else if (n % 2 == 0) getOddCollatz0(n\
    \ / 2, acc)\n            else getOddCollatz0(3 * n + 1, n :: acc)\n        }\n\
    \        getOddCollatz0(n, List[Long]()).sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0xktuv79.scala:26)\n\tat Problem.main(tmp0xktuv79.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n    \tval collatz = new mutable.ArrayBuffer[Long]()\n    \t\
    var i = n\n    \twhile (i != 1) {\n    \t\tcollatz += i\n    \t\tif (i % 2 ==\
    \ 0) i /= 2\n    \t\telse i = 3 * i + 1\n    \t}\n    \tcollatz += 1\n    \tcollatz.filter(_\
    \ % 2 == 1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmp_8rvzi.scala:18:26 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m    \t\e[33mval\e[0m \e[36mcollatz\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m    \t      \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m    \t                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009246
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        require(n > 0)\n        var results = ListBuffer[Long]()\n\
    \        val seq = Stream.iterate(n)(x => if (x % 2 == 0) x / 2 else 3 * x + 1)\n\
    \        seq.takeWhile(_ != 1).foreach(x => if (x % 2 == 1) results += x)\n  \
    \      results += 1\n        results.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq7_zzhfy.scala:26)\n\tat Problem.main(tmpq7_zzhfy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009252
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatz = new ArrayBuffer[Long]()\n        collatz\
    \ += n\n        var num = n\n        while (num != 1) {\n            num = if\
    \ (num % 2 == 0) num / 2 else num * 3 + 1\n            collatz += num\n      \
    \  }\n        collatz.filter(x => x % 2 == 1).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpft63t4qq.scala:28)\n\tat Problem.main(tmpft63t4qq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009251
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n <= 0) return List()\n        var set = List[Long]()\n\
    \        var x = n\n        while (x != 1) {\n            if (x % 2 == 1) set\
    \ = x :: set\n            x = if (x % 2 == 0) x / 2 else 3 * x + 1\n        }\n\
    \        set = 1 :: set\n        set.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def f(n : Long, res : List[Long]) : List[Long] = {\n\
    \            if (n == 1) res.reverse\n            else if (n % 2 == 0) f(n / 2,\
    \ res)\n            else f(3 * n + 1, n :: res)\n        }\n        f(n, List())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsfe70g85.scala:26)\n\tat Problem.main(tmpsfe70g85.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val queue = new ListBuffer[Long]()\n        val oddNums\
    \ = new ListBuffer[Long]()\n        if (n <= 0) return List[Long]()\n        queue\
    \ += n\n        while (!queue.isEmpty) {\n            val curr = queue.remove(0)\n\
    \            if (curr % 2 == 1) oddNums += curr\n            val next = if (curr\
    \ % 2 == 0) curr / 2 else curr * 3 + 1\n            if (next != 1) queue += next\n\
    \        }\n        return oddNums.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4m_9_sft.scala:31)\n\tat Problem.main(tmp4m_9_sft.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val collatz = new HashMap[Long, List[Long]]\n      \
    \  collatz += (1l -> List(1l))\n        def next(x : Long) : Long = {\n      \
    \      if (x % 2 == 0) x / 2\n            else 3 * x + 1\n        }\n        def\
    \ listCollatz(x : Long) : List[Long] = {\n            if (collatz.contains(x))\
    \ collatz(x)\n            else {\n                val collatzNext = listCollatz(next(x))\n\
    \                collatz += (x -> (x :: collatzNext))\n                collatz(x)\n\
    \            }\n        }\n        collatz(n).filter(x => x % 2 == 1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: key not found: 14\n\tat scala.collection.MapOps.default(Map.scala:274)\n\
    \tat scala.collection.MapOps.default$(Map.scala:273)\n\tat scala.collection.AbstractMap.default(Map.scala:405)\n\
    \tat scala.collection.mutable.HashMap.apply(HashMap.scala:425)\n\tat Problem$.getOddCollatz(tmpfwkp1ijq.scala:32)\n\
    \tat Problem$.main(tmpfwkp1ijq.scala:35)\n\tat Problem.main(tmpfwkp1ijq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        return getOddCollatz(List[Long](n)).reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn7xo37k4.scala:18:39\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mreturn\e[0m getOddCollatz(List[\e\
    [35mLong\e[0m](n)).reverse\n\e[31m\e[31m   |\e[0m                            \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Found:    \e\
    [1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m    \
    \                         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009255
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) List(1)\n        else {\n            var\
    \ oddList = List[Long]()\n            var currentNum = n\n            while (currentNum\
    \ != 1) {\n                if (currentNum % 2 == 1) {\n                    oddList\
    \ = oddList :+ currentNum\n                }\n                currentNum = if\
    \ (currentNum % 2 == 0) currentNum / 2 else 3 * currentNum + 1\n            }\n\
    \            oddList = oddList :+ 1\n            oddList.sorted\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009257
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def recurse(c : Long, m : Long) : Long = {\n       \
    \     if (c % 2 == 0) recurse(c / 2, m)\n            else recurse(3 * c + 1, m\
    \ + 1)\n        }\n        def recurse2(c : Long, l : List[Long]) : List[Long]\
    \ = {\n            if (c % 2 == 0) recurse2(c / 2, l)\n            else if (c\
    \ == 1) l\n            else recurse2(3 * c + 1, c :: l)\n        }\n        recurse2(n,\
    \ List[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpulpyscsb.scala:30)\n\tat Problem.main(tmpulpyscsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var list = List[Long]()\n        var m = n\n       \
    \ while (m != 1) {\n            if (m % 2 == 1) list = list :+ m\n           \
    \ m = m / 2\n        }\n        list = list :+ 1\n        list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph338_u5_.scala:28)\n\tat Problem.main(tmph338_u5_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var l = List[Long]()\n        if (n < 1) return l\n\
    \        var m = n\n        while (m != 1) {\n            if (m % 2 == 1) l =\
    \ m :: l\n            m = nextCollatz(m)\n        }\n        l = 1 :: l\n    \
    \    l.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuj6ngo_q.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            m = nextCollatz(m)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: nextCollatz\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009254
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def getSequence(n : Long) : List[Long] = {\n       \
    \     if (n == 1) List(1)\n            else if (n % 2 == 0) n :: getSequence(n\
    \ / 2)\n            else n :: getSequence(3 * n + 1)\n        }\n        getSequence(n).filter(_\
    \ % 2 == 1)\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt1n1hhwn.scala:26)\n\tat Problem.main(tmpt1n1hhwn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009259
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def collatz(n : Long) : List[Long] = {\n           \
    \ val l = new ListBuffer[Long]\n            var a = n\n            l += a\n  \
    \          while (a != 1) {\n                if (a % 2 == 0) a = a / 2\n     \
    \           else a = 3 * a + 1\n                l += a\n            }\n      \
    \      l.toList\n        }\n        var l = new ListBuffer[Long]\n        collatz(n).filter(x\
    \ => x % 2 == 1).distinct.sorted\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009260
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val list = ListBuffer[Long]()\n        var m = n\n \
    \       list += 1\n        while (m != 1) {\n            if (m % 2 == 0) m /=\
    \ 2\n            else {\n                list += m\n                m = 3 * m\
    \ + 1\n            }\n        }\n        list.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009260
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = ListBuffer[Long]()\n        var x = n\n\
    \        while (x != 1) {\n            if (x % 2 == 1) result += x\n         \
    \   x = if (x % 2 == 0) x / 2 else 3 * x + 1\n        }\n        result += 1\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvnijl97j.scala:28)\n\tat Problem.main(tmpvnijl97j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009261
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var set = Set[Long]()\n        var x = n\n        while\
    \ (x != 1) {\n            set += x\n            if (x % 2 == 0) x /= 2\n     \
    \       else x = 3 * x + 1\n        }\n        set.toList.sorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4vbk6aqp.scala:28)\n\tat Problem.main(tmp4vbk6aqp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var oddCollatz = new ListBuffer[Long]()\n        val\
    \ sequence = new ListBuffer[Long]()\n        var current = n\n        do {\n \
    \           sequence += current\n            if (current % 2 == 1) {\n       \
    \         oddCollatz += current\n            }\n            current = if (current\
    \ % 2 == 0) current / 2 else current * 3 + 1\n        } while (current != 1)\n\
    \        sequence += 1\n        oddCollatz += 1\n        oddCollatz.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpx4xcepjc.scala:21:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mdo\e[0m {\n\e[31m\e[31m   |\e[0m      \
    \  ^^\e[0m\n\e[31m   |\e[0m        end of statement expected but 'do' found\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009256
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def getOddCollatz0(n : Long, m : List[Long]) : List[Long]\
    \ = n match {\n            case 1 => 1 :: m\n            case _ => if (n % 2 ==\
    \ 0) getOddCollatz0(n / 2, m) else getOddCollatz0(3 * n + 1, n :: m)\n       \
    \ }\n        def removeDuplicates(arr : List[Long]) : List[Long] = arr match {\n\
    \            case Nil => Nil\n            case head :: tail => head :: removeDuplicates(tail.filter(_\
    \ != head))\n        }\n        removeDuplicates(getOddCollatz0(n, Nil)).sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009262
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var l = List[Long]()\n        var t = n\n        while\
    \ (t != 1) {\n            l = l :+ t\n            if (t % 2 == 0) t = t / 2\n\
    \            else t = 3 * t + 1\n        }\n        l = l :+ 1\n        l.filter(_\
    \ % 2 == 1)\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptehkw5j_.scala:29)\n\tat Problem.main(tmptehkw5j_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009261
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var dic = new scala.collection.mutable.HashMap[Long,\
    \ List[Long]]()\n        def collatz(n : Long) : List[Long] = {\n            if\
    \ (n == 1) {\n                List(1)\n            } else if (n % 2 == 0) {\n\
    \                n :: collatz(n / 2)\n            } else {\n                n\
    \ :: collatz(3 * n + 1)\n            }\n        }\n        if (n % 2 == 0) collatz(n).filter(x\
    \ => x % 2 == 1)\n        else collatz(n).filter(x => x % 2 == 1)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp34rvj4wt.scala:32)\n\tat Problem.main(tmp34rvj4wt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009262
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // 1. Base case\n        if (n == 1) {\n           \
    \ List(1l)\n        }\n        // 2. Return odd numbers in collatz sequence\n\
    \        else {\n            var list = List[Long]()\n            var num = n\n\
    \            while (num != 1) {\n                if (num % 2 == 1) {\n       \
    \             list = list :+ num\n                }\n                num = if\
    \ (num % 2 == 0) {\n                    num / 2\n                }\n         \
    \       else {\n                    3 * num + 1\n                }\n         \
    \   }\n            list.reverse\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe6cwsuj4.scala:41)\n\tat Problem.main(tmpe6cwsuj4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009261
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var oddList = new ListBuffer[Long]\n        if (n ==\
    \ 1) return 1l :: Nil\n        var current_num = n\n        while (current_num\
    \ != 1) {\n            if (current_num % 2 == 1) {\n                oddList +=\
    \ current_num\n            }\n            current_num = if (current_num % 2 ==\
    \ 0) current_num / 2 else current_num * 3 + 1\n        }\n        return oddList.toList.sortWith(_\
    \ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprcgkptlj.scala:30)\n\tat Problem.main(tmprcgkptlj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009262
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // 1st implementation - it uses a mutable list. And\
    \ is correct only if we order the odd numbers\n        // correctly.\n       \
    \ // TODO: a = a - 1; if(a % 2 == 0) { a = a / 2; } else { a = 3 * a + 1; }\n\
    \        def getOddCollatzRec(a : Long, sofar : ListBuffer[Long]) : List[Long]\
    \ = {\n            if(a == 1) {\n                return sofar.toList;\n      \
    \      }\n            else {\n                if(a % 2 == 0) {\n             \
    \       getOddCollatzRec(a / 2, sofar)\n                }\n                else\
    \ {\n                    sofar += a;\n                    getOddCollatzRec(3 *\
    \ a + 1, sofar)\n                }\n            }\n        }\n        getOddCollatzRec(n,\
    \ ListBuffer[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr3z3bt4w.scala:38)\n\tat Problem.main(tmpr3z3bt4w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009262
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        var collatz = List[Long]()\n\
    \        var m = n\n        while (m != 1) {\n            collatz = m :: collatz\n\
    \            if (m % 2 == 0) m = m / 2\n            else m = 3 * m + 1\n     \
    \   }\n        collatz = 1 :: collatz\n        var odd_collatz = List[Long]()\n\
    \        for (i <- collatz) {\n            if (i % 2 == 1) odd_collatz = i ::\
    \ odd_collatz\n        }\n        odd_collatz.sortWith(_ < _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009264
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val list = ListBuffer[Long]()\n        var i = n\n \
    \       while (i != 1) {\n            list += i\n            if (i % 2 == 0) i\
    \ /= 2\n            else i = 3 * i + 1\n        }\n        list += 1\n       \
    \ return list.filter(_ % 2 == 1).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0barsq7y.scala:29)\n\tat Problem.main(tmp0barsq7y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009263
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var nn = n\n        var lst = new ListBuffer[Long]()\n\
    \        while (nn != 1) {\n            if (nn % 2 == 1) {\n                lst\
    \ += nn\n            }\n            nn = if (nn % 2 == 0) nn / 2 else 3 * nn +\
    \ 1\n        }\n        return lst.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ijutxdo.scala:29)\n\tat Problem.main(tmp0ijutxdo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009264
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var current = n\n        var result = List[Long]()\n\
    \        while (current != 1) {\n            result = result :+ current\n    \
    \        if (current % 2 == 0) current /= 2\n            else current = current\
    \ * 3 + 1\n        }\n        result = result :+ 1\n        result = result.filter(x\
    \ => x % 2 == 1)\n        result.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009264
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var odd = List[Long]()\n        def collatz(n : Long)\
    \ : Long = if (n == 1) 1 else if (n % 2 == 0) collatz(n / 2) else collatz(3 *\
    \ n + 1)\n        for (i <- 1 to n.toInt) if (collatz(i) % 2 == 1) odd = odd :+\
    \ i\n        odd\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpix5xhlni.scala:24)\n\tat Problem.main(tmpix5xhlni.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var list = List[Long]()\n        if (n == 1) {\n   \
    \         list :+ 1\n        } else {\n            var input = n\n           \
    \ while (input != 1) {\n                if (input % 2 == 0) {\n              \
    \      input = input / 2\n                } else {\n                    input\
    \ = 3 * input + 1\n                    list :+ input\n                }\n    \
    \        }\n            list :+ 1\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptwvj_92f.scala:35)\n\tat Problem.main(tmptwvj_92f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        val collatz = ArrayBuffer[Long]()\n\
    \        var current : Long = n\n        collatz += current\n        while (current\
    \ != 1) {\n            if (current % 2 == 0) current /= 2\n            else current\
    \ = 3 * current + 1\n            collatz += current\n        }\n        val result\
    \ = ListBuffer[Long]()\n        collatz.foreach {x => if (x % 2 == 1) result +=\
    \ x}\n        result.toList\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb8zzeecn.scala:32)\n\tat Problem.main(tmpb8zzeecn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009267
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        require(n > 0)\n        var list = ListBuffer[Long]()\n\
    \        var m = n\n        while (m != 1) {\n            list += m\n        \
    \    if (m % 2 == 0) m /= 2\n            else m = 3 * m + 1\n        }\n     \
    \   list += 1\n        list.filter(_ % 2 == 1).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnohbclda.scala:30)\n\tat Problem.main(tmpnohbclda.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009267
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val odd = new ListBuffer[Long]\n        var x = n\n\
    \        while (x != 1) {\n            odd += x\n            x = if (x % 2 ==\
    \ 0) x / 2 else 3 * x + 1\n        }\n        odd += 1\n        odd.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpom1alfvp.scala:28)\n\tat Problem.main(tmpom1alfvp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009267
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n <= 0) return Nil\n        var collatzList = new\
    \ ListBuffer[Long]\n        collatzList += n\n        var x = n\n        while\
    \ (x != 1) {\n            collatzList += (x / 2)\n            x = x / 2\n    \
    \    }\n        val oddList = new ListBuffer[Long]\n        for (i <- collatzList.indices)\
    \ {\n            if (collatzList(i) % 2 == 1) oddList += collatzList(i)\n    \
    \    }\n        return oddList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkyg5_9yn.scala:33)\n\tat Problem.main(tmpkyg5_9yn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // O(n)\n        def collatzOdd(n : Long, result : List[Long])\
    \ : List[Long] = {\n            if (n == 1) result\n            else {\n     \
    \           if (n % 2 == 0) collatzOdd(n / 2, result)\n                else collatzOdd(3\
    \ * n + 1, n :: result)\n            }\n        }\n        collatzOdd(n, List[Long]()).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsppb3x8x.scala:29)\n\tat Problem.main(tmpsppb3x8x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var list = new ListBuffer[Long]()\n        var x = n\n\
    \        while (x != 1) {\n            if (x % 2 == 1) list += x\n           \
    \ x = if (x % 2 == 0) x / 2 else 3 * x + 1\n        }\n        list += 1\n   \
    \     list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpud7anp4z.scala:28)\n\tat Problem.main(tmpud7anp4z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = List[Long]()\n        var number = n\n\
    \        while (number != 1) {\n            if (number % 2 == 1) result = result\
    \ :+ number\n            number = if (number % 2 == 0) number / 2 else 3 * number\
    \ + 1\n        }\n        result = result :+ 1\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplsqnldwf.scala:28)\n\tat Problem.main(tmplsqnldwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009270
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var currentNumber = n\n        var oddCollatzNumbers\
    \ = List[Long]()\n        while (currentNumber != 1) {\n            if (currentNumber\
    \ % 2 == 1) {\n                oddCollatzNumbers = oddCollatzNumbers :+ currentNumber\n\
    \            }\n            currentNumber = currentNumber / 2\n        }\n   \
    \     oddCollatzNumbers = oddCollatzNumbers :+ 1\n        oddCollatzNumbers.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn1vaylku.scala:30)\n\tat Problem.main(tmpn1vaylku.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009272
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatzList = List[Long]()\n        var collatzQueue\
    \ = Queue[Long]()\n        collatzQueue.enqueue(n)\n        while (!collatzQueue.isEmpty)\
    \ {\n            var value = collatzQueue.dequeue\n            if (value == 1)\
    \ {\n                collatzList = collatzList :+ value\n            } else {\n\
    \                if (value % 2 == 1) {\n                    collatzList = collatzList\
    \ :+ value\n                    collatzQueue.enqueue(value * 3 + 1)\n        \
    \        } else {\n                    collatzQueue.enqueue(value / 2)\n     \
    \           }\n            }\n        }\n        collatzList.sorted\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009272
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def helper(i : Long, l : List[Long]) : List[Long] =\
    \ {\n            if (i == 1) {\n                l\n            } else {\n    \
    \            if (i % 2 == 0) helper(i / 2, l)\n                else helper(3 *\
    \ i + 1, i :: l)\n            }\n        }\n        if (n == 1) List(1)\n    \
    \    else {\n            val l = helper(n, List())\n            // remove duplicates\n\
    \            var result = new ListBuffer[Long]()\n            result += l.head\n\
    \            for (i <- 1 until l.length) {\n                if (l(i) != l(i -\
    \ 1)) result += l(i)\n            }\n            result.toList\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_qmw5syr.scala:39)\n\tat Problem.main(tmp_qmw5syr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var collatz = List[Long]()\n        if (n == 1) {\n\
    \            collatz = 1 :: collatz\n        } else {\n            while (n !=\
    \ 1) {\n                if (n % 2 == 0) {\n                    n = n / 2\n   \
    \             } else {\n                    n = 3 * n + 1\n                }\n\
    \                if (n % 2 != 0) {\n                    collatz = n :: collatz\n\
    \                }\n            }\n        }\n        collatz.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpa2f0h20e.scala:24:22 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    n = n / \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \    Reassignment to val n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpa2f0h20e.scala:26:22 -----------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    n = \e[31m3\e[0m * n + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Reassignment to val n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // start with n\n        // if n is even, divide by\
    \ 2\n        // if n is odd, multiply by 3 and add 1\n        // Stop when n is\
    \ 1.\n        var result = new ListBuffer[Long]\n        var num = n\n       \
    \ while (num != 1) {\n            if (num % 2 == 1) {\n                // odd\n\
    \                result += num\n                num = num * 3 + 1\n          \
    \  } else {\n                // even\n                num = num / 2\n        \
    \    }\n        }\n        // add 1\n        result += 1\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp83q7lmnm.scala:39)\n\tat Problem.main(tmp83q7lmnm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Iterative\n        if (n <= 0) return Nil\n     \
    \   if (n == 1) return List(1)\n        var current : Long = n\n        var list\
    \ : List[Long] = Nil\n        while (current != 1) {\n            if (current\
    \ % 2 == 1) list = current :: list\n            current = (if (current % 2 ==\
    \ 0) current / 2 else current * 3 + 1)\n        }\n        return (1 :: list).reverse\n\
    \        // Recursive\n        // if (n <= 0) return Nil\n        // if (n ==\
    \ 1) return List(1)\n        // var current : Long = n\n        // var list :\
    \ List[Long] = Nil\n        // while (current != 1) {\n        //     if (current\
    \ % 2 == 1) list = current :: list\n        //     current = (if (current % 2\
    \ == 0) current / 2 else current * 3 + 1)\n        // }\n        // return (1\
    \ :: list).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxg3_km9y.scala:27:27\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m (\e\
    [31m1\e[0m :: list).reverse\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e\
    [31m   |\e[0m               Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009271
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n      var x = n\n      var list = List[Long]()\n      while\
    \ (x != 1) {\n        if (x % 2 == 1) list = list :+ x\n        if (x % 2 == 0)\
    \ x = x / 2\n        else x = 3 * x + 1\n      }\n      list = list :+ 1\n   \
    \   list\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcdvgjgh5.scala:29)\n\tat Problem.main(tmpcdvgjgh5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009273
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n      def getOddCollatzImp(n : Long, cur : Long, acc : List[Long])\
    \ : List[Long] = {\n        if (cur == 1) {\n          return acc\n        }\n\
    \        if (cur % 2 == 1) {\n          val new_acc = cur :: acc\n          return\
    \ getOddCollatzImp(n, 3 * cur + 1, new_acc)\n        }\n        getOddCollatzImp(n,\
    \ cur / 2, acc)\n      }\n      val acc = List[Long]()\n      getOddCollatzImp(n,\
    \ n, acc)\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp21w_fxqn.scala:32)\n\tat Problem.main(tmp21w_fxqn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009273
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var result = List[Long]()\n        var num = n\n   \
    \     while (num != 1) {\n            if (num % 2 == 1) result = num :: result\n\
    \            num = if (num % 2 == 0) num / 2 else 3 * num + 1\n        }\n   \
    \     result = 1 :: result\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_90l9y4s.scala:28)\n\tat Problem.main(tmp_90l9y4s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009273
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var c : Long = n\n        var oddCollatz : HashSet[Long]\
    \ = HashSet.empty[Long]\n        while (c != 1) {\n            if (c % 2 == 1)\
    \ {\n                oddCollatz += c\n            }\n            c = if (c % 2\
    \ == 0) {\n                c / 2\n            } else {\n                c * 3\
    \ + 1\n            }\n        }\n        oddCollatz.toList.sorted\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphvflisi6.scala:33)\n\tat Problem.main(tmphvflisi6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009273
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var list = new ArrayBuffer[Long]\n        var curr =\
    \ n\n        while (curr != 1) {\n            list += curr\n            if (curr\
    \ % 2 == 0) curr /= 2\n            else curr = 3 * curr + 1\n        }\n     \
    \   list += 1\n        list.filter(x => x % 2 == 1).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmb44opx9.scala:29)\n\tat Problem.main(tmpmb44opx9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        val sequence = collatz(n)\n\
    \        var result = new ListBuffer[Long]\n        for (i <- sequence) if (i\
    \ % 2 == 1) result += i\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpch05hqte.scala:19:23 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msequence\e[0m = collatz(n)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: collatz\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009270
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // If n = 0, return List[Long]().\n        if (n ==\
    \ 0) return List[Long]()\n        // If n = 1, return List[Long](1).\n       \
    \ if (n == 1) return List[Long](1)\n        // If n = 2, return List[Long](1).\n\
    \        if (n == 2) return List[Long](1)\n        // If n is even, the collatz\
    \ sequence is (n)\n        // If n is odd, the collatz sequence is (n, 3 * n +\
    \ 1, n / 2).\n        // If n is odd, the odds are (n, n / 2).\n        val s\
    \ = new Stack[Long]()\n        s.push(n)\n        while (s.top != 1) {\n     \
    \       if (s.top % 2 == 0) s.push(s.top / 2)\n            else s.push(3 * s.top\
    \ + 1)\n        }\n        // Now we have the stack containing all the numbers\
    \ in collatz sequence.\n        // Get all the odd numbers by popping the odd\
    \ numbers.\n        val oddList = new ListBuffer[Long]()\n        while (!s.isEmpty)\
    \ {\n            val n = s.pop\n            if (n % 2 == 1) oddList += n\n   \
    \     }\n        oddList.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_4lwxw8d.scala:43)\n\tat Problem.main(tmp_4lwxw8d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009274
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val L = new ListBuffer[Long]()\n        var m = n\n\
    \        while (m != 1) {\n            if (m % 2 == 1) {\n                L +=\
    \ m\n            }\n            m = (if (m % 2 == 0) m / 2 else 3 * m + 1)\n \
    \       }\n        L += 1\n        L.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe3ecs53g.scala:30)\n\tat Problem.main(tmpe3ecs53g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009275
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var hash = HashMap[Long, Boolean]()\n        hash +=\
    \ (1l -> true)\n        var collatz = List[Long](1l)\n        var i = 1l\n   \
    \     while (i < n) {\n            var number = i\n            var last_odd =\
    \ i\n            while (number != 1) {\n                if (number % 2 == 0) number\
    \ /= 2\n                else {\n                    number = 3 * number + 1\n\
    \                    if (number <= n) {\n                        hash += (number\
    \ -> true)\n                        last_odd = number\n                    }\n\
    \                }\n            }\n            i += 1\n        }\n        hash.keySet.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn7z5lptm.scala:40)\n\tat Problem.main(tmpn7z5lptm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n      var counter = n\n      var numbers = List[Long]()\n  \
    \    while (counter != 1) {\n        if (counter % 2 == 1) {\n          numbers\
    \ = counter :: numbers\n        }\n        counter = if (counter % 2 == 0) counter\
    \ / 2 else counter * 3 + 1\n      }\n      numbers.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7yhy72b2.scala:29)\n\tat Problem.main(tmp7yhy72b2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009275
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        // Returns all numbers in Collatz sequence starting\
    \ from n, until it reaches 1.\n        def collatz(n : Long) : List[Long] = {\n\
    \            var sequence = List[Long]()\n            var m = n\n            while\
    \ (m != 1) {\n                sequence = m :: sequence\n                if (m\
    \ % 2 == 0) {\n                    m = m / 2\n                } else {\n     \
    \               m = m * 3 + 1\n                }\n            }\n            sequence\
    \ = 1l :: sequence\n            sequence\n        }\n        collatz(n).filter(e\
    \ => e % 2 == 1)\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp00mj_vvy.scala:36)\n\tat Problem.main(tmp00mj_vvy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var res = List[Long]()\n        var c = n\n        res\
    \ = res :+ c\n        var prev = c\n        do {\n            c = if (c % 2 ==\
    \ 0) c / 2 else c * 3 + 1\n            if (c % 2 == 1) {\n                res\
    \ = res :+ c\n                prev = c\n            }\n        } while (c != 1)\n\
    \        return res\n    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpna30jg_k.scala:22:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mdo\e[0m {\n\e[31m\e[31m   |\e[0m      \
    \  ^^\e[0m\n\e[31m   |\e[0m        end of statement expected but 'do' found\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009273
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n    \tvar seq = List[Long]()\n    \tvar last = n\n    \twhile\
    \ (last != 1) {\n    \t\tif (last % 2 == 1) seq = last :: seq\n    \t\tlast =\
    \ if (last % 2 == 0) last / 2 else last * 3 + 1\n    \t}\n    \tseq.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy1in406u.scala:27)\n\tat Problem.main(tmpy1in406u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val oddCollatz = ListBuffer[Long]()\n        def getOddCollatz(n\
    \ : Long) : Unit = {\n            if (n == 1) {\n                oddCollatz +=\
    \ 1\n            } else {\n                oddCollatz += n\n                if\
    \ (n % 2 == 0) {\n                    getOddCollatz(n / 2)\n                }\
    \ else {\n                    getOddCollatz(3 * n + 1)\n                }\n  \
    \          }\n        }\n        getOddCollatz(n)\n        oddCollatz.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpys1xl1x7.scala:35)\n\tat Problem.main(tmpys1xl1x7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n      var result = List[Long]()\n      var temp = n\n      while\
    \ (temp != 1) {\n        if (temp % 2 == 1) {\n          result = result :+ temp\n\
    \        }\n        temp = if (temp % 2 == 0) temp / 2 else 3 * temp + 1\n   \
    \   }\n      result = result :+ 1\n      result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4cyworfg.scala:30)\n\tat Problem.main(tmp4cyworfg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009277
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var even = true\n        var collatz = new ListBuffer[Long]()\n\
    \        var current = n\n        while (current != 1) {\n            if (even)\
    \ {\n                current = current / 2\n                even = false\n   \
    \         } else {\n                collatz += current\n                current\
    \ = 3 * current + 1\n                even = true\n            }\n        }\n \
    \       collatz += 1\n        collatz.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009282
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val oddList = ListBuffer[Long]()\n        val queue\
    \ = Queue[Long]()\n        queue.enqueue(n)\n        while (!queue.isEmpty) {\n\
    \            val a = queue.dequeue\n            if (a % 2 == 1) {\n          \
    \      oddList += a\n            }\n            val b = a * 3 + 1\n          \
    \  if (b > 1) queue.enqueue(b)\n            if (a % 2 == 0) {\n              \
    \  val c = a / 2\n                if (c > 1) queue.enqueue(c)\n            }\n\
    \        }\n        oddList.toList.sortWith(_ < _)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009282
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) List(1)\n        else if (n % 2 == 0) getOddCollatz(n\
    \ / 2)\n        else List(n) ::: getOddCollatz(3 * n + 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf36a0atj.scala:23)\n\tat Problem.main(tmpf36a0atj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009278
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        var lst = new ListBuffer[Long]()\n        if (n <= 0)\
    \ return lst.toList\n        var cur = n\n        while (cur != 1) {\n       \
    \     if (cur % 2 == 1) lst += cur\n            cur = collatz(cur)\n        }\n\
    \        lst += 1\n        lst.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvu65in1i.scala:23:18 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            cur = collatz(cur)\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: collatz\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009276
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        if (n == 1) return List(1)\n        val oddNumberList\
    \ = ListBuffer[Long]()\n        val queue = new Queue[Long]()\n        queue.enqueue(n)\n\
    \        while (!queue.isEmpty) {\n            val nextNumber = queue.dequeue\n\
    \            if (nextNumber % 2 == 1) {\n                oddNumberList += nextNumber\n\
    \                queue.enqueue(nextNumber * 3 + 1)\n            }\n          \
    \  if (nextNumber % 2 == 0) {\n                queue.enqueue(nextNumber / 2)\n\
    \            }\n        }\n        oddNumberList.toList.sorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009283
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        def helper(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n        \tif (n == 1) {\n        \t\treturn 1 :: acc\n        \t}\n   \
    \     \telse if (n % 2 == 0) {\n        \t\thelper(n / 2, acc)\n        \t}\n\
    \        \telse {\n        \t\thelper(3 * n + 1, n :: acc)\n        \t}\n    \
    \    }\n        helper(n, Nil).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2wylezkw.scala:32)\n\tat Problem.main(tmp2wylezkw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009278
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n    \tval stack = Stack[Long]()\n    \tvar num = n\n    \twhile\
    \ (num != 1) {\n    \t\tif (num % 2 == 1) {\n    \t\t\tstack.push(num)\n    \t\
    \t}\n    \t\tnum = if (num % 2 == 0) {\n    \t\t\tnum / 2\n    \t\t} else {\n\
    \    \t\t\tnum * 3 + 1\n    \t\t}\n    \t}\n    \tstack.toList.sorted\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyc9ld5x8.scala:33)\n\tat Problem.main(tmpyc9ld5x8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009279
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n    // The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    // as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    // previous\
    \ term as follows: if the previous term is even, the next term is one half of\
    \ \n    // the previous term. If the previous term is odd, the next term is 3\
    \ times the previous\n    // term plus 1. The conjecture is that no matter what\
    \ value of n, the sequence will always reach 1.\n    // Note: \n    // 1. Collatz(1)\
    \ is [1].\n    // 2. returned list sorted in increasing order.\n    // For example:\n\
    \    // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5,\
    \ 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    // >>> getOddCollatz((5l))\n\
    \    // (List[Long](1l.toLong, 5l.toLong))\n    def getOddCollatz(n : Long) :\
    \ List[Long] = {\n        val lst = new ListBuffer[Long]\n        var n2 = n\n\
    \        while (n2 != 1) {\n            if (n2 % 2 == 1) {\n                lst\
    \ += n2\n            }\n            n2 = if (n2 % 2 == 0) n2 / 2 else 3 * n2 +\
    \ 1\n        }\n        lst += 1\n        lst.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
    \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009279
