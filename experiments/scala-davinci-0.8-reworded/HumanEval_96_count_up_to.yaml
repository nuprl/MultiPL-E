name: HumanEval_96_count_up_to
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Implement a function that takes an non-negative integer and returns a list\
  \ of the first n\n    // integers that are prime numbers and less than n.\n    //\
  \ for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n\
  \    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n\
  \    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong,\
  \ 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n\
  \    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) :\
  \ List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
  \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
  \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
  \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
  \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
  \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
  \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
  \ 97l.toLong))));\n    }\n\n}\n"
completions: ["        def countUpTo0(n : Long, acc : List[Long]) : List[Long] = {\n\
    \            if (n < 2) acc\n            else if (acc.length == 0) countUpTo0(n,\
    \ List(2))\n            else {\n                val next = acc.last + 2\n    \
    \            if (next == n) acc :+ next\n                else if (acc.takeWhile(next\
    \ % _ != 0).length == acc.length) countUpTo0(n, acc :+ next)\n               \
    \ else countUpTo0(n, acc)\n            }\n        }\n        countUpTo0(n, List())",
  "        def isPrime(n : Long) : Boolean = {\n            if (n < 2) {\n       \
    \         return false\n            }\n            for (i <- 2l.toLong to sqrt(n).toLong)\
    \ {\n                if (n % i == 0) {\n                    return false\n   \
    \             }\n            }\n            return true\n        }\n        if\
    \ (n <= 0) {\n            return List[Long]()\n        }\n        var s : ListBuffer[Long]\
    \ = ListBuffer[Long]()\n        for (i <- 2l.toLong to n) {\n            if (isPrime(i))\
    \ {\n                s += i\n            }\n        }\n        return s.toList",
  "        def countUpToAcc(n : Long, acc : List[Long]) : List[Long] = {\n       \
    \     if (n < 2)\n                acc\n            else if (checkPrimality(n))\n\
    \                countUpToAcc(n - 1, n :: acc)\n            else\n           \
    \     countUpToAcc(n - 1, acc)\n        }\n        def checkPrimality(n : Long)\
    \ : Boolean = {\n            def checkPrimalityAcc(curr : Long, acc : Boolean)\
    \ : Boolean = {\n                if (curr == 1)\n                    acc\n   \
    \             else if (n % curr == 0)\n                    checkPrimalityAcc(curr\
    \ - 1, false)\n                else\n                    checkPrimalityAcc(curr\
    \ - 1, acc)\n            }\n            checkPrimalityAcc(n - 1, true)\n     \
    \   }\n        countUpToAcc(n, List())", "        var primes = new ListBuffer[Long]()\n\
    \        for (i <- (2l to n).toList if !((2l to i - 1).toList.exists(i % _ ==\
    \ 0))) primes += i\n        primes.toList", "        if (n < 2) {\n          \
    \  return List[Long]()\n        }\n        val result = new ListBuffer[Long]()\n\
    \        val primeList = new ListBuffer[Long]()\n        primeList += 2l\n   \
    \     primeList += 3l\n        var i = 5l\n        while (i < n) {\n         \
    \   var isPrime = true\n            for (j <- primeList) {\n                if\
    \ (i % j == 0) {\n                    isPrime = false\n                    break\n\
    \                }\n            }\n            if (isPrime) {\n              \
    \  primeList += i\n            }\n            i += 2\n        }\n        for (i\
    \ <- primeList) {\n            result += i\n        }\n        return result.toList",
  "        // TODO: implement this function\n        List()", "        def countUpToHelper(n\
    \ : Long, acc : List[Long]) : List[Long] = {\n            if (n < 2) acc\n   \
    \         else if (acc.size == 0) countUpToHelper(n, List(2))\n            else\
    \ if (isPrime(n)) countUpToHelper(n - 1, acc :+ n)\n            else countUpToHelper(n\
    \ - 1, acc)\n        }\n        countUpToHelper(n, List[Long]())", "        var\
    \ array : ArrayBuffer[Long] = new ArrayBuffer\n        for (i <- 1 until n.toInt)\
    \ {\n            if (isPrime(i)) {\n                array += i\n            }\n\
    \        }\n        array.toList", "    val primes : ArrayBuffer[Long] = ArrayBuffer[Long]()\n\
    \    primes += 2l\n    primes += 3l\n    primes += 5l\n    val primesSize : Int\
    \ = primes.size\n    if (n == 0l) {\n        return primes.toList", "        def\
    \ countUpTo1(n : Long, accum : List[Long]) : List[Long] = {\n            if (n\
    \ < 2)\n                accum\n            else if (isPrime(n))\n            \
    \    countUpTo1(n - 1, accum :+ n)\n            else\n                countUpTo1(n\
    \ - 1, accum)\n        }\n        countUpTo1(n, List())", "        // Write your\
    \ code here\n        null", "        if (n == 1) {\n            return List()\n\
    \        }\n        if (n == 2) {\n            return List(2)\n        }\n   \
    \     def isPrime(n : Long) : Boolean = {\n            if (n == 1) {\n       \
    \         return false\n            }\n            if (n == 2) {\n           \
    \     return true\n            }\n            for (i <- 2 until n) {\n       \
    \         if (n % i == 0) {\n                    return false\n              \
    \  }\n            }\n            return true\n        }\n        var list = new\
    \ ListBuffer[Long]()\n        for (i <- 1 until n) {\n            if (isPrime(i))\
    \ {\n                list += i\n            }\n        }\n        return list.toList",
  "        // Given a number n > 1, check whether any prime integer m from 2 to \u221A\
    n evenly divides n\n        // (the division leaves no remainder).\n        //\
    \ if n is divisible by none of them, n is prime.\n        // for example, with\
    \ n = 7, we see that none of the 7 numbers from 2 to 2.6 leave a remainder\n \
    \       // when divided into 7, we conclude that 7 is prime.\n        // prime\
    \ candidates are only odd number > 2\n        def isPrime(n : Long) : Boolean\
    \ = {\n            var m = 2l\n            while (m <= sqrt(n)) {\n          \
    \      if (n % m == 0) {\n                    return false\n                }\n\
    \                m += 1\n            }\n            return true\n        }\n \
    \       var primes = List[Long]()\n        var i = 2l\n        while (i < n) {\n\
    \            if (isPrime(i)) {\n                primes = primes :+ i\n       \
    \     }\n            i += 1\n        }\n        return primes", "        if (n\
    \ < 2) return List[Long]()\n        val list = new ListBuffer[Long]()\n      \
    \  for (i <- 2l to n if isPrime(i)) list += i\n        list.toList", "       \
    \ var a = new ArrayBuffer[Long]()\n        if (n < 2) return a.toList\n      \
    \  a += 2\n        for (i <- 3 until n by 2) {\n            if (a.forall(x =>\
    \ i % x != 0)) a += i\n        }\n        a.toList", "        def isPrime(number\
    \ : Long) : Boolean = {\n            (number > 1) && (Array.range(2, number.toInt\
    \ + 1) forall (number % _ != 0))\n        }\n        Array.range(2, n.toInt +\
    \ 1) filter (isPrime(_)) toList", "        def isPrime(n : Long) : Boolean = {\n\
    \            for (i <- 2l to n-1l if n % i == 0) return false\n            return\
    \ true\n        }\n        var result = List[Long]()\n        for (i <- 2l to\
    \ n if isPrime(i)) result = result :+ i\n        return result", "        require(n\
    \ >= 0)\n        if (n <= 1) Nil\n        else {\n            val primes = new\
    \ ListBuffer[Long]\n            for (i <- 2 to n.toInt) {\n                if\
    \ (isPrime(i)) primes += i\n            }\n            primes.toList\n       \
    \ }", "        def countUpTo(i : Long, l : List[Long]) : List[Long] = {\n    \
    \        if (i == 0 || i == 1) l\n            else if (i == 2) 2l :: l\n     \
    \       else if (i == 3) 3l :: l\n            else if (i % 2 == 0) countUpTo(i\
    \ - 1, l)\n            else if (i % 3 == 0) countUpTo(i - 1, l)\n            else\
    \ if (l.exists(_ > sqrt(i))) i :: l\n            else if (l.exists(i % _ == 0))\
    \ countUpTo(i - 1, l)\n            else countUpTo(i - 1, i :: l)\n        }\n\
    \        countUpTo(n, List()).reverse", "        var a = new ArrayBuffer[Long]()\n\
    \        if (n < 2) a.toList\n        else {\n            var f = new ArrayBuffer[Long]()\n\
    \            for (x <- 2 to n.toInt) {\n                var b = true\n       \
    \         for (y <- f) {\n                    if (x % y == 0) {\n            \
    \            b = false\n                        y = n.toInt\n                \
    \    }\n                }\n                if (b) {\n                    f +=\
    \ x\n                    a += x\n                }\n            }\n          \
    \  a.toList\n        }", "        var count = 2l\n        val primes = new ListBuffer[Long]\n\
    \        while (count < n) {\n            if (prime(count)) primes += count\n\
    \            count += 1\n        }\n        primes.toList", "        // >>> countUpTo((5l))\n\
    \        // (List[Long](2l.toLong, 3l.toLong))\n        // >>> countUpTo((11l))\n\
    \        // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n       \
    \ // >>> countUpTo((0l))\n        // (List[Long]())\n        // >>> countUpTo((20l))\n\
    \        // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong,\
    \ 13l.toLong, 17l.toLong, 19l.toLong))\n        // >>> countUpTo((1l))\n     \
    \   // (List[Long]())\n        // >>> countUpTo((18l))\n        // (List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    \
    \    val isPrime : HashMap[Long, Boolean] = new HashMap[Long, Boolean]\n     \
    \   for (i <- 2l to n) {\n            isPrime.update(i, true)\n        }\n   \
    \     for (i <- 2l to n) {\n            for (j <- 2l to (n / i)) {\n         \
    \       isPrime.update(i * j, false)\n            }\n        }\n        (for (i\
    \ <- 2l to n if isPrime(i)) yield i).toList", "        if (n < 0) throw new IllegalArgumentException\n\
    \        if (n < 2) return List()\n        def isPrime(n : Long) : Boolean = {\n\
    \            if (n <= 1) return false\n            if (n <= 3) return true\n \
    \           val s = scala.math.sqrt(n)\n            var i = 2\n            while\
    \ (i <= s) {\n                if (n % i == 0) return false\n                i\
    \ += 1\n            }\n            return true\n        }\n        var r = ListBuffer[Long]()\n\
    \        var i = 2l\n        while (i < n) {\n            if (isPrime(i)) r +=\
    \ i\n            i += 1\n        }\n        return r.toList", "        def inner(c\
    \ : Long, acc : List[Long]) : List[Long] = {\n            if (c >= n) acc\n  \
    \          else if (checkPrime(c)) inner(c + 1, acc :+ c)\n            else inner(c\
    \ + 1, acc)\n        }\n        inner(2, List())", "        var list = ListBuffer[Long]()\n\
    \        if (n < 0) {\n            list.toList\n        } else {\n           \
    \ for (i <- 2l to n) {\n                if (i.isPrime) {\n                   \
    \ list += i\n                }\n            }\n            list.toList\n     \
    \   }", "        // START SOLUTION\n        def isPrime(num : Long) : Boolean\
    \ = {\n            if (num < 2) return false\n            val limit = ceil(sqrt(num)).toLong\n\
    \            var i = 2l\n            while (i <= limit) {\n                if\
    \ (num % i == 0) return false\n                i += 1\n            }\n       \
    \     return true\n        }\n        var l = new ListBuffer[Long]()\n       \
    \ var curr = 2l\n        while (curr < n) {\n            if (isPrime(curr)) l\
    \ += curr\n            curr += 1\n        }\n        return l.toList\n       \
    \ // END SOLUTION", '        return List[Long]()', "        if (n < 2)\n     \
    \       List[Long]()\n        else\n            getPrimes(n)", '        return
    List[Long]()', "        // Fill in here\n        List[Long]()", "        var list\
    \ = new ListBuffer[Long]\n        for (i <- 2l to n) {\n            var flag =\
    \ true\n            for (j <- 2l to i - 1)\n                if (i % j == 0) flag\
    \ = false\n            if (flag) list += i\n        }\n        list.toList", " \
    \       var l = List[Long]()\n        var prime = 0l\n        while (prime < n)\
    \ {\n            var c = prime + 1\n            while (!isPrime(c)) {\n      \
    \          c += 1\n            }\n            prime = c\n            if (prime\
    \ < n) l ::= prime\n        }\n        l.reverse", "        if (n <= 1) {\n  \
    \          List()\n        } else {\n            lazy val primes: Stream[Long]\
    \ = 2 #:: Stream.from(3).filter(i =>\n                primes.takeWhile{j => j\
    \ * j <= i}.forall{ k => i % k > 0})\n            primes.takeWhile(_ < n).toList\n\
    \        }", "        // Your Code Here\n        ???", "        if (n < 2) {\n\
    \            List()\n        } else {\n            (2L to n).toList.filter(x =>\
    \ isPrime(x))\n        }", "        def isPrime(n : Long) : Boolean = {\n    \
    \        if (n == 1) return false\n            if (n == 2) return true\n     \
    \       if (n % 2 == 0) return false\n            if (n % 3 == 0) return false\n\
    \            val sqrt = sqrt(n).toLong\n            for (i <- 2l to sqrt) {\n\
    \                if (n % i == 0) return false\n            }\n            return\
    \ true\n        }\n        var primes = new ListBuffer[Long]\n        for (i <-\
    \ 2l to n) {\n            if (isPrime(i)) primes += i\n        }\n        return\
    \ primes.toList", "        var l : List[Long] = List()\n        var i : Long =\
    \ 2l\n        var cnt : Long = 0l\n        var f = false\n        while(i < n)\
    \ {\n            for(j <- 2l to (i - 1l))\n                if(i % j == 0l) {\n\
    \                    f = true\n                    break\n                }\n\
    \            if(!f) {\n                l = i :: l\n                cnt += 1l\n\
    \            }\n            i += 1l\n            f = false\n        }\n      \
    \  return l", "        if (n < 0) {\n            return List[Long]()\n       \
    \ }\n        else if (n < 2) {\n            return List[Long]()\n        }\n \
    \       else if (n == 2) {\n            return List[Long](2)\n        }\n    \
    \    else {\n            var lst = new ListBuffer[Long]()\n            lst +=\
    \ 2\n            var isPrime : (Long => Boolean) = (m : Long) => {\n         \
    \       if (m == 1) {\n                    return false\n                }\n \
    \               else if (m < 4) {\n                    return true\n         \
    \       }\n                else if (m % 2 == 0) {\n                    return\
    \ false\n                }\n                else if (m < 9) {\n              \
    \      return true\n                }\n                else if (m % 3 == 0) {\n\
    \                    return false\n                }\n                else {\n\
    \                    var r = sqrt(m)\n                    var f = 5\n        \
    \            while (f <= r) {\n                        if (m % f == 0) {\n   \
    \                         return false\n                        }\n          \
    \              if (m % (f + 2) == 0) {\n                            return false\n\
    \                        }\n                        f += 6\n                 \
    \   }\n                    return true\n                }\n            }\n   \
    \         for (i <- 3l until n by 2) {\n                if (isPrime(i)) {\n  \
    \                  lst += i\n                }\n            }\n            return\
    \ lst.toList\n        }", "        def isPrime(n : Long) : Boolean = {\n     \
    \       if (n == 2) true\n            else if (n == 1) false\n            else\
    \ {\n                val sqrt = math.sqrt(n)\n                var i = 2l\n   \
    \             while (i <= sqrt) {\n                    if (n % i == 0) return\
    \ false\n                    i += 1\n                }\n                true\n\
    \            }\n        }\n        if (n == 0) List[Long]()\n        else {\n\
    \            var result = List[Long]()\n            var i = 2l\n            while\
    \ (i < n) {\n                if (isPrime(i)) result = i :: result\n          \
    \      i += 1\n            }\n            result\n        }", "        if (n ==\
    \ 0) {\n            List[Long]()\n        } else {\n            var list = List[Long]()\n\
    \            var current = 2\n            while (current < n) {\n            \
    \    if (isPrime(current)) {\n                    list = list :+ current\n   \
    \             }\n                current += 1\n            }\n            list\n\
    \        }", "        if (n <= 0) return List[Long]()\n        var list = List[Long]()\n\
    \        for (i <- 2 to n.toInt) {\n            if (isPrime(i)) list = list :+\
    \ i\n        }\n        list", "        def isPrime(x : Long) : Boolean = {\n\
    \            for (i <- 2l until (min(x, ceil(sqrt(x.toDouble)).toLong + 1l)) if\
    \ (x % i == 0l)) return false\n            return true\n        }\n        val\
    \ lst = new ArrayBuffer[Long]\n        if (n < 2l) return List()\n        for\
    \ (i <- 2l until n if (isPrime(i))) lst += i\n        return lst.toList", "\t\
    def isPrime(n : Long) : Boolean = {\n\t    if (n < 2) false\n\t    else {\n\t\t\
    val sq = scala.math.sqrt(n).toLong\n\t\tdef iter(i : Long) : Boolean = {\n\t\t\
    \    if (i > sq) true\n\t\t    else n % i != 0 && iter(i + 1)\n\t\t}\n\t\titer(2)\n\
    \t    }\n\t}\n\tdef iter(n : Long, acc : List[Long]) : List[Long] = {\n\t    if\
    \ (n < 2) acc\n\t    else if (isPrime(n)) iter(n - 1, n :: acc)\n\t    else iter(n\
    \ - 1, acc)\n\t}\n\titer(n, List[Long]())", "        // your code here\n     \
    \   return List[Long]()", "        if (n < 0) return List[Long]()\n        def\
    \ isPrime(n : Long) : Boolean = {\n            for (i <- 2 to n.toInt / 2) {\n\
    \                if (n % i == 0) return false\n            }\n            return\
    \ true\n        }\n        var primes = List[Long]()\n        for (i <- 2 to n.toInt)\
    \ {\n            if (isPrime(i)) primes = primes :+ i\n        }\n        return\
    \ primes", "        val l : ListBuffer[Long] = new ListBuffer[Long]\n        l.toList",
  "        def isPrime(n : Long) : Boolean = {\n            (2 to (n - 1).toInt).foreach(i\
    \ => if (n % i == 0) return false)\n            true\n        }\n        if (n\
    \ <= 0) return List()\n        var primeList = List[Long]()\n        (2l to n).foreach(i\
    \ => if (isPrime(i)) primeList = primeList :+ i)\n        primeList", "      \
    \  def isPrime(n : Long) : Boolean = {\n            if (n < 2) return false\n\
    \            var i = 2\n            while (i < n) {\n                if (n % i\
    \ == 0) return false\n                i += 1\n            }\n            return\
    \ true\n        }\n        var l = List[Long]()\n        var i = 0\n        while\
    \ (i < n) {\n            if (isPrime(i)) {\n                l = l :+ i\n     \
    \       }\n            i += 1\n        }\n        return l", "      def aux(n\
    \ : Long, v : Long, p : List[Long]) : List[Long] = {\n        if (v >= n) p\n\
    \        else {\n          if (isPrime(v)) aux(n, v + 1, v :: p)\n          else\
    \ aux(n, v + 1, p)\n        }\n      }\n      aux(n, 2, Nil)", "        // Implement\
    \ your solution here\n        var l : List[Long] = Nil\n        var i = 1l\n \
    \       while (i < n) {\n            if (isPrime(i)) l = i :: l\n            i\
    \ += 1\n        }\n        l.reverse", "        def isPrime(x : Long) : Boolean\
    \ = x match {\n            case 1l => false\n            case 2l => true\n   \
    \         case x => {\n                val prime = List.range(2, (ceil(sqrt(x)).toInt)\
    \ + 1)\n                prime.forall(y => x % y != 0)\n            }\n       \
    \ }\n        if (n <= 0) List()\n        else {\n            val primes = for\
    \ {\n                x <- 2 to n.toInt\n                if isPrime(x)\n      \
    \      } yield x\n            primes.toList.map(_.toLong)\n        }", "     \
    \   var ans : List[Long] = List()\n        var a : Long = 2l\n        while (a\
    \ < n) {\n            if (checkPrime(a)) {\n                ans = ans :+ a\n \
    \           }\n            a += 1\n        }\n        ans", "        if (n <=\
    \ 0) List()\n        else {\n            val all = new ArrayBuffer[Long]\n   \
    \         for (i <- 2l to n) all += i\n            val primes = new ArrayBuffer[Long]\n\
    \            while (all.size > 0) {\n                val p = all.remove(0)\n \
    \               primes += p\n                all --= all.filter(i => i % p ==\
    \ 0)\n            }\n            primes.toList\n        }", "        // Fill up\
    \ this function body\n        // You can add another function as well, if required\n\
    \        return List[Long]()", "        val r = new Range(2l, n, 1l)\n       \
    \ val a = r.toList\n        val set = scala.collection.mutable.HashSet[Long]()\n\
    \        val ret = ListBuffer[Long]()\n        var i = 0\n        while (i < a.length)\
    \ {\n            var j = i + 1\n            var isPrime = true\n            while\
    \ (j < a.length) {\n                if (a(i) != a(j) && a(j) % a(i) == 0) {\n\
    \                    isPrime = false\n                    j = a.length\n     \
    \           }\n                j += 1\n            }\n            if (isPrime)\
    \ {\n                ret += a(i)\n            }\n            i += 1\n        }\n\
    \        ret.toList", "        // Insert your code here\n        countUpTo(n,\
    \ List[Long]())", "        if (n < 2) return List[Long]()\n        val primes\
    \ = new HashSet[Long]\n        def isPrime(a : Long) : Boolean = {\n         \
    \   if (a == 2) return true\n            if (a < 2 || a % 2 == 0) return false\n\
    \            val root = math.sqrt(a).toLong\n            primes.foreach(p => if\
    \ (p > root) return true else if (a % p == 0) return false)\n            true\n\
    \        }\n        for (i <- 2l to n) {\n            if (isPrime(i)) primes +=\
    \ i\n        }\n        primes.toList", "        val a = new ArrayBuffer[Long]\n\
    \        for (i <- 1 to n.toInt)\n            if (isPrime(i)) a += i\n       \
    \ a.toList", "        def iter(x : Long, acc : List[Long]) : List[Long] = {\n\
    \            if (x == n) acc\n            else if (Prime.isPrime(x)) iter(x +\
    \ 1, acc :+ x)\n            else iter(x + 1, acc)\n        }\n        iter(2,\
    \ List())", '        // your code here', "        // Your code here\n        if\
    \ (n <= 1) {\n            List()\n        } else {\n            var primes = new\
    \ ListBuffer[Long]()\n            primes += 2\n            for (i <- 3l to n by\
    \ 2) {\n                var isPrime = true\n                for (j <- 0 until\
    \ primes.length if isPrime) {\n                    if (i % primes(j) == 0) isPrime\
    \ = false\n                }\n                if (isPrime) primes += i\n     \
    \       }\n            primes.toList\n        }", "        //\n        // Insert\
    \ your code here\n        //", "        // Your Code Here\n        var lst: List[Long]\
    \ = List()\n        var i = 1l\n        while (i <= n) {\n            if (prime(i))\
    \ {\n                lst = lst :+ i\n            }\n            i += 1\n     \
    \   }\n        lst", "        if (n < 2) return List[Long]()\n        val primes\
    \ = new ArrayBuffer[Long]()\n        val notPrimes = new HashSet[Long]()\n   \
    \     def isPrime(n : Long) : Boolean = {\n            val nsqrt = sqrt(n)\n \
    \           val primesBelowN = primes.filter(_ <= nsqrt)\n            primesBelowN.forall(n\
    \ % _ != 0)\n        }\n        for (i <- 2l to n) {\n            if (!notPrimes.contains(i))\
    \ {\n                primes += i\n                for (j <- 2l to n / i) {\n \
    \                   notPrimes += j * i\n                }\n            }\n   \
    \     }\n        primes.toList", "        // your code goes here\n        List[Long]()",
  "        var results = List[Long]()\n        for (i <- 2l to n) {\n            if\
    \ (isPrime(i)) {\n                results = results :+ i\n            }\n    \
    \    }\n        results", "        // Your code here\n        if (n == 0) List()\n\
    \        else if (n == 1) List()\n        else {\n            val temp1 = (2l\
    \ to n).toList\n            val temp2 = temp1.filter(temp1 => isPrime(temp1))\n\
    \            temp2\n        }", "        if (n < 2)\n            List[Long]()\n\
    \        else {\n            var primeList = new ListBuffer[Long]\n          \
    \  primeList += 2\n            for (j <- 3 to n.toInt) {\n                val\
    \ sqrtj = sqrt(j).toInt\n                var flag = true\n                for\
    \ (i <- primeList) {\n                    if (i > sqrtj)\n                   \
    \     break\n                    if (j % i == 0) {\n                        flag\
    \ = false\n                        break\n                    }\n            \
    \    }\n                if (flag)\n                    primeList += j\n      \
    \      }\n            primeList.toList\n        }", "        def isPrime(n : Long)\
    \ : Boolean = {\n            if (n < 2) return false\n            if (n < 4) return\
    \ true\n            if (n % 2 == 0) return false\n            if (n < 9) return\
    \ true\n            if (n % 3 == 0) return false\n            val sr = math.sqrt(n).toLong\n\
    \            var f = 5\n            while (f <= sr) {\n                if (n %\
    \ f == 0) return false\n                if (n % (f + 2) == 0) return false\n \
    \               f += 6\n            }\n            return true\n        }\n  \
    \      var list = List[Long]()\n        for (i <- 1 to n.toInt if isPrime(i))\
    \ {\n            list = list :+ i\n        }\n        return list", "\t\tif (n\
    \ == 0) List[Long]()\n\t\telse if (n == 1) List[Long]()\n\t\telse if (n == 2)\
    \ List[Long](2)\n\t\telse {\n\t\t\tvar l = countUpTo(sqrt(n).toLong)\n\t\t\tif\
    \ (n % 2 == 0) l\n\t\t\telse if (n % 3 == 0) l\n\t\t\telse if (n % 5 == 0) l\n\
    \t\t\telse if (n % 7 == 0) l\n\t\t\telse if (n % 11 == 0) l\n\t\t\telse if (n\
    \ % 13 == 0) l\n\t\t\telse if (n % 17 == 0) l\n\t\t\telse if (n % 19 == 0) l\n\
    \t\t\telse 2 :: 3 :: 5 :: 7 :: 11 :: 13 :: 17 :: 19 :: countUpTo(19)\n\t\t}",
  "        var temp : List[Long] = Nil\n        for (i <- 2l to n) {\n           \
    \ if (isPrime(i)) {\n                temp = i :: temp\n            }\n       \
    \ }\n        temp.reverse", "        if (n == 0) List()\n        else {\n    \
    \        def countUpTo2(n : Long, result : List[Long]) : List[Long] = {\n    \
    \            if (n == 1) result\n                else if (result.last > math.sqrt(n))\
    \ result :+ n\n                else if (n % result.last == 0) countUpTo2(n, result)\n\
    \                else countUpTo2(n, result :+ result.last + 1)\n            }\n\
    \            countUpTo2(n, List(2))\n        }", "        def filterOutMultiples(xs\
    \ : List[Long], n : Long) : List[Long] = {\n            if (n * n > xs.last) xs\n\
    \            else filterOutMultiples(xs.filter(x => x % n != 0), n + 1)\n    \
    \    }\n        def sieveOfEratosthenes(xs : List[Long]) : List[Long] = {\n  \
    \          if (xs.isEmpty) List()\n            else {\n                val prime\
    \ = xs.head\n                prime :: sieveOfEratosthenes(filterOutMultiples(xs.tail,\
    \ prime))\n            }\n        }\n        if (n <= 1) List()\n        else\
    \ sieveOfEratosthenes((2l to n).toList)", "        var res = List[Long]()\n  \
    \      var i = 2l\n        while (i < n) {\n            var j = 2l\n         \
    \   var isPrime = true\n            while (j < i) {\n                if (i % j\
    \ == 0) {\n                    isPrime = false\n                    j = i\n  \
    \              }\n                j += 1\n            }\n            if (isPrime)\
    \ {\n                res = res :+ i\n            }\n            i += 1\n     \
    \   }\n        res", "        if (n == 0) return List[Long]()\n        var i =\
    \ 1L\n        var done = false\n        var primes = List[Long]()\n        while\
    \ (i < n) {\n            if (isPrime(i)) primes = primes :+ i\n            i +=\
    \ 1\n        }\n        primes", "        val num = n + 1\n        val primes\
    \ = new Array[Boolean](num.toInt)\n        for (i <- 2 until num.toInt) {\n  \
    \          primes(i) = true\n        }\n        for (i <- 2 until sqrt(num).toInt)\
    \ {\n            if (primes(i)) {\n                for (j <- (i * i) until num.toInt\
    \ by i) {\n                    primes(j) = false\n                }\n        \
    \    }\n        }\n        val result = new ArrayBuffer[Long]()\n        for (i\
    \ <- 2 until num.toInt) {\n            if (primes(i)) {\n                result\
    \ += i.toLong\n            }\n        }\n        result.toList", "        var\
    \ primes = new ListBuffer[Long]()\n        if (n < 2) return primes.toList\n \
    \       primes += 2\n        for (i <- 3l to n by 2) {\n            var isPrime\
    \ = true\n            for (p <- primes if p * p <= i) {\n                if (i\
    \ % p == 0) {\n                    isPrime = false\n                    break\n\
    \                }\n            }\n            if (isPrime) primes += i\n    \
    \    }\n        primes.toList", '        return Nil', "        if (n == 0) {\n\
    \            return List[Long]()\n        }\n        val list = countUpTo(n -\
    \ 1)\n        if (list.forall(x => n % x != 0)) {\n            return list :+\
    \ n\n        }\n        list", "        // your answer here\n        var i = 2l\n\
    \        var numList = new ListBuffer[Long]()\n        while (i <= n){\n     \
    \       var isPrime = true\n            var k = 2l\n            while (k < i &&\
    \ isPrime){\n                if (i % k == 0){\n                    isPrime = false\n\
    \                }\n                k += 1\n            }\n            if (isPrime){\n\
    \                numList += i\n            }\n            i += 1\n        }\n\
    \        numList.toList", "        def countUpToHelper(number : Long, count :\
    \ Long, l : List[Long]) : List[Long] = {\n            if (count >= n) l\n    \
    \        else if (number == 1) l\n            else if (isPrime(number)) countUpToHelper(number\
    \ + 1, count + 1, l :+ number)\n            else countUpToHelper(number + 1, count,\
    \ l)\n        }\n        countUpToHelper(2, 0, List())", "        def sqrt(n :\
    \ Long) : Long = {\n            def sqrtIter(guess : Long) : Long = {\n      \
    \          if (abs(guess * guess - n) < 1) {\n                    guess\n    \
    \            } else {\n                    sqrtIter((guess + n / guess) / 2)\n\
    \                }\n            }\n            sqrtIter(1)\n        }\n      \
    \  def isPrime(n : Long) : Boolean = {\n            def isPrimeIter(i : Long)\
    \ : Boolean = {\n                if (i > sqrt(n)) {\n                    true\n\
    \                } else if (n % i == 0) {\n                    false\n       \
    \         } else {\n                    isPrimeIter(i + 1)\n                }\n\
    \            }\n            if (n == 1) {\n                false\n           \
    \ } else {\n                isPrimeIter(2)\n            }\n        }\n       \
    \ def countUpToIter(m : Long, result : List[Long]) : List[Long] = {\n        \
    \    if (m > n) {\n                result\n            } else if (isPrime(m))\
    \ {\n                countUpToIter(m + 1, result :+ m)\n            } else {\n\
    \                countUpToIter(m + 1, result)\n            }\n        }\n    \
    \    countUpToIter(1, List())", "        var result : List[Long] = Nil\n     \
    \   for (i <- 2 to n.toInt) {\n            if (isPrime(i)) result = i :: result\n\
    \        }\n        result", '        return List[Long]()', "        // Scala\
    \ 2.7.7\n        // val p = 2l #:: Stream.from(3).map(_.toLong).filter(i =>\n\
    \        //     p.takeWhile{j => j * j <= i}.forall{ k => i % k > 0})\n      \
    \  // \n        // Scala 2.8\n        def countUpTo(n : Long) : List[Long] = {\n\
    \            val numbers = ArrayBuffer.empty[Long]\n            numbers += 2l\n\
    \            if (n > 2) {\n                var num = 3l\n                while\
    \ (num < n) {\n                    numbers += num\n                    num +=\
    \ 2\n                }\n            }\n            var sqrtN = sqrt(n).toLong\n\
    \            if (sqrtN % 2 == 0) sqrtN -= 1\n            var num = sqrtN\n   \
    \         while (num > 2) {\n                var i = 0\n                while\
    \ (i < numbers.length) {\n                    if (num % numbers(i) == 0) {\n \
    \                       num -= 2\n                        i = numbers.length -\
    \ 1\n                    }\n                    i += 1\n                }\n  \
    \              if (i == numbers.length) {\n                    numbers += num\n\
    \                    num -= 2\n                }\n            }\n            numbers.toList\n\
    \        }", "        // implementation here\n        List[Long]()", "       \
    \ if (n < 2) {\n            return List[Long]()\n        }\n        var x = 2l\n\
    \        var res = List[Long]()\n        while (x < n) {\n            var isPrime\
    \ = true\n            var y = 2l\n            while (y <= sqrt(x) && isPrime)\
    \ {\n                if (x % y == 0) {\n                    isPrime = false\n\
    \                }\n                y += 1\n            }\n            if (isPrime)\
    \ {\n                res = res :+ x\n            }\n            x += 1\n     \
    \   }\n        return res", "        var list : List[Long] = List()\n        for\
    \ (i <- 2l to n) {\n            var isPrime = true\n            for (j <- 2l to\
    \ (i / 2)) {\n                if (i % j == 0) isPrime = false\n            }\n\
    \            if (isPrime) list = list :+ i\n        }\n        list", '        (for
    (i <- 2l to n if (isPrime(i))) yield i).toList', "        if (n <= 1) {\n    \
    \        return List[Long]()\n        }\n        var primes : List[Long] = List[Long](2l)\n\
    \        var candidate : Long = 3l\n        while (candidate < n) {\n        \
    \    val max : Long = floor(sqrt(candidate)).toLong\n            var in : Long\
    \ = 0l\n            while (in < primes.length && primes(in.toInt) <= max) {\n\
    \                if (candidate % primes(in.toInt) == 0) {\n                  \
    \  in = Long.MaxValue\n                }\n                in += 1\n          \
    \  }\n            if (in != Long.MaxValue) {\n                primes = primes\
    \ :+ candidate\n            }\n            candidate += 2\n        }\n       \
    \ return primes", "        var primes : List[Long] = List[Long]()\n        for\
    \ (i <- 2l to n) if (i.isPrime) primes = primes :+ i\n        primes", '        countUpToHelper(n,
    List())', "        var result = new ListBuffer[Long]\n        for (i <- 0l until\
    \ n) {\n            if (i == 0l || i == 1l)\n                result += i\n   \
    \         else if (i % 2l != 0 && i % 3l != 0 && i % 5l != 0 && i % 7l != 0)\n\
    \                result += i\n        }\n        result.toList", "        def\
    \ isPrime(x : Long) : Boolean = {\n            //def getDivisors(x : Long) : List[Long]\
    \ = {\n            //    if (x == 1) List[Long](1l)\n            //    else List[Long](1l,\
    \ x) ++ (2l to (x/2l) by 1l).toList.filter(x % _ == 0)\n            //}\n    \
    \        //getDivisors(x).length == 2\n            if (x <= 1) false\n       \
    \     else if (x == 2) true\n            else !(2l to (sqrt(x)).toLong by 1l).toList.exists(x\
    \ % _ == 0)\n        }\n        if (n <= 1) List[Long]()\n        else List[Long](2l)\
    \ ++ (3l to n by 2l).toList.filter(isPrime(_))", "        var primes = List[Long]()\n\
    \        for (i <- (2l to n)) {\n            var isPrime = true\n            for\
    \ (p <- primes) {\n                if (i % p == 0) {\n                    isPrime\
    \ = false\n                    break\n                }\n            }\n     \
    \       if (isPrime) primes = primes :+ i\n        }\n        primes", "     \
    \   // Write your code here\n        if (n < 2) return List[Long]()\n        var\
    \ p : List[Long] = List[Long](2l)\n        for (x <- 3l to n by 2l) {\n      \
    \      if (p.forall(f => x % f != 0)) p = p :+ x\n        }\n        return p",
  "        if (n < 0) throw new IllegalArgumentException(\"CountUpTo can only be used\
    \ with non-negative integers\")\n        else {\n            if (n < 2) List()\n\
    \            else {\n                def isPrime(num : Long) : Boolean = {\n \
    \                   val sqrt = math.sqrt(num).toLong\n                    for\
    \ (a <- 2l to sqrt) {\n                        if (num % a == 0) return false\n\
    \                    }\n                    true\n                }\n        \
    \        val list = new ListBuffer[Long]()\n                for (x <- 2l to n)\
    \ {\n                    if (isPrime(x)) list += x\n                }\n      \
    \          list.toList\n            }\n        }", "        def isPrime(n : Long)\
    \ : Boolean = {\n            var isPrime = true\n            val max = sqrt(n).toLong\n\
    \            var i = 2l\n            while (i <= max) {\n                if (n\
    \ % i == 0) isPrime = false\n                i += 1\n            }\n         \
    \   isPrime\n        }\n        var result = List[Long]()\n        var i = 2l\n\
    \        while (i < n) {\n            if (isPrime(i)) result = result :+ i\n \
    \           i += 1\n        }\n        result", "        if (n <= 1) List()\n\
    \        else {\n            var i = 3\n            var l = List[Long](2)\n  \
    \          while (i < n) {\n                if (isPrime(i)) l = l :+ i\n     \
    \           i += 2\n            }\n            l\n        }", "        var result\
    \ = List[Long]()\n        var i = 2l\n        while (i < n) {\n            var\
    \ j = 2l\n            var isPrime = true\n            while (j < i) {\n      \
    \          if (i % j == 0) isPrime = false\n                j += 1\n         \
    \   }\n            if (isPrime) result ::= i\n            i += 1\n        }\n\
    \        result.reverse", "        var primes = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- (2l to n)) {\n            if (i % 2 == 0 && i != 2) {\n   \
    \         } else if (isPrime(i)) {\n                primes += i\n            }\n\
    \        }\n        return primes.toList", "        if (n <= 1) return List()\n\
    \        var numbers = (2l to n).toArray\n        for (i <- 2l to sqrt(n).toLong)\
    \ {\n            if (numbers(i.toInt - 2) != 0) {\n                for (j <- i\
    \ * i to n by i) {\n                    numbers(j.toInt - 2) = 0\n           \
    \     }\n            }\n        }\n        return numbers.filter(e => e != 0).toList",
  "        var prime_count = 1l;\n        var list = new ListBuffer[Long]();\n   \
    \     if (n == 0) {\n            return List[Long]();\n        }\n        for\
    \ (i <- 2l until n) {\n            if (prime_count == n) {\n                return\
    \ list.toList;\n            }\n            if (isPrime(i)) {\n               \
    \ list += i;\n                prime_count += 1;\n            }\n        }\n  \
    \      return list.toList;", "        // your code goes here...\n        List()",
  "        if (n <= 0) {\n            return List[Long]()\n        }\n        // following\
    \ is from http://www.math.utah.edu/~pa/math/prim/prim.html,\n        // except\
    \ that I am too lazy to figure out how to get rid of 2 in the first step.\n  \
    \      var m : Long = 0\n        var N : Long = n - 1\n        var p : Long =\
    \ 2\n        val sieve : Array[Boolean] = Array.fill[Boolean]((N + 1).toInt)(true)\n\
    \        sieve(0) = false\n        while (p <= sqrt(N)) {\n            if (sieve(p.toInt))\
    \ {\n                m = 0\n                while (p * p + m * p <= N) {\n   \
    \                 sieve(p * p + m * p) = false\n                    m += 1\n \
    \               }\n            }\n            p += 1\n        }\n        val result\
    \ : ListBuffer[Long] = ListBuffer[Long]()\n        for (i <- 2 to N.toInt) {\n\
    \            if (sieve(i)) {\n                result += i.toLong\n           \
    \ }\n        }\n        return result.toList", "        def countUpToImpl(n :\
    \ Long, count : Long) : List[Long] = {\n            if (count >= n) Nil\n    \
    \        else if (isPrime(count)) count :: countUpToImpl(n, count + 1)\n     \
    \       else countUpToImpl(n, count + 1)\n        }\n        countUpToImpl(n,\
    \ 2)", "        if (n <= 1) List()\n        else (2l to n).toList.filter(isPrime)",
  "        val c = new CountUpToClass(n)\n        c.countUpTo(n)", "        // your\
    \ code here\n        List[Long]()", "        var result = List[Long]()\n     \
    \   def count(n : Long) : Unit = {\n            if (n < 2) return\n          \
    \  var isPrime = true\n            for (i <- 2l to sqrt(n).toLong) {\n       \
    \         if (n % i == 0) {\n                    isPrime = false\n           \
    \         return\n                }\n            }\n            if (isPrime) result\
    \ = result :+ n\n            count(n - 1)\n        }\n        count(n)\n     \
    \   result", "        var primes = new ListBuffer[Long]()\n        if (n > 1)\
    \ primes += 2\n        for (i <- 3l to n by 2) {\n            var isPrime = true\n\
    \            for (p <- primes) {\n                if (i % p == 0) {\n        \
    \            isPrime = false\n                    break\n                }\n \
    \           }\n            if (isPrime) primes += i\n        }\n        primes.toList",
  "    }\n    // The Fibonacci sequence is the sequence of numbers beginning with\
    \ 0 and 1 such that each \n    // subsequent number is the sum of the two preceding.\
    \ For example, the first 7 numbers of \n    // the sequence are 0, 1, 1, 2, 3,\
    \ 5, 8. Write a function that takes an integer n and returns \n    // the nth\
    \ number of the sequence.\n    // for example:\n    // >>> fibonacci(0)\n    //\
    \ 0\n    // >>> fibonacci(1)\n    // 1\n    // >>> fibonacci(2)\n    // 1\n  \
    \  // >>> fibonacci(3)\n    // 2\n    // >>> fibonacci(4)\n    // 3\n    // >>>\
    \ fibonacci(5)\n    // 5\n    // >>> fibonacci(6)\n    // 8\n    // >>> fibonacci(7)\n\
    \    // 13\n    // >>> fibonacci(8)\n    // 21\n    // >>> fibonacci(9)\n    //\
    \ 34\n    // >>> fibonacci(10)\n    // 55\n    // >>> fibonacci(11)\n    // 89\n\
    \    // >>> fibonacci(12)\n    // 144\n    // >>> fibonacci(13)\n    // 233\n\
    \    // >>> fibonacci(14)\n    // 377\n    // >>> fibonacci(15)\n    // 610\n\
    \    // >>> fibonacci(16)\n    // 987\n    // >>> fibonacci(17)\n    // 1597\n\
    \    // >>> fibonacci(18)\n    // 2584\n    // >>> fibonacci(19)\n    // 4181\n\
    \    // >>> fibonacci(20)\n    // 6765\n    // >>> fibonacci(21)\n    // 10946\n\
    \    // >>> fibonacci(22)\n    // 17711\n    // >>> fibonacci(23)\n    // 28657\n\
    \    // >>> fibonacci(24)\n    // 46368\n    // >>> fibonacci(25)\n    // 75025\n\
    \    // >>> fibonacci(26)\n    // 121393\n    // >>> fibonacci(27)\n    // 196418\n\
    \    // >>> fibonacci(28)\n   ", "        /**\n         * Your code goes here\n\
    \         */", "        if (n == 0) List[Long]()\n        else {\n           \
    \ val l = (2l to n).toList\n            l.filter(x => isPrime(x))\n        }",
  "        var result = List[Long]()\n        for (i <- 2l until n) {\n          \
    \  if (isPrime(i)) result = result :+ i\n        }\n        result", "       \
    \ def count(n : Long, acc : List[Long]) : List[Long] = n match {\n           \
    \ case n if (n < 2) => acc\n            case n if (isPrime(n)) => count(n - 1,\
    \ n :: acc)\n            case n => count(n - 1, acc)\n        }\n        count(n,\
    \ List[Long]())", "        def isPrime(num : Long) : Boolean = (2l to sqrt(num).toLong).forall(num\
    \ % _ != 0)\n        (2l to n).filter(isPrime).toList", "        var primes =\
    \ new ListBuffer[Long]()\n        for (i <- 2l to n) {\n            if (BigInt(i).isProbablePrime(100))\
    \ {\n                primes += i\n            }\n        }\n        primes.toList",
  "        var result : List[Long] = List()\n        if (n > 1) {\n            for\
    \ (i <- 2l to n) {\n                if (isPrime(i)) result = result :+ i\n   \
    \         }\n        }\n        result", "        var out : List[Long] = List[Long]()\n\
    \        if (n >= 2) {\n            var isPrime = true\n            for (i <-\
    \ 2l until n if isPrime) {\n                for (j <- 2l until i if isPrime) {\n\
    \                    if (i % j == 0) {\n                        isPrime = false\n\
    \                    }\n                }\n                if (isPrime) {\n  \
    \                  out = out :+ i\n                }\n                isPrime\
    \ = true\n            }\n        }\n        return out", '        throw new UnsupportedOperationException("Problem.countUpTo
    is not implemented yet.")', "        require(n >= 0l)\n        // your code here\n\
    \        var list: List[Long] = List()\n        if (n >= 2) {\n            list\
    \ = list :+ 2\n        }\n        var i = 3\n        while (i < n) {\n       \
    \     if (isPrime(i)) {\n                list = list :+ i\n            }\n   \
    \         i += 2\n        }\n        list", "        var c = 0\n        var result\
    \ = List[Long]()\n        var i = 2\n        while (i < n) {\n            var\
    \ isPrime = true\n            for (j <- 2 to i - 1) {\n                if (i %\
    \ j == 0) {\n                    isPrime = false\n                }\n        \
    \    }\n            if (isPrime) {\n                result = result :+ i\n   \
    \         }\n            i += 1\n        }\n        result", "        def isPrime(a\
    \ : Long) : Boolean = {\n            var b = 2l\n            while (b <= sqrt(a))\
    \ {\n                if (a % b == 0) {\n                    return false\n   \
    \             }\n                b += 1\n            }\n            return true\n\
    \        }\n        var i = 2l\n        var l = List[Long]()\n        while (i\
    \ < n) {\n            if (isPrime(i)) {\n                l = i :: l\n        \
    \    }\n            i += 1\n        }\n        return l", "        var primes\
    \ : List[Long] = List[Long]()\n        for (i <- 2l to n) {\n            if (prime(i))\
    \ primes = primes :+ i\n        }\n        primes", "        @annotation.tailrec\n\
    \        def countUpTo(n : Long, acc : List[Long]) : List[Long] = {\n        \
    \    if (n < 2) acc\n            else if (isPrime(n)) countUpTo(n - 1, n :: acc)\n\
    \            else countUpTo(n - 1, acc)\n        }\n        def isPrime(n : Long)\
    \ : Boolean = {\n            if (n == 2) true\n            else if (n % 2 == 0)\
    \ false\n            else {\n                def isPrime(n : Long, divisor : Long)\
    \ : Boolean = {\n                    if (divisor == n) true\n                \
    \    else if (n % divisor == 0) false\n                    else isPrime(n, divisor\
    \ + 1)\n                }\n                isPrime(n, 3)\n            }\n    \
    \    }\n        countUpTo(n, List())", "        if (n < 2) {\n            List()\n\
    \        } else {\n            List(2) ++ (3 until n by 2).filter(i => (2 until\
    \ ceil(sqrt(i)).toInt).forall(j => i % j != 0)).toList\n        }", "        if\
    \ (n <= 1) List[Long]()\n        else List[Long](2l) ++ (3 to n.toInt by 2).filter(isPrime).map(_.toLong)",
  "        def countUpTo(n : Long, list : List[Long]) : List[Long] = {\n         \
    \   if (n < 2) list\n            else if (isPrime(n)) countUpTo(n - 1, n :: list)\n\
    \            else countUpTo(n - 1, list)\n        }\n        countUpTo(n, List())",
  "        val primes = new Primes(n)\n        primes.nums.toList", '        for (i
    <- 1l to n if n % i == 0) yield (i)', '        return List[Long]()', "       \
    \ val sqrtN = math.sqrt(n).toLong\n        val primeSet = ArrayBuffer(2L)\n  \
    \      val primeList = ArrayBuffer(2L)\n        for (i <- 3L to n by 2) {\n  \
    \          var isPrime = true\n            val primeLength = primeSet.length\n\
    \            var pi = 0\n            while (pi < primeLength && isPrime) {\n \
    \               if (i % primeSet(pi) == 0) {\n                    isPrime = false\n\
    \                }\n                pi += 1\n            }\n            if (isPrime)\
    \ {\n                primeSet += i\n                primeList += i\n         \
    \   }\n        }\n        primeList.toList", "        def isPrime(i : Long) :\
    \ Boolean = {\n            if (i <= 1) false\n            else if (i == 2) true\n\
    \            else !(2 until i).exists(x => i % x == 0)\n        }\n        (2\
    \ until n.toInt).filter(isPrime).map(_.toLong).toList", "        def checkPrime(num\
    \ : Long) : Boolean = {\n            var i = 2\n            while (i <= math.sqrt(num).toInt)\
    \ {\n                if (num % i == 0) return false\n                i += 1\n\
    \            }\n            return true\n        }\n        if (n <= 1) return\
    \ List[Long]()\n        var i = 1l\n        var primes = List[Long]()\n      \
    \  while (i < n) {\n            if (checkPrime(i)) primes = primes :+ i\n    \
    \        i += 1\n        }\n        return primes", "        if (n == 0)\n   \
    \         List[Long]()\n        else {\n            var candidates = 2l until\
    \ n\n            var primes = List[Long]()\n            var p = 2l\n         \
    \   do {\n                primes = primes :+ p\n                candidates = candidates.filter((i\
    \ : Long) => i % p != 0)\n                p = candidates.head\n            } while\
    \ (p * p <= n)\n            primes = primes ++ candidates\n            primes\n\
    \        }", "        val list = ListBuffer[Long]()\n        for (i <- (2l to\
    \ n).toList) {\n            if (isPrime(i)) list += i\n        }\n        list.toList",
  "        def countUpToRec(n : Long, primeList : List[Long]) : List[Long] = {\n \
    \           // TODO: write this function, and return your answer\n           \
    \ if (n == 1) return primeList\n            if (isPrime(n)) return countUpToRec(n\
    \ - 1, primeList :+ n)\n            countUpToRec(n - 1, primeList)\n        }\n\
    \        countUpToRec(n, List[Long]())", "        if (n <= 1) return List[Long]()\n\
    \        val l = ListBuffer[Long]()\n        val ps = SieveOfEratosthenes(n.toInt).getPrimes\n\
    \        var i = 2\n        while (i < n) {\n            if (ps(i)) l += i\n \
    \           i += 1\n        }\n        l.toList", "\t\t// TODO: implement this.\n\
    \t\tvar result = List[Long]()\n\t\tvar i = 2l\n\t\twhile (i <= n) {\n\t\t\tif\
    \ (isPrime(i)) {\n\t\t\t\tresult = result :+ i\n\t\t\t}\n\t\t\ti += 1\n\t\t}\n\
    \t\tresult", "        def countUpToInternal(n : Long, primeList : List[Long])\
    \ : List[Long] = {\n            if (n <= 2) primeList\n            else {\n  \
    \              val next = primeList.head\n                if (n % next == 0) primeList\n\
    \                else countUpToInternal(n, next :: primeList)\n            }\n\
    \        }\n        countUpToInternal(n, List(2l))", "        var list = List[Long]()\n\
    \        var i = 2l\n        while (i < n) {\n            var isPrime = true\n\
    \            var j = 2l\n            while (j < i && isPrime) {\n            \
    \    if (i % j == 0) {\n                    isPrime = false\n                }\n\
    \                j += 1\n            }\n            if (isPrime) {\n         \
    \       list = list :+ i\n            }\n            i += 1\n        }\n     \
    \   list", "        // your solution here\n        n match {\n            case\
    \ 0 => List[Long]()\n            case 1 => List[Long]()\n            case 2 =>\
    \ List[Long](2)\n            case _ => List.range(2, n.toInt + 1).filter(isPrime).toList\n\
    \        }", "        // Your code goes here\n        return List[Long]()", " \
    \       var range = (2l to n)\n        var primes = List[Long]()\n        while\
    \ (range.head < sqrt(n)) {\n            primes = primes :+ range.head\n      \
    \      range = range.filter((x => x % range.head != 0))\n        }\n        primes\
    \ ++ range", "        val limit = sqrt(n).toLong\n        val prime = new HashSet[Long]()\n\
    \        prime += 2l\n        for (i <- 3l to n by 2l) {\n            if (prime.forall(p\
    \ => i % p != 0)) prime += i\n        }\n        prime.toList", "        // YOUR\
    \ CODE HERE\n        n match {\n            case 0 => List()\n            case\
    \ 1 => List()\n            case _ => List.range(1, n.toInt).map(x => List(2, x).reduceLeft(_.gcd(_))).filter(_\
    \ == 1).map(_ + 1).map(_.toLong).filter(_ != 1).filter(_ != 2).filter(_ != 0)\n\
    \        }", '        // your code goes here', "        // your code goes here\n\
    \        def isPrime(n : Long) : Boolean = {\n            if (n < 2) return false\n\
    \            if (n == 2) return true\n            for (i <- 2 to (ceil(sqrt(n)).toInt\
    \ + 1)) {\n                if (n % i == 0) return false\n            }\n     \
    \       return true\n        }\n        if (n < 1) return List[Long]()\n     \
    \   var cnt = 1\n        var ans = List[Long]()\n        while (cnt <= n) {\n\
    \            if (isPrime(cnt)) ans = ans :+ cnt\n            cnt += 1\n      \
    \  }\n        return ans", "        // your implementation goes here\n       \
    \ null", "        // Fill in the implementation here.\n        return List[Long]()",
  "        var primes : List[Long] = List()\n        var i : Long = 2\n        while\
    \ (i < n) {\n            if (isPrime(i)) primes = primes :+ i\n            i +=\
    \ 1\n        }\n        primes", '        // your code goes here', '        //
    your answer here', "        // your implementation here\n        // var list:\
    \ List[Long] = List();\n        // for (i <- 2L to n) {\n        //     if (isPrime(i))\
    \ {\n        //         list = list :+ i;\n        //     }\n        // }\n  \
    \      // return list;\n        val list = (2L to n).toList.filter(isPrime(_));\n\
    \        return list;", "        var list = new ListBuffer[Long]()\n        if\
    \ (n <= 1) return list.toList\n        list += 2\n        for (i <- 3 to n.toInt)\
    \ {\n            var isPrime = true\n            var upper = sqrt(i).toInt\n \
    \           for (j <- 0 to list.length - 1) {\n                if (list(j) > upper)\
    \ break\n                if (i % list(j) == 0) {\n                    isPrime\
    \ = false\n                    break\n                }\n            }\n     \
    \       if (isPrime) list += i\n        }\n        list.toList", "        // YOUR\
    \ CODE HERE\n        null", "        def countUpToHelper(n : Long, result : List[Long])\
    \ : List[Long] = {\n            if (n == 0l)\n                result\n       \
    \     else if (isPrime(n))\n                countUpToHelper(n - 1, n :: result)\n\
    \            else\n                countUpToHelper(n - 1, result)\n        }\n\
    \        countUpToHelper(n, List())", "        if (n == 0l) return List[Long]()\n\
    \        def helper(x : Long, l : List[Long]) : List[Long] = {\n            if\
    \ (x >= n) return l\n            if (l.forall(y => x % y != 0)) return helper(x\
    \ + 1, l :+ x)\n            else return helper(x + 1, l)\n        }\n        return\
    \ helper(2, List[Long]())", "        var primes = List[Long]()\n        var nprimes\
    \ = List[Long]()\n        val last = n\n        if (n == 0l) {\n            return\
    \ primes\n        }\n        if (n == 1l) {\n            return primes\n     \
    \   }\n        if (n == 2l) {\n            return primes\n        }\n        //\
    \ Map[Long, Long]()\n        var a = 0l\n        while (a < n) {\n           \
    \ if (a % 2 == 0) {\n                a += 1\n                continue\n      \
    \      }\n            var i = 3l\n            var isPrime = true\n           \
    \ while (i <= sqrt(a)) {\n                if (a % i == 0) {\n                \
    \    isPrime = false\n                    break\n                }\n         \
    \       i += 2\n            }\n            if (isPrime) {\n                primes\
    \ = primes :+ a\n            }\n            a += 1\n        }\n        primes.foreach(a\
    \ => nprimes = nprimes :+ a)\n        return nprimes", '        // your solution
    here', "        var l = List[Long]()\n        for (i <- 1 to n.toInt if isPrime(i))\
    \ l = i :: l\n        l.sortWith(_ < _)", "        val primes = new ListBuffer[Long]()\n\
    \        for (i <- 2l to n) if (i.isPrime) primes += i\n        primes.toList",
  "        def count(n : Long, a : Long, ls : List[Long]) : List[Long] = {\n     \
    \       if (n < a) {\n                ls\n            } else {\n             \
    \   if (ls.exists(e => (a % e == 0l))) {\n                    count(n, a + 1l,\
    \ ls)\n                } else {\n                    count(n, a + 1l, ls :+ a)\n\
    \                }\n            }\n        }\n        count(n, 2l, List[Long]())",
  "        if (n < 2) List[Long]()\n        else {\n            val primes = new ArrayBuffer[Long]()\n\
    \            val composites = new ArrayBuffer[Long]()\n            for (i <- 2l\
    \ to n) {\n                if (!composites.contains(i)) {\n                  \
    \  primes += i\n                    var j = i * i\n                    while (j\
    \ <= n) {\n                        composites += j\n                        j\
    \ += i\n                    }\n                }\n            }\n            primes.toList\n\
    \        }", "        val l = new ArrayBuffer[Long]()\n        for (i <- 2l to\
    \ n) {\n            if (isPrime(i)) l += i\n        }\n        l.toList", "  \
    \      if (n == 0) return List()\n        var primes : List[Long] = List()\n \
    \       var nums : List[Long] = List()\n        for (i <- 2l to n) {\n       \
    \     if (nums.forall(num => i % num != 0)) {\n                primes = i :: primes\n\
    \            }\n            nums = i :: nums\n        }\n        primes.reverse",
  "        // Your code here\n        var prime = ListBuffer[Long]()\n        if (n\
    \ == 0) prime = ListBuffer[Long]()\n        else {\n            var count = 2l\n\
    \            while (count < n) {\n                var i = 2l\n               \
    \ var flag = true\n                while (i <= count / 2) {\n                \
    \    if (count % i == 0) {\n                        flag = false\n           \
    \             i = count\n                    }\n                    i += 1\n \
    \               }\n                if (flag) prime += count\n                count\
    \ += 1\n            }\n        }\n        prime.toList", "        if (n == 0)\
    \ {\n            return List()\n        }\n        var p = 2l\n        var res\
    \ = List[Long]()\n        while (p < n) {\n            if (isPrime(p)) {\n   \
    \             res = res :+ p\n            }\n            p += 1\n        }\n \
    \       return res", '        (2l to n).toList.filter(x => isPrime(x))', '        //
    Write your code here', "        if (n < 2) List[Long]()\n        else {\n    \
    \        var primes = new ArrayBuffer[Long]()\n            for (i <- 2 to n.toInt\
    \ if isPrime(i)) primes += i\n            primes.toList\n        }", "       \
    \ def countUpToAcc(n : Long, acc : List[Long]) : List[Long] = {\n            def\
    \ isPrime(n : Long) : Boolean = {\n                if (n < 2) return false\n \
    \               val sqrt = math.sqrt(n).toLong\n                for (i <- 2l to\
    \ sqrt) {\n                    if (n % i == 0) return false\n                }\n\
    \                return true\n            }\n            n match {\n         \
    \       case n if n < 2 => acc\n                case n if isPrime(n) => countUpToAcc(n\
    \ - 1, n :: acc)\n                case _ => countUpToAcc(n - 1, acc)\n       \
    \     }\n        }\n        countUpToAcc(n, List())", "        def inner(n : Long,\
    \ acc : List[Long]) : List[Long] = {\n            if (n == 1) acc\n          \
    \  else if (n > 1 && n < 3) inner(n - 1, 2l :: acc)\n            else if (n >\
    \ 2 && n < 5) inner(n - 1, 3l :: acc)\n            else if (n > 4 && n < 7) inner(n\
    \ - 1, 5l :: acc)\n            else if (n > 6 && n < 11) inner(n - 1, 7l :: acc)\n\
    \            else if (n > 10 && n < 13) inner(n - 1, 11l :: acc)\n           \
    \ else if (n > 12 && n < 17) inner(n - 1, 13l :: acc)\n            else if (n\
    \ > 16 && n < 19) inner(n - 1, 17l :: acc)\n            else if (n > 18 && n <\
    \ 23) inner(n - 1, 19l :: acc)\n            else if (n > 22 && n < 29) inner(n\
    \ - 1, 23l :: acc)\n            else if (n > 28 && n < 31) inner(n - 1, 29l ::\
    \ acc)\n            else if (n > 30 && n < 37) inner(n - 1, 31l :: acc)\n    \
    \        else if (n > 36 && n < 41) inner(n - 1, 37l :: acc)\n            else\
    \ if (n > 40 && n < 43) inner(n - 1, 41l :: acc)\n            else if (n > 42\
    \ && n < 47) inner(n - 1, 43l :: acc)\n            else if (n > 46 && n < 53)\
    \ inner(n - 1, 47l :: acc)\n            else if (n > 52 && n < 59) inner(n - 1,\
    \ 53l :: acc)\n            else if (n > 58 && n < 61) inner(n - 1, 59l :: acc)\n\
    \            else if (n > 60 && n < 67) inner(n - 1, 61l :: acc)\n           \
    \ else if (n > 66 && n < 71) inner(n - 1, 67l :: acc)\n            else if (n\
    \ > 70 && n < 73) inner(n - 1, 71l :: acc)\n", "        var primes = new ListBuffer[Long]()\n\
    \        var i = 2l\n        while (i < n) {\n            primes += i\n      \
    \      i += 1\n        }\n        primes.toList", "        // your solution here\n\
    \        ???", "        val p = 2l\n        return null;", "        // Compute\
    \ the answer and return it\n        var ans = List[Long]()\n        if (n < 2)\
    \ {\n            return ans\n        }\n        ans = ans :+ 2\n        for (i\
    \ <- 3 to n.toInt by 2) {\n            if (isPrime(i)) {\n                ans\
    \ = ans :+ i\n            }\n        }\n        return ans", "        if (n <=\
    \ 1) return List[Long]()\n        var primes = List[Long](2)\n        for (i <-\
    \ 3 to n.toInt) {\n            if (primes.exists(e => (i % e == 0))) {\n     \
    \           // nothing\n            } else {\n                primes = primes\
    \ :+ i\n            }\n        }\n        primes", "        val list = (2l to\
    \ n).toList\n        println(list)\n        val primes = list.filter(isPrime(_)).filter(_\
    \ < n)\n        println(primes)\n        primes", "        var list = new ListBuffer[Long]()\n\
    \        var end = floor(sqrt(n)).toLong\n        for (x <- 2l until n) {\n  \
    \          var isPrime = true\n            for (y <- 2l until end) {\n       \
    \         if (x % y == 0) isPrime = false\n            }\n            if (isPrime)\
    \ list += x\n        }\n        list.toList", "        var result = List[Long]()\n\
    \        val start = 2l\n        if (n == 0) {\n            return result\n  \
    \      }\n        if (n == 1) {\n            return result\n        }\n      \
    \  if (n == 2) {\n            result = start :: result\n            return result\n\
    \        }\n        var flag = true\n        var i = 2l\n        while (flag)\
    \ {\n            if (i >= n) {\n                flag = false\n            } else\
    \ {\n                var j = 2l\n                var primeFlag = true\n      \
    \          while (j < i) {\n                    if (i % j == 0) {\n          \
    \              primeFlag = false\n                    }\n                    j\
    \ += 1\n                }\n                if (primeFlag) {\n                \
    \    result = i :: result\n                }\n            }\n            i +=\
    \ 1\n        }\n        return result", '        ???', "        def countUpToIter(n\
    \ : Long, acc : List[Long]) : List[Long] = {\n            if (n <= 1) acc\n  \
    \          else if (n == 2) 2l :: acc\n            else {\n                if\
    \ (prime(n)) countUpToIter(n - 1, n :: acc)\n                else countUpToIter(n\
    \ - 1, acc)\n            }\n        }\n        countUpToIter(n, List[Long]())",
  "        def countUpTo(n : Long, current : Long, result : List[Long]) : List[Long]\
    \ = {\n            if (current > n) {\n                result\n            } else\
    \ if (isPrime(current)) {\n                countUpTo(n, current + 1, current ::\
    \ result)\n            } else {\n                countUpTo(n, current + 1, result)\n\
    \            }\n        }\n        countUpTo(n, 2, List[Long]())", "        if\
    \ (n <= 1) return List[Long]()\n        // TODO - implement the problem\n    \
    \    return List[Long]()", "        def isPrime(num : Long) : Boolean = {\n  \
    \          (num < 0) match {\n                case true => false\n           \
    \     case false => {\n                    val sqrt_num = sqrt(num)\n        \
    \            (num % 2 == 0) match {\n                        case true => false\n\
    \                        case false => {\n                            ((2 until\
    \ sqrt_num.toInt) toList).forall(x => num % x != 0)\n                        }\n\
    \                    }\n                }\n            }\n        }\n        (2\
    \ until n toList).filter(isPrime(_))", "        if (n == 0) {\n            return\
    \ List()\n        }\n        val result = scala.collection.mutable.ListBuffer[Long]()\n\
    \        val mark = Array.fill(n.toInt + 1)(true)\n        for (i <- 2 until n.toInt)\
    \ {\n            if (mark(i)) {\n                result += i\n               \
    \ for (j <- i * i until n.toInt by i) {\n                    mark(j) = false\n\
    \                }\n            }\n        }\n        result.toList", "      \
    \  val limit = sqrt(n)\n        val isPrime = new Array[Boolean](n.toInt + 1)\n\
    \        for (i <- 0 to n.toInt) isPrime(i) = true\n        isPrime(0) = false\n\
    \        isPrime(1) = false\n        for (i <- 2 to floor(limit).toInt) if (isPrime(i))\
    \ {\n            for (j <- i*i to n.toInt by i) isPrime(j) = false\n        }\n\
    \        var res = List[Long]()\n        for (i <- 2 to n.toInt) if (isPrime(i))\
    \ res = res :+ i.toLong\n        res", "        // your code goes here\n     \
    \   List()", "        var l : List[Long] = List[Long]()\n        for (i <- 2l\
    \ to n) {\n            if (isPrime(i)) {\n                l = i :: l\n       \
    \     }\n        }\n        l.reverse", "        var result = new ArrayBuffer[Long]()\n\
    \        if (n > 1) {\n            for (i <- 1 to n.toInt) {\n               \
    \ if (isPrime(i)) {\n                    result += i\n                }\n    \
    \        }\n        }\n        return result.toList", "        var list = List[Long]()\n\
    \        for (i <- 2l to n) {\n            if (isPrime(i)) list = list :+ i\n\
    \        }\n        list", "        var result : List[Long] = Nil\n        var\
    \ i : Long = 2\n        while (i < n) {\n            if (count(i)) {\n       \
    \         result = result :+ i\n            }\n            i += 1\n        }\n\
    \        result", "        //TODO: Implement Code Here\n        return null",
  '        ???', "        // Given a number n, find the count of numbers less than\
    \ n that are prime.\n        def countPrimesLessThan(n : Long) : Long = {\n  \
    \          val primesLessThan = n match {\n                case n if n < 2 =>\
    \ List[Long]()\n                case n if n == 2 => List[Long](2)\n          \
    \      case n if n % 2 == 0 => countPrimesLessThan(n - 1)\n                case\
    \ n => {\n                    val primesLessThan = new ArrayBuffer[Long]()\n \
    \                   var x = 3\n                    while (x < n) {\n         \
    \               if (isPrime(x)) primesLessThan += x\n                        x\
    \ += 2\n                    }\n                    primesLessThan.toList\n   \
    \             }\n            }\n            primesLessThan.length\n        }\n\
    \        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n\
    \            else if (n <= 3) return true\n            else if (n % 2 == 0 ||\
    \ n % 3 == 0) return false\n            var i = 5\n            while (i * i <=\
    \ n) {\n                if (n % i == 0 || n % (i + 2) == 0) return false\n   \
    \             i += 6\n            }\n            return true\n        }\n    \
    \    def findPrimes(n : Long) : List[Long] = {\n            if (n < 2) return\
    \ List[Long]()\n            else if (n == 2) return List[Long](2)\n          \
    \  else if (n % 2 == 0) return findPrimes(n - 1)\n            else {\n       \
    \         val primes = new ArrayBuffer[Long]()\n                var x = 3\n  \
    \              while (x < n) {\n                    if (isPrime(x)) primes +=\
    \ x\n                    x += 2\n                }\n                primes.toList\n\
    \            }\n        }\n        findPrimes(n)", "        if (n <= 0) return\
    \ List()\n        else {\n            val primes = ListBuffer(2L)\n          \
    \  (3L to n by 2L).foreach(i => if (primes.forall(p => i % p != 0)) primes +=\
    \ i)\n            primes.toList\n        }", "        // Your code here.\n   \
    \     null", "        var result : List[Long] = List()\n        var i : Long =\
    \ 2\n        while (i < n) {\n            if (isPrime(i)) {\n                result\
    \ = result :+ i\n            }\n            i = i + 1\n        }\n        return\
    \ result"]
stop_tokens:
- "\n    }\n"
