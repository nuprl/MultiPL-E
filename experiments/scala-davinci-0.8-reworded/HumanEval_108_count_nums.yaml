name: HumanEval_108_count_nums
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function count_nums which takes a list of integers and returns\n\
  \    // the number of elements which has a sum of digits > 0.\n    // If a number\
  \ is negative, then its first signed digit will be negative:\n    // e.g. -123 has\
  \ signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n\
  \    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    //\
  \ (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n  \
  \  // (3l)\n    def countNums(arr : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]()))\
  \ == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong)))\
  \ == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong,\
  \ 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong,\
  \ 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n\
  \    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong,\
  \ 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong,\
  \ 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n   \
  \ assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong)))\
  \ == (1l));\n    }\n\n}\n"
completions: ['        arr.filter(x => x.toString.map(y => y.asDigit).sum > 0).size',
  "        def sumDigits(n : Long) : Long = {\n            if (n == 0) 0\n       \
    \     else abs(n % 10) + sumDigits(n / 10)\n        }\n        arr.filter(sumDigits(_)\
    \ > 0).length", '        return arr.filter(x => abs(x).toString.map(_.asDigit).sum
    > 0).length', '        arr.map(x => x.abs.toString.map(_.asDigit).sum).filter(_
    > 0).size', "        val indices = (for (i <- 0 until arr.length) yield i).toArray\n\
    \        val sums = new Array[Long](arr.length)\n        for (i <- 0 until indices.length)\
    \ {\n            var sum = 0l\n            var v = arr(i)\n            if (v <\
    \ 0) v = -v\n            while (v > 0) {\n                sum += v % 10\n    \
    \            v /= 10\n            }\n            sums(i) = sum\n        }\n  \
    \      val sortedIndices = indices.sortWith((a, b) => sums(a) < sums(b))\n   \
    \     var count = 0l\n        var m = sums(sortedIndices(0))\n        for (i <-\
    \ 0 until sortedIndices.length) {\n            if (sums(sortedIndices(i)) > m)\
    \ {\n                count += (i + 1l) * (sortedIndices.length - i).toLong\n \
    \               m = sums(sortedIndices(i))\n            }\n        }\n       \
    \ count", "    \tdef f(n : Long) : Long = {\n    \t\tif (n == 0) 0 else n % 10\
    \ + f(n / 10)\n    \t}\n    \tarr.map(f(_)).filter(_ > 0).length", "        val\
    \ sumDigits = (arr map (a => a.abs.toString.map(_.asDigit).sum)).filter(_ > 0)\n\
    \        val result = sumDigits.foldLeft(0)(_ + _)\n        result", '        return
    arr.filter(e => (e.toString.split("").filter(c => c != "-").map(c => c.toLong).sum
    != 0)).length', "        if (arr.length == 0) return 0l\n        else {\n    \
    \        val x = arr.head\n            if (x < 0) return countNums(arr.tail) +\
    \ (if (signedSum(x) > 0) 1 else 0)\n            else return countNums(arr.tail)\
    \ + (if (sumDigits(x) > 0) 1 else 0)\n        }", '        arr.filter(x => if
    (x < 0) x.toString.tail.map(_.asDigit).sum + 1 > 0 else x.toString.map(_.asDigit).sum
    > 0).length', "        def isPositive(x : Long) : Boolean = {\n            if\
    \ (x < 0) true\n            else if (x == 0) false\n            else isPositive(x\
    \ / 10)\n        }\n        def signedDigits(x : Long) : List[Long] = {\n    \
    \        if (x == 0) List()\n            else List(x % 10 * (if (x < 0) -1 else\
    \ 1)) ::: signedDigits(x / 10)\n        }\n        def signedDigitsSum(x : Long)\
    \ : Long = {\n            signedDigits(x).sum\n        }\n        def sum(x :\
    \ Long) : Long = {\n            if (x == 0) 0\n            else x % 10 + sum(x\
    \ / 10)\n        }\n        def countNums(acc : Long, arr : List[Long]) : Long\
    \ = {\n            if (arr.isEmpty) acc\n            else countNums(acc + (if\
    \ (isPositive(arr.head)) 1 else 0), arr.tail)\n        }\n        countNums(0,\
    \ arr)", '        return arr.count(x => x.toString.map(x => abs(x.asDigit)).sum
    > 0)', '        return 0l', "        def loop(num : Long, acc : Long) : Long =\
    \ {\n            if (num == 0) acc else loop(num / 10, acc + (num % 10))\n   \
    \     }\n        arr.filter(loop(_, 0) > 0).length", "        def countNums(i\
    \ : Long, arr : List[Long]) : Long = {\n            if (arr.isEmpty) i\n     \
    \       else if (arr.head.toString.split(\"\").map(_.toLong).sum > 0) countNums(i\
    \ + 1, arr.tail)\n            else countNums(i, arr.tail)\n        }\n       \
    \ countNums(0, arr)", '        return 0l', "        if (arr.length == 0) return\
    \ 0\n        arr.filter(x => signum(x) * sumDigits(abs(x)) > 0).length", "   \
    \     def sign(n : Long) : Long = if (n < 0) -1 else 1\n        def countNumsRec(arr\
    \ : List[Long], signSum : Long) : Long = arr match {\n            case Nil =>\
    \ if (signSum > 0) 1 else 0\n            case h :: t => sign(h) + countNumsRec(t,\
    \ signSum + sign(h))\n        }\n        countNumsRec(arr, 0)", '        arr.count(x
    => if (x < 0) x.toString.tail.map(_.asDigit).sum else x.toString.map(_.asDigit).sum
    > 0)', "        var count = 0l\n        for (a <- arr) {\n            val sign\
    \ = if (a < 0) -1 else 1\n            var n = sign * a\n            var sum =\
    \ 0\n            while (n > 0) {\n                sum += n % 10\n            \
    \    n /= 10\n            }\n            if (sum > 0) count += 1\n        }\n\
    \        count", "        var sum : Long = 0\n        for (num <- arr) {\n   \
    \         if (num < 0) {\n                var n : Long = num\n               \
    \ var flag : Long = 1\n                var minus : Long = 0\n                while\
    \ (n != 0) {\n                    if (flag == 1) {\n                        minus\
    \ += (n % 10)\n                        flag = 0\n                    } else {\n\
    \                        minus -= (n % 10)\n                    }\n          \
    \          n /= 10\n                }\n                sum += minus\n        \
    \    } else {\n                var n : Long = num\n                var sum : Long\
    \ = 0\n                while (n != 0) {\n                    sum += (n % 10)\n\
    \                    n /= 10\n                }\n                if (sum != 0)\
    \ {\n                    sum += 1\n                }\n            }\n        }\n\
    \        sum", '        0l', "        if (arr.isEmpty) 0l\n        else if (arr.head\
    \ < 0) {\n            if (abs(arr.head).toString.map(_.asDigit).sum > 0) 1l +\
    \ countNums(arr.tail)\n            else countNums(arr.tail)\n        }\n     \
    \   else {\n            if (arr.head.toString.map(_.asDigit).sum > 0) 1l + countNums(arr.tail)\n\
    \            else countNums(arr.tail)\n        }", '        arr.filter(x => (abs(x).toString.map(_.asDigit).sum
    > 0)).length', "        val s : Long = arr.foldLeft(0l)((acc, v) => acc + Math.abs(v).toString.map(_.asDigit).sum)\n\
    \        if (s > 0) arr.length\n        else 0", "\t\tvar t : Long = 0\n\t\tfor\
    \ (i <- arr) {\n\t\t\tif (i < 0) {\n\t\t\t\tif (i % 10 == i) {\n\t\t\t\t\tt +=\
    \ 1\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (i / 10 == 0) {\n\t\t\t\t\tt += 1\n\
    \t\t\t\t} else {\n\t\t\t\t\tvar sum : Long = 0\n\t\t\t\t\tvar a : Long = i\n\t\
    \t\t\t\twhile (a != 0) {\n\t\t\t\t\t\tsum += a % 10\n\t\t\t\t\t\ta /= 10\n\t\t\
    \t\t\t}\n\t\t\t\t\tif (sum > 0) {\n\t\t\t\t\t\tt += 1\n\t\t\t\t\t}\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t\tt", '        arr.filter(x => x.toString.map(x => x.asDigit).sum
    > 0).size', "        if (arr.length == 0) {\n            0l\n        } else {\n\
    \            if (arr.head > 0) {\n                List(arr.head - 1, arr.head,\
    \ arr.head + 1).map(i => countNums(arr.tail :+ i)).max\n            } else {\n\
    \                countNums(arr.tail :+ (arr.head + 1))\n            }\n      \
    \  }", "      var c = 0\n      for (n <- arr) {\n        if (n < 0) c += -n/10\
    \ + abs(n % 10)\n        else c += n/10 + n % 10\n      }\n      return c", " \
    \       var count = 0l\n        for (x <- arr) {\n            if (toDigits(x).sum\
    \ > 0) count += 1\n        }\n        count", "        var sum = 0l\n        arr.foreach\
    \ { x => sum += (x / 100) + (x % 100) / 10 + (x % 10) }\n        sum", "     \
    \   // Fill up this function body\n        // You can add another function as\
    \ well, if required\n        var counts = 0\n        for (i <- arr) {\n      \
    \      var num = i\n            var sum = 0\n            while (num != 0) {\n\
    \                sum += math.abs(num%10)\n                num /= 10\n        \
    \    }\n            if (sum > 0) counts += 1\n        }\n        counts", "  \
    \  \tarr.filter(e => e.toString.filter(c => c != '-').map(c => c.asDigit).sum\
    \ > 0).size", "        def countNums0(n : Long) : Long = {\n            var x\
    \ = n\n            var r = 0l\n            while (x != 0) {\n                r\
    \ += x % 10\n                x /= 10\n            }\n            if (r > 0) 1\
    \ else 0\n        }\n        arr.map(x => countNums0(x)).sum", "        def sumDigits(num\
    \ : Long) : Long = {\n            if (num < 0) (-1l) * (num / 10l + num % 10l)\n\
    \            else if (num < 10) num\n            else sumDigits(num / 10l) + num\
    \ % 10l\n        }\n        arr.filter(sumDigits(_) > 0l).length", '        arr.map(x
    => if (x < 0) -x else x).map(x => if (x < 10) 1 else if (x < 100) 10 + x % 10
    else 100 + x % 10 + (x / 10) % 10).foldLeft(0)(_ + _)', "        def sd(n : Long)\
    \ : Long = {\n            if (n < 0) { -n } else { n }\n        }\n        arr.filter(n\
    \ => sd(n).toString.map(_.asDigit).sum > 0).size", "        // Write your code\
    \ here\n        if (arr.length == 0) 0\n        else {\n            var sum =\
    \ 0\n            for (i <- arr) {\n                var j = i\n               \
    \ while (j != 0) {\n                    sum += j%10\n                    j /=\
    \ 10\n                }\n            }\n            if (sum > 0) 1\n         \
    \   else 0\n        }", "        def sign(x : Long) : Long = {\n            if\
    \ (x < 0) -1\n            else 1\n        }\n        def sumDigits(x : Long) :\
    \ Long = {\n            if (x == 0) 0\n            else sign(x) * (x % 10) + sumDigits(x\
    \ / 10)\n        }\n        def isSign(x : Long) : Boolean = {\n            if\
    \ (sumDigits(x) > 0) true\n            else false\n        }\n        arr.filter(isSign(_)).length",
  "        arr.filter(n => {\n            if (n < 0) n = -n\n            var sum =\
    \ 0\n            while (n > 0) {\n                sum += n % 10\n            \
    \    n /= 10\n            }\n            sum > 0\n        }).length", "      \
    \  // Precondition: arr is a valid list of integers\n        def sumDigits(num\
    \ : Long) : Long = {\n            // Precondition: num is a valid integer\n  \
    \          val digitString = math.abs(num).toString\n            digitString.map(c\
    \ => c.asDigit).sum\n        }\n        arr.map(sumDigits).count(_ > 0)", "  \
    \      def sign(x : Long) : Long = if (x < 0) -1 else 1\n        def countNums2(arr\
    \ : List[Long], acc : Long) : Long = {\n            if (arr.isEmpty) acc\n   \
    \         else {\n                val h = arr.head\n                val d = sign(h)\
    \ * h.toString.map(x => x.asDigit).sum\n                if (d > 0) countNums2(arr.tail,\
    \ acc + 1)\n                else countNums2(arr.tail, acc)\n            }\n  \
    \      }\n        countNums2(arr, 0)", "    \tif (arr.isEmpty) 0l\n    \telse\
    \ if (arr.head.toString.split(\"\").map(_.toLong).sum > 0) 1l + countNums(arr.tail)\n\
    \    \telse countNums(arr.tail)", '        arr.filter(getDigitSum(_) > 0).length',
  "    \tval cnt = arr.foldLeft(0l)((acc, x) => {\n    \t\tacc + (if (x < 0l) 1l else\
    \ 0l) + x.abs.toString.map(_.asDigit).sum\n    \t})\n    \tcnt", "        def\
    \ getCount(num : Long) : Long = {\n            val sign = if (num < 0) -1 else\
    \ 1\n            val absNum = abs(num)\n            var ds = List[Long]()\n  \
    \          var num2 = absNum\n            while (num2 > 0) {\n               \
    \ ds = (num2 % 10) :: ds\n                num2 /= 10\n            }\n        \
    \    if (sign < 0) ds = (-ds.head) :: ds.tail\n            ds.sum\n        }\n\
    \        return arr.filter(n => getCount(n) > 0).length", "        var res = 0l\n\
    \        for (i <- arr) {\n            if (i < 0) {\n                var num =\
    \ -i\n                while (num > 0) {\n                    res += num % 10\n\
    \                    num /= 10\n                }\n                res += 1\n\
    \            } else {\n                var num = i\n                while (num\
    \ > 0) {\n                    res += num % 10\n                    num /= 10\n\
    \                }\n            }\n        }\n        res", "        arr.map(x\
    \ =>\n            if (x < 0) {\n                abs(x) % 10 + 1\n            }\
    \ else {\n                x % 10\n            }\n        ).filter(x => x != 0).size",
  "        var count = 0l\n        for (num <- arr) {\n            var sum = 0l\n\
    \            var n = num\n            if (n < 0) n = -n\n            while (n\
    \ > 0) {\n                sum += n % 10\n                n /= 10\n           \
    \ }\n            if (sum > 0) count += 1\n        }\n        count", "       \
    \ // Fill up this function body\n        // You can add another function as well,\
    \ if required\n        val len = arr.length\n        var i = 0\n        var res\
    \ = 0\n        while (i < len) {\n            val num = abs(arr(i))\n        \
    \    val len2 = num.toString.length\n            var j = 0\n            var temp\
    \ = 0\n            while (j < len2) {\n                temp += num.toString.charAt(j).asDigit\n\
    \                j += 1\n            }\n            if (temp > 0) res += 1\n \
    \           i += 1\n        }\n        res", "        def sumDigits(num : Long)\
    \ : Long = {\n            var sum = 0l\n            val numAbs = abs(num)\n  \
    \          var i = numAbs\n            while (i > 0) {\n                sum +=\
    \ i % 10\n                i /= 10\n            }\n            if (num < 0) return\
    \ -sum\n            return sum\n        }\n        var count = 0l\n        for\
    \ (num <- arr) {\n            if (sumDigits(num) > 0) count += 1\n        }\n\
    \        return count", "        val ans = new ListBuffer[Long]()\n        val\
    \ arr_positive = arr.filter(x => x > 0)\n        val arr_negative = arr.filter(x\
    \ => x < 0)\n        for (a <- arr_positive) {\n            val digits = a.toString.toCharArray.map(x\
    \ => x.toLong - 48)\n            val digits_sum = digits.sum\n            if (digits_sum\
    \ > 0) ans += a\n        }\n        for (a <- arr_negative) {\n            val\
    \ digits = a.toString.toCharArray.map(x => x.toLong - 48)\n            val digits_sum\
    \ = digits.sum\n            if (digits_sum < 0) ans += a\n        }\n        ans.length",
  "        var count = 0l\n        for (i <- arr) {\n            var sum = 0l\n  \
    \          var num = i\n            while (num != 0) {\n                sum +=\
    \ (num % 10).abs\n                num /= 10\n            }\n            if (sum\
    \ > 0) count += 1\n        }\n        count", "        var sum : Long = 0\n  \
    \      arr.foreach(x => sum += signum(x) * (x.abs % 10))\n        sum", "    \
    \    def countNums0(n : Long) : Long = {\n            if (n < 0) {\n         \
    \       -(((n + 1) % 10) + 1) + countNums0((n + 1) / 10)\n            } else {\n\
    \                (n % 10) + countNums0(n / 10)\n            }\n        }\n   \
    \     arr.map(countNums0(_)).filter(_ > 0).length", "        // if (arr.length\
    \ == 0) {\n        //     return 0l\n        // }\n        // if (arr.last < 0)\
    \ {\n        //     return 1l + countNums(arr.init)\n        // }\n        //\
    \ if (arr.last == 0) {\n        //     return 0l + countNums(arr.init)\n     \
    \   // }\n        // if (arr.last > 0) {\n        //     return 1l + countNums(arr.init)\n\
    \        // }\n        // return 0l\n        arr.count(x => x > 0)", '        return
    arr.map(x => if (x < 0) -1 else 1).scanLeft(0)(_ + _).count(_ != 0)', "      \
    \  def helper(sum : Long, arr : List[Long]) : Long = {\n            arr match\
    \ {\n                case Nil => 0\n                case x :: xs => if (x.abs.toString.map(x\
    \ => x.asDigit).sum > 0) helper(x, xs) + 1 else helper(x, xs)\n            }\n\
    \        }\n        arr match {\n            case Nil => 0\n            case x\
    \ :: xs => helper(x, xs)\n        }", "        def signedDigits(n : Long) : List[Long]\
    \ = {\n            if (n == 0) List(0)\n            else {\n                val\
    \ q = n / 10\n                val r = n % 10\n                if (q < 0) r ::\
    \ signedDigits(q)\n                else signedDigits(q) :+ r\n            }\n\
    \        }\n        def hasNonZeroSumDigits(n : Long) : Boolean = {\n        \
    \    signedDigits(n).sum > 0\n        }\n        arr.count(hasNonZeroSumDigits)",
  "        //println(arr)\n        var result = 0l\n        for (i <- arr) {\n   \
    \         var a = abs(i)\n            var sum = 0l\n            while (a > 0)\
    \ {\n                sum += a % 10\n                a /= 10\n            }\n \
    \           if (sum > 0) result += 1\n        }\n        result", "        val\
    \ digits = arr.map(a => {\n            var s = a.toString\n            if (s.length\
    \ > 1 && s.charAt(0) == '-') {\n                s = s.substring(1)\n         \
    \   }\n            s.map(c => c.asDigit).sum\n        })\n        digits.filter(d\
    \ => d > 0).length", '        arr.count(i => abs(i).toString.map(_.asDigit).sum
    > 0)', "        val map = HashMap[Long, Int]()\n        var ans = 0\n        arr.foreach(x\
    \ => {\n            if (x < 0) {\n                val res = -x\n             \
    \   map(res) = map.getOrElse(res, 0) + 1\n            } else {\n             \
    \   map(x) = map.getOrElse(x, 0) + 1\n            }\n        })\n        map.foreach(x\
    \ => {\n            val (n, cnt) = x\n            val digits = n.toString.map(x\
    \ => x.asDigit).sum\n            if (digits > 0) ans += cnt\n        })\n    \
    \    ans", "    \tdef countNums0(sum : Long, sum2 : Long, num : Long) : Long =\
    \ {\n    \t\tif (num != 0) countNums0(sum + (num % 10), sum2, num / 10)\n    \t\
    \telse sum2 + (if (sum > 0) 1 else 0)\n    \t}\n    \tval l = arr.filter(_ > 0).map(countNums0(0,\
    \ 0, _)).filter(_ > 0).length\n    \tl", "        // I'm going to keep two lists.\
    \ The first list, nums, stores the numbers\n        // directly. The second list,\
    \ numsLengths, is an integer sequence\n        // which stores the lengths of\
    \ numbers in nums. It's useful to have\n        // this because it saves us from\
    \ having to repeatedly convert strings\n        // back to longs.\n        var\
    \ nums : List[Long] = List[Long]()\n        var numsLengths : List[Int] = List[Int]()\n\
    \        // We also have a long variable, largestNumber, which keeps track of\n\
    \        // the largest number in nums. We also have another long variable,\n\
    \        // numDigits, which stores the number of digits in largestNumber.\n \
    \       var largestNumber : Long = 0\n        var numDigits : Long = 0\n     \
    \   for (i <- 0 until arr.length) {\n            if (arr(i) != 0) {\n        \
    \        // We only have to do work if the number is nonzero.\n              \
    \  // See if the number is positive or negative.\n                if (arr(i) >\
    \ 0) {\n                    // The number is positive.\n                    //\
    \ We can simply add the number to nums.\n                    nums = nums :+ arr(i)\n\
    \                    numsLengths = numsLengths :+ arr(i).toString.length\n   \
    \                 if (arr(i) > largestNumber) {\n                        largestNumber\
    \ = arr(i)\n                        numDigits = largestNumber.toString.length\n\
    \                    }\n                } else {\n                    // The number\
    \ is negative.\n                    // We will have to do work.\n            \
    \        // We need to convert arr(i) to a string, then extract the\n        \
    \            // first digit of the string. This first digit will be\n        \
    \            // used to construct the number.\n                    val numAsString\
    \ : String = arr(i).toString\n                    val firstDigit = numAsString.substring(1,\
    \ 2).toLong\n                    // Now we want to find the first two digits of\
    \ the number.\n                    // We also want to find the sign of the number.\
    \ We do this\n                    // by finding the sign of firstDigit.\n    \
    \                val firstTwoDigits : Long = \n                        (if (firstDigit\
    \ > 0) {\n                            10", "        if (arr.length == 0) 0 else\
    \ {\n            val (sum, count) = arr.foldLeft((0, 0))((a, b) => {\n       \
    \         val sum = a._1 + b.abs.toString.foldLeft(0)((a, b) => a + b.asDigit)\n\
    \                if (sum > 0) (0, a._2 + 1) else (sum, a._2)\n            })\n\
    \            if (sum > 0) count + 1 else count\n        }", "        var result\
    \ : Long = 0\n        arr.foreach(x => result += if(x.toString.map(c => c.asDigit).sum\
    \ > 0) 1 else 0)\n        result", "    \treturn 0l;", "        val numbers =\
    \ arr.filter(_ > 0).toSet\n        val sums = numbers.map(_.toString.split(\"\"\
    ).map(_.toLong).sum)\n        val res = for {\n            number <- numbers\n\
    \            (sign, digits) = if (number > 0) (1, number.toString.split(\"\").map(_.toLong))\
    \ else (-1, number.toString.split(\"\").map(_.toLong).tail)\n            if sign\
    \ * digits.sum > 0\n        } yield number\n        res.size", "        var count\
    \ = 0l\n        for (i <- arr) {\n            if (i < 0) count += (i.toString.length\
    \ - 1)\n            else count += i.toString.length\n        }\n        count",
  '        return arr.map(x => x.abs.toString.split("").map(x => x.toLong).sum).filter(x
    => x > 0).length', "        def sumSignedDigits(n : Long) : Long = {\n       \
    \     if (n == 0) 0\n            else sumSignedDigits(n / 10) + n % 10\n     \
    \   }\n        return arr.filter(n => sumSignedDigits(n) > 0).length", "     \
    \   def count(a : Long) : Int = {\n            if (a < 0) a.toString.substring(1).map(x\
    \ => x.asDigit).sum\n            else a.toString.map(x => x.asDigit).sum\n   \
    \     }\n        arr.filter(x => count(x) > 0).length", "        def sumOfDigits(n\
    \ : Long) : Long = n.toString.map(_.asDigit).sum\n        arr.filter(sumOfDigits(_)\
    \ > 0).length", "        val sum = (arr.length).toLong\n        var count = 0\n\
    \        var i = 0\n        while (i < sum) {\n            var temp = arr(i).toString\n\
    \            var sum = 0\n            var j = 0\n            while (j < temp.length)\
    \ {\n                sum += temp(j).asDigit\n                j += 1\n        \
    \    }\n            if (sum != 0) {\n                count += 1\n            }\n\
    \            i += 1\n        }\n        count", "        def signedDigits(num\
    \ : Long) : Long = {\n            def signedDigits0(num : Long, acc : Long) :\
    \ Long = {\n                num match {\n                    case 0 => acc\n \
    \                   case _ => signedDigits0(num / 10, acc + num % 10)\n      \
    \          }\n            }\n            if (num < 0) num + signedDigits0(-num,\
    \ 0) else signedDigits0(num, 0)\n        }\n        arr.filter(x => signedDigits(x)\
    \ > 0).length", "        var sum = 0l\n        for (i <- arr) {\n            var\
    \ v = i\n            if (v < 0) v = -v\n            var r = 0l\n            while\
    \ (v > 0) {\n                r += v % 10\n                v /= 10\n          \
    \  }\n            if (r > 0) sum += 1\n        }\n        sum", "        // Recursive\
    \ function to find the sum of digits of a number\n        def digitSum(n : Long)\
    \ : Long = {\n            if (n < 0) return -digitSum(-n)\n            if (n <\
    \ 10) return n\n            return n % 10 + digitSum(n / 10)\n        }\n    \
    \    var count = 0l\n        for (a <- arr) if (digitSum(a) > 0) count += 1\n\
    \        return count", '        arr.filter(x => Math.abs(x).toString.map(_.asDigit).sum
    > 0).size', '        arr.filter(n => if (n < 0) sumDigits(n * -1) > 0 else sumDigits(n)
    > 0).length', "        // Fill up this function body\n        // You can add another\
    \ function as well, if required\n        val list = new ListBuffer[Long]\n   \
    \     val list1 = new ListBuffer[Int]\n        val list2 = new ListBuffer[Long]\n\
    \        var sum = 0\n        var count = 0\n        var num = 0\n        for(i\
    \ <- 0 until arr.length) {\n            num = arr(i).toString.toList.map(_.asDigit).sum\n\
    \            sum = num.abs\n            list1 += sum\n        }\n        for(i\
    \ <- 0 until list1.length) {\n            if(list1(i) == 0) {\n              \
    \  list2 += arr(i)\n            }\n        }\n        for(i <- 0 until list2.length)\
    \ {\n            for(j <- 0 until arr.length) {\n                if(list2(i) ==\
    \ arr(j)) {\n                    arr.drop(j)\n                }\n            }\n\
    \        }\n        arr.length", "        def f(n : Long) : Long = {\n       \
    \     if (n < 0) return f(-n)\n            var sum = 0l\n            var nn =\
    \ n\n            while (nn > 0) {\n                sum += nn % 10\n          \
    \      nn /= 10\n            }\n            return sum\n        }\n        arr.map(n\
    \ => f(n)).filter(n => n > 0).length", "      def sumOfDigits(x : Long) : Long\
    \ = {\n        if (x == 0) 0\n        else {\n          val signedDigit = x %\
    \ 10\n          signedDigit + sumOfDigits(x / 10)\n        }\n      }\n      def\
    \ solve(n : Int, l : List[Long]) : Long = {\n        if (n == l.length) 0\n  \
    \      else {\n          if (sumOfDigits(l(n)) > 0) 1 + solve(n + 1, l)\n    \
    \      else solve(n + 1, l)\n        }\n      }\n      solve(0, arr)", "     \
    \   var count = 0l\n        for (v <- arr) {\n            var x = 0l\n       \
    \     var w = if (v < 0) -v else v\n            while (w > 0) {\n            \
    \    x += w % 10\n                w /= 10\n            }\n            if (x >\
    \ 0) count += 1\n        }\n        count", '        arr.filter(_.toString.map(_.asDigit).sum
    > 0).size', "      var sum : Long = 0\n      for (i <- arr) {\n        if (i >\
    \ 0) sum += i\n        else {\n          var s = i.toString\n          var num\
    \ : Long = 0\n          for (c <- s) {\n            if (c != '-') num += (c -\
    \ '0')\n          }\n          if (num > 0) sum += 1\n        }\n      }\n   \
    \   sum", "        var count = 0l\n        for (num <- arr) {\n            if\
    \ (num >= 0) {\n                if (num.toString.split(\"\").toList.map(s => s.toLong).sum\
    \ > 0) count += 1\n            } else {\n                if (num.toString.split(\"\
    \").toList.map(s => s.toLong).tail.sum > 0) count += 1\n            }\n      \
    \  }\n        count", "        var count = 0l\n        for (i <- arr) {\n    \
    \        if (i < 0) {\n                var dig = -(i % 10)\n                i\
    \ /= 10\n                dig += abs(i)\n                if (dig > 0) count +=\
    \ 1\n            } else {\n                var dig = 0\n                while\
    \ (i > 0) {\n                    dig += i % 10\n                    i /= 10\n\
    \                }\n                if (dig > 0) count += 1\n            }\n \
    \       }\n        count", "        var l = List[Int]()\n        for (i <- arr)\
    \ {\n            var sum = 0\n            var t = abs(i)\n            while (t\
    \ > 0) {\n                sum += t % 10\n                t /= 10\n           \
    \ }\n            l = l :+ sum\n        }\n        return l.filter(x => x > 0).length",
  "        val l = arr.map(abs).map(_.toString.map(_.asDigit.toLong).sum).filter(_\
    \ > 0)\n        l.size", "        // recursive solution\n        def countNumsRec(arr\
    \ : List[Long], count : Long) : Long = {\n            if (arr.isEmpty) count\n\
    \            else {\n                val n = arr.head\n                if (n >=\
    \ 0) countNumsRec(arr.tail, count + 1)\n                else countNumsRec(arr.tail,\
    \ count)\n            }\n        }\n        countNumsRec(arr, 0)", "    \tdef\
    \ positiveSum(l : List[Long]) : Boolean = {\n    \t\tl.map(abs(_)).map(_.toString).map(_.map(_.asDigit).sum).sum\
    \ > 0\n    \t}\n    \tarr.filter(positiveSum(_)).length", "        var count =\
    \ 0l\n        for (num <- arr) {\n            var sum = 0l\n            var x\
    \ = 0l\n            if (num < 0) x = -num else x = num\n            while (x >\
    \ 0) {\n                sum += x % 10\n                x /= 10\n            }\n\
    \            if (sum > 0) count += 1\n        }\n        return count", "    \
    \    def sumDigits(x : Long) : Long = {\n            if (x == 0) 0 else (x % 10)\
    \ + sumDigits(x / 10)\n        }\n        arr.map(x => if (sumDigits(x) > 0) 1\
    \ else 0).sum", "    \t// Fill Up this function body\n                // `0` is\
    \ a valid candidate\n                return arr.filter(x => x.toString.map(x =>\
    \ abs(x - '0')).sum > 0).size", "        if (arr.length == 0) return 0\n     \
    \   var sum = 0l\n        var last = 0l\n        for (i <- 0 until arr.length)\
    \ {\n            last = arr(i)\n            if (last < 0) last = -last\n     \
    \       while (last > 0) {\n                sum += last % 10\n               \
    \ last /= 10\n            }\n        }\n        sum", "        def signDigits(n\
    \ : Long) : Long = {\n            if (n == 0) 0\n            else abs(n % 10)\
    \ + signDigits(n / 10)\n        }\n        (for (a <- arr) yield if (signDigits(a)\
    \ == 0) 0 else 1).sum", '        arr.map(abs(_)).map(x => x.toString.split("").map(_.toLong).sum).count(_
    > 0)', '        return arr.map(math.abs(_)).map(_.toString.map(_.asDigit).sum).filter(_
    != 0).length', "        def getSign(x : Long) : Long = if (x < 0) -1 else 1\n\
    \        def countNumsHelper(x : Long) : Long = {\n            var count = 0l\n\
    \            for (c <- x.toString) count += (c - '0')\n            count\n   \
    \     }\n        var count = 0l\n        for (x <- arr) if (countNumsHelper(getSign(x)\
    \ * x) > 0) count += 1\n        count", "        def abs(x : Long) : Long = if\
    \ (x >= 0) x else -x\n        def signedDigits(x : Long) : List[Long] = {\n  \
    \          if (x == 0) Nil\n            else if (x > 0) signedDigits(x / 10) :+\
    \ (x % 10)\n            else signedDigits(-x / 10) :+ (-x % 10)\n        }\n \
    \       def sum(arr : List[Long]) : Long = {\n            if (arr.length == 0)\
    \ 0\n            else if (arr.length == 1) arr(0)\n            else arr(0) + sum(arr.slice(1,\
    \ arr.length))\n        }\n        def signedSum(x : Long) : Long = {\n      \
    \      sum(signedDigits(x))\n        }\n        def countNumsRec(arr : List[Long],\
    \ result : Long) : Long = {\n            if (arr.length == 0) result\n       \
    \     else if (signedSum(arr(0)) > 0) countNumsRec(arr.slice(1, arr.length), result\
    \ + 1)\n            else countNumsRec(arr.slice(1, arr.length), result)\n    \
    \    }\n        countNumsRec(arr, 0)", "        var c = 0l\n        for (i <-\
    \ arr) {\n            if (signedSum(i) > 0) c += 1\n        }\n        c", " \
    \       // Write your code here\n        if (arr.length == 0) return 0\n     \
    \   var res = 0\n        for (i <- 0 until arr.length) {\n            var temp\
    \ = arr(i)\n            var total = 0\n            if (temp < 0) temp = -temp\n\
    \            while (temp > 0) {\n                total += temp % 10\n        \
    \        temp /= 10\n            }\n            if (total > 0) res += 1\n    \
    \    }\n        return res", "        var res = 0\n        for (i <- arr) {\n\
    \            var sum = 0\n            for (j <- i.toString.toList) sum += j.toString.toInt\n\
    \            if (sum != 0) res += 1\n        }\n        res", "        var count\
    \ = 0l\n        for (i <- arr) {\n            if (i < 0) count += abs(i).toString.sum\
    \ - 48\n            else count += i.toString.sum\n        }\n        return count",
  '        0', '        arr.filter(x => (x.toString.map(x => abs(x.asDigit)).sum >
    0)).length', "        var count = 0\n        for (i <- arr) {\n            if\
    \ (abs(i) % 10 > 0) {\n                count += 1\n            }\n        }\n\
    \        return count", '        arr.filter(x => x.toString.foldLeft(0)((acc,
    x) => acc + x.asDigit)).length', "        def isSigned(n : Long) : Boolean = if\
    \ (n < 0) true else false\n        def countSignedDigits(n : Long) : Long = {\n\
    \            def countSignedDigits(n : Long, acc : Long) : Long = {\n        \
    \        if (n == 0) acc\n                else countSignedDigits(n / 10, acc +\
    \ abs(n % 10))\n            }\n            if (isSigned(n)) countSignedDigits(n\
    \ / 10, 1) + abs(n % 10)\n            else countSignedDigits(n, 0)\n        }\n\
    \        def helper(arr : List[Long], acc : Long) : Long = {\n            if (arr.isEmpty)\
    \ acc\n            else helper(arr.tail, if (countSignedDigits(arr.head) > 0)\
    \ acc + 1 else acc)\n        }\n        helper(arr, 0)", "        var result :\
    \ Long = 0\n        arr.foreach(i => if (i >= 0) result += 1)\n        result",
  '        return arr.map(a => abs(a)).map(a => a.toString.map(c => c.asDigit.toLong).sum).filter(a
    => a > 0).size', "        def countNums0(arr : List[Long], res : Long) : Long\
    \ = {\n            if (arr.isEmpty) res\n            else {\n                val\
    \ cur : Long = arr.head\n                val curabs : Long = abs(cur)\n      \
    \          var sums : Long = 0\n                var curabs0 : Long = curabs\n\
    \                while (curabs0 > 0) {\n                    sums += curabs0 %\
    \ 10\n                    curabs0 /= 10\n                }\n                if\
    \ (sums != 0 && cur != 0) countNums0(arr.tail, res + 1)\n                else\
    \ countNums0(arr.tail, res)\n            }\n        }\n        countNums0(arr,\
    \ 0)", '        return -1', "        if (arr.length == 0) 0\n        else if (arr.head\
    \ != 0 && arr.head % 9 != 0) 1 + countNums(arr.tail)\n        else countNums(arr.tail)",
  '        arr.map((x) => if (x < 0) -1 * x else x).map((x) => math.abs(x % 10) +
    math.abs(x / 10)).filter((x) => x > 0).size', '        arr.map(i => i.toString.split("").map(j
    => j.toLong).reduceLeft(_ + _)).filter(i => i > 0).length', "        def sumDigits(n\
    \ : Long) : Long = {\n            var x = if (n < 0) -n else n\n            var\
    \ total = 0l\n            while (x > 0) {\n                total += x % 10\n \
    \               x /= 10\n            }\n            return total\n        }\n\
    \        return arr.filter(a => sumDigits(a) > 0).length", "        return arr.filter(x\
    \ =>\n            if (x > 0) {\n                x.toString.map(_.asDigit).sum\
    \ > 0\n            } else {\n                x.toString.map(_.asDigit).tail.sum\
    \ < 0\n            }\n        ).length", "        val negative = arr.filter(_\
    \ < 0).map(abs(_))\n        val positive = arr.filter(_ >= 0)\n        val sumDigits\
    \ = (x : Long) => x.toString.toCharArray.map(_.asDigit).sum\n        negative.map(sumDigits).sum\
    \ + positive.map(sumDigits).sum", "        def countNumsHelper(x : Long) : Long\
    \ = {\n            if (x == 0) 0 else x % 10 + countNumsHelper(x / 10)\n     \
    \   }\n        val sum = arr.foldLeft(0l)((res, cur) => {\n            val sign\
    \ = if (cur >= 0) 1 else -1\n            val sumDigits = sign * countNumsHelper(abs(cur))\n\
    \            if (sumDigits > 0) res + 1 else res\n        })\n        sum", " \
    \       var total : Long = 0l\n        for (n <- arr) {\n            var sum :\
    \ Long = 0l\n            var m : Long = n\n            while (m != 0) {\n    \
    \            sum += m % 10\n                m /= 10\n            }\n         \
    \   if (sum > 0) {\n                total += 1\n            }\n        }\n   \
    \     return total", "        val xs = arr\n        xs.filter(x => x % 10 != 0).count(_.toString.split(\"\
    \").map(_.toInt).sum > 0)", "        def getDigits(num : Long) : List[Long] =\
    \ {\n            def getDigitsInner(num : Long, digits : List[Long]) : List[Long]\
    \ = {\n                if (num == 0) digits else getDigitsInner(num / 10, (num\
    \ % 10) :: digits)\n            }\n            if (num < 0) (-num) :: getDigitsInner(-num,\
    \ List[Long]()) else getDigitsInner(num, List[Long]())\n        }\n        def\
    \ getSum(nums : List[Long]) : Long = {\n            def getSumInner(nums : List[Long],\
    \ sum : Long) : Long = {\n                if (nums.isEmpty) sum else getSumInner(nums.tail,\
    \ sum + nums.head)\n            }\n            getSumInner(nums, 0)\n        }\n\
    \        def getCount(nums : List[Long]) : Long = {\n            def getCountInner(nums\
    \ : List[Long], count : Long) : Long = {\n                if (nums.isEmpty) count\
    \ else {\n                    if (getSum(getDigits(nums.head)) > 0) getCountInner(nums.tail,\
    \ count + 1) else getCountInner(nums.tail, count)\n                }\n       \
    \     }\n            getCountInner(nums, 0)\n        }\n        getCount(arr)",
  "        def digsum(x : Long) : Long = {\n            var x0 = abs(x)\n        \
    \    var s = 0l\n            while (x0 > 0) {\n                s += x0 % 10\n\
    \                x0 /= 10\n            }\n            s\n        }\n        def\
    \ f(x : Long) : Long = if (digsum(x) > 0) 1 else 0\n        arr.map(f).sum", " \
    \       var count = 0l\n        for (num <- arr) {\n            if (num != 0l)\
    \ {\n                var sumDigits = 0l\n                var n = abs(num)\n  \
    \              while (n > 0) {\n                    sumDigits += n % 10\n    \
    \                n /= 10\n                }\n                if (sumDigits > 0)\
    \ count += 1\n            }\n        }\n        count", "        val numbers =\
    \ arr\n        var count : Long = 0l\n        for (n <- numbers) {\n         \
    \   var sum : Long = 0l\n            var _n : Long = n\n            if (_n < 0)\
    \ {\n                sum = -_n\n                _n = -_n\n            }\n    \
    \        while (_n != 0) {\n                sum += _n % 10\n                _n\
    \ /= 10\n            }\n            if (sum > 0) count += 1\n        }\n     \
    \   count", '        return arr.filter(x => x.toString.map(x => x.asDigit).sum
    > 0).length', "        var z = 0l\n        arr.foreach(x => z += (if (x < 0) x\
    \ * -1 else x).toString.map(_.asDigit).sum > 0)\n        z", '        arr.filter(x
    => x.toString.split("").map(_.toLong).sum > 0).size', '        arr.filter(x =>
    x.toString.map(x => abs(x.asDigit)).sum > 0).size', '        arr.map(x => abs(x).toString.map(_.asDigit).sum).count(_
    > 0)', "        // Write your code here\n        arr.map(x => abs(x)).map(x =>\
    \ x.toString().map(y => y.asDigit)).filter(x => x.sum > 0).size", '        arr.filter(x
    => x.toString.toCharArray.map(x => abs(x.toString.toLong)).sum > 0).length', " \
    \       //long Solution\n        def sum(n : Long) : Long = {\n            var\
    \ s = 0l\n            var num = if (n < 0) -n else n\n            while (num >\
    \ 0) {\n                s += num % 10\n                num /= 10\n           \
    \ }\n            return s\n        }\n        var count = 0l\n        for (num\
    \ <- arr) {\n            if (sum(num) > 0) {\n                count += 1\n   \
    \         }\n        }\n        return count", '        arr.filter(x => getDigitSum(x)
    > 0).length', "        def signedDigits(n : Long) : List[Long] = {\n         \
    \   def loop(n : Long, acc : List[Long]) : List[Long] = {\n                if\
    \ (n == 0) acc\n                else loop(n / 10, (n % 10) :: acc)\n         \
    \   }\n            if (n < 0) loop(-n, -1l :: Nil)\n            else loop(n, Nil)\n\
    \        }\n        var result = 0l\n        for (n <- arr) if (signedDigits(n).sum\
    \ > 0) result += 1\n        result", "        var count = 0l\n        for (i <-\
    \ arr) {\n            if (i >= 0) {\n                if (i.toString.split(\"\"\
    ).foldLeft(0l)((a,b) => a + b.toInt) > 0) count += 1\n            } else {\n \
    \               if (i.toString.split(\"\").tail.foldLeft(0l)((a,b) => a + b.toInt)\
    \ > 0) count += 1\n            }\n        }\n        count", "        def sumDigits(n\
    \ : Long) : Long = {\n            def loop(n : Long, res : Long) : Long = {\n\
    \                if (n == 0) res\n                else loop(n / 10, res + n %\
    \ 10)\n            }\n            loop(abs(n), 0)\n        }\n        arr.filter(x\
    \ => sumDigits(x) > 0).length", "        return arr.map(x => abs(x)).map(x =>\
    \ x.toString.map(x => (x - '0')).sum).filter(x => x > 0).length", "        def\
    \ sumDigits(num : Long) : Long = {\n            if (num == 0) return 0\n     \
    \       if (num < 0) return -num % 10 + sumDigits(-num / 10)\n            return\
    \ num % 10 + sumDigits(num / 10)\n        }\n        var sum = 0l\n        for\
    \ (n <- arr) {\n            if (sumDigits(n) > 0) sum += 1\n        }\n      \
    \  return sum", "        def dsum(n : Long) : Long = {\n            var n1 = n.abs\n\
    \            var res = 0l\n            while (n1 > 0) {\n                res +=\
    \ n1 % 10\n                n1 /= 10\n            }\n            res\n        }\n\
    \        return arr.filter(x => dsum(x) > 0).length", "        // Fill up this\
    \ function body\n        // You can add another function as well, if required\n\
    \        return 0", '        arr.map(_.abs).map(_.toString.map(_.asDigit).sum).count(_
    > 0)', "        return (0l.toLong /: arr) {(count, x) => if (x.toString.foldLeft(0l.toLong)((z,\
    \ c) => z + (c - '0')).abs >= 1l.toLong) count + 1l.toLong else count}", "   \
    \     // Fill Up this function body\n        // `0` is the only number whose signed\
    \ digits sum is 0\n        arr.map(x => if (x == 0) 0 else abs(x)).map(x => x.toString.map(_.asDigit).sum).filter(_\
    \ > 0).length", "        var count = 0l\n        for (i <- arr) {\n          \
    \  var sum = 0l\n            var l = i\n            if (l < 0) l = -l\n      \
    \      while (l > 0) {\n                sum += l % 10\n                l /= 10\n\
    \            }\n            if (sum > 0) count += 1\n        }\n        count",
  "        // Write your code here\n        arr.filter(x => x.toString.map(x => x.asDigit).sum\
    \ > 0).size", "        def sumDigits(n : Long) : Long = {\n            if (n ==\
    \ 0) 0\n            else n % 10 + sumDigits(n / 10)\n        }\n        arr.filter(sumDigits(_)\
    \ > 0).length", "        var sum = 0l\n        for (num <- arr) {\n          \
    \  val digits = math.abs(num).toString.map(_.asDigit)\n            if (digits.sum\
    \ > 0) sum += 1\n        }\n        sum", "        def sumDigits(x : Long) : Long\
    \ = (if (x < 0) -x else x).toString.map(_.asDigit.toLong).sum\n        arr.map(sumDigits).filter(_\
    \ > 0).size", "        def countNumsRec(current : Long, result : Long, arr : List[Long])\
    \ : Long = {\n            if (arr.length == 0) result\n            else {\n  \
    \              if (abs(current % 10) + abs(current / 10) > 0) {\n            \
    \        countNumsRec(arr.head, result + 1, arr.tail)\n                }\n   \
    \             else {\n                    countNumsRec(arr.head, result, arr.tail)\n\
    \                }\n            }\n        }\n        countNumsRec(arr.head, 0,\
    \ arr.tail)", "        var cnt = 0l\n        for (x <- arr) {\n            var\
    \ k = 0l\n            if (x < 0) k = -x\n            else k = x\n            while\
    \ (k > 0) {\n                cnt += k % 10\n                k /= 10\n        \
    \    }\n        }\n        cnt", '        arr.filter(x => if (x < 0) sumDigits(x).toLong
    * -1 else sumDigits(x)).size', '        arr.filter(x => x.toString.toList.map(x
    => x.toString.toInt).sum > 0).length', "        var count = 0l\n        for (i\
    \ <- arr) {\n            if (i > 0) {\n                var temp = i\n        \
    \        var sum = 0\n                while (temp > 0) {\n                   \
    \ sum += temp % 10\n                    temp /= 10\n                }\n      \
    \          if (sum > 0) count += 1\n            } else {\n                var\
    \ temp = -i\n                var sum = -1\n                while (temp > 0) {\n\
    \                    sum += temp % 10\n                    temp /= 10\n      \
    \          }\n                if (sum > 0) count += 1\n            }\n       \
    \ }\n        return count", "        val total = Array(0l, 0l, 0l, 0l, 0l, 0l,\
    \ 0l, 0l, 0l, 0l)\n        for (i <- 0 until arr.length) {\n            for (j\
    \ <- arr(i).toString) {\n                total(j.toString.toInt - 48) += 1\n \
    \           }\n        }\n        total.max", "        def countNums0(arr : List[Long],\
    \ dic : HashMap[Long, Long]) : Long = {\n            if (arr.isEmpty) dic.size\n\
    \            else {\n                val head = arr.head\n                val\
    \ sum = (head * signum(head)).toString.toList.map(_.asDigit).sum\n           \
    \     if (dic.contains(sum)) countNums0(arr.tail, dic)\n                else countNums0(arr.tail,\
    \ dic += (sum -> 0))\n            }\n        }\n        countNums0(arr, HashMap[Long,\
    \ Long]())", "        // Implement this function\n        return 0l;", '        return
    arr.filter(x => x < 0 || x.toString.map(_.asDigit).sum > 0).length', "       \
    \ def sumDigits(x : Long) : Long = {\n            if (x < 0) return sumDigits(-x)\n\
    \            if (x < 10) return x\n            else return x % 10 + sumDigits(x\
    \ / 10)\n        }\n        return arr.filter(x => sumDigits(x) > 0).length",
  "        // your code here\n        arr.count(x => x.toString.map(_.asDigit).sum\
    \ != 0)", '        arr.map(abs(_)).map(_.toString.map(_.asDigit).sum).filter(_
    > 0).length', "        def func(item : Long) : Long = {\n            if (item\
    \ < 0) func(abs(item)) else item.toString.toCharArray.map(i => i.toString.toLong).sum\n\
    \        }\n        arr.map(i => func(i)).filter(i => i > 0).length", "      \
    \  def sumDigits(n : Long) : Long = {\n            def go(n : Long, acc : Long)\
    \ : Long = {\n                if (n < 0) go(-n, acc)\n                else if\
    \ (n == 0) acc\n                else go(n / 10, acc + n % 10)\n            }\n\
    \            go(n, 0)\n        }\n        arr.map(sumDigits(_)).count(_ > 0)",
  "\t\tval res = arr.filter(x => {\n\t\t\tval s = x.toString\n\t\t\tvar sum = 0\n\t\
    \t\tfor (c <- s) {\n\t\t\t\tval n = c.toString.toInt\n\t\t\t\tsum += n\n\t\t\t\
    }\n\t\t\tif (sum != 0) true else false\n\t\t})\n\t\tres.length", "        var\
    \ result : Long = 0l\n        for (num <- arr) {\n            val sum : Long =\
    \ sumDigits(num)\n            if (sum > 0) result += 1\n        }\n        return\
    \ result", '        arr.map(x => if (x < 0) -x else x).map(x => x.toString.map(x
    => x.asDigit).sum).count(x => x > 0)', "        // This solution will be O(n*k)\
    \ where n is the length of the array and k is the\n        // length of the longest\
    \ number in the array (for signed numbers the longest number\n        // is just\
    \ the max value of a signed long because that number is the most difficult\n \
    \       // to find the sum of digits).\n        // Since this solution is slow,\
    \ we can accelerate it by realizing that the numbers\n        // do not change\
    \ at all. We can use some kind of hash table or lookup table which\n        //\
    \ maps numbers to their sum of digits. If we can find the sum of digits for a\
    \ number\n        // really fast then we can use this technique to speed up the\
    \ overall algorithm.\n        arr.filter((x : Long) => x.toString.split(\"\").map((y\
    \ : String) => y.toLong).sum > 0).length.toLong", "        var count = 0\n   \
    \     arr.foreach(x => if (x.toString.length > 1) {\n        \tvar sum = 0\n \
    \       \tx.toString.foreach(d => if (d != '-') sum += d.asDigit)\n        \t\
    if (sum > 0) count += 1\n        })\n        count", "        // \n        //\
    \ Complete this function.\n        //\n        var s = List[Long]()\n        for\
    \ (i <- arr) {\n            var n = 0l\n            var p = i\n            if\
    \ (p < 0) {\n                p = abs(p)\n                n += abs(p % 10)\n  \
    \              p /= 10\n            }\n            while (p > 0) {\n         \
    \       n += p % 10\n                p /= 10\n            }\n            s = n\
    \ :: s\n        }\n        var count = 0l\n        for (i <- s) {\n          \
    \  if (i > 0) count += 1\n        }\n        count", "        def getSumOfDigits(x\
    \ : Long) : Long = x match {\n            case x if x > 0 => x.toString.map(_.asDigit).sum\n\
    \            case x if x < 0 => -(x.toString.tail.map(_.asDigit).sum)\n      \
    \      case _ => 0\n        }\n        arr.filter(getSumOfDigits(_) > 0).length",
  "        var answer : Long = 0\n        for (i <- arr) {\n            var num =\
    \ i\n            var sum = 0\n            if (num < 0) num = -num\n          \
    \  while (num > 0) {\n                sum += num % 10\n                num /=\
    \ 10\n            }\n            if (sum > 0) answer += 1\n        }\n       \
    \ return answer", "        def countDigits(n : Long) : Long = n match {\n    \
    \        case n if n < 0 => n + 1\n            case 0 => 0\n            case _\
    \ => countDigits(n / 10) + n % 10\n        }\n        arr.filter(x => countDigits(x)\
    \ > 0).length", "    \t// Fill Up this function body\n        // `arr` is a list\
    \ of integers\n        // `return` the number of elements which has a sum of digits\
    \ > 0\n        var num = 0l\n        for (a <- arr) {\n            var n = a\n\
    \            var sum = 0l\n            if (n < 0) {\n                n = -n\n\
    \                sum = n % 10\n                n /= 10\n            }\n      \
    \      while (n > 0) {\n                sum += n % 10\n                n /= 10\n\
    \            }\n            if (sum > 0) num += 1\n        }\n        num", " \
    \       // println(arr.toString)\n        arr.map(x => x.toString.toList.map(y\
    \ => y.toString.toInt).sum).count(x => x > 0)", '        0', "      val ds = new\
    \ DigitSum();\n      val ret = (0 until arr.length).map(i => {\n        if (arr(i)\
    \ >= 0) ds.solve(arr(i))\n        else ds.solve(-arr(i))\n      }).map(i => if\
    \ (i > 0) 1 else 0).reduceLeft(_ + _)\n      ret", "        val n = arr.length;\n\
    \        val cnt = Array.fill(10)(0l);\n        for (num <- arr) {\n         \
    \   var x = 0;\n            val v = abs(num);\n            while (v > 0) {\n \
    \               x += v % 10;\n                v /= 10;\n            }\n      \
    \      cnt(x) += 1;\n        }\n        var ans = 0l;\n        for (i <- 0 until\
    \ 10) {\n            ans += (cnt(i) * (cnt(i) - 1)) / 2;\n        }\n        ans;",
  "        def digitsum(n : Long) : Long = {\n            var s = 0l\n           \
    \ var n1 = n\n            if (n < 0) n1 = -n\n            while (n1 > 0) {\n \
    \               s += n1 % 10\n                n1 /= 10\n            }\n      \
    \      return s\n        }\n        return arr.map(digitsum(_)).filter(_ > 0).length",
  "    \tvar ret = 0l\n    \tfor (n <- arr) {\n    \t\tif (sumDigits(n) > 0) ret +=\
    \ 1\n    \t}\n    \tret", '        arr.count(x => if (x < 0) x.toString.drop(1).map(_.asDigit).sum
    + 1 else x.toString.map(_.asDigit).sum)', "        var count = 0l\n        for\
    \ (num <- arr) {\n            var sum = 0l\n            var current = abs(num)\n\
    \            while (current > 0) {\n                sum += current % 10\n    \
    \            current /= 10\n            }\n            if (sum > 0) count += 1\n\
    \        }\n        count", "        var count = 0\n        for (i <- arr) {\n\
    \            val sum = sumDigits(i)\n            if (sum > 0) count += 1\n   \
    \     }\n        count", "        def countNumsAcc(arr : List[Long], acc : Long)\
    \ : Long = {\n            if (arr.length == 0) acc\n            else if (abs(arr.head).toString.map(x\
    \ => x.asDigit).sum > 0) countNumsAcc(arr.tail, acc + 1)\n            else countNumsAcc(arr.tail,\
    \ acc)\n        }\n        countNumsAcc(arr, 0)", "        def countNums0(arr\
    \ : List[Long], count : Long) : Long = {\n            if (arr.isEmpty) count\n\
    \            else {\n                var digits = arr.head.abs.toString\n    \
    \            var sum = 0\n                for (i <- 0 until digits.length) {\n\
    \                    sum += digits(i).asDigit\n                }\n           \
    \     if (sum > 0) countNums0(arr.tail, count + 1)\n                else countNums0(arr.tail,\
    \ count)\n            }\n        }\n        countNums0(arr, 0)", "        var\
    \ count = 0l\n        for (n <- arr) {\n            val s = if (n < 0) -n else\
    \ n\n            var sum = 0l\n            while (s > 0) {\n                sum\
    \ += s % 10\n                s /= 10\n            }\n            if (sum > 0)\
    \ count += 1\n        }\n        count", '        return arr.count(i => ((i %
    10) + abs(i / 10) > 0))', '        arr.count(x => signedDigits(x).sum > 0)', " \
    \       def sumDigits(x : Long) : Long = {\n            if (x == 0) 0\n      \
    \      else x % 10 + sumDigits(x / 10)\n        }\n        arr.filter(sumDigits(_)\
    \ > 0).length", "        if (arr.isEmpty) return 0\n        val signedDigits =\
    \ arr.map(i => {\n            if (i < 0) i * -1\n            var num = i\n   \
    \         var digits = List[Long]()\n            while (num > 0) {\n         \
    \       digits = (num % 10) :: digits\n                num /= 10\n           \
    \ }\n            digits\n        })\n        val digits = signedDigits.map(i =>\
    \ i.reduce(_ + _))\n        digits.count(i => i > 0)", '        arr.filter(x =>
    (x < 0 && x.toString.tail.map(_.asDigit).sum > 0) || (x >= 0 && x.toString.map(_.asDigit).sum
    > 0)).length', '        arr.map(x => (if (x >= 0) x else -x).toString.map(_.asDigit).sum).count(_
    > 0)', "        def helper(i : Long) : Long = {\n            if (i == 0) 0\n \
    \           else {\n                val dig = (i % 10).abs\n                dig\
    \ + helper(i / 10)\n            }\n        }\n        arr.filter(i => helper(i)\
    \ > 0).length", "        def digits(num : Long) : List[Long] = {\n           \
    \ if (num > 0) digits(num / 10) :+ (num % 10)\n            else List[Long]()\n\
    \        }\n        def digitSum(num : Long) : Long = {\n            digits(num).foldLeft(0l)((sum,\
    \ digit) => sum + digit)\n        }\n        arr.filter(digitSum(_) > 0).size",
  "        var count = 0\n        for (num <- arr) {\n            var digitSum = 0\n\
    \            if (num < 0) {\n                digitSum += num * -1\n          \
    \  } else {\n                digitSum += num\n            }\n            if (digitSum\
    \ > 0) {\n                count += 1\n            }\n        }\n        return\
    \ count", "        def countDigits(x : Long) : Long = {\n            var y = x\n\
    \            var count = 0l\n            while (y != 0) {\n                count\
    \ += abs(y % 10)\n                y /= 10\n            }\n            count\n\
    \        }\n        arr.map(countDigits(_)).filter(_ > 0).length", "        //\
    \ Define a helper method to convert a long to a list of signed digits.\n     \
    \   def toSignedDigits(n : Long) : List[Long] = {\n            if (n == 0) List[Long]()\n\
    \            else {\n                if (n > 0) toSignedDigits(n / 10) :+ (n %\
    \ 10)\n                else -toSignedDigits(-n / 10) :+ -(n % 10)\n          \
    \  }\n        }\n        // Use the helper method to convert to a list of signed\
    \ digits and \n        // calculate the sum of the signed digits.\n        arr.filter(n\
    \ => toSignedDigits(n).foldLeft(0L)(_ + _) > 0).size", '        arr.filter(x =>
    sumDigits(x) > 0).length', "        var sum = BigInt(0)\n        for (i <- arr)\
    \ {\n            sum += BigInt(i.abs).toString.map(_.asDigit).sum\n        }\n\
    \        sum.toLong"]
stop_tokens:
- "\n    }\n"
