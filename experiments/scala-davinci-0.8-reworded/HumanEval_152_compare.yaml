name: HumanEval_152_compare
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // I think we all remember that feeling when the result of some long-awaited\n\
  \    // event is finally known. The feelings and thoughts you have at that moment\
  \ are\n    // definitely worth noting down and comparing.\n    // Your task is to\
  \ determine if a person correctly guessed the results of a number of matches.\n\
  \    // You are given two lists of scores and guesses of equal length, where each\
  \ index shows a match. \n    // Return a list of the same length denoting how far\
  \ off each guess was. If they have guessed correctly,\n    // the value is 0, and\
  \ if not, the value is the absolute difference between the guess and the score.\n\
  \    // example:\n    // >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 2l.toLong, -2l.toLong)))\n    // (List[Long](0l.toLong, 0l.toLong,\
  \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))\n    // >>> compare((List[Long](0l.toLong,\
  \ 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong,\
  \ 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))\n    // (List[Long](4l.toLong,\
  \ 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))\n    def compare(game\
  \ : List[Long], guess : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
  \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
  \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
completions: ['        game.zip(guess).map(t => abs(t._1 - t._2))', "        var ans\
    \ = new ListBuffer[Long]()\n        if (game.length != guess.length) {\n     \
    \       println(\"Error: game and guess are not the same length\")\n         \
    \   return List()\n        }\n        for (i <- 0 until game.length) {\n     \
    \       ans += abs(game(i) - guess(i))\n        }\n        return ans.toList",
  "        val result = ListBuffer[Long]()\n        for (i <- 0 until game.length)\
    \ {\n            result += abs(game(i) - guess(i))\n        }\n        result.toList",
  "      val result = new ArrayBuffer[Long]()\n      var i = 0\n      while (i < game.length)\
    \ {\n        result += abs(game(i) - guess(i))\n        i += 1\n      }\n    \
    \  result.toList", '        (game, guess).zipped.map(_ - _).map(abs(_))', '        return
    game.zip(guess).map(p => abs(p._1 - p._2))', "        // Fill in the function\
    \ here\n        return List[Long]()", '        game.zip(guess).map(i => abs(i._1
    - i._2))', "        // game and guess are equal length Lists\n        // we want\
    \ to return a List[Long] that shows how far off each guess was.\n        var result\
    \ = new ListBuffer[Long]()\n        for(i <- 0 until game.length) {\n        \
    \    var absValue = abs(game(i) - guess(i))\n            result += absValue\n\
    \        }\n        return result.toList", '        game.zip(guess).map(t => abs(t._1
    - t._2))', "        // Fill up this function body\n        // You have to return\
    \ a list of Long\n        val l = ArrayBuffer[Long]()\n        for (i <- 0 until\
    \ game.length) {\n        \tif (guess(i) < 0) l += abs(guess(i))\n        \telse\
    \ l += abs(game(i) - guess(i))\n        }\n        l.toList", "        var res\
    \ = List[Long]()\n        for (idx <- 0 until game.length) {\n            val\
    \ distance = abs(game(idx) - guess(idx))\n            res = res :+ distance\n\
    \        }\n        res", "        def compare(game : List[Long], guess : List[Long],\
    \ res : List[Long]) : List[Long] = game match {\n            case Nil => res\n\
    \            case x :: xs => {\n                val y = guess.head\n         \
    \       if (x == y) compare(xs, guess.tail, 0l :: res)\n                else compare(xs,\
    \ guess.tail, abs(x - y) :: res)\n            }\n        }\n        compare(game,\
    \ guess, Nil).reverse", "        if (game.length != guess.length) {\n        \
    \    throw new Exception(\"Invalid list length!\")\n        }\n        val res\
    \ = ListBuffer[Long]()\n        var i = 0\n        while (i < game.length) {\n\
    \            res += abs(game(i) - guess(i))\n            i += 1\n        }\n \
    \       res.toList", "        var result : List[Long] = List()\n        for (i\
    \ <- 0 until game.length) result = result :+ abs(game(i) - guess(i))\n       \
    \ result", "        var result : List[Long] = Nil\n        for (i <- 0 until game.length)\
    \ {\n            result = abs(game(i) - guess(i)) :: result\n        }\n     \
    \   result.reverse", "        var result : List[Long] = List()\n        for(i\
    \ <- 0 until game.length) result = result :+ abs(game(i) - guess(i))\n       \
    \ result", '        for (i <- 0 until game.length) yield abs(game(i) - guess(i))',
  "        def loop(game : List[Long], guess : List[Long], ret : List[Long]) : List[Long]\
    \ = (game, guess) match {\n            case (List(), List()) => ret\n        \
    \    case (h1 :: t1, h2 :: t2) => loop(t1, t2, ret :+ abs(h1 - h2))\n        }\n\
    \        loop(game, guess, List())", "      // complete the method here\n    \
    \  val r = game.zip(guess).map(x => abs(x._1 - x._2))\n      return r", "    \
    \    val result = ListBuffer[Long]()\n        for (i <- 0 until game.length) result\
    \ += abs(game(i) - guess(i))\n        result.toList", "        var result = new\
    \ ListBuffer[Long]()\n        for (i <- 0 until game.length) {\n            result\
    \ += abs(game(i) - guess(i))\n        }\n        result.toList", '        game.zip(guess).map(
    x => math.abs(x._1 - x._2))', "        var answer : List[Long] = List[Long]()\n\
    \        if (game.length == guess.length) {\n            for (i <- game.indices)\
    \ {\n                answer = answer :+ abs(game(i) - guess(i))\n            }\n\
    \        }\n        return answer", "        def compareRecursive(game : List[Long],\
    \ guess : List[Long], acc : List[Long]) : List[Long] = {\n            if (game.length\
    \ == 0) acc.reverse\n            else compareRecursive(game.tail, guess.tail,\
    \ (abs(game.head - guess.head) :: acc))\n        }\n        compareRecursive(game,\
    \ guess, List())", "        var result : List[Long] = List()\n        var i =\
    \ 0\n        while (i < game.length) {\n            result = result :+ (abs(game(i)\
    \ - guess(i)))\n            i += 1\n        }\n        return result", "     \
    \   var retval = new ListBuffer[Long]\n        for(i <- 0 until game.length) {\n\
    \            var diff = abs(game(i) - guess(i))\n            retval += diff\n\
    \        }\n        return retval.toList", "        var result = new ListBuffer[Long]()\n\
    \        for (i <- 0 until game.length) {\n            result += abs(game(i) -\
    \ guess(i))\n        }\n        result.toList", "        val a = for (i <- 0 until\
    \ game.length) yield {abs(game(i) - guess(i))}\n        a.toList", "        var\
    \ result = new ListBuffer[Long]\n        for(i <- 0 until game.length) {\n   \
    \         if(game(i) == guess(i)) result += 0l\n            else result += abs(game(i)\
    \ - guess(i))\n        }\n        result.toList", '        game.zip(guess).map(pair
    => Math.abs(pair._1 - pair._2))', "        if (game.length == 0) List[Long]()\n\
    \        else {\n            val g = game.head\n            val gs = guess.head\n\
    \            val diff = abs(g - gs)\n            List(diff) ::: compare(game.tail,\
    \ guess.tail)\n        }", "        var diffs : List[Long] = List[Long]()\n  \
    \      for (i <- 0 until game.length) {\n            diffs = diffs :+ abs(game(i)\
    \ - guess(i))\n        }\n        diffs", "        // write your code here\n \
    \       return List()", "        var result = List[Long]()\n        for (i <-\
    \ 0 until game.length) result ::= (abs(game(i) - guess(i)))\n        result.reverse",
  '        return game.zip(guess).map{case (a, b) => abs(a - b)}', "        if (game.length\
    \ != guess.length) {\n            throw new Exception(\"List lengths are not equal.\"\
    )\n        }\n        val result = ListBuffer[Long]()\n        for (i <- 0 until\
    \ game.length) {\n            result += abs(game(i) - guess(i))\n        }\n \
    \       result.toList", "        if (game.length != guess.length)\n          \
    \  throw new Exception(\"Invalid input\")\n        (game zip guess) map (i =>\
    \ abs(i._1 - i._2))", "        // Build a list of all match results where the\
    \ index is the match number and the value is the delta between\n        // what\
    \ the person predicted and what the result actually was.\n        game.zip(guess).map({\
    \ case (a, b) => (a - b).abs })", "      // >>> compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)))\n      // print(game)\n\
    \      // print(guess)\n      // List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong)\n      // game.zip(guess).map(e => abs(e._1 - e._2))\n\
    \      game.zip(guess).map{case (x, y) => abs(x - y)}", "        val diffs = new\
    \ Array[Long](game.length)\n        for (i <- 0 until game.length) {\n       \
    \     diffs(i) = math.abs(game(i) - guess(i))\n        }\n        diffs.toList",
  '        game.zip(guess).map(x => abs(x._1 - x._2))', "      var result = List[Long]()\n\
    \      val zip = game.zip(guess)\n      for (z <- zip) {\n        result = result\
    \ :+ abs(z._1 - z._2)\n      }\n      result", "    \tif (game.length == 0) Nil\n\
    \    \telse (game.head - guess.head).abs :: compare(game.tail, guess.tail)", " \
    \       // Write your code here\n        var list : List[Long] = List()\n    \
    \    for (i <- 0 until game.length) {\n            var l : Long = abs(game(i)\
    \ - guess(i))\n            list = list :+ l\n        }\n        return list",
  '        game.zip(guess).map(x => abs(x._1 - x._2))', '        (game, guess).zipped.map((x,
    y) => abs(x - y))', '        (game, guess).zipped.map((a, b) => Math.abs(a - b))',
  "        var scores = ListBuffer[Long]()\n        for (i <- 0 until game.length)\
    \ {\n            scores += abs(game(i) - guess(i))\n        }\n        scores.toList",
  "        // longs are passed to the function\n        return game.zip(guess).map{case\
    \ (a, b) => if (a == b) 0 else Math.abs(a - b)}", '        game.zip(guess).map({case
    (game, guess) => (game - guess).abs})', '        return game.zip(guess).map{case
    (x, y) => abs(x - y)}', '        return List()', '        game.zip(guess).map(x
    => abs(x._1 - x._2))', "        var ret = new ListBuffer[Long]\n        for (i\
    \ <- 0 until game.length) {\n            var temp = abs(game(i) - guess(i))\n\
    \            ret += temp\n        }\n        ret.toList", "        var result\
    \ : List[Long] = List()\n        for (i <- 0 until game.length) result :+= abs(game(i)\
    \ - guess(i))\n        result", "        // Fill in the code here:\n        var\
    \ result = List[Long]()\n        for (i <- 0 until game.length) {\n          \
    \  var diff = abs(game(i) - guess(i))\n            result = result :+ diff\n \
    \       }\n        result", "        var ret = List[Long]()\n        for (i <-\
    \ 0 until game.length) {\n            ret = ret :+ abs(game(i) - guess(i))\n \
    \       }\n        ret", "        var diffs = List[Long]()\n        for (i <-\
    \ 0 until game.length) {\n            diffs = diffs :+ (abs(game(i) - guess(i)))\n\
    \        }\n        diffs", "        if (game.length != guess.length) {\n    \
    \        return Nil\n        }\n        (game zip guess).map(x => abs(x._1 - x._2))",
  '        game.zip(guess).map({case (a, b) => abs(a - b)})', "        if (game.length\
    \ != guess.length) throw new RuntimeException(\"game and guess must be of equal\
    \ length\")\n        var output : List[Long] = List()\n        for (i <- 0 until\
    \ game.length) {\n            val diff = abs(game(i) - guess(i))\n           \
    \ output = output :+ diff\n        }\n        output", '        game.zip(guess).map(x
    => math.abs(x._1 - x._2))', "        if (game.length == 0) return List[Long]()\n\
    \        return abs(game.head - guess.head) :: compare(game.tail, guess.tail)",
  '        game.zip(guess).map {case (x, y) => math.abs(x - y)}', "    \t(game, guess).zipped.map(_\
    \ - _).map(x => abs(x))", "        if (game.size == 0) return List[Long]()\n \
    \       List(abs(game.head - guess.head)) ::: compare(game.tail, guess.tail)",
  "        def compare_recur(game : List[Long], guess : List[Long], result : List[Long])\
    \ : List[Long] = {\n            if (game.isEmpty) result.reverse\n           \
    \ else compare_recur(game.tail, guess.tail, abs(game.head - guess.head) :: result)\n\
    \        }\n        compare_recur(game, guess, List())", '        game.zip(guess).map(x
    => abs(x._1 - x._2))', "        // your answer here\n        return List[Long]()",
  "        // def abs(in : Long) : Long = if (in < 0) -in else in\n        game.zip(guess).map(pair\
    \ => abs(pair._1 - pair._2))", "        var total = List[Long]()\n        for\
    \ (i <- 0 until game.length) {\n            var result = abs(game(i) - guess(i))\n\
    \            total = total :+ result\n        }\n        return total", '        game.zip(guess).map(a
    => abs(a._1 - a._2))', '        (game zip guess).map(x => abs(x._1 - x._2))',
  "        if (game.length == guess.length) {\n            val compare = for (i <-\
    \ 0 until game.length) yield abs(game(i) - guess(i))\n            compare.toList\n\
    \        } else {\n            List()\n        }", "      if (game.length != guess.length)\
    \ {\n        return List[Long]()\n      }\n      var result : List[Long] = List[Long]()\n\
    \      for (i <- 0 until game.length) {\n        result = (abs(game(i) - guess(i))\
    \ :: result).reverse\n      }\n      return result", "        var result = List[Long]()\n\
    \        val n = game.length\n        var i = 0\n        while (i < n) {\n   \
    \         val difference = math.abs(game(i) - guess(i))\n            result =\
    \ result :+ difference\n            i += 1\n        }\n        result", "    \
    \    // Your code goes here\n        return null;", "        var dif : List[Long]\
    \ = List()\n        for (i <- 0 until game.length) {\n            if (game(i)\
    \ == guess(i)) {\n                dif = dif :+ 0\n            } else {\n     \
    \           dif = dif :+ abs(game(i) - guess(i))\n            }\n        }\n \
    \       dif", '      game.zip(guess).map(x => math.abs(x._1 - x._2))', '        for
    (i <- (0 to game.length - 1).toList) yield abs(game(i) - guess(i))', "       \
    \ if (game.length != guess.length) throw new IllegalArgumentException\n      \
    \  game.zip(guess).map(t => abs(t._1 - t._2))", "        val result : MutableList[Long]\
    \ = MutableList[Long]()\n        for (i <- 0 until game.length) result += abs(game(i)\
    \ - guess(i))\n        result.toList", "      game.zip(guess).map({\n        case\
    \ (x : Long, y : Long) => abs(x - y)\n      })", '        return game.zip(guess).map((x
    : (Long, Long)) => abs(x._1 - x._2))', '        game.zip(guess).map(a => abs(a._1
    - a._2))', "        if (game.length != guess.length) return (List[Long]())\n \
    \       (game, guess).zipped.map((a, b) => abs(a - b))", "        // your code\
    \ here\n        (game, guess).zipped.map((a, b) => abs(a - b))", '        game.zip(guess).map(p
    => Math.abs(p._1 - p._2))', "        var result : List[Long] = List[Long]()\n\
    \        for(i <- 0 until game.length) {\n            result = result :+ abs(game(i)\
    \ - guess(i))\n        }\n        return result", '        game.zip(guess).map(p
    => abs(p._1 - p._2))', '        game.zip(guess).map(e => abs(e._1 - e._2))', " \
    \       var result = List[Long]()\n        for (i <- 0 until game.length) {\n\
    \            if (guess(i) < 0) result = result ++ List(abs(guess(i) + game(i)))\n\
    \            else result = result ++ List(abs(guess(i) - game(i)))\n        }\n\
    \        result", '        game.zip(guess).map{case (g, gs) => abs(g - gs)}',
  "        var distance : List[Long] = List[Long]()\n        for (i <- 0 until game.length)\
    \ {\n            distance = distance :+ abs(game(i) - guess(i))\n        }\n \
    \       return distance", "        val result = ListBuffer[Long]()\n        for\
    \ (i <- 0 until game.length) result += abs(game(i) - guess(i))\n        result.toList",
  "        if (game.length != guess.length) {\n            throw new Exception(\"\
    The length of the two lists are not equal\")\n        }\n        val out = new\
    \ ListBuffer[Long]\n        for (i <- 0 until game.length) {\n            val\
    \ diff = abs(game(i) - guess(i))\n            out += diff\n        }\n       \
    \ out.toList", '        for (i <- 0 until game.length) yield if (guess(i) < 0)
    abs(guess(i)) else abs(game(i) - guess(i))', '        game.zip(guess).map { case
    (a, b) => abs(a - b) }', "        if (game.size != guess.size) {\n           \
    \ (List[Long]())\n        } else {\n            var result : List[Long] = List[Long]()\n\
    \            for (x <- 0 until game.size) {\n                result = result :+\
    \ abs(game(x) - guess(x))\n            }\n            result\n        }", '        List[Long]()',
  "        var result = new ListBuffer[Long]\n        for (i <- 0 until game.length)\
    \ {\n            if (guess(i) == game(i)) result += 0\n            else result\
    \ += abs(guess(i) - game(i))\n        }\n        result.toList", "        // Fill\
    \ in the function here\n        for (index <- 0 until game.length) yield abs(game(index)\
    \ - guess(index)).toLong", '        game.zip(guess).map(x => x._1 - x._2).map(x
    => if (x < 0) x * -1 else x)', '        game.zip(guess).map(g => abs(g._1 - g._2))',
  "        // Do your work here\n        // Return your answer\n        var x = ListBuffer[Long]()\n\
    \        for (i <- 0 until game.length) {\n            x += abs(game(i) - guess(i))\n\
    \        }\n        x.toList", "        if (game.size != guess.size)\n       \
    \     return List[Long]()\n        val ret = ListBuffer[Long]()\n        for (i\
    \ <- 0 until game.size) {\n            val diff = abs(game(i) - guess(i))\n  \
    \          ret += diff\n        }\n        ret.toList", '        game.zip(guess).map(x
    => (abs(x._1 - x._2)))', '        return (game, guess).zipped.map(_ - _).map(Math.abs(_)).toList',
  "        val result = scala.collection.mutable.ListBuffer[Long]()\n        for (i\
    \ <- 0 until game.length) {\n            result += abs(game(i) - guess(i))\n \
    \       }\n        result.toList", '        game.zip(guess).map(x => abs(x._1
    - x._2))', '        (game zip guess).map(x => abs(x._1 - x._2))', "      // Good\
    \ luck!\n      return List.empty[Long]", "        var ab : List[Long] = List[Long]()\n\
    \        for (i <- 0 until game.length) {\n            ab = ab :+ (math.abs(game(i)\
    \ - guess(i)))\n        }\n        ab", '        game.zip(guess).map(t => abs(t._1
    - t._2))', "        var answer = List[Long]()\n        for (i <- 0 until game.length)\
    \ {\n            var x = game(i) - guess(i)\n            if (x < 0) { x = x *\
    \ -1 }\n            answer = answer :+ x\n        }\n        return answer", "\t\t\
    game.zip(guess).map(i => abs(i._1 - i._2))", "        val result = ArrayBuffer[Long]()\n\
    \        for (i <- 0 until game.length) result += abs(game(i) - guess(i))\n  \
    \      result.toList", "        if (game.length == guess.length)\n           \
    \ game.zip(guess).map(t => abs(t._1 - t._2))\n        else\n            List()",
  "        // Fill in the function here\n        (game zip guess).map(x => Math.abs(x._1\
    \ - x._2))", "        val list = new ListBuffer[Long]\n        for (i <- 0 until\
    \ game.length) {\n            val difference = abs(game(i) - guess(i))\n     \
    \       list += difference\n        }\n        list.toList", '        for ((x,
    y) <- game zip guess) yield abs(x - y)', '        return game.zip(guess).map(x
    => abs(x._1 - x._2))', "      val zip = game.zip(guess)\n      val result = zip.map\
    \ {case (game, guess) => (game - guess).abs}\n      result", "        if (game.length\
    \ == 0) List[Long]()\n        else (game.head - guess.head).abs :: compare(game.tail,\
    \ guess.tail)", "        def helper(gs : List[Long], gg : List[Long], acc : List[Long])\
    \ : List[Long] = {\n            if (gs.isEmpty) acc\n            else {\n    \
    \            val curRes = Math.abs(gs.head - gg.head)\n                helper(gs.tail,\
    \ gg.tail, acc :+ curRes)\n            }\n        }\n        helper(game, guess,\
    \ List())", "        // Fill in the code here\n        Nil", "        // Fill\
    \ in the code here\n        val tuples = game.zip(guess)\n        val result =\
    \ new ListBuffer[Long]()\n        for (tuple <- tuples) {\n            val a =\
    \ tuple._1\n            val b = tuple._2\n            result += abs(a - b)\n \
    \       }\n        result.toList", '        game.zip(guess).map(x => abs(x._1
    - x._2))', "        var result : List[Long] = Nil\n        for (i <- 0 until game.length)\
    \ {\n            result = result :+ abs(game(i) - guess(i))\n        }\n     \
    \   result", '        (game zip guess).map(pair => abs(pair._1 - pair._2))', " \
    \   \tgame.zip(guess).map(a => abs(a._1 - a._2))", "        val cmp = new ListBuffer[Long]\n\
    \        for(i <- 0 until game.length) {\n            cmp += abs(game(i) - guess(i))\n\
    \        }\n        cmp.toList", '      game.zip(guess).map(x => abs(x._1 - x._2))',
  "        var result = List[Long]()\n        for (i <- 0 until game.length) result\
    \ = result :+ abs(game(i) - guess(i))\n        result", '        game.zip(guess).map(x
    => abs(x._1 - x._2))', "        var answer = List[Long]()\n        for (i <- 0\
    \ until game.length) {\n            answer = answer :+ abs(game(i) - guess(i))\n\
    \        }\n        return answer", '        game.zip(guess).map(x => abs(x._1
    - x._2))', "        val result : Buffer[Long] = Buffer[Long]()\n        for (i\
    \ <- 0 until game.length) result += abs(game(i) - guess(i))\n        result.toList",
  "        var res : List[Long] = Nil\n        var i = 0\n        while (i < game.length)\
    \ {\n            res = abs(game(i) - guess(i)) :: res\n            i += 1\n  \
    \      }\n        res.reverse", '        for ((x, y) <- game zip guess) yield
    abs(x - y)', "      var result = new ListBuffer[Long]()\n      if (game.length\
    \ != guess.length) {\n        return result.toList\n      }\n      else {\n  \
    \      for (i <- 0 until game.length) {\n          if (game(i) == guess(i)) {\n\
    \            result += 0\n          }\n          else {\n            result +=\
    \ abs(game(i) - guess(i))\n          }\n        }\n        return result.toList\n\
    \      }", "        var result : List[Long] = List[Long]()\n        for(i <- 0\
    \ until game.length) result = result :+ abs(game(i) - guess(i))\n        result",
  "        var result = List[Long]()\n        for (i <- 0 until game.length) {\n \
    \           if (game(i) != guess(i)) result = result :+ abs(game(i) - guess(i))\n\
    \            else result = result :+ 0\n        }\n        result", "        //\
    \ Your code goes here\n        val length = game.length\n        if (length !=\
    \ guess.length) {\n            throw new IllegalArgumentException(\"guess and\
    \ game are not the same length.\")\n        }\n        var res = List[Long]()\n\
    \        for (i <- 0 until length) {\n            res = res :+ abs(game(i) - guess(i))\n\
    \        }\n        res", "        require(game.length == guess.length)\n    \
    \    val scores = new ListBuffer[Long]\n        for(i <- 0 until game.length)\
    \ {\n            scores += abs(game(i) - guess(i))\n        }\n        scores.toList",
  '        game.zip(guess).map(x => abs(x._1 - x._2))', "        // Good luck!\n \
    \       if (game.length == 0) List[Long]()\n        else if (game.length == 1)\
    \ List[Long](abs(game(0) - guess(0)))\n        else List[Long](abs(game(0) - guess(0)))\
    \ ::: compare(game.tail, guess.tail)", "        var s : List[Long] = List()\n\
    \        for (i <- 0 until game.length) {\n            s = s :+ abs(game(i) -\
    \ guess(i))\n        }\n        s", "        val list = new ListBuffer[Long]\n\
    \        for (n <- 0 until game.length) {\n            list += abs(game(n) - guess(n))\n\
    \        }\n        list.toList", "    \tval t = List[Long]()\n    \tvar result\
    \ = t\n    \tfor (i <- 0 to game.length - 1) {\n    \t\tif (game(i) == guess(i))\
    \ result = 0l.toLong :: result\n    \t\telse result = (abs(game(i) - guess(i))).toLong\
    \ :: result\n    \t}\n    \tresult.reverse", "      val score = game.zip(guess).map(x\
    \ => abs(x._1 - x._2))\n      score", "        val finalGame = game.map(x => x)\n\
    \        val finalGuess = guess.map(x => x)\n        val pointValueList = ListBuffer[Long]()\n\
    \        for(i <- (0 until game.length)) {\n            val pointValue = abs(finalGame(i)\
    \ - finalGuess(i))\n            pointValueList += pointValue\n        }\n    \
    \    pointValueList.toList", '        (game zip guess).map(p => abs(p._1 - p._2))',
  "        val result = new ListBuffer[Long]\n        for (i <- 0 until game.length)\
    \ result += abs(game(i) - guess(i))\n        result.toList", "        if (game.length\
    \ != guess.length) throw new IllegalArgumentException\n        for (i <- 0 until\
    \ game.length) yield abs(game(i) - guess(i))", "        def g(game : List[Long],\
    \ guess : List[Long], acc : List[Long]) : List[Long] = (game, guess) match {\n\
    \            case (hg :: tg, hs :: ts) => g(tg, ts, (acc :+ abs(hg - hs)))\n \
    \           case _ => acc\n        }\n        g(game, guess, List[Long]())", " \
    \       val l = ListBuffer[Long]()\n        for (i <- 0 until game.length) {\n\
    \            val r = math.abs(game(i) - guess(i))\n            l += r\n      \
    \  }\n        l.toList", '        game.zip(guess).map(t => abs(t._1 - t._2))',
  '        game.zip(guess).map(x => abs(x._1 - x._2))', "        if (game.length !=\
    \ guess.length) {\n            return (List[Long]())\n        }\n        return\
    \ game.zip(guess).map(x => abs(x._1 - x._2))", "        var list = List[Long]()\n\
    \        for (i <- 0 until game.length) {\n            list = list :+ abs(game(i)\
    \ - guess(i))\n        }\n        list", "        val error = ListBuffer[Long]()\n\
    \        for (i <- 0 until game.length) {\n            error += abs(game(i) -\
    \ guess(i))\n        }\n        error.toList", "        val list = new ArrayBuffer[Long]\n\
    \        for (i <- 0 until game.length) {\n            list += abs(game(i) - guess(i))\n\
    \        }\n        list.toList", '        game.zip(guess).map(t => abs(t._1 -
    t._2))', '      //your code here', "        // // Your Code Here\n        var\
    \ result : List[Long] = List()\n        for(i <- 0 until game.length) {\n    \
    \        result = result :+ (abs(game(i) - guess(i)))\n        }\n        return\
    \ result", "        val List(game, guess) = List(game, guess)\n        List(game,\
    \ guess).transpose.map(i => abs(i.head - i.last))", '        (for (i <- 0 until
    game.length) yield abs(game(i) - guess(i))).toList', "      val result = game.indices.map(i\
    \ => abs(game(i) - guess(i))).toList\n      result", "    \t(game, guess).zipped.map((a,\
    \ b) => abs(a - b))", '        (game, guess).zipped.map((x, y) => if (x < 0 ||
    y < 0) math.abs(math.abs(x) - math.abs(y)) else math.abs(x - y))', "        if\
    \ (game.length == 0)\n            return List()\n        if (guess.length == 0)\n\
    \            return List()\n        if (game.length != guess.length)\n       \
    \     return List()\n        return List(abs(game(0) - guess(0))) ::: compare(game.tail,\
    \ guess.tail)", '        for ((x,y) <- game.zip(guess)) yield abs(x - y)', " \
    \       def f(guess : List[Long], game : List[Long], result : List[Long]) : List[Long]\
    \ = guess match {\n            case Nil => {\n                result\n       \
    \     }\n            case x :: xs => {\n                f(xs, game.tail, result\
    \ :+ math.abs(game.head - x))\n            }\n        }\n        f(guess, game,\
    \ List[Long]())", "        var res = List[Long]()\n        for (i <- 0 until game.length)\
    \ {\n            if (game(i) == guess(i)) res = res :+ 0\n            else res\
    \ = res :+ abs(game(i) - guess(i))\n        }\n        res", '        game.zip(guess).map(i
    => abs(i._1 - i._2))', "        if (game.length != guess.length) throw new IllegalArgumentException\n\
    \        else (game zip guess).map{case (a, b) => abs(a - b)}", '        for (i
    <- 0 until game.length) yield abs(game(i) - guess(i))', '        return game.zip(guess).map({case
    (score, guess) => abs(score - guess)})', '      (game, guess).zipped.map((g,h)
    => abs(g-h))', '        game.zip(guess).map(x => abs(x._1 - x._2))', '        (game
    zip guess).map{case (x, y) => abs(x - y)}', "        var result = new ListBuffer[Long]()\n\
    \        for (i <- 0 until game.length) {\n            result += abs(game(i) -\
    \ guess(i))\n        }\n        result.toList", "      // TODO: Complete this\
    \ implementation.\n      return List[Long]()", "        val zip = game.zip(guess)\n\
    \        val res = zip.map(a => abs(a._1 - a._2))\n        return res", '        game.zip(guess).map(x
    => abs(x._1 - x._2))', "        var result : List[Long] = Nil\n        val zipped\
    \ = game.zip(guess)\n        zipped.foreach{ case (i, j) => {\n            result\
    \ = abs(i - j) :: result\n        }}\n        result.reverse", "        val result\
    \ : ListBuffer[Long] = new ListBuffer[Long]\n        for (i <- 0 until game.length)\
    \ result += abs(game(i) - guess(i))\n        result.toList", "        // Your\
    \ Code Here\n        return List[Long]()", '        // your code goes here', '        //
    your code goes here', "        // Fill in the code here\n        var result :\
    \ List[Long] = List[Long]()\n        for(i <- 0 until game.length) {\n       \
    \     result = result :+ (abs(game(i) - guess(i)))\n        }\n        return\
    \ result", '        (for (i <- 0 until game.length) yield abs(game(i) - guess(i))).toList',
  '        game.indices.map(i => abs(game(i) - guess(i))).toList', '        game.zip(guess).map(x
    => abs(x._1 - x._2))', '      (game zip guess).map(x => x._1 - x._2).map(x =>
    math.abs(x))', "        if (game.length != guess.length) {\n            return\
    \ List[Long]()\n        }\n        var result = List[Long]()\n        for (i <-\
    \ 0 until game.length) {\n            var x = game(i) - guess(i)\n           \
    \ if (x < 0) {\n                x = x * -1\n            }\n            result\
    \ = result :+ x\n        }\n        return result", '        return game.zip(guess).map(x
    => abs(x._1 - x._2))', '        return game.zip(guess).map(x => (x._1 - x._2).abs)']
stop_tokens:
- "\n    }\n"
