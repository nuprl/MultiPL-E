name: HumanEval_135_can_arrange
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function which returns the largest index of an element which\n\
  \    // is not greater than or equal to the element immediately preceding it. If\n\
  \    // no such element exists then return -1. The given list will not contain\n\
  \    // duplicate values.\n    // Examples:\n    // >>> canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))\n    // (3l)\n    // >>> canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (-1l)\n    def canArrange(arr : List[Long]) :\
  \ Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
  \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong,\
  \ 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) == (-1l));\n\
  \    }\n\n}\n"
completions: ["        arr.zipWithIndex.foldLeft(arr.length - 1, true) {\n       \
    \     case ((currentIndex, first), (element, index)) =>\n                if (index\
    \ == 0) {\n                    (index, true)\n                } else {\n     \
    \               if (element <= arr(currentIndex)) {\n                        (index,\
    \ false)\n                    } else {\n                        (currentIndex,\
    \ first)\n                    }\n                }\n        }._1", "        val\
    \ m = arr.length - 1\n        val map = arr.zipWithIndex.toMap\n        (0 to\
    \ m).filter(i => map.contains(arr(i) + 1)).max", "        // Write your code here\n\
    \        return -1l;", "        var n = arr.length\n        var ind = 0\n    \
    \    while (ind < n - 1) {\n            if (arr(ind) >= arr(ind + 1)) return ind.toLong\n\
    \            ind += 1\n        }\n        -1l", "        var max = 0\n       \
    \ for (i <- 0 until arr.length) {\n            var j = i + 1\n            while\
    \ (j < arr.length && arr(j) >= arr(i)) j += 1\n            if (j == arr.length)\
    \ return -1\n            max = max.max(j)\n        }\n        return max", " \
    \       val a = arr\n        var index = -1l\n        for (i <- 0 until a.length\
    \ - 1) {\n            if (a(i) >= a(i + 1)) {\n                index = i.toLong\n\
    \            }\n        }\n        return index", "        val n = arr.length\n\
    \        val a = arr.toArray\n        val st = new Stack[(Long, Int)]\n      \
    \  st.push((a(0), 0))\n        for (i <- 1 until n) {\n            val x = a(i)\n\
    \            while (!st.isEmpty && st.top._1 >= x) {\n                st.pop\n\
    \            }\n            st.push((x, i))\n        }\n        if (st.size ==\
    \ 1) {\n            return st.top._2\n        }\n        var res = -1l\n     \
    \   for (x <- st.drop(1)) {\n            res = max(res, x._2)\n        }\n   \
    \     res", "      var cnt = 0\n      for (i <- 0 until arr.length) {\n      \
    \  for (j <- i until arr.length) {\n          if (arr(i) == arr(j)) cnt += 1\n\
    \        }\n        if (cnt > 1) return i.toLong\n        cnt = 0\n      }\n \
    \     return -1l", "        var largestIndex = -1\n        var index = 0\n   \
    \     while (index < arr.length - 1) {\n            if (arr(index) <= arr(index\
    \ + 1)) {\n                if (index > largestIndex) {\n                    largestIndex\
    \ = index\n                }\n            }\n            index += 1\n        }\n\
    \        return largestIndex", "        arr.foldLeft(List[Long](), -1l)((x, y)\
    \ => if (x._1.isEmpty || y <= x._1.head) (y :: x._1, x._2) else (y :: x._1, arr.indexOf(y).toLong))\
    \ match {\n            case (_, index) => index\n        }", "    \treturn -1l",
  "        var max = -1l\n        for (i <- 1 until arr.length) {\n            if\
    \ (arr(i) >= arr(i - 1)) {\n                if (i > max) max = i\n           \
    \ }\n        }\n        max", "\t\tvar maxIndex = -1\n\t\tfor (i <- 1 until arr.length)\
    \ {\n\t\t\tif (arr(i) <= arr(i - 1)) maxIndex = i\n\t\t}\n\t\treturn maxIndex",
  "        if (arr.length < 2) -1\n        else {\n            var index = -1\n  \
    \          for (i <- 0 until arr.length - 1) if (arr(i) >= arr(i + 1)) index =\
    \ i\n            index\n        }", "        if (arr.isEmpty) {\n            return\
    \ -1l\n        }\n        val arr1 = arr.slice(0, arr.length - 1)\n        val\
    \ arr2 = arr.slice(1, arr.length)\n        var m = arr1.length\n        for (i\
    \ <- 0 until arr1.length) {\n            if (arr1(i) <= arr2(i)) {\n         \
    \       m = i\n            }\n        }\n        if (m == arr1.length) {\n   \
    \         return -1l\n        }\n        return m.toLong", "        var maxIndex\
    \ = 0\n        var max = 0\n        for (i <- 0 until arr.length - 1) {\n    \
    \        if (arr(i) <= arr(i + 1)) maxIndex = i + 1\n            else {\n    \
    \            if (maxIndex > max) max = maxIndex\n                maxIndex = 0\n\
    \            }\n        }\n        if (maxIndex > max) max = maxIndex\n      \
    \  if (max == 0) -1 else max", "        for (i <- arr.length - 1 to 0 by -1) if\
    \ (arr(i) <= arr(i - 1)) return i else {}\n        -1", "        if (arr.length\
    \ == 0) return -1l\n        var curMin = arr(0)\n        var curMinIndex = 0l\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) <= curMin) {\n\
    \                curMin = arr(i)\n                curMinIndex = i\n          \
    \  }\n        }\n        curMinIndex", "        val arr2 = arr.reverse\n     \
    \   val arr3 = arr2.zipWithIndex\n        val arr4 = arr3.filter(_._1 >= arr2(0))\n\
    \        val arr5 = arr4.map(_._2)\n        val arr6 = arr5.sorted\n        if\
    \ (arr6.length == 0) return -1 else arr6(0)", "        // Write your code here\n\
    \        return 0l;", "        val a = arr\n        val b = arr.sortWith((x, y)\
    \ => x < y)\n        val m = Map[Long, Long]()\n        var i = 0\n        while\
    \ (i < b.length) {\n            m(b(i)) = i\n            i += 1\n        }\n \
    \       var j = 0\n        while (j < a.length) {\n            if (m(a(j)) !=\
    \ j) return j - 1\n            j += 1\n        }\n        -1", "        arr match\
    \ {\n            case Nil => -1l\n            case _ => arr.foldLeft((-1l, arr.head))((a,\
    \ b) => if (b >= a._2) (arr.indexOf(b), b) else a)._1\n        }", '        -1l',
  "        var max = -1\n        for (i <- arr.length - 2 to 0 by -1) if (arr(i) >=\
    \ arr(i + 1)) max = i + 1\n        return max", "        var index = -1\n    \
    \    for (i <- 0 until arr.length - 1) {\n            if (arr(i) <= arr(i + 1))\
    \ {\n                index = i\n            }\n        }\n        return index.toLong",
  "        var maxIndex = -1l\n        var maxValue = 0l\n        for (i <- arr.indices)\
    \ {\n            if (arr(i) <= maxValue) maxIndex = i\n            else if (arr(i)\
    \ > maxValue) maxValue = arr(i)\n        }\n        maxIndex", "        var x\
    \ = arr.size - 1\n        while (x > 0) {\n            if (arr(x) < arr(x - 1))\
    \ {\n                return x - 1\n            }\n            x -= 1\n       \
    \ }\n        return -1", "        def canArrangeIter(lst : List[Long], max : Long,\
    \ k : Long) : Long = {\n            lst match {\n                case Nil => -1l\n\
    \                case hd :: tl => if (hd <= max) k else canArrangeIter(tl, hd,\
    \ lst.length)\n            }\n        }\n        canArrangeIter(arr, Long.MinValue,\
    \ -1l)", "        var arr2 = arr.toArray\n        var maxInd = -1\n        for\
    \ (i <- 1 until arr2.length) {\n            if (arr2(i) <= arr2(i - 1)) {\n  \
    \              maxInd = i\n            }\n        }\n        return maxInd", " \
    \       val n = arr.length\n        val prefixSum = new Array[Long](n)\n     \
    \   prefixSum(0) = arr(0)\n        for (i <- 1 until n) prefixSum(i) = prefixSum(i\
    \ - 1) + arr(i)\n        val suffixSum = new Array[Long](n)\n        suffixSum(n\
    \ - 1) = arr(n - 1)\n        for (i <- n - 2 to 0 by -1) suffixSum(i) = suffixSum(i\
    \ + 1) + arr(i)\n        val smallSum = (for (i <- 0 until n) yield prefixSum(i)\
    \ - arr(i)).toList\n        val smallSumIndex = (for (i <- 0 until n) yield (smallSum(i),\
    \ i)).toMap\n        val largeSum = (for (i <- 0 until n) yield suffixSum(i) -\
    \ arr(i)).toList\n        val largeSumIndex = (for (i <- 0 until n) yield (largeSum(i),\
    \ i)).toMap\n        val elements = smallSum.zip(largeSum).sortWith((x, y) =>\
    \ x._1 < y._1)\n        var res = -1l\n        var m = 0\n        for (i <- 0\
    \ until n) {\n            if (smallSumIndex(elements(i)._1) < largeSumIndex(elements(i)._2))\
    \ {\n                m += 1\n                res = elements(i)._1\n          \
    \  }\n        }\n        if (m == 1) res else -1", "\t\tfor (i <- arr.size - 1\
    \ to 0 by -1) {\n\t\t\tif (arr(i) <= arr(i - 1)) return i\n\t\t}\n\t\t-1", " \
    \       // Fill this in.\n        var count = 0;\n        var max = 0;\n     \
    \   for (i <- 0 until arr.length) {\n            var arr1 = arr.toArray;\n   \
    \         arr1 = arr1.filter(_ != arr(i));\n            var hasSmaller = false;\n\
    \            for (j <- 0 until arr1.length) {\n                if (arr1(j) <=\
    \ arr(i)) {\n                    hasSmaller = true;\n                }\n     \
    \       }\n            if (!hasSmaller) {\n                count += 1;\n     \
    \           max = i;\n            }\n        }\n        if (count == 1) {\n  \
    \          return max;\n        }\n        else {\n            return -1;\n  \
    \      }", '        -1l', "        val dp = Array.fill(arr.length)(1l)\n     \
    \   // dp contains non-increasing values (although not\n        // necessarily\
    \ strictly non-increasing)\n        for (i <- 1 until arr.length) {\n        \
    \    if (arr(i) <= arr(i - 1)) {\n                dp(i) = dp(i - 1) + 1\n    \
    \        }\n        }\n        // Now dp contains strictly non-increasing values.\n\
    \        val indexes = SortedMap[Long, List[Int]]()\n        for (i <- 0 until\
    \ arr.length) {\n            if (!indexes.contains(arr(i))) indexes(arr(i)) =\
    \ List[Int]()\n            indexes(arr(i)) = indexes(arr(i)) :+ i\n        }\n\
    \        var max = -1l\n        for (value <- indexes.keys) {\n            val\
    \ indices = indexes(value)\n            for (i <- 0 until indices.length) {\n\
    \                if (i + 1 < indices.length) {\n                    val a = indices(i)\n\
    \                    val b = indices(i + 1)\n                    if (b - a - 1\
    \ > max) {\n                        max = dp(a)\n                    }\n     \
    \           }\n            }\n        }\n        max", "      var res = -1l\n\
    \      arr.foreach(x => {\n        if (arr.indexOf(x) < arr.indexOf(x + 1)) res\
    \ = arr.indexOf(x)\n      })\n      res", "        if (arr.length <= 1) return\
    \ -1\n        var max_index = 0\n        for (i <- 1 until arr.length) {\n   \
    \         if (arr(i) <= arr(i - 1)) {\n                max_index = i\n       \
    \     }\n        }\n        return max_index", "        // Fill in the missing\
    \ code here.\n        val indexOfMax = (arr zip arr.tail).zipWithIndex.filter{\
    \ case ((a, b), i) => a >= b }.map{case ((a, b), i) => i}.max\n        if (indexOfMax\
    \ == -1) -1l else (indexOfMax + 1).toLong", "        arr.size match {\n      \
    \      case 0 => -1\n            case 1 => -1\n            case _ => {\n     \
    \           var index = 0\n                var list = (List[Long]() ++ arr)\n\
    \                var result = -1\n                while(list.size != 0) {\n  \
    \                  if(list.size == 1) {\n                        return -1\n \
    \                   }\n                    if(list.size > 1) {\n             \
    \           val prevElement = list(0)\n                        val currentElement\
    \ = list(1)\n                        if(currentElement < prevElement) {\n    \
    \                        result = index + 1\n                            return\
    \ result\n                        }\n                        index += 1\n    \
    \                    list = list.tail\n                    }\n               \
    \ }\n                result\n            }\n        }", "        val (n, last)\
    \ = (arr.length, arr.last)\n        if (n == 1) -1l else {\n            val (a,\
    \ b) = (arr.init, arr.last)\n            val (a2, b2) = (a.scanLeft(0l)((x, y)\
    \ => x ^ y), b ^ a.last)\n            if (a2.last == b2) n - 1l else -1l\n   \
    \     }", "        var left = arr.head\n        var right = arr.tail.head\n  \
    \      var pos = 1\n        while (right >= left) {\n            left = right\n\
    \            right = arr(pos)\n            pos += 1\n        }\n        pos -\
    \ 1", "        var max = -1l\n        for (i <- 0 until arr.length - 1) if (arr(i)\
    \ >= arr(i + 1)) max = max max i\n        max", "      if (arr.size == 1) return\
    \ -1\n      val b = arr.sorted\n      val x = b.init\n      val y = b.last\n \
    \     var max = -1l\n      for (i <- 0 until x.size) {\n        if (x(i) <= y)\
    \ max = i\n      }\n      return max", '        -1', "        if (arr.length ==\
    \ 0) -1l else {\n            val sorted = arr.sorted\n            val index =\
    \ sorted.indexWhere(x => x < sorted(sorted.indexOf(x) - 1))\n            if (index\
    \ == -1) -1l else arr.indexOf(sorted(index))\n        }", "        var h = -1l.toLong\n\
    \        var result = h\n        for (i <- 0 until arr.length - 1) {\n       \
    \     if (arr(i) >= arr(i + 1)) {\n                h = i\n            }\n    \
    \    }\n        if (h != -1l.toLong) {\n            for (i <- h until arr.length\
    \ - 1) {\n                if (arr(i) <= arr(i + 1)) {\n                    result\
    \ = i\n                }\n            }\n        }\n        result", "    \tif\
    \ (arr.length == 0) return -1l\n    \tvar max = arr(0)\n    \tvar index = 0l\n\
    \    \tfor (i <- 1 until arr.length) {\n    \t\tif (arr(i) <= max) {\n    \t\t\
    \tmax = arr(i)\n    \t\t\tindex = i\n    \t\t}\n    \t}\n    \treturn index",
  "\t\tvar ans = -1l\n\t\tif (arr.size == 1) return ans\n\t\tfor (i <- 0 until arr.size\
    \ - 1) {\n\t\t\tif (arr(i) <= arr(i + 1)) {\n\t\t\t\tans = i\n\t\t\t}\n\t\t}\n\
    \t\tans", "      var index : Long = -1\n      var i : Long = 0\n      var prev\
    \ : Long = 0\n      while (i < arr.length) {\n        if (arr(i.toInt) <= prev)\
    \ {\n          return i - 1\n        }\n        prev = arr(i.toInt)\n        i\
    \ += 1\n      }\n      return index", "        var dp = ListBuffer[Long]()\n \
    \       for (i <- arr.indices) {\n            var j = i - 1\n            while\
    \ (j >= 0 && arr(j) >= arr(i)) j -= 1\n            dp += j\n        }\n      \
    \  var max = -1\n        for (i <- arr.indices) {\n            var j = dp(i)\n\
    \            if (j == -1) {\n                if (i > max) max = i\n          \
    \  } else {\n                while (j >= 0 && dp(j) == -1) j -= 1\n          \
    \      if (j >= 0 && arr(j) == arr(i)) {\n                    if (i - j > max)\
    \ max = i - j\n                }\n            }\n        }\n        max", "  \
    \      // Define our return value\n        var result : Long = -1\n        //\
    \ We will handle the case where the input array is\n        // empty by just returning\
    \ -1.\n        // If the length of the array is not zero then we\n        // will\
    \ loop over the array indices and for each\n        // index, i, we will loop\
    \ over the array indices\n        // from i + 1 to the end of the array. If we\n\
    \        // encounter a smaller element at index j then\n        // we will set\
    \ the result to j.\n        if (arr.length != 0) {\n            for (i <- 0 until\
    \ arr.length) {\n                for (j <- i + 1 until arr.length) {\n       \
    \             if (arr(j) < arr(i)) {\n                        result = j\n   \
    \                 }\n                }\n            }\n        }\n        // return\
    \ the result\n        result", '        return -1l', "        arr.indices.foldLeft(-1l)((lastMax,\
    \ i) => if (lastMax < 0) -1 else {\n            if (arr(i) <= arr(lastMax.toInt))\
    \ lastMax else i\n        })", "        val prefixSum = new Array[Long](arr.length)\n\
    \        for (i <- 0 until arr.length) {\n            if (i == 0) prefixSum(i)\
    \ = arr(i)\n            else prefixSum(i) = prefixSum(i - 1) + arr(i)\n      \
    \  }\n        val leftMax = new Array[Long](arr.length)\n        for (i <- arr.length\
    \ - 1 to 0 by -1) {\n            if (i == arr.length - 1) leftMax(i) = arr(i)\n\
    \            else leftMax(i) = max(leftMax(i + 1), arr(i))\n        }\n      \
    \  val rightMax = new Array[Long](arr.length)\n        for (i <- 0 until arr.length)\
    \ {\n            if (i == 0) rightMax(i) = arr(i)\n            else rightMax(i)\
    \ = max(rightMax(i - 1), arr(i))\n        }\n        var index = -1\n        for\
    \ (i <- 1 until arr.length) {\n            if (rightMax(i - 1) <= arr(i) && leftMax(i\
    \ + 1) <= arr(i) && arr(i) * arr.length - prefixSum(i) + arr(i - 1) >= prefixSum(i\
    \ - 1)) {\n                index = i\n            }\n        }\n        return\
    \ index", "        if (arr.length == 0) -1\n        else {\n            val reverse\
    \ = arr.reverse\n            if (reverse(0) < reverse(1)) {\n                -1\n\
    \            } else {\n                var maxIndex = -1\n                for\
    \ (i <- 0 until arr.length - 1) {\n                    if (arr(i) >= arr(i + 1))\
    \ {\n                        maxIndex = i\n                    }\n           \
    \     }\n                maxIndex\n            }\n        }", "        var max\
    \ = -1l\n        for (i <- 0 until arr.length) {\n            if (i == 0) {\n\
    \                max = arr(i)\n            } else {\n                if (arr(i)\
    \ <= max) {\n                    max = arr(i)\n                }\n           \
    \ }\n        }\n        return max", "        var max = -1\n        var i = 0\n\
    \        while (i < arr.length - 1) {\n            if (arr(i) >= arr(i + 1)) {\n\
    \                max = max max i\n            }\n            i += 1\n        }\n\
    \        max", '        arr.zipWithIndex.reverse.minBy(((x : (Long, Int)) => x._1))._2.toLong',
  "        var maxIndex = -1l\n        var max = -1l\n        var index = 0\n    \
    \    while (index < arr.length) {\n            if (arr(index) <= max)\n      \
    \          maxIndex = index\n            max = max(max, arr(index))\n        \
    \    index += 1\n        }\n        maxIndex", "        var max = -1\n       \
    \ for (i <- 0 until arr.length - 1) {\n            if (arr(i) <= arr(i + 1)) {\n\
    \                max = i\n            }\n        }\n        max", "        if\
    \ (arr.size <= 1) -1l\n        else {\n            var max = -1l\n           \
    \ for (i <- 1 until arr.size) {\n                if (arr(i - 1) >= arr(i)) max\
    \ = i - 1\n            }\n            max\n        }", "        // This is the\
    \ largest value that can be chosen to get us to the end of\n        // the input\
    \ list.\n        var max : Long = arr.length - 1\n        // This loop will terminate\
    \ when we have determined if the given input\n        // list is possible or not.\n\
    \        while (max >= 0) {\n            // This loop will terminate when we have\
    \ determined if the given\n            // input list is possible or not.\n   \
    \         var curr : Long = max\n            while (curr >= 0) {\n           \
    \     // If we are at the end of the input list, then the input list\n       \
    \         // is possible.\n                if (curr == arr.length - 1) {\n   \
    \                 return curr\n                }\n                // If the value\
    \ at the current index is greater than the\n                // maximum index,\
    \ then the input list is not possible.\n                if (arr(curr.toInt) >\
    \ max) {\n                    break\n                }\n                // If\
    \ the value at the current index is less than the value at\n                //\
    \ the next index, then the input list is not possible.\n                if (arr(curr.toInt)\
    \ < arr(curr.toInt + 1)) {\n                    break\n                }\n   \
    \             // If we have not failed in any way, then increment the index.\n\
    \                curr += 1\n            }\n            // Decrement the maximum\
    \ index.\n            max -= 1\n        }\n        // The input list is not possible,\
    \ so return -1.\n        return -1", "        val n = arr.length\n        var\
    \ idx = n - 1\n        var largest = arr(n - 1)\n        while (idx >= 0) {\n\
    \            if (arr(idx) >= largest) {\n                largest = arr(idx)\n\
    \                idx -= 1\n            } else {\n                return idx.toLong\n\
    \            }\n        }\n        return -1l", "        // Implement solution\
    \ here\n        val n = arr.length\n        var i = n - 1\n        while (i >\
    \ 0) {\n            if (arr(i - 1) <= arr(i)) {\n                i -= 1\n    \
    \        } else {\n                return i\n            }\n        }\n      \
    \  -1", "        arr.tail.foldLeft(1) {\n            case (acc, elem) =>\n   \
    \             if (arr(acc - 1l) <= elem) acc\n                else -1l\n     \
    \   }", "        val f = -1\n        var result = f\n        for (i <- arr.length\
    \ - 1 to 1 by -1) {\n            if (arr(i) <= arr(i - 1)) result = i\n      \
    \  }\n        result", "        // Write your code here\n        0l", "      \
    \  def recur(arr : List[Long], accum : Long) : Long = {\n            if (arr.length\
    \ <= 0) accum\n            else {\n                val x = arr.head\n        \
    \        val index = arr.drop(1).indexWhere(y => y < x)\n                if (index\
    \ < 0) accum\n                else recur(arr.drop(index + 1), accum + index +\
    \ 1)\n            }\n        }\n        recur(arr, -1)", "        var m : Map[Long,\
    \ Long] = Map();\n        var ans : Long = -1;\n        for (i <- 0 until arr.length)\
    \ {\n            m += (arr(i) -> i);\n        }\n        for (i <- 0 until arr.length\
    \ - 1) {\n            var mx : Long = arr(i);\n            var j : Long = i +\
    \ 1;\n            while (j < arr.length && arr(j) >= mx) {\n                mx\
    \ = arr(j);\n                j += 1;\n            }\n            j -= 1;\n   \
    \         if (j != i) {\n                ans = math.max(ans, m(mx));\n       \
    \     }\n        }\n        return ans;", "        val c = arr.toArray\n     \
    \   val n = c.length\n        val l = ListBuffer[Long]()\n        for (i <- n\
    \ - 1 to 0 by -1) {\n            var j = i - 1\n            while (j >= 0 && c(j)\
    \ < c(i)) {\n                l += j\n                j -= 1\n            }\n \
    \       }\n        if (l.isEmpty) return -1\n        l.max", "        var max\
    \ = -1l;\n        var max_index = -1l;\n        for (i <- arr.indices) {\n   \
    \         if (arr(i) >= max) {\n                max = arr(i);\n              \
    \  max_index = i;\n            }\n        }\n        return max_index;", "   \
    \     val l = arr.length\n        var m = -1\n        for (x <- 0 until l - 1)\
    \ {\n            if (arr(x) >= arr(x + 1)) {\n                m = x\n        \
    \    }\n        }\n        m", "        var c = 0\n        for (i <- 0 until arr.length\
    \ - 1) {\n            if (arr(i) >= arr(i + 1)) c += 1\n        }\n        if\
    \ (c == arr.length - 1) -1 else c", "        val indexA = arr.indices.reverse\n\
    \        var maxIndex : Long = -1l\n        for (i <- indexA) {\n            if\
    \ (arr(i) <= arr(i + 1)) {\n                maxIndex = i.toLong\n            }\n\
    \        }\n        maxIndex", "        var index : Long = -1\n        for (i\
    \ <- 0 until arr.length - 1) {\n            if (arr(i) <= arr(i + 1)) {\n    \
    \            index = max(index, i)\n            }\n        }\n        return index",
  "        var new_arr = ArrayBuffer[Long]()\n        for (i <- 0 until arr.length)\
    \ {\n            new_arr += arr(i)\n        }\n        var max = -1\n        for\
    \ (i <- 1 until new_arr.length) {\n            if (new_arr(i) <= new_arr(i - 1))\
    \ {\n                max = i - 1\n            }\n        }\n        max", "  \
    \      val last = arr.zipWithIndex.maxBy(_._1)._2\n        for (i <- (0 to last).reverse)\
    \ {\n            if (arr(i) < arr(i - 1)) {\n                return (i - 1).toLong\n\
    \            }\n        }\n        return -1l", "        for (i <- arr.length\
    \ - 1 to 0 by -1) {\n            if (arr(i) >= arr(i - 1)) return i - 1\n    \
    \    }\n        return -1", "        val n = arr.length\n        var m = -1\n\
    \        var a = 0l\n        while (a < n) {\n            if (a == 0) {\n    \
    \            a += 1\n            } else {\n                if (arr(a.toInt) <=\
    \ arr(a.toInt - 1)) {\n                    m = a\n                }\n        \
    \        a += 1\n            }\n        }\n        return m.toLong", "       \
    \ var index = -1\n        var previous = Long.MaxValue\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) <= previous) {\n                index\
    \ = i\n                previous = arr(i)\n            }\n        }\n        return\
    \ index", '        return -1l', "        var index = -1l\n        for (i <- 0\
    \ until arr.length - 1) {\n            if (arr(i + 1) <= arr(i)) {\n         \
    \       index = i\n            }\n        }\n        return index", '        arr.zipWithIndex.filter(x
    => x._1 < arr(x._2 - 1)).map(_._2).max', "      var max = 0l\n      for (i <-\
    \ 1 until arr.length) {\n        if (arr(i) <= arr(i - 1)) max = i\n      }\n\
    \      return if (max == 0) -1 else max", "        val table = Array.fill(arr.length)(0)\n\
    \        for (i <- 0 until arr.length) table(i) = arr(i).toInt\n        table.sorted.zipWithIndex.maxBy(_._1)._2",
  '        return 0l', "        val a = arr.sortWith(_ < _)\n        val a2 = a.zipWithIndex.map(e\
    \ => (e._1, e._2 + 1))\n        val a3 = a2.zipWithIndex.map(e => (e._1._1, e._1._2\
    \ - e._2))\n        a3.foldLeft((-1l, 0l))((ac, e) => if (e._2 <= 0) ac else (max(ac._1,\
    \ e._2), e._2))._1", '        -1l', "        def helper(arr : List[Long], index\
    \ : Long) : Long = {\n            if (index == arr.length) return -1l\n      \
    \      if (arr(index.toInt) <= arr(max(0, index - 1).toInt)) {\n             \
    \   helper(arr, index + 1)\n            } else {\n                index\n    \
    \        }\n        }\n        helper(arr, 1)", "        val n = arr.length\n\
    \        for (i <- 0 until n) {\n            if (arr(i) > i) {\n             \
    \   val diff = arr(i) - i\n                var j = i + 1\n                while\
    \ (j < n && arr(j) < arr(i)) {\n                    if (arr(j) == diff + j) return\
    \ j\n                    j += 1\n                }\n            }\n        }\n\
    \        -1", "\tif (arr.isEmpty) -1\n\telse {\n\t    val maxIndex = arr.lastIndexOf(arr.max)\n\
    \t    maxIndex match {\n\t\tcase -1 => -1\n\t\tcase _ => {\n\t\t    val left =\
    \ arr.take(maxIndex)\n\t\t    if (left.size < 2) maxIndex\n\t\t    else if (left.max\
    \ >= arr(maxIndex)) -1\n\t\t    else {\n\t\t\tval result = canArrange(left)\n\t\
    \t\tif (result == -1) -1\n\t\t\telse if (arr(result) >= arr(maxIndex)) result\n\
    \t\t\telse maxIndex\n\t\t    }\n\t\t}\n\t    }\n\t}", '        return 0', "  \
    \      val nonEmpty = arr.filter(a => a > 0)\n        if (nonEmpty.length == 0)\
    \ return -1\n        nonEmpty.reduceLeft((a, b) => if (a < b) a else b)", '        -1l',
  "        def recur(l : List[Long], index : Long) : Long = {\n            if (l.size\
    \ == 1) return index\n            val x = l.head\n            val y = l.tail.max\n\
    \            if (x <= y) return recur(l.tail, index + 1)\n            return index\n\
    \        }\n        return recur(arr, -1)", "        val input = new Array[Long](arr.length)\n\
    \        val output = new Array[Long](arr.length)\n        val temp = new Array[Long](arr.length)\n\
    \        val soln = arr.zipWithIndex.map(e => (e._1, e._2, e._1)).toArray\n  \
    \      val len = soln.length\n        for (iter <- 0 until len) {\n          \
    \  for (i <- iter until len) {\n                if (soln(i)._1 > soln(iter)._1)\
    \ {\n                    val temp = soln(i)\n                    soln(i) = soln(iter)\n\
    \                    soln(iter) = temp\n                }\n            }\n   \
    \     }\n        var max = 0\n        for (iter <- 0 until len) {\n          \
    \  for (i <- iter until len) {\n                if (soln(i)._1 == soln(iter)._1)\
    \ {\n                    output(soln(i)._2) = output(soln(iter)._2) + 1\n    \
    \                if (output(soln(i)._2) > max) max = output(soln(i)._2)\n    \
    \            }\n            }\n        }\n        return max", "        if (arr.isEmpty)\
    \ -1l\n        else arr.scanLeft(arr.head)(_ max _).tail.zipWithIndex.foldLeft((-1l,\
    \ arr.head))((r, c) => if (c._1 >= c._2._2) (c._2._1.toLong, c._1) else r)._1",
  "        var m = arr.indices.map(i => (arr(i), i)).toMap\n        for (i <- arr.indices)\
    \ m = m - arr(i)\n        if (m.isEmpty) return -1 else return m.values.max",
  "        arr.indices.reverse.foreach(i => if (arr(i) < arr(i - 1)) return i.toLong)\n\
    \        -1l", "        arr.indices.toList.reverse.foreach(i => {\n          \
    \  if (i - 1 >= 0 && arr(i) < arr(i - 1))\n                return i.toLong\n \
    \       })\n        -1", "        val n = arr.length\n        var stack = new\
    \ Stack[Long]\n        stack.push(arr(0))\n        var indexMap = new HashMap[Long,\
    \ Long]\n        for (i <- 1 until n) {\n            val a = arr(i)\n        \
    \    while (!stack.isEmpty && stack.top >= a) {\n                stack.pop\n \
    \           }\n            if (stack.isEmpty) {\n                indexMap.put(a,\
    \ -1)\n            } else {\n                indexMap.put(a, arr.indexOf(stack.top))\n\
    \            }\n            stack.push(a)\n        }\n        val result = new\
    \ HashMap[Long, Long]\n        for (i <- 0 until n) {\n            val a = arr(i)\n\
    \            val index = indexMap.get(a)\n            if (index != None) {\n \
    \               result.put(i, index.get)\n            }\n        }\n        var\
    \ max = 0l\n        for (i <- 0 until n) {\n            val a = arr(i)\n     \
    \       val index = result.get(i)\n            if (index != None) {\n        \
    \        max = max max (i - index.get)\n            }\n        }\n        max",
  "        val n = arr.length\n        var dp = Array.fill(n)(1)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until i) {\n                if (arr(j)\
    \ <= arr(i)) {\n                    dp(i) = max(dp(i), dp(j) + 1)\n          \
    \      }\n            }\n        }\n        dp.max", "    \tif (arr.length ==\
    \ 0) return -1l\n    \tvar best = -1l\n    \tvar min = arr(0)\n    \tfor (i <-\
    \ 1 until arr.length) {\n    \t\tif (arr(i) <= min) {\n    \t\t\tbest = i.toLong\n\
    \    \t\t\tmin = arr(i)\n    \t\t}\n    \t}\n    \treturn best", "        var\
    \ largest : Long = -1l\n        for (i <- 0 until arr.length) {\n            val\
    \ cur = arr(i)\n            if (i == 0) largest = cur\n            else if (cur\
    \ > largest) largest = cur\n            else return largest\n        }\n     \
    \   return largest", "        val arr2 = arr.zipWithIndex\n        val arr3 =\
    \ arr2.zipWithIndex\n        val ind = arr3.map(x => x._1._2 -> x._2).toMap\n\
    \        var sorted = arr2.sortBy(_._1)\n        val first = sorted.head._2\n\
    \        var last = sorted.last._2\n        if (first != 0) {\n            return\
    \ ind(first)\n        }\n        var prev = sorted.head._1\n        sorted = sorted.tail\n\
    \        while (sorted.nonEmpty) {\n            val cur = sorted.head\n      \
    \      if (cur._1 > prev) {\n                prev = cur._1\n            } else\
    \ {\n                return ind(cur._2)\n            }\n            sorted = sorted.tail\n\
    \        }\n        return -1", "        var maxI = -1\n        var maxE = 0l\n\
    \        for (i <- arr.length - 1 to 0 by -1) {\n            val e = arr(i)\n\
    \            if (e >= maxE) {\n                maxI = i\n                maxE\
    \ = e\n            }\n        }\n        return maxI", '        return -1l;',
  "        val map = HashMap[Long, Long]()\n        for (i <- arr.indices) map(arr(i))\
    \ = i\n        map.values.toList.sorted.toBuffer\n        for (i <- 0 until map.size\
    \ - 1) if (map(arr(i)) > map(arr(i + 1))) return map(arr(i + 1))\n        -1",
  '        -1', "        if (arr.size == 0) return -1\n        var n = arr.size\n\
    \        for (i <- 0 until n) {\n            if (arr(i) >= arr(i - 1)) return\
    \ i - 1\n        }\n        return -1", '        -1l', "        if (arr.isEmpty)\
    \ return -1\n        var largest_index = -1\n        var element = 0\n       \
    \ for (i <- 1 until arr.length) {\n            if (arr(i) < arr(i - 1)) {\n  \
    \              largest_index = i\n                element = arr(i).toInt\n   \
    \         }\n        }\n        for (i <- largest_index + 1 until arr.length)\
    \ {\n            if (arr(i) == element) largest_index = i\n        }\n       \
    \ largest_index", "        val n = arr.length\n        var a = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) a(i) = arr(i).toInt\n        a = a.sorted\n    \
    \    val m = Array.fill(n)(0)\n        var mm = -1\n        for (i <- 0 until\
    \ n) {\n            var l = 0\n            var r = mm\n            while (l <=\
    \ r) {\n                val mid = (l + r) / 2\n                if (a(m(mid)) <\
    \ a(i)) l = mid + 1\n                else r = mid - 1\n            }\n       \
    \     val nl = l\n            m(nl) = i\n            if (nl == mm) mm += 1\n \
    \       }\n        if (mm == -1) -1\n        else m(mm)", "        var m = Map[Long,\
    \ Long]()\n        var result = -1l.toLong\n        for (i <- 0 until arr.length)\
    \ m(arr(i)) = i\n        var lst = arr.sorted\n        for (i <- 0 until lst.length\
    \ - 1) if (m(lst(i)) > m(lst(i + 1))) result = m(lst(i + 1))\n        result",
  "        var output = -1l\n        for (i <- 0 until arr.length - 1) {\n       \
    \     if (arr(i) >= arr(i + 1)) {\n                output = i.toLong\n       \
    \     }\n        }\n        output", "      arr.size match {\n        case 0 =>\
    \ -1\n        case 1 => -1\n        case _ => {\n          val reverseArr = arr.reverse\n\
    \          var index = arr.size - 1\n          while (index >= 0) {\n        \
    \    if (reverseArr(index) < reverseArr(index - 1)) return (arr.size - index -\
    \ 1)\n            index -= 1\n          }\n          -1\n        }\n      }",
  "        val set = arr.toSet\n        for (i <- arr.length - 1 to 0 by -1) {\n \
    \           val s = set.toArray\n            var exist = false\n            for\
    \ (j <- 0 until s.length) {\n                if (s(j) <= arr(i) && arr(i) < arr(i\
    \ - 1)) {\n                    exist = true\n                    break\n     \
    \           }\n            }\n            if (exist) return i.toLong\n       \
    \ }\n        return -1l", "        var b = new ListBuffer[Int]\n        for (i\
    \ <- 1 until arr.length) {\n            if (arr(i) <= arr(i - 1)) b += i\n   \
    \     }\n        if (b.length == 0) -1 else b.max", "        val size = arr.size\n\
    \        var dp = new Array[Long](size)\n        var max = Long.MinValue\n   \
    \     var p = size - 1\n        while (p >= 0) {\n            var i = p - 1\n\
    \            var maxVal = Long.MinValue\n            var maxI = p\n          \
    \  while (i >= 0) {\n                if (arr(i) >= arr(p) && arr(i) > maxVal)\
    \ {\n                    maxVal = arr(i)\n                    maxI = i\n     \
    \           }\n                i -= 1\n            }\n            dp(p) = maxI\n\
    \            max = maxI\n            p -= 1\n        }\n        max", "      \
    \  val x = arr.sliding(2).collect { case List(x, y) if x >= y => x }.toList\n\
    \        if (x.length == 0) -1l else arr.indexOf(x.head)", "        var m = new\
    \ HashMap[Long, Long]\n        for (i <- 0 until arr.length) {\n            if\
    \ (m.contains(arr(i))) {\n                m.put(arr(i), m(arr(i)) + 1)\n     \
    \       } else {\n                m.put(arr(i), 1)\n            }\n        }\n\
    \        var result = -1\n        var keys = m.keys.toList.sorted\n        for\
    \ (i <- 1 until keys.length) {\n            if (keys(i) > keys(i - 1)) {\n   \
    \             result = max(result, keys(i - 1))\n            }\n        }\n  \
    \      if (result == -1) {\n            if (m.contains(1)) {\n               \
    \ result = 0\n            }\n        }\n        result", "        def canArrange(arr\
    \ : List[Long], s : Long) : Long = {\n            arr match {\n              \
    \  case Nil => -1l\n                case x :: xs => if (x >= s) xs.indexOf(arr.min)\
    \ + 1 else canArrange(xs, x)\n            }\n        }\n        canArrange(arr,\
    \ 0l)", '        -1l', "        var max : Long = arr(0)\n        var index : Long\
    \ = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) > max)\
    \ {\n                max = arr(i)\n                index = i\n            }\n\
    \        }\n        return index", "        if (arr.length == 0) {\n         \
    \   return -1l\n        }\n        var maxIndex = -1l\n        for (i <- 0 to\
    \ arr.length - 2) {\n            if (arr(i) <= arr(i + 1)) {\n               \
    \ maxIndex = i.toLong\n            }\n        }\n        return maxIndex", '        return
    arr.indexWhere(x => x >= arr(arr.indexOf(x) - 1))', "        var ans = -1l\n \
    \       var prev = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) <= prev) {\n                ans = i - 1\n                break\n\
    \            }\n            prev = arr(i)\n        }\n        return ans", '        arr.indices.maxBy(i
    => if (i == 0) 0 else min(arr(i - 1), arr(i)))', '        return -1', "      //if\
    \ (arr.last > arr.head) {\n      var first = -1l\n      var index = 0\n      var\
    \ result = -1l\n      for (i <- arr) {\n        if (first == -1l) first = i\n\
    \        else if (i < first) {\n          if (result == -1l) result = index -\
    \ 1\n          else result = max(result, index - 1)\n        }\n        first\
    \ = i\n        index += 1\n      }\n      result", "        def canArrange_helper(arr\
    \ : List[Long], count : Long) : Long = {\n            if (arr.length < 2) return\
    \ -1l\n            if (arr(0) >= arr(1)) return count\n            return canArrange_helper(arr.tail,\
    \ count + 1)\n        }\n        return canArrange_helper(arr, 0)", '        -1l',
  "        val a = arr.toArray\n        val b = arr.reverse.toArray\n        val n\
    \ = a.length\n        val L = Array.fill(n)(0)\n        val R = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            if (i == 0) {\n                L(i)\
    \ = -1\n                R(i) = -1\n            } else {\n                if (a(i)\
    \ <= a(i - 1)) L(i) = L(i - 1)\n                else L(i) = i - 1\n          \
    \      if (b(i) <= b(i - 1)) R(i) = R(i - 1)\n                else R(i) = i -\
    \ 1\n            }\n        }\n        var max = -1\n        for (i <- 0 until\
    \ n) {\n            val j = L(i)\n            val k = R(n - i - 1)\n         \
    \   if (j != -1 && k != -1) {\n                max = max max (j + k)\n       \
    \     }\n        }\n        max", "        def nextVal(vals : List[Long], currentVal\
    \ : Long) : Long = {\n            if (vals.isEmpty) {\n                currentVal\n\
    \            } else {\n                nextVal(vals.tail, if (vals.head <= currentVal)\
    \ currentVal else vals.head)\n            }\n        }\n        var currentVal\
    \ = 0l\n        var index = 0\n        var largestIndex = -1\n        var currentIndex\
    \ = 0\n        for (i <- 0 until arr.length) {\n            currentVal = nextVal(arr.drop(i),\
    \ arr(i))\n            currentIndex = arr.indexOf(currentVal)\n            if\
    \ (currentIndex > largestIndex) {\n                largestIndex = currentIndex\n\
    \            }\n        }\n        largestIndex", "        val n = arr.length\n\
    \        if (n == 0) {\n            -1\n        } else {\n            var x =\
    \ arr(n - 1)\n            var index = -1\n            for (i <- n - 2 to 0 by\
    \ -1) {\n                if (arr(i) <= x) {\n                    x = arr(i)\n\
    \                    index = i\n                }\n            }\n           \
    \ index\n        }", "        val greater = new HashMap[Long, List[Long]]()\n\
    \        for (i <- arr.indices) {\n            for (j <- (i + 1) until arr.length)\
    \ {\n                if (arr(i) < arr(j)) {\n                    if (!greater.contains(arr(i)))\
    \ {\n                        greater(arr(i)) = List[Long]()\n                \
    \    }\n                    greater(arr(i)) = greater(arr(i)) :+ arr(j)\n    \
    \            }\n            }\n        }\n        var result = -1l\n        for\
    \ (i <- arr.indices) {\n            val b = greater.getOrElse(arr(i), List[Long]())\n\
    \            if (b.length == 0) {\n                if (result == -1l) {\n    \
    \                result = arr(i)\n                } else if (result < arr(i))\
    \ {\n                    result = arr(i)\n                }\n            } else\
    \ {\n                val smaller = b.filter((y : Long) => y < arr(i + 1))\n  \
    \              if (smaller.length == 0) {\n                    if (result == -1l)\
    \ {\n                        result = arr(i)\n                    } else if (result\
    \ < arr(i)) {\n                        result = arr(i)\n                    }\n\
    \                }\n            }\n        }\n        result", "        val maxArr\
    \ = new Array[Long](arr.length)\n        maxArr(0) = arr(0)\n        var ans =\
    \ -1l\n        for (i <- 1 until arr.length) {\n            if (arr(i) <= maxArr(i\
    \ - 1)) {\n                ans = i\n            }\n            maxArr(i) = max(maxArr(i\
    \ - 1), arr(i))\n        }\n        ans", "        var indices = ArrayBuffer[Int]()\n\
    \        for (i <- arr.indices) {\n            indices += i\n        }\n     \
    \   var maxIndex = -1\n        for (i <- 0 until arr.length - 1) {\n         \
    \   if (arr(i) <= arr(i + 1)) {\n                indices.remove(i)\n         \
    \   }\n        }\n        if (indices.length > 0) {\n            maxIndex = indices.max\n\
    \        }\n        maxIndex", "\t\tif (arr.size == 1) -1l\n\t\telse {\n\t\t\t\
    var m = scala.collection.mutable.Map[Long, Int]()\n\t\t\tfor (i <- 0 until arr.size)\
    \ m += (arr(i) -> i)\n\t\t\tvar ans = -1l\n\t\t\tfor (i <- 0 until arr.size -\
    \ 1) if (m.contains(arr(i) + 1)) ans = max(ans, m(arr(i) + 1))\n\t\t\tans\n\t\t\
    }", '        -1', "        var current_max = Long.MinValue\n        var index\
    \ = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) <= current_max)\
    \ {\n                index = i\n                current_max = arr(i)\n       \
    \     }\n        }\n        index", "        for (i <- arr.length - 1 to 0 by\
    \ -1) {\n            if (arr(i) >= arr(i - 1)) return i - 1\n        }\n     \
    \   return -1", "      if (arr.length == 0) return -1\n      var current = arr(0)\n\
    \      var max = 0\n      var left = false\n      for (i <- 1 until arr.length)\
    \ {\n        if (arr(i) >= current) {\n          current = arr(i)\n          max\
    \ = i\n          left = true\n        }\n      }\n      if (left) return max\n\
    \      else return -1", "        // if arr.length == 0 return -1\n        if (arr.length\
    \ == 0) {\n            return -1l\n        }\n        // set index to -1\n   \
    \     var index : Long = -1l\n        // set max to -1\n        var max : Long\
    \ = -1l\n        // set prev to arr(0)\n        var prev : Long = arr(0)\n   \
    \     // for i in 1..arr.length - 1\n        for (i <- 1 until arr.length) {\n\
    \            // if arr(i) < prev\n            if (arr(i) < prev) {\n         \
    \       // set max to i\n                max = i\n            }\n            //\
    \ set prev to arr(i)\n            prev = arr(i)\n        }\n        // set prev\
    \ to arr(max)\n        prev = arr(max.toInt)\n        // for i in max - 1..0\n\
    \        for (i <- max.toInt - 1 to 0 by -1) {\n            // if arr(i) < prev\n\
    \            if (arr(i) < prev) {\n                // set index to i\n       \
    \         index = i\n            }\n            // set prev to arr(i)\n      \
    \      prev = arr(i)\n        }\n        // return index\n        return index",
  "        val length = arr.length\n        var i = 1\n        while (i < length)\
    \ {\n            if (arr(i) >= arr(i - 1)) {\n                i += 1\n       \
    \     } else {\n                return i - 1\n            }\n        }\n     \
    \   return -1", "        var i = arr.length - 1\n        while (i > 0) {\n   \
    \         if (arr(i) <= arr(i - 1)) i -= 1\n            else return i\n      \
    \  }\n        return -1", "      val allIndices = arr.indices.toList\n      allIndices.reverse.map(a\
    \ => (a, allIndices.take(a).filter(b => arr(b) <= arr(a)).lastOption)).filter(a\
    \ => a._2.isDefined).maxBy(a => a._2.get)._1", '        return 0l;', "       \
    \ if (arr.length <= 1) return -1\n        var (index, stack) = (0, Stack[Long]())\n\
    \        while (index < arr.length) {\n            if (stack.isEmpty || arr(index)\
    \ < stack.top) stack.push(arr(index))\n            else {\n                while\
    \ (!stack.isEmpty && arr(index) >= stack.top) stack.pop\n                if (stack.isEmpty)\
    \ return index\n                else stack.push(arr(index))\n            }\n \
    \           index += 1\n        }\n        return -1", "        var max = 0\n\
    \        var x = arr.length - 1\n        while (x >= 0) {\n            if (arr(x)\
    \ >= max) {\n                max = arr(x).toInt\n                x -= 1\n    \
    \        } else {\n                return x.toLong\n            }\n        }\n\
    \        return -1", "        for (x <- arr.indices.reverse) {\n            if\
    \ (arr(x) < arr(x - 1)) {\n                return x.toLong;\n            }\n \
    \       }\n        return -1;", "        var maxIndex = -1l\n        var maxValue\
    \ = -1l\n        for (i <- 0 until arr.length - 1) {\n            if (arr(i) >=\
    \ maxValue) {\n                maxValue = arr(i)\n                maxIndex = i\n\
    \            }\n        }\n        maxIndex", "        val indices = for(i <-\
    \ 0 until arr.length - 1) yield {\n            if(arr(i) <= arr(i + 1)) i else\
    \ -1\n        }\n        if(indices.filter(_ != -1).length == 0) -1 else indices.filter(_\
    \ != -1).max", '        arr.zipWithIndex.filter(x => x._1 >= arr.indexOf(x._2)).map(x
    => x._2).max', "        val n = arr.length\n        for (i <- (n - 1) to 0 by\
    \ -1) {\n            if (arr(i) > arr(i - 1)) return i - 1\n        }\n      \
    \  return -1l", "        val a = arr.zipWithIndex.to[Array]\n        val indexes\
    \ = a.sortBy(_._1).map(_._2)\n        val sorted = a.sortBy(_._1).map(_._1)\n\
    \        val b = sorted.zipWithIndex.map(x => (x._1, indexes(x._2))).sortBy(_._2)\n\
    \        var result = -1l\n        for (i <- 1 until b.length) if (b(i)._1 >=\
    \ b(i - 1)._1) result = max(result, b(i)._2)\n        result", "\t\tval ls = arr\n\
    \t\tvar ind = -1\n\t\tfor (i <- 1 until ls.length) if (ls(i - 1) >= ls(i)) ind\
    \ = i\n\t\treturn ind", '        -1', "        def check(arr : List[Long], index\
    \ : Long) : Long = {\n            if (index < arr.length) {\n                val\
    \ max = arr.take(index.toInt + 1).max\n                if (max <= arr(index.toInt))\
    \ check(arr, index + 1)\n                else index\n            }\n         \
    \   else -1\n        }\n        check(arr, 0)", "        var cnt = -1l\n     \
    \   for (i <- 0 until arr.length - 1) {\n            if (arr(i) > arr(i + 1))\
    \ {\n                if (cnt == -1l) cnt = i.toLong\n                else return\
    \ -1l\n            }\n        }\n        return cnt", '        return -1l', " \
    \       val newarr = arr.reverse\n        val max = newarr.max\n        val min\
    \ = newarr.min\n        val range = max - min\n        val set = BitSet()\n  \
    \      var newarr1 = List[Long]()\n        newarr.foreach(x => {\n           \
    \ if (!set.contains(x)) {\n                set.add(x)\n                newarr1\
    \ = x :: newarr1\n            }\n        })\n        var index = -1l\n       \
    \ var i = 0\n        while (i < newarr1.length - 1) {\n            if (newarr1(i)\
    \ <= newarr1(i + 1)) index = i\n            i += 1\n        }\n        index",
  "        if (arr.size < 2) -1l else\n        (arr.size - 1 to 0 by -1).map(i =>\
    \ if (arr(i) >= arr(i - 1)) i else -1).filter(_ != -1).head", "        var result\
    \ = -1l\n        for (i <- 0 until arr.length - 1) {\n            if (arr(i) >=\
    \ arr(i + 1)) {\n                result = i\n            }\n        }\n      \
    \  result", "        val n = arr.length\n        var m = HashMap[Long, Int]()\n\
    \        for (i <- n - 1 to 0 by -1) {\n            if (m.contains(arr(i) - 1))\
    \ {\n                m(arr(i)) = m(arr(i) - 1)\n            } else {\n       \
    \         m(arr(i)) = i\n            }\n        }\n        if (m.contains(arr(0)))\
    \ -1 else m(arr(0))", "        val arrSet = arr.toSet\n        if (arrSet.size\
    \ == 1) -1\n        else {\n            val sortedArr = arr.sortWith(_ < _)\n\
    \            val max = sortedArr.last\n            var i = sortedArr.length -\
    \ 2\n            while (i >= 0) {\n                if (sortedArr(i) < max) return\
    \ i\n                i -= 1\n            }\n            -1\n        }", "    \
    \    var maxIndex = arr.length - 1\n        for (i <- arr.length - 2 to 0 by -1)\
    \ {\n            if (arr(i) > arr(i + 1)) maxIndex = i\n        }\n        return\
    \ maxIndex", "        val n = arr.length\n        val n1 = (n + 1) / 2\n     \
    \   val arr1 = arr.take(n1)\n        val arr2 = arr.drop(n1)\n        var table\
    \ = Array.fill(n2)(0l)\n        for (i <- 0 until n2) {\n            table(i)\
    \ = arr2(i) - arr1(i)\n        }\n        var table = table.sorted\n        var\
    \ count = 0\n        var i = 0\n        var j = n1 - 1\n        while (i < n1\
    \ && j >= 0) {\n            if (table(i) + table(j) >= 0) {\n                count\
    \ += j + 1\n                i += 1\n            } else {\n                j -=\
    \ 1\n            }\n        }\n        count", '        -1l', '        -1l', " \
    \       var i = arr.length - 1\n        while (i > 0) {\n            if (arr(i)\
    \ <= arr(i - 1)) {\n                return i\n            }\n            i -=\
    \ 1\n        }\n        return -1l", '        -1l', "        // write your code\
    \ here\n        return 0l", "        val sorted = arr.zipWithIndex.sortBy(_._1)\n\
    \        val closest = new Array[Int](arr.length)\n        for (i <- arr.indices)\
    \ {\n            val (num, index) = sorted(i)\n            closest(index) = binarySearch(sorted,\
    \ i - 1, num)\n        }\n        var result = -1\n        for (i <- arr.indices)\
    \ {\n            if (closest(i) != -1 && arr(i) != arr(closest(i))) {\n      \
    \          result = i\n            }\n        }\n        result", "        val\
    \ (_, index) = (arr.drop(1).zipWithIndex.map(x => if (x._1 <= arr(x._2)) (true,\
    \ x._2) else (false, -1l)).find(x => x._1).getOrElse((false, -1l)))\n        return\
    \ index", "      val sortedList = arr.sorted\n      var count = 0\n      for (i\
    \ <- 0 until sortedList.length - 1) {\n        if (sortedList(i) == sortedList(i\
    \ + 1)) count += 1\n      }\n      if (count == sortedList.length - 1) return\
    \ sortedList.length - 1\n      var can = true\n      var max = 0\n      for (i\
    \ <- 0 until sortedList.length - 1) {\n        if (sortedList(i) > sortedList(i\
    \ + 1)) can = false\n        if (sortedList(i) <= sortedList(i + 1)) max = i\n\
    \      }\n      if (can) max\n      else -1", "        arr match {\n         \
    \   case x::xs => {\n                var current = x\n                for (i <-\
    \ 1 until arr.length) {\n                    if (arr(i) >= current) {\n      \
    \                  return i - 1l\n                    }\n                    current\
    \ = arr(i)\n                }\n                return -1l\n            }\n   \
    \         case Nil => {\n                return -1l\n            }\n        }",
  "        if (arr.length < 2) return -1l\n        val arrSorted = arr.sorted\n  \
    \      val maxIndex = arrSorted.length - 1\n        var canBuild = maxIndex -\
    \ 1\n        for (i <- 0 to maxIndex - 1) {\n            if (arrSorted(i) >= arrSorted(i\
    \ + 1)) {\n                canBuild = i - 1\n                break\n         \
    \   }\n        }\n        return canBuild", "        var result = -1l\n      \
    \  for (i <- 0 until arr.length - 1) {\n            if (arr(i) >= arr(i + 1))\
    \ {\n                result = i.toLong\n            }\n        }\n        return\
    \ result", "        val index = new HashMap[Long, Int]\n        for(i <- 0 until\
    \ arr.length) index += (arr(i) -> i)\n        val sorted = arr.sorted\n      \
    \  var max = -1\n        for(i <- 1 until sorted.length) {\n            if(sorted(i\
    \ - 1) < sorted(i)) max = max max index(sorted(i))\n        }\n        max", '        -1',
  '        0', "        var s = Stack[Long]()\n        for (v <- arr) {\n        \
    \    if (s.isEmpty || s.top <= v) s.push(v)\n            else if (s.top == v +\
    \ 1) s.pop\n            else return -1\n        }\n        if (s.isEmpty) -1\n\
    \        else arr.indexOf(s.top)", '        -1', "        if (arr.length < 2)\
    \ return -1\n        var arr2 = arr.sortWith((x, y) => x < y)\n        for (i\
    \ <- 0 until arr2.length - 1) {\n            if (arr2(i) < arr2(i + 1)) return\
    \ arr(i + 1)\n        }\n        return -1", "        val arr_sorted = arr.sorted\n\
    \        var largest = -1l\n        for (i <- 0 until arr_sorted.length - 1) {\n\
    \            if (arr_sorted(i) >= arr_sorted(i + 1)) {\n                largest\
    \ = i.toLong\n            }\n        }\n        var idx = 0\n        for (i <-\
    \ arr) {\n            if (i == arr_sorted(largest.toInt)) {\n                return\
    \ idx\n            }\n            idx += 1\n        }\n        return -1l", '        -1l',
  "        val a = arr.toArray\n        // The \"canArrange\" function will determine\
    \ whether it is possible to\n        // sort the array in such a way that the\
    \ value at each index is not\n        // greater than or equal to the value at\
    \ the index immediately before\n        // it in the sorted array.\n        def\
    \ canArrange(x : Array[Long]) : Boolean = {\n            // For simplicity the\
    \ comparison will be done by counting the number\n            // of elements in\
    \ the array which are not greater than the value at\n            // the next index.\
    \ If the array does not contain an element which is\n            // not greater\
    \ than the value at the next index then we know that it\n            // is not\
    \ possible to sort the array in the way we want to. If there\n            // is\
    \ at least one element which is not greater than the value at the\n          \
    \  // next index then we know that the array can be sorted.\n            def notGreaterThanNext(x\
    \ : Array[Long]) : Boolean = {\n                def notGreaterThanNext(x : Array[Long],\
    \ i : Int) : Boolean = {\n                    if (i >= x.length - 1) true\n  \
    \                  else if (x(i) > x(i + 1)) false\n                    else notGreaterThanNext(x,\
    \ i + 1)\n                }\n                notGreaterThanNext(x, 0)\n      \
    \      }\n            // Make a copy of the array.\n            val y = x.clone\n\
    \            // If the array can be sorted in the way we want to then there is\
    \ a\n            // non-negative value which can be assigned to the largest index\n\
    \            // where the value at that index is not greater than the value at\
    \ the\n            // next index in the sorted array.\n            def canArrange(x\
    \ : Array[Long], n : Int) : Boolean = {\n                if (n < 0) false\n  \
    \              else {\n                    // Assign the value at the largest\
    \ index where the value at\n                    // that index is not greater than\
    \ the value at the next index\n                    // in the sorted array to the\
    \ largest value that it can be\n                    // assigned to.\n        \
    \            val t = y(n)\n                    y(n) = y(n + 1) - 1\n         \
    \           // If the array can be sorted the way we want to then", "    \tif\
    \ (arr.length == 0) {\n    \t\treturn -1\n    \t}\n    \tfor (i <- arr.length\
    \ - 1 to 0 by -1) {\n    \t\tif (arr(i) >= arr(i - 1)) {\n    \t\t\treturn i -\
    \ 1\n    \t\t}\n    \t}\n    \treturn -1", '        arr.toArray.indices.map(i
    => arr.drop(i + 1).indexWhere(j => j < arr(i)) + 1).max', "\t\tvar maxIndex =\
    \ -1\n\t\tfor (i <- 1 until arr.length) {\n\t\t\tif (arr(i) <= arr(i - 1)) {\n\
    \t\t\t\tmaxIndex = i - 1\n\t\t\t}\n\t\t}\n\t\tmaxIndex", "        for (i <- arr.length\
    \ - 1 to 0 by -1) {\n            if (arr(i) < arr(i - 1)) return i - 1\n     \
    \   }\n        return -1l", "        def canArrange_rec(arr : List[Long], idx\
    \ : Long) : Long = {\n            if (idx < 0) -1\n            else if (arr(idx.toInt)\
    \ < arr(idx.toInt - 1)) idx\n            else canArrange_rec(arr, idx - 1)\n \
    \       }\n        if (arr.length == 1) -1\n        else canArrange_rec(arr, arr.length\
    \ - 1)", "        val n = arr.length;\n        val dp = new Array[Long](n);\n\
    \        dp(0) = -1;\n        for (i <- 1 until n) {\n            var j = i -\
    \ 1;\n            while (j >= 0 && arr(j) >= arr(i)) {\n                j = dp(j).toInt;\n\
    \            }\n            if (j == -1) dp(i) = -1;\n            else dp(i) =\
    \ j.toLong;\n        }\n        dp(n - 1);", "        for (i <- arr.length - 1\
    \ to 0 by -1) {\n            val ai = arr(i)\n            val aj = arr(i - 1)\n\
    \            if (ai <= aj) {\n                return i.toLong\n            }\n\
    \        }\n        return -1l", '        arr.lastIndexWhere(x => (x <= arr(arr.indexOf(x)
    - 1)))', '        arr.scanLeft(Long.MaxValue)((x, y) => min(x, y)).drop(1).zipWithIndex.maxBy(_._1)._2',
  "        val dp = new Array[Long](arr.length)\n        for (i <- 0 until arr.length)\
    \ {\n            dp(i) = 1\n            for (j <- 0 until i) {\n             \
    \   if (arr(j) >= arr(i)) dp(i) = max(dp(i), dp(j) + 1)\n            }\n     \
    \   }\n        var ans = 0l\n        for (i <- 0 until arr.length) {\n       \
    \     ans = max(ans, dp(i))\n        }\n        ans", "    \t// Write your code\
    \ here\n    \t-1l", "      arr.zipWithIndex.foldLeft((-1l, 0l)){\n        case\
    \ ((prevIndex, prevValue), (currValue, currIndex)) =>\n          if (currValue\
    \ >= prevValue) (currIndex, currValue)\n          else (prevIndex, currValue)\n\
    \      }._1", "        // This solution was obtained from the discussion forum.\n\
    \        // It uses range from 1 to N-1\n        // Where N is the size of arr\n\
    \        // And it uses a new array for the indices of the values\n        //\
    \ And it uses an array for the remainder of (arr(i) - arr(i-1)) % N\n        val\
    \ N = arr.length\n        val indices = (1 to N-1).toArray\n        val remainder\
    \ = new Array[Long](N)\n        remainder(0) = 0\n        var max_diff = 0\n \
    \       for (i <- 1 to N-1) {\n            remainder(i) = (arr(i) - arr(i-1))\
    \ % N\n            max_diff = max(max_diff, remainder(i))\n        }\n       \
    \ if (max_diff == 0) {\n            return -1l\n        }\n        for (i <- 1\
    \ to N-1) {\n            remainder(i) = (remainder(i) + N - remainder(0)) % N\n\
    \        }\n        remainder(0) = 0\n        indices.sortInPlace(remainder)\n\
    \        var p = 0\n        for (i <- 1 to N-1) {\n            if (remainder(i)\
    \ == 0) {\n                p = i\n            }\n        }\n        var len =\
    \ N - remainder(indices(p))\n        if (len == N) {\n            return indices(p)\n\
    \        }\n        var q = (p + 1) % N\n        var cnt = 0\n        while (cnt\
    \ < N) {\n            cnt += 1\n            if (remainder(indices(q)) >= len)\
    \ {\n                p = q\n                len = remainder(indices(p)) - len\n\
    \                if (len == N) {\n                    return indices(p)\n    \
    \            }\n            }\n            q = (q + 1) % N\n        }\n      \
    \  return -1l"]
stop_tokens:
- "\n    }\n"
