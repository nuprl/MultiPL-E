name: HumanEval_11_string_xor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform\
  \ binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"\
  010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String)\
  \ : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
  ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
  0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n   \
  \ }\n\n}\n"
completions: ["        val a_list = a.toList\n        val b_list = b.toList\n    \
    \    def xor_list(a_list : List[Char], b_list : List[Char]) : List[Char] = {\n\
    \            if (a_list.length != b_list.length) {throw new Exception(\"Input\
    \ Lists of different length\")}\n            if (a_list.length == 0) {List()}\n\
    \            else {\n                if (a_list.head == b_list.head) {'0' :: xor_list(a_list.tail,\
    \ b_list.tail)}\n                else {'1' :: xor_list(a_list.tail, b_list.tail)}\n\
    \            }\n        }\n        val result = xor_list(a_list, b_list)\n   \
    \     result.mkString", "        val n = a.length()\n        val c = new StringBuilder()\n\
    \        for (i <- 0 until n) {\n            val x = (a.charAt(i) == '1') ^ (b.charAt(i)\
    \ == '1')\n            c.append(if (x) \"1\" else \"0\")\n        }\n        c.toString()",
  "        if (a.length != b.length) {\n            throw new IllegalArgumentException(\"\
    Cannot XOR string of different lengths.\")\n        }\n        // a ^ b\n    \
    \    a.zip(b).map(x => (x._1.toInt ^ x._2.toInt).toString).mkString", "      \
    \  val n = max(a.length, b.length)\n        var result = Array.fill(n)('0')\n\
    \        for (i <- 0 until n) {\n            result(i) = if (a(i) == b(i)) '0'\
    \ else '1'\n        }\n        result.mkString", "        def inner(a: List[Char],\
    \ b: List[Char], ac: List[Char]): List[Char] = {\n            if (a.isEmpty) {\n\
    \                if (b.isEmpty)\n                    ac\n                else\n\
    \                    inner(a, b.tail, (b.head ^ ac.head) :: ac.tail)\n       \
    \     }\n            else {\n                if (b.isEmpty)\n                \
    \    inner(a.tail, b, (a.head ^ ac.head) :: ac.tail)\n                else\n \
    \                   inner(a.tail, b.tail, (a.head ^ b.head ^ ac.head) :: ac.tail)\n\
    \            }\n        }\n        inner(a.toList, b.toList, List('0')).mkString",
  "        var res = \"\"\n        var a_index = a.length - 1\n        var b_index\
    \ = b.length - 1\n        while (a_index >= 0 || b_index >= 0) {\n           \
    \ val a_bit = if (a_index >= 0) a(a_index) - '0' else 0\n            val b_bit\
    \ = if (b_index >= 0) b(b_index) - '0' else 0\n            res = (a_bit ^ b_bit).toString\
    \ + res\n            a_index -= 1\n            b_index -= 1\n        }\n     \
    \   res", "        if (a.length != b.length) {\n            throw new IllegalArgumentException(\"\
    Arguments should be equal in length\")\n        }\n        val buf = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) {\n    \
    \            buf += '0'\n            } else {\n                buf += '1'\n  \
    \          }\n        }\n        buf.toString", "        val l = a.length\n  \
    \      val res = new StringBuilder()\n        for (i <- 0 until l) {\n       \
    \     if (a(i) == b(i)) res.append(\"0\")\n            else res.append(\"1\")\n\
    \        }\n        res.toString", "        val n = min(a.length, b.length)\n\
    \        var s = \"\"\n        for (i <- 0 until n) {\n            if (a(i) ==\
    \ b(i)) s += \"0\"\n            else s += \"1\"\n        }\n        s", "    \
    \    def xor(x : Char, y : Char) : Char = {\n            if (x == y) '0' else\
    \ '1'\n        }\n        val padded = a.length max b.length\n        val a1 =\
    \ a.reverse.padTo(padded, '0').reverse\n        val b1 = b.reverse.padTo(padded,\
    \ '0').reverse\n        val result = for ((x, y) <- a1 zip b1) yield xor(x, y)\n\
    \        result.mkString", "        assert(a.length == b.length)\n        val\
    \ c = new StringBuilder\n        for (i <- 0 until a.length) {\n            c.append((a(i)\
    \ - '0') ^ (b(i) - '0'))\n        }\n        c.toString", "        var c = \"\"\
    \n        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) {\n   \
    \             c += \"0\"\n            } else {\n                c += \"1\"\n \
    \           }\n        }\n        return c", "        // NOTE: a and b are the\
    \ same length\n        val n = a.length\n        // perform xor on each bit\n\
    \        def go(i : Int, res : String) : String =\n            if (i == n) res\n\
    \            else if (a(i) == b(i)) go(i + 1, res + \"0\")\n            else go(i\
    \ + 1, res + \"1\")\n        go(0, \"\")", "        val out = new StringBuilder()\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) {\n    \
    \            out.append(\"0\")\n            } else {\n                out.append(\"\
    1\")\n            }\n        }\n        out.toString", "        val output = for\
    \ ((x, y) <- a zip b) yield x ^ y\n        output.mkString", "        val aBit\
    \ = BigInt(a, 2)\n        val bBit = BigInt(b, 2)\n        val result = (aBit\
    \ ^ bBit).toString(2)\n        if (result.length < a.length) \"0\" * (a.length\
    \ - result.length) + result\n        else result", "        assert(a.length ==\
    \ b.length)\n        var result = \"\"\n        for (i <- 0 until a.length) {\n\
    \            if (a(i) == b(i)) result += \"0\"\n            else result += \"\
    1\"\n        }\n        return result", "        val s = for (i <- 0 until a.length)\
    \ yield {\n            val a1 = a(i)\n            val b1 = b(i)\n            if\
    \ (a1 == b1) {\n                \"0\"\n            } else {\n                \"\
    1\"\n            }\n        }\n        s.mkString", "        val aBits = a.toList.map(c\
    \ => BigInt(c.toString, 16))\n        val bBits = b.toList.map(c => BigInt(c.toString,\
    \ 16))\n        val xor = aBits.zip(bBits).map(p => p._1 ^ p._2)\n        xor.map(i\
    \ => i.toString(16)).mkString", "        // We assume that the two input strings\
    \ are the same length\n        require(a.length == b.length)\n        def toInt(x\
    \ : Char) : Int = if (x == '0') 0 else 1\n        def toChar(x : Int) : Char =\
    \ if (x == 0) '0' else '1'\n        val charPairs = a.zip(b)\n        val result\
    \ = for (pair <- charPairs) yield toChar(toInt(pair._1) ^ toInt(pair._2))\n  \
    \      result.mkString", "        require(a.length == b.length)\n        a.zip(b).map(x\
    \ => (x._1.toInt ^ x._2.toInt).toString).mkString", "        // a.map(c => b.map(d\
    \ => if (c == d) \"0\" else \"1\").mkString)\n        // a.map(c => b.map(d =>\
    \ if (c == d) 0 else 1).mkString)\n        // a.map(c => b.map(d => (c - '0')\
    \ ^ (d - '0')).mkString)\n        a.map(c => b.map(d => (c - '0') ^ (d - '0')\
    \ + '0').mkString)", "        // Java's XOR: XOR is ^ in java.\n        def boolXor(a\
    \ : Boolean, b : Boolean) : Boolean = {\n            if (a == b) {\n         \
    \       false\n            } else {\n                true\n            }\n   \
    \     }\n        // Convert strings to booleans\n        val aa = a.toCharArray.map(x\
    \ => if (x == '1') true else false)\n        val bb = b.toCharArray.map(x => if\
    \ (x == '1') true else false)\n        // Perform XOR on booleans\n        val\
    \ cc = aa.zip(bb).map(x => boolXor(x._1, x._2))\n        // Convert booleans to\
    \ strings\n        cc.map(x => if (x) \"1\" else \"0\").reduce(_ + _)", "    \
    \    var result = \"\"\n        for (i <- 0 until a.length) {\n            if\
    \ (a(i) == b(i)) {\n                result += \"0\"\n            } else {\n  \
    \              result += \"1\"\n            }\n        }\n        return result",
  '        (a, b).zipped.map(_ ^ _).map(_.toString).reduce(_+_)', "        if (a.length\
    \ != b.length) throw new IllegalArgumentException()\n        var buffer = new\
    \ StringBuilder\n        for (i <- 0 until a.length) {\n            if (a(i) ==\
    \ b(i)) {\n                buffer += '0'\n            } else {\n             \
    \   buffer += '1'\n            }\n        }\n        buffer.toString", "     \
    \   // Bitwise XOR (^)\n        val c = BigInt(a, 2) ^ BigInt(b, 2)\n        c.toString(2)",
  "        val aBits = a.toList.map(_.toString.toInt)\n        val bBits = b.toList.map(_.toString.toInt)\n\
    \        aBits.zip(bBits).map(bitPair => bitPair._1 ^ bitPair._2).mkString", " \
    \       val bits = a.zip(b)\n        val xor = bits.map(i => (i._1, i._2)).map(i\
    \ => i._1.toString.toInt ^ i._2.toString.toInt)\n        return xor.map(i => i.toString).mkString",
  "        var xor = new StringBuilder\n        for (i <- 0 until a.length) {\n  \
    \          xor += a(i) ^ b(i)\n        }\n        return xor.toString", "    \
    \    val len = a.length\n        var c = ArrayBuffer[Char]()\n        for (i <-\
    \ 0 until len) {\n            if (a(i) == b(i)) c += '0'\n            else c +=\
    \ '1'\n        }\n        return c.mkString", "        val c = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            c.append((if (a(i) == '1')\
    \ 1 else 0) ^ (if (b(i) == '1') 1 else 0))\n        }\n        c.toString", " \
    \       var res = \"\"\n        for(i <- 0 until a.length) {\n            res\
    \ += (if(a(i) == b(i)) \"0\" else \"1\")\n        }\n        return res", "  \
    \      if (a.length != b.length) {\n            println(\"Unequal strings\")\n\
    \            return \"\"\n        }\n        val n = a.length\n        var buffer\
    \ = new StringBuilder\n        for (i <- 0 until n) {\n            if (a(i) ==\
    \ b(i)) buffer.append(\"0\")\n            else buffer.append(\"1\")\n        }\n\
    \        buffer.toString", "        // Define the result string.\n        var\
    \ result = \"\"\n        // Loop over each char in both strings.\n        for\
    \ (i <- 0 until a.length) {\n            // Get the chars from string a and b\
    \ at position i.\n            val ai = a.charAt(i)\n            val bi = b.charAt(i)\n\
    \            // Append to result XOR on ai and bi chars.\n            result +=\
    \ (if (ai == bi) '0' else '1')\n        }\n        // Return the result string.\n\
    \        result", "        val result = new StringBuilder\n        for (i <- 0\
    \ until a.length) {\n            if (a(i) == b(i)) result.append(\"0\")\n    \
    \        else result.append(\"1\")\n        }\n        result.toString", "   \
    \     def xor(a : Char, b : Char) : Char = (a, b) match {\n            case ('0',\
    \ '0') => '0'\n            case ('0', '1') => '1'\n            case ('1', '0')\
    \ => '1'\n            case ('1', '1') => '0'\n        }\n        a.zip(b).map(c\
    \ => xor(c._1, c._2)).mkString", "      var c = \"\"\n      for (i <- 0 until\
    \ a.length) {\n        if (a(i) == b(i)) {\n          c += \"0\"\n        } else\
    \ {\n          c += \"1\"\n        }\n      }\n      return c", "        var c\
    \ = new StringBuilder()\n        for (i <- 0 until a.length) {\n            if\
    \ (a(i) == b(i)) c += \"0\"\n            else c += \"1\"\n        }\n        return\
    \ c.toString", "        val length = a.length\n        var result = \"\"\n   \
    \     for (i <- 0 until length) {\n            val x = if (a(i) == '1') 1 else\
    \ 0\n            val y = if (b(i) == '1') 1 else 0\n            val z = x ^ y\n\
    \            result += z.toString\n        }\n        result", "        // Use\
    \ mutable variable to make the code more concise.\n        var c = \"\"\n    \
    \    for (i <- 0 until a.length) {\n            val d = a(i) ^ b(i)\n        \
    \    c += d.toChar\n        }\n        c", "      var result = \"\"\n      for\
    \ (i <- 0 until a.length) {\n        val bitA = a(i)\n        val bitB = b(i)\n\
    \        if (bitA == bitB) result += \"0\"\n        else result += \"1\"\n   \
    \   }\n      result", "      val aBinary : Array[Int] = a.map(_.asDigit).toArray\n\
    \      val bBinary : Array[Int] = b.map(_.asDigit).toArray\n      val cBinary\
    \ : Array[Int] = aBinary.zip(bBinary).map(x => (x._1 ^ x._2))\n      val c : String\
    \ = cBinary.map(_.toString).reduce(_+_)\n      return c", "        if (a.length\
    \ != b.length)\n            throw new IllegalArgumentException(\"inputs are of\
    \ different length\")\n        val aa = a.toList\n        val bb = b.toList\n\
    \        val cc = aa.zip(bb).map({case (x, y) => if (x == y) '0' else '1'})\n\
    \        return cc.mkString", "        var r = \"\";\n        for (i <- 0 until\
    \ min(a.length, b.length)) {\n            r += if (a(i) == b(i)) '0' else '1';\n\
    \        }\n        if (a.length < b.length) r = b.substring(0, b.length - a.length)\
    \ + r;\n        else if (a.length > b.length) r = a.substring(0, a.length - b.length)\
    \ + r;\n        return r;", "        assert(a.length == b.length)\n        val\
    \ len = a.length\n        (0 until len).map(i => (a(i) - '0') ^ (b(i) - '0')).mkString",
  "        var result = \"\"\n        for (i <- 0 until a.length) {\n            val\
    \ aInt = a(i).toString.toInt\n            val bInt = b(i).toString.toInt\n   \
    \         result += (aInt ^ bInt).toString\n        }\n        return result",
  "        var a_array = a.toArray\n        var b_array = b.toArray\n        var result_array\
    \ = Array.fill(a_array.length)(0)\n        for (i <- 0 until a_array.length) {\n\
    \            if (a_array(i) == b_array(i)) result_array(i) = 0\n            else\
    \ result_array(i) = 1\n        }\n        return result_array.mkString", '        (for
    (i <- 0 until a.length) yield (a(i) != b(i)).toString).mkString', "        val\
    \ result = new StringBuilder\n        for (i <- 0 until a.length) {\n        \
    \    if (a(i) == b(i)) result += '0'\n            else result += '1'\n       \
    \ }\n        result.toString", "        if (a.length != b.length) throw new IllegalArgumentException(\"\
    Input strings should have the same length!\")\n        def xor(x : Char, y : Char)\
    \ : Char = if (x == y) '0' else '1'\n        val result = for ((x, y) <- a zip\
    \ b) yield xor(x, y)\n        result.mkString", "      val sb = new StringBuilder\n\
    \      for (i <- 0 until a.length)\n        sb.append((if (a(i) == b(i)) \"0\"\
    \ else \"1\"))\n      sb.toString", "        if (a.size != b.size) throw new Exception(\"\
    Input strings do not have the same length.\")\n        var ret = \"\"\n      \
    \  for (i <- 0 until a.size) {\n            ret += ((a(i) - '0') ^ (b(i) - '0')).toString\n\
    \        }\n        ret", '        a.zip(b).map { case (x, y) => x ^ y }.mkString',
  "        val n = a.length()\n        var res = \"\"\n        for (i <- 0 until n)\
    \ {\n            val a_i = a(i).toString.toInt\n            val b_i = b(i).toString.toInt\n\
    \            res += (a_i ^ b_i).toString\n        }\n        res", '        a.zip(b).map(x
    => (x._1.toInt ^ x._2.toInt).toString).mkString', "        val sb = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append(\"\
    0\")\n            else sb.append(\"1\")\n        }\n        sb.toString", "  \
    \      def loop(a : List[Char], b : List[Char], result : List[Char]) : List[Char]\
    \ = (a, b) match {\n            case (Nil, Nil) => result\n            case (x\
    \ :: xs, y :: ys) => loop(xs, ys, result :+ (if (x == y) '0' else '1'))\n    \
    \    }\n        loop(a.toList, b.toList, Nil).mkString", "        val l = a.length\n\
    \        var r = \"\"\n        for (i <- 0 until l) {\n            if (a(i) ==\
    \ b(i)) r += \"0\"\n            else r += \"1\"\n        }\n        r", "    \
    \    val aBinary = new BigInteger(a, 2)\n        val bBinary = new BigInteger(b,\
    \ 2)\n        val result = aBinary.xor(bBinary)\n        result.toString(2)",
  "        val buf = new StringBuilder\n        val size = a.size\n        for (i\
    \ <- 0 until size) {\n            val ai = a(i).toString.toInt\n            val\
    \ bi = b(i).toString.toInt\n            buf.append((ai + bi) % 2)\n        }\n\
    \        buf.toString", "        var result = \"\"\n        var a_i = 0\n    \
    \    var b_i = 0\n        while (a_i < a.length || b_i < b.length) {\n       \
    \     var r = 0\n            if (a_i < a.length && a(a_i) == '1') {\n        \
    \        r = 1\n            }\n            if (b_i < b.length && b(b_i) == '1')\
    \ {\n                r = 1 - r\n            }\n            result += r.toString\n\
    \            a_i += 1\n            b_i += 1\n        }\n        return result",
  "        val result = new StringBuilder\n        for (i <- 0 until a.length)\n \
    \           result.append((a(i) != b(i)).toString)\n        result.toString",
  "        (for (i <- 0 until a.length) yield if (a(i) == b(i)) '0' else '1').mkString",
  "        // the resulting string must be of the same length\n        assert(a.length\
    \ == b.length)\n        // initialize result\n        var res = new StringBuilder(a.length)\n\
    \        // to each bit of a and b do XOR\n        for (bit <- 0 until a.length)\
    \ {\n            if (a(bit) == b(bit)) res.append(\"0\")\n            else res.append(\"\
    1\")\n        }\n        // return result as a string\n        res.toString",
  "        require(a.length == b.length)\n        for (i <- 0 until a.length) yield\
    \ {\n            if (a(i) == b(i)) \"0\" else \"1\"\n        } mkString(\"\")",
  "        return a.zip(b).map(t => if (t._1 == t._2) '0' else '1').mkString(\"\")",
  "        a.zip(b).map((c : (Char, Char)) => { if (c._1 != c._2) '1' else '0' }).mkString",
  "        var ret = \"\"\n        for (i <- 0 until a.length) {\n            if (a(i)\
    \ == b(i)) ret += \"0\"\n            else ret += \"1\"\n        }\n        return\
    \ ret", "        if (a.length != b.length) {\n            throw new IllegalArgumentException(\"\
    Strings a and b must be of equal length.\")\n        }\n        var xorResult\
    \ = \"\"\n        for (i <- 0 until a.length) {\n            if (a(i) == b(i))\
    \ {\n                xorResult += \"0\"\n            } else {\n              \
    \  xorResult += \"1\"\n            }\n        }\n        return xorResult", '        a.zip(b).map(x
    => (x._1 ^ x._2).toString).mkString', "      if (a.length != b.length) throw new\
    \ IllegalArgumentException(\"Input lengths must be equal\")\n      (for(i <- 0\
    \ until a.length) yield ((a(i) - '0') ^ (b(i) - '0')).toString).mkString", " \
    \       assert(a.length == b.length)\n        (for (i <- 0 until a.length) yield\
    \ (if (a(i) == b(i)) \"0\" else \"1\")).mkString", '        a.zip(b).map(x =>
    (x._1 != x._2).toString).mkString', '      (a zip b).map(x => x._1 ^ x._2).mkString',
  "        require(a.length == b.length)\n        val sb = new StringBuilder\n   \
    \     for (i <- 0 until a.length) {\n            val aBit = a(i) - '0'\n     \
    \       val bBit = b(i) - '0'\n            sb.append((aBit ^ bBit).toString)\n\
    \        }\n        sb.toString", "        val length = a.length\n        var\
    \ result = \"\"\n        for (i <- 0 until length) {\n            if (a(i) ==\
    \ b(i)) {\n                result += \"0\"\n            } else {\n           \
    \     result += \"1\"\n            }\n        }\n        result", "        val\
    \ a = \"010110\"\n        val b = \"101110\"\n        val c = \"111001\"\n   \
    \     val l = a.length\n        var xor = \"\"\n        for (i <- 0 until l) {\n\
    \            val c1 = a(i).toString.toInt\n            val c2 = b(i).toString.toInt\n\
    \            xor += (c1 ^ c2).toString\n        }\n        return xor", '        a.zip(b).map
    { case (x, y) => (x ^ y).toString }.mkString', "        val len = a.length\n \
    \       val charArray = new Array[Char](len)\n        for (i <- 0 until len) {\n\
    \            if (a(i) == b(i)) charArray(i) = '0'\n            else charArray(i)\
    \ = '1'\n        }\n        return new String(charArray)", "        assert(a.length\
    \ == b.length)\n        val ca = a.toCharArray\n        val cb = b.toCharArray\n\
    \        val result = new StringBuilder(ca.length)\n        for (i <- 0 until\
    \ ca.length) {\n            if (ca(i) == cb(i)) result.append('0')\n         \
    \   else result.append('1')\n        }\n        result.toString", '        a.zip(b).map(x
    => (x._1 ^ x._2).toString).reduceLeft(_ + _)', "        (for ((c, d) <- a zip\
    \ b) yield if (c == d) '0' else '1').mkString", "        a.zip(b).map(x => if\
    \ (x._1 == x._2) '0' else '1').mkString", "        // Assert a and b have same\
    \ length.\n        require(a.length == b.length)\n        val r = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            r.append((a(i) == b(i)) match\
    \ {\n                case true => \"0\"\n                case false => \"1\"\n\
    \            })\n        }\n        r.toString", '        a.zip(b).map(p => (p._1,
    p._2)).map(p => p._1 ^ p._2).map(_.toString).reduce(_ + _)', "        a.zip(b).map(x\
    \ => ((x._1 - '0') ^ (x._2 - '0')).toString).mkString", "        val result =\
    \ new Array[Int](max(a.length, b.length))\n        for (i <- 0 until result.length)\
    \ {\n            val x = if (i < a.length) if (a(i) == '1') 1 else 0 else 0\n\
    \            val y = if (i < b.length) if (b(i) == '1') 1 else 0 else 0\n    \
    \        result(i) = (x + y) % 2\n        }\n        result.map(x => x.toString).reduceLeft(_\
    \ + _)", "        val aBitArray = a.split(\"\").map(BitArray(_))\n        val\
    \ bBitArray = b.split(\"\").map(BitArray(_))\n        aBitArray.zip(bBitArray).map(x\
    \ => (x._1 ^ x._2).bitString).mkString", "        def go(a : List[Char], b : List[Char],\
    \ acc : List[Char]) : List[Char] = {\n            if (a.isEmpty)\n           \
    \     acc.reverse\n            else {\n                val s : Int = if (a.head\
    \ == b.head) 0 else 1\n                go(a.tail, b.tail, s :: acc)\n        \
    \    }\n        }\n        go(a.toList, b.toList, Nil).mkString", "        val\
    \ n = a.length\n        val lst = ListBuffer[Char]()\n        for (i <- 0 until\
    \ n) {\n            if (a(i) == b(i)) lst += '0'\n            else lst += '1'\n\
    \        }\n        return lst.mkString", "        var result = \"\"\n       \
    \ for (i <- 0 until a.length) {\n            result += (if (a(i) == b(i)) '0'\
    \ else '1')\n        }\n        return result", "        var res = \"\"\n    \
    \    for (i <- 0 until a.length) {\n            res += if (a(i) == b(i)) '0' else\
    \ '1'\n        }\n        res", '        (a zip b).map { case (a, b) => (a + b).toInt.toString
    }.mkString', "        // assert that lengths are the same\n        assert(a.length\
    \ == b.length)\n        val bXor = a.zip(b).map { case (x, y) => if (x == y) '0'\
    \ else '1' }\n        bXor.mkString", "        val tmp = for (i <- 0 until a.length)\
    \ yield a(i) ^ b(i)\n        tmp.map(_.toString).reduce(_ + _)", "        val\
    \ maxlen = max(a.length, b.length)\n        val result = new StringBuilder\n \
    \       for (i <- 0 until maxlen) {\n            result += ((if (a.charAt(i) ==\
    \ b.charAt(i)) '0' else '1'))\n        }\n        result.toString", "        (for\
    \ (i <- 0 until min(a.length, b.length)) yield ((a(i) - '0') ^ (b(i) - '0')).toString).mkString",
  "        if (a.length != b.length)\n            throw new IllegalArgumentException(\"\
    Bit strings a and b must have the same length!\")\n        var r = \"\"\n    \
    \    for (i <- 0 until a.length) {\n            val c1 = a(i); val c2 = b(i)\n\
    \            val xor = (c1, c2) match {\n                case ('0', '0') => '0'\n\
    \                case ('0', '1') => '1'\n                case ('1', '0') => '1'\n\
    \                case ('1', '1') => '0'\n            }\n            r += xor\n\
    \        }\n        r", "        require(a.length == b.length)\n        val sb\
    \ = new StringBuilder()\n        for (i <- 0 until a.length) {\n            sb.append((a(i)\
    \ - '0') ^ (b(i) - '0'))\n        }\n        sb.toString", "        assert(a.length\
    \ == b.length)\n        (for (i <- 0 until a.length) yield (if (a(i) == b(i))\
    \ \"0\" else \"1\")).mkString", "        val a_ = new BigInt(a, 2)\n        val\
    \ b_ = new BigInt(b, 2)\n        val x = a_ ^ b_\n        x.toString(2)", "  \
    \      val r = new StringBuilder()\n        (a, b).zipped.foreach{\n         \
    \   case('0', '0') => r.append('0')\n            case('0', '1') => r.append('1')\n\
    \            case('1', '0') => r.append('1')\n            case('1', '1') => r.append('0')\n\
    \        }\n        r.toString", "        val bin_a = BigInt(a, 2)\n        val\
    \ bin_b = BigInt(b, 2)\n        val bin_c = bin_a ^ bin_b\n        bin_c.toString(2)",
  "        var result = \"\"\n        for (i <- 0 until a.length) {\n            if\
    \ (a(i) == b(i)) result += \"0\"\n            else result += \"1\"\n        }\n\
    \        return result", "        var ans = \"\"\n        for (i <- 0 until a.length)\
    \ {\n            if (a(i) == b(i)) {\n                ans += \"0\"\n         \
    \   } else {\n                ans += \"1\"\n            }\n        }\n       \
    \ return ans", "        require(a.length == b.length)\n        var res = \"\"\n\
    \        for (i <- 0 until a.length) {\n            res += if (a(i) == b(i)) '0'\
    \ else '1'\n        }\n        res", "        (for (i <- 0 until a.length) yield\
    \ {\n            if (a(i) == b(i)) '0' else '1'\n        }).mkString", "     \
    \   def xor(a : Char, b : Char) : Char = {\n            if (a == b) '0' else '1'\n\
    \        }\n        a.zip(b).map(x => xor(x._1, x._2)).mkString", "        val\
    \ c = new StringBuilder()\n        for (i <- 0 until a.length) {\n           \
    \ if (a(i) == b(i)) {\n                c.append(\"0\")\n            } else {\n\
    \                c.append(\"1\")\n            }\n        }\n        c.toString",
  "        val totalLength = max(a.length, b.length)\n        val paddedA = (\"0\"\
    \ * (totalLength - a.length)) + a\n        val paddedB = (\"0\" * (totalLength\
    \ - b.length)) + b\n        val result = paddedA.zip(paddedB).map(x => ((x._1\
    \ == x._2) match {\n                case true => 0\n                case false\
    \ => 1\n            }).toString).mkString\n        return result", "        val\
    \ sb = new StringBuilder()\n        for (i <- 0 until a.length) {\n          \
    \  if (a(i) == b(i)) sb.append(\"0\")\n            else sb.append(\"1\")\n   \
    \     }\n        sb.toString", "        val xor = Integer.parseInt(a, 2) ^ Integer.parseInt(b,\
    \ 2)\n        return xor.toBinaryString", "        if (a.length != b.length) throw\
    \ new IllegalArgumentException\n        val len = a.length\n        var result\
    \ = \"\"\n        for (i <- 0 until len) {\n            result += (if (a(i) ==\
    \ b(i)) \"0\" else \"1\")\n        }\n        result", "        val arr = a.zip(b)\n\
    \        val res = arr.map(x => ((x._1 == '1') ^ (x._2 == '1')).toString).mkString\n\
    \        res", "        val result : ArrayBuffer[Char] = new ArrayBuffer[Char]\n\
    \        for (i <- 0 until min(a.length, b.length)) {\n            val x = a(i)\n\
    \            val y = b(i)\n            if (x == y) result += '0'\n           \
    \ else result += '1'\n        }\n        result.mkString", "        val length\
    \ = max(a.length, b.length)\n        val a0 = a.padTo(length, '0')\n        val\
    \ b0 = b.padTo(length, '0')\n        (a0, b0).zipped.map {\n            case (x,\
    \ y) => if (x == y) '0' else '1'\n        }.mkString", "      var as = a.split(\"\
    \")\n      var bs = b.split(\"\")\n      as.zip(bs).map(p => (p._1.toInt ^ p._2.toInt).toString).mkString",
  "        require(a.length == b.length)\n        val builder = new StringBuilder()\n\
    \        for (i <- 0 until a.length) {\n            val x = a(i)\n           \
    \ val y = b(i)\n            val res = if (x == y) '0' else '1'\n            builder.append(res)\n\
    \        }\n        builder.toString", "        val len = a.length\n        val\
    \ bInt = Integer.parseInt(b, 2)\n        val aInt = Integer.parseInt(a, 2)\n \
    \       val cInt = aInt ^ bInt\n        val c = cInt.toBinaryString\n        return\
    \ \"0\" * (len - c.length) + c", "        //assert(a.length == b.length)\n   \
    \     (a zip b) map {case (x, y) => if (x == y) '0' else '1'} mkString(\"\")",
  "        val sb = new StringBuilder\n        for (i <- 0 until a.length) {\n   \
    \         if (a(i) == b(i)) sb.append(\"0\")\n            else sb.append(\"1\"\
    )\n        }\n        sb.toString", "        require(a.length == b.length)\n \
    \       val result = new StringBuilder\n        for (i <- 0 until a.length) {\n\
    \            result.append((a(i) - '0') ^ (b(i) - '0'))\n        }\n        result.toString",
  "        val sb = new StringBuilder\n        for (i <- 0 until a.length) {\n   \
    \         if (a(i) == b(i)) sb.append(\"0\")\n            else sb.append(\"1\"\
    )\n        }\n        sb.toString", '        a.zip(b).map(e => (e._1.toInt ^ e._2.toInt).toString).mkString',
  '        (a zip b).map { x => if (x._1 == x._2) "0" else "1" }.mkString', "    \
    \    a.zip(b).map((x : (Char, Char)) => ('0' + ('1' - x._1) + ('1' - x._2) - '0').toChar).mkString",
  "        if (a.length != b.length) throw new IllegalArgumentException(\"a and b\
    \ must be the same length\")\n        else {\n            var output : String\
    \ = \"\"\n            var i : Int = 0\n            while (i < a.length) {\n  \
    \              if (a(i) == b(i)) output += \"0\"\n                else output\
    \ += \"1\"\n                i += 1\n            }\n            return output\n\
    \        }", "        var result = \"\"\n        for(i <- 0 until a.length) {\n\
    \            if(a(i) == b(i)) result += \"0\"\n            else result += \"1\"\
    \n        }\n        return result", "      require(a.length == b.length)\n  \
    \    val aB = a.toList.map(_.toString.toInt)\n      val bB = b.toList.map(_.toString.toInt)\n\
    \      aB.zip(bB).map {case (x, y) => if (x == y) 0 else 1}.mkString", "     \
    \   val ret = new StringBuilder\n        for (i <- 0 until a.length) {\n     \
    \       if (a(i) == b(i)) ret += '0'\n            else ret += '1'\n        }\n\
    \        ret.toString", "        val zipped = a.zip(b)\n        val result = zipped.map(c\
    \ => c._1 ^ c._2)\n        result.map(_.toString).reduceLeft(_+_)", "        require(a.length\
    \ == b.length)\n        (for ((c, d) <- a zip b) yield (c.toInt + d.toInt).toString).mkString",
  "        val ab = a.zip(b)\n        val xor = ab.map(x => x._1 == x._2)\n      \
    \  val xorS = xor.map(x => if (x) \"0\" else \"1\")\n        return xorS.mkString",
  "        // Make the strings the same length.\n        val shorter = min(a.length,\
    \ b.length)\n        val longer = max(a.length, b.length)\n        val a2 = a.reverse.padTo(longer,\
    \ '0').reverse\n        val b2 = b.reverse.padTo(longer, '0').reverse\n      \
    \  val result = new StringBuilder\n        for (i <- 0 until shorter) result.append(if\
    \ (a2(i) == b2(i)) '0' else '1')\n        result.toString", "        def xor(x\
    \ : Int, y : Int) : Int = {\n            if (x == y) 0 else 1\n        }\n   \
    \     val result = new StringBuilder\n        for (i <- 0 until a.length) {\n\
    \            result.append(xor(a(i) - '0', b(i) - '0'))\n        }\n        result.toString",
  "        if (a.size != b.size) {\n            return (\"String sizes do not match.\
    \ \")\n        }\n        var s = \"\"\n        for (i <- 0 until a.size) {\n\
    \            val a_i = a(i).toString.toInt\n            val b_i = b(i).toString.toInt\n\
    \            s += (a_i ^ b_i).toString\n        }\n        return s", '        (for
    (i <- 0 until a.length) yield (a(i) != b(i)).toString).mkString', "        assert(a.length\
    \ == b.length)\n        val result = new StringBuilder()\n        for (i <- 0\
    \ until a.length) {\n            if (a(i) == b(i)) result.append(\"0\")\n    \
    \        else result.append(\"1\")\n        }\n        result.toString", "   \
    \     var result = \"\"\n        for (i <- 0 until a.length) {\n            if\
    \ (a(i) == b(i)) result += \"0\"\n            else result += \"1\"\n        }\n\
    \        return result", "        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            val intA = a(i).toString.toInt\n            val intB\
    \ = b(i).toString.toInt\n            val intC = if (intA == intB) 0 else 1\n \
    \           result += intC.toString\n        }\n        return result", "    \
    \    val ab = a.zip(b)\n        ab.map{case (x, y) => (x.toInt ^ y.toInt).toString}.mkString",
  "        val aBytes = a.toCharArray\n        val bBytes = b.toCharArray\n      \
    \  val cBytes = Array.fill(max(aBytes.length, bBytes.length)) {\n            if\
    \ (aBytes.length > bBytes.length) {\n                if (aBytes(i) == '1')\n \
    \                   if (bBytes(i) == '1')\n                        '0'\n     \
    \               else\n                        '1'\n                else\n    \
    \                bBytes(i)\n            } else {\n                if (bBytes(i)\
    \ == '1')\n                    if (aBytes(i) == '1')\n                       \
    \ '0'\n                    else\n                        '1'\n               \
    \ else\n                    aBytes(i)\n            }\n        }\n        val cString\
    \ = new String(cBytes)\n        return cString", "        val a_n = BigInt(a,\
    \ 2)\n        val b_n = BigInt(b, 2)\n        val c_n = a_n ^ b_n\n        c_n.toString(2)",
  "        val zipped = a.zip(b)\n        zipped.map(c => ((c._1 - '0') ^ (c._2 -\
    \ '0')).toString).mkString", "        if (a.length != b.length) {\n          \
    \  return \"\"\n        }\n        // TODO: Implement method\n        return \"\
    \"", "        require(a.length == b.length)\n        return a.zip(b).map((x :\
    \ (Char, Char)) => (x._1 ^ x._2).toChar).mkString", "        var c = \"\"\n  \
    \      for (i <- 0 until a.length) {\n            if (a(i) == b(i)) {\n      \
    \          c += \"0\"\n            } else {\n                c += \"1\"\n    \
    \        }\n        }\n        return c", "        var c = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) c += \"0\"\n         \
    \   else c += \"1\"\n        }\n        return c", "        a.zip(b).map(f =>\
    \ if (f._1 == f._2) '0' else '1').mkString", "        if (a.length() != b.length())\
    \ {\n            println(\"Error: String lengths not equal. Exit.\")\n       \
    \     return \"\"\n        }\n        var result = ArrayBuffer[Char]()\n     \
    \   for (i <- 0 until a.length()) {\n            if (a(i) == b(i)) result += '0'\n\
    \            else result += '1'\n        }\n        return result.mkString", " \
    \       var result = \"\"\n        for (i <- 0 until a.length)\n            result\
    \ += (if (a(i) == b(i)) \"0\" else \"1\")\n        return result", "        var\
    \ result = Array[String]()\n        var i = 0\n        while (i < a.length) {\n\
    \            if (a(i) == b(i)) result = result :+ \"0\"\n            else result\
    \ = result :+ \"1\"\n            i += 1\n        }\n        return result.mkString",
  "        var result = \"\"\n        for (i <- 0 until a.length) {\n            result\
    \ += (if (a(i) == b(i)) '0' else '1')\n        }\n        return result", "  \
    \      require(a.length == b.length)\n        val aBitArray = a.map { _.asDigit\
    \ }.toArray\n        val bBitArray = b.map { _.asDigit }.toArray\n        val\
    \ resultBitArray = new Array[Int](a.length)\n        for (i <- 0 until a.length)\
    \ {\n            resultBitArray(i) = (aBitArray(i) + bBitArray(i)) % 2\n     \
    \   }\n        resultBitArray.mkString", "        val result = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append(\"\
    0\")\n            else result.append(\"1\")\n        }\n        result.toString",
  "        // We assume both inputs are the same length.\n        assert(a.length\
    \ == b.length)\n        val n = a.length\n        val result = new StringBuilder()\n\
    \        for (i <- 0 until n) {\n            result += (if (a(i) == b(i)) \"0\"\
    \ else \"1\")\n        }\n        result.toString", "        val al = a.toList\n\
    \        val bl = b.toList\n        val cl = (al zip bl).map((x) => if (x._1 ==\
    \ x._2) '0' else '1')\n        cl.mkString", "        if (a.length != b.length)\
    \ throw new Error(\"a and b must be of equal length.\")\n        val c = new StringBuilder(a.length)\n\
    \        for (i <- 0 until a.length) {\n            c.append(if (a(i) == b(i))\
    \ '0' else '1')\n        }\n        c.toString", "        val len : Int = a.length()\n\
    \        var res : String = \"\"\n        for (i <- 0 until len) {\n         \
    \   if (a(i) == b(i)) res += \"0\"\n            else res += \"1\"\n        }\n\
    \        return res", "        val a1 = a.toList\n        val b1 = b.toList\n\
    \        (a1 zip b1).map(p => (p._1, p._2)).map(p => p match {\n            case\
    \ ('0', '0') => '0'\n            case ('1', '1') => '0'\n            case ('0',\
    \ '1') => '1'\n            case ('1', '0') => '1'\n        }).mkString", "   \
    \     val ai = a.toList.map(_.toString.toInt)\n        val bi = b.toList.map(_.toString.toInt)\n\
    \        val xor = for {\n            i <- 0 until ai.length\n        } yield\
    \ (ai(i) ^ bi(i)).toString\n        xor.mkString", "        val l = min(a.length,\
    \ b.length)\n        val c = new StringBuilder\n        for (i <- 0 until l) {\n\
    \            if (a(i) == b(i)) {\n                c.append(\"0\")\n          \
    \  } else {\n                c.append(\"1\")\n            }\n        }\n     \
    \   return c.toString", "        def zipped_array = a.zip(b)\n        def xor_lst\
    \ = zipped_array.map(x => if (x._1 == x._2) '0' else '1')\n        xor_lst.mkString",
  "        var c = \"\"\n        for (i <- 0 until a.length) {\n            c += (if\
    \ (a(i) == b(i)) \"0\" else \"1\")\n        }\n        return c", "        var\
    \ result = new StringBuilder()\n        var i = 0\n        while (i < a.length)\
    \ {\n            if (a(i) == b(i)) result.append(\"0\")\n            else result.append(\"\
    1\")\n            i += 1\n        }\n        return result.toString", "      \
    \  val c = for ((x, y) <- a zip b) yield (if (x == y) \"0\" else \"1\")\n    \
    \    c.mkString", "        var res = \"\"\n        for (i <- 0 until a.length)\
    \ res += (if (a(i) == b(i)) \"0\" else \"1\")\n        res", "        val r =\
    \ new StringBuilder()\n        for(i <- 0 until a.length) {\n            if(a(i)\
    \ == b(i)) r.append(\"0\")\n            else r.append(\"1\")\n        }\n    \
    \    r.toString", "        // This is the fastest way.\n        //((a.toInt(2)\
    \ ^ b.toInt(2)).toBinaryString)\n        // This is the longest way.\n       \
    \ (((a zip b) map {case (x, y) => if (x == y) \"0\" else \"1\"}).mkString)", " \
    \       a.zip(b).map(p => (p._1 == p._2) match {\n            case true => '0'\n\
    \            case false => '1'\n        }).mkString", "        val n = a.length\n\
    \        var result = new StringBuilder\n        for (i <- 0 until n) {\n    \
    \        if (a(i) == b(i)) result.append(\"0\")\n            else result.append(\"\
    1\")\n        }\n        result.toString", "        val result = new StringBuilder\n\
    \        var i = 0\n        while (i < a.length) {\n            val x = a(i)\n\
    \            val y = b(i)\n            if (x == y) result.append(\"0\")\n    \
    \        else result.append(\"1\")\n            i += 1\n        }\n        result.toString",
  "        val zipped = a.zip(b)\n        zipped.map { case (x, y) =>\n          \
    \  val t = x.toInt ^ y.toInt\n            t.toString\n        }.mkString", '      (a,
    b).zipped.map((x, y) => if (x == y) "0" else "1").mkString', "        val xor\
    \ = BigInt(a, 2) ^ BigInt(b, 2)\n        return xor.toString(2)", "        val\
    \ result = new StringBuilder\n        for(i <- 0 until a.length) {\n         \
    \   if(a(i) == b(i)) result.append(\"0\")\n            else result.append(\"1\"\
    )\n        }\n        result.toString", "        var result = \"\"\n        for\
    \ (i <- 0 until a.length) {\n            result += if (a(i) == b(i)) \"0\" else\
    \ \"1\"\n        }\n        return result", "        (a zip b).map(x => ((x._1\
    \ - '0') ^ (x._2 - '0')).toString).mkString", "        assert(a.length == b.length)\n\
    \        val a_list = a.split(\"\").toList\n        val b_list = b.split(\"\"\
    ).toList\n        return (a_list zip b_list).map(t => (t._1.toInt + t._2.toInt)\
    \ % 2).mkString(\"\")", "        if (a.length != b.length) throw new IllegalArgumentException(\"\
    String lengths differ: \" + a.length + \" != \" + b.length)\n        var result\
    \ = \"\"\n        for (i <- 0 until a.length) {\n            if (a(i) == b(i))\
    \ {\n                result += \"0\"\n            } else {\n                result\
    \ += \"1\"\n            }\n        }\n        return result", "        a.zip(b).map\
    \ {case (i, j) => if ((i == '1') ^ (j == '1')) '1' else '0'}.mkString", "    \
    \    var result = \"\"\n        for (i <- 0 until a.length) {\n            if\
    \ (a(i) == b(i)) result += \"0\"\n            else result += \"1\"\n        }\n\
    \        return result", "        val aN = a.length\n        val bN = b.length\n\
    \        var maxN = max(aN, bN)\n        var minN = min(aN, bN)\n        var str\
    \ = \"\"\n        var A = a\n        var B = b\n        if (aN > bN) {\n     \
    \       B = b.padTo(aN, '0')\n        } else if (aN < bN) {\n            A = a.padTo(bN,\
    \ '0')\n        }\n        for (i <- 0 until maxN) {\n            if (A(i) ==\
    \ B(i)) {\n                str += \"0\"\n            } else {\n              \
    \  str += \"1\"\n            }\n        }\n        str", "        var c = \"\"\
    \n        for (i <- 0 until a.length)\n            c += (if (a(i) == b(i)) \"\
    0\" else \"1\")\n        return c", "        require(a.length == b.length)\n \
    \       val n = a.length\n        val result = Array.fill(n)('0')\n        for\
    \ (i <- 0 until n) {\n            result(i) = ('0' + ('1' - a(i)) * ('1' - b(i))).toChar\n\
    \        }\n        result.mkString", "        //split string by each character\n\
    \        val a_split = a.split(\"\")\n        val b_split = b.split(\"\")\n  \
    \      //initialize new string to return\n        var ret = \"\"\n        for\
    \ (i <- 0 until a_split.length) {\n            if ((a_split(i) == \"1\" && b_split(i)\
    \ == \"0\") || (a_split(i) == \"0\" && b_split(i) == \"1\")) {\n             \
    \   ret += \"1\"\n            } else {\n                ret += \"0\"\n       \
    \     }\n        }\n        ret", "        a.zip(b).map((i) => if (i._1 == i._2)\
    \ '0' else '1').mkString", '        (a zip b) map { case (x, y) => (x.toInt ^
    y.toInt).toString } mkString ""', "      if (a.length != b.length)\n        throw\
    \ new Exception(\"You must pass two strings of the same length\")\n      return\
    \ a.zip(b).map(x => (x._1 ^ x._2).toString).mkString", "        var output : String\
    \ = \"\"\n        for (i <- 0 until a.length) {\n            val ai = a(i).toString.toInt\n\
    \            val bi = b(i).toString.toInt\n            val oi = ai ^ bi\n    \
    \        output += oi.toString\n        }\n        return output", "        assert(a.length\
    \ == b.length)\n        a.zip(b).map(x => (x._1 == x._2) match {\n           \
    \ case true => \"0\"\n            case false => \"1\"\n        }).mkString", '        a.toList.zip(b.toList).map(x
    => (x._1.toString.toInt ^ x._2.toString.toInt).toString).mkString', "        require(a.length\
    \ == b.length)\n        val result = new StringBuilder()\n        for (i <- 0\
    \ until a.length) {\n            val x = a(i)\n            val y = b(i)\n    \
    \        if (x == y) result.append(\"0\")\n            else result.append(\"1\"\
    )\n        }\n        result.toString", "        def stringXor(a : String, b :\
    \ String, result : String) : String = {\n            if (a.length == 0) result\n\
    \            else stringXor(a.substring(1), b.substring(1), result + (if (a(0)\
    \ == b(0)) '0' else '1'))\n        }\n        stringXor(a, b, \"\")", "      \
    \  val xor = a.toInt(2) ^ b.toInt(2)\n        xor.toBinaryString", "        val\
    \ as = a.split(\"\").map(_.toInt)\n        val bs = b.split(\"\").map(_.toInt)\n\
    \        val l = as.length\n        val cs = (for (i <- 0 until l) yield as(i)\
    \ ^ bs(i)).map(_.toString).reduce(_ + _)\n        cs", "        require(a.length\
    \ == b.length)\n        val result = for (i <- 0 until a.length) yield {\n   \
    \         val x = a(i)\n            val y = b(i)\n            val intX = if (x\
    \ == '0') 0 else 1\n            val intY = if (y == '0') 0 else 1\n          \
    \  if (intX == intY) '0' else '1'\n        }\n        result.mkString", "    \
    \    var result = \"\"\n        var i = 0\n        while (i < a.length) {\n  \
    \          result += (((a(i) - '0') ^ (b(i) - '0')) + '0').toChar\n          \
    \  i += 1\n        }\n        return result", "        def xor(i : Int, j : Int)\
    \ : Int = {\n            if (i == j) {\n                0\n            } else\
    \ {\n                1\n            }\n        }\n        require(a.length ==\
    \ b.length)\n        val c = for (i <- 0 until a.length) yield xor(a(i).asDigit,\
    \ b(i).asDigit)\n        c.mkString"]
stop_tokens:
- "\n    }\n"
