name: HumanEval_39_prime_fib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\
  \    // >>> primeFib((1l))\n    // (2l)\n    // >>> primeFib((2l))\n    // (3l)\n\
  \    // >>> primeFib((3l))\n    // (5l)\n    // >>> primeFib((4l))\n    // (13l)\n\
  \    // >>> primeFib((5l))\n    // (89l)\n    def primeFib(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) ==\
  \ (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n\
  \    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n  \
  \  assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n \
  \   assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n\
  \    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"
completions: ["        var f2 = 2l;\n        var f1 = 3l;\n        var i = 1l;\n \
    \       while (i != n) {\n            val f0 = f1 + f2;\n            f2 = f1;\n\
    \            f1 = f0;\n            if (f0 % 2 != 0 && f0 % 3 != 0 && f0 % 5 !=\
    \ 0 && f0 % 7 != 0 && f0 % 11 != 0 && f0 % 13 != 0 && f0 % 17 != 0 && f0 % 19\
    \ != 0 && f0 % 23 != 0 && f0 % 29 != 0 && f0 % 31 != 0 && f0 % 37 != 0 && f0 %\
    \ 41 != 0 && f0 % 43 != 0 && f0 % 47 != 0 && f0 % 53 != 0 && f0 % 59 != 0 && f0\
    \ % 61 != 0 && f0 % 67 != 0 && f0 % 71 != 0 && f0 % 73 != 0 && f0 % 79 != 0 &&\
    \ f0 % 83 != 0 && f0 % 89 != 0 && f0 % 97 != 0 && f0 % 101 != 0 && f0 % 103 !=\
    \ 0 && f0 % 107 != 0 && f0 % 109 != 0 && f0 % 113 != 0 && f0 % 127 != 0 && f0\
    \ % 131 != 0 && f0 % 137 != 0 && f0 % 139 != 0 && f0 % 149 != 0 && f0 % 151 !=\
    \ 0 && f0 % 157 != 0 && f0 % 163 != 0 && f0 % 167 != 0 && f0 % 173 != 0 && f0\
    \ % 179 != 0 && f0 % 181 != 0 && f0 % 191 != 0 && f0 % 193 != 0 && f0 % 197 !=\
    \ 0 && f0 % 199 != 0 && f0 % 211 != 0 && f0 % 223 != 0 && f0 % 227 != 0 && f0\
    \ % 229 != 0 && f0 % 233 != 0 && f0 % 239 != 0 && f0 % 241 != 0 && f0 % 251 !=\
    \ 0 && f0 % 257 != 0 && f0 % 263 != 0 && f0 % 269 != 0 && f0 % 271 != 0 && f0\
    \ % 277 != 0 && f0 % 281 != 0 && f0 % 283 != 0 && f0 % 293 != 0 && f0 % 307 !=\
    \ 0 && f0 % 311", "        def recur(n : Long, v0 : Long, v1 : Long, current :\
    \ Long) : Long = n match {\n            case 0 => v0\n            case _ => if\
    \ (current.isPrime) recur(n - 1, v1, v0 + v1, current + 1) else recur(n, v0, v1,\
    \ current + 1)\n        }\n        recur(n, 2, 3, 3)", "    \tval fib = Array.ofDim[Long](20000)\n\
    \    \tfib(0) = 2\n    \tfib(1) = 3\n    \tvar i = 2\n    \twhile (i < 20000)\
    \ {\n    \t\tfib(i) = fib(i - 1) + fib(i - 2)\n    \t\ti += 1\n    \t}\n    \t\
    val isPrime = Array.ofDim[Boolean](1000000)\n    \ti = 0\n    \twhile (i < 1000000)\
    \ {\n    \t\tisPrime(i) = true\n    \t\ti += 1\n    \t}\n    \tisPrime(0) = false\n\
    \    \tisPrime(1) = false\n    \tval primes = ArrayBuffer[Long]()\n    \ti = 2\n\
    \    \twhile (i < 1000000) {\n    \t\tif (isPrime(i)) {\n    \t\t\tprimes += i\n\
    \    \t\t\tvar j = i * 2\n    \t\t\twhile (j < 1000000) {\n    \t\t\t\tisPrime(j)\
    \ = false\n    \t\t\t\tj += i\n    \t\t\t}\n    \t\t}\n    \t\ti += 1\n    \t\
    }\n    \tvar p = 0\n    \twhile (p < 20000) {\n    \t\tif (primes.contains(fib(p)))\
    \ {\n    \t\t\tn -= 1\n    \t\t\tif (n == 0) return fib(p)\n    \t\t}\n    \t\t\
    p += 1\n    \t}\n    \treturn -1", "        var count = 0\n        var p = 2l\n\
    \        while (count < n) {\n            p = Helper.nextPrime(p)\n          \
    \  if (Helper.isFib(p)) {\n                count += 1\n            }\n       \
    \ }\n        return p", "        var fib : Seq[Long] = Stream.iterate((0l, 1l))((p)\
    \ => (p._2, p._1 + p._2)).map((p) => p._2)\n        var count : Long = 0\n   \
    \     for (i <- fib) {\n            if (i.isPrime) {\n                count +=\
    \ 1\n                if (count == n) return i\n            }\n        }\n    \
    \    return 0", "        var a = 2L;\n        var b = 3L;\n        var index =\
    \ 2L;\n        while ({\n            {\n                index += 1;\n        \
    \        index - 1\n            }\n        } < n) {\n            {\n         \
    \       var c = a + b;\n                if (isPrime(c)) {\n                  \
    \  a = b;\n                    b = c;\n                    index += 1\n      \
    \          } \n            }\n        }\n        b", "        def fib(m : Long)\
    \ : Long = {\n            if (m == 0) {\n                0\n            } else\
    \ if (m == 1) {\n                1\n            } else {\n                fib(m\
    \ - 1) + fib(m - 2)\n            }\n        }\n        val f = new ArrayBuffer[Long]();\n\
    \        val maxFib = fib(n);\n        var i = 0;\n        while (fib(i) <= maxFib)\
    \ {\n            f += fib(i);\n            i += 1;\n        }\n        val p =\
    \ Prime.primes(maxFib);\n        val primeFib = new ArrayBuffer[Long]();\n   \
    \     for (i <- f) {\n            if (p.contains(i)) {\n                primeFib\
    \ += i;\n            }\n        }\n        primeFib(n.toInt - 1);", "      def\
    \ isPrime(i : Long) : Boolean = {\n        if (i < 2) return false\n        if\
    \ (i == 2) return true\n        if (i % 2 == 0) return false\n        var j =\
    \ 3\n        while (j * j <= i) {\n          if (i % j == 0) return false\n  \
    \        j += 2\n        }\n        return true\n      }\n      def primeFibStream()\
    \ : Stream[Long] = {\n        def loop(h : Long, h2 : Long) : Stream[Long] = {\n\
    \          val n = h + h2\n          n #:: loop(h2, n)\n        }\n        2l\
    \ #:: 3l #:: loop(2l, 3l)\n      }\n      var i = 1l\n      var c = primeFibStream\n\
    \      while (i < n) {\n        c = c.tail\n        i += 1\n      }\n      c.head",
  "        if (n < 1) throw new IllegalArgumentException\n        val res = new ArrayBuffer[Long]()\n\
    \        val fib = new FibonacciSequence()\n        while (res.length < n) {\n\
    \            val v = fib.next()\n            if (v.isPrime) res += v\n       \
    \ }\n        res(n.toInt - 1)", "        var f = new Array[Long](100)\n      \
    \  var p = new Array[Boolean](100)\n        f(0) = 2; f(1) = 3; f(2) = 5; f(3)\
    \ = 13; f(4) = 89;\n        p(0) = true; p(1) = true; p(2) = true; p(3) = true;\
    \ p(4) = true;\n        var count = 5\n        var nth = 5\n        var x = 0l\n\
    \        while (count < n) {\n            x = f(nth - 1) + f(nth - 2)\n      \
    \      var fx = factor(x)\n            if (fx.length == 1) {\n               \
    \ f(count) = x\n                p(count) = true\n                count += 1\n\
    \            }\n            nth += 1\n        }\n        return f(count - 1)",
  "        def fibs(m : Long) : List[Long] = {\n            if (m == 0) List(1)\n\
    \            else if (m == 1) List(1, 2)\n            else {\n               \
    \ val xs = fibs(m - 1)\n                xs :+ (xs(xs.length - 1) + xs(xs.length\
    \ - 2))\n            }\n        }\n        def primes(n : Long) : List[Long] =\
    \ {\n            def loop(i : Long, primes : List[Long]) : List[Long] = {\n  \
    \              if (primes.length == n) primes\n                else {\n      \
    \              if (primes.forall(p => i % p != 0)) loop(i + 1, primes :+ i)\n\
    \                    else loop(i + 1, primes)\n                }\n           \
    \ }\n            loop(2, List())\n        }\n        def isPrime(n : Long) : Boolean\
    \ = {\n            primes(10000).forall(p => n % p != 0)\n        }\n        fibs(1000).filter(isPrime)(n.toInt\
    \ - 1)", "        var index = 0l\n        var i = 2l\n        var j = 3l\n   \
    \     var k = 0l\n        while (index < n) {\n            k = i + j\n       \
    \     i = j\n            j = k\n            if (P46.isPrime(i)) index += 1\n \
    \       }\n        return i", "        var count = 0l\n        var fib = 0l\n\
    \        var oldFib = 0l\n        var oldOldFib = 0l\n        while (count < n)\
    \ {\n            oldOldFib = oldFib\n            oldFib = fib\n            fib\
    \ = oldFib + oldOldFib\n            if (fib < 2) fib = 1\n            if (fib\
    \ == 2) count += 1\n            else if (fib % 2 == 1 && pow(3, (fib - 1) / 2).toLong\
    \ % fib == 1) count += 1\n        }\n        return fib", "        val primes\
    \ = {\n            val buf = new ArrayBuffer[Long]\n            buf += 2\n   \
    \         buf\n        }\n        val fibs = {\n            val buf = new ArrayBuffer[Long]\n\
    \            buf += 2\n            buf += 3\n            buf\n        }\n    \
    \    def gen : Unit = {\n            val next = fibs(fibs.length - 1) + fibs(fibs.length\
    \ - 2)\n            if (n <= fibs.length) return\n            if (isPrime(next))\
    \ primes += next\n            fibs += next\n            gen\n        }\n     \
    \   gen\n        primes(primes.length - 1)", "        val ps = sieve(1000000)\n\
    \        def fib(k : Long) : Long = {\n            def fib2(k : Long, a : Long,\
    \ b : Long) : Long = if (k == n) b else fib2(k + 1, b, a + b)\n            fib2(1,\
    \ 0, 1)\n        }\n        def loop(n : Long, m : Long) : Long = if (ps(m)) loop(n\
    \ + 1, m + 1) else loop(n, m + 1)\n        fib(loop(0, 0))", "      var a : Long\
    \ = 1\n      var b : Long = 1\n      var i : Long = 1\n      while (i < n) {\n\
    \        {\n          val c : Long = a + b\n          if (isPrime(c)) {\n    \
    \        i += 1\n          }\n          a = b\n          b = c\n        }\n  \
    \    }\n      return b", "        var primeFibSeq : Seq[Long] = Seq(2l, 3l)\n\
    \        while (primeFibSeq.length < n) {\n            var fibNum = primeFibSeq(primeFibSeq.length\
    \ - 1) + primeFibSeq(primeFibSeq.length - 2)\n            if (Utils.isPrime(fibNum))\
    \ {\n                primeFibSeq = primeFibSeq :+ fibNum\n            }\n    \
    \    }\n        return primeFibSeq(primeFibSeq.length - 1)", "        // genFibs\
    \ returns a list of Fibonacci numbers\n        // >>> genFibs((100l))\n      \
    \  // List((2l), (3l), (5l), (8l), (13l), (21l), (34l), (55l), (89l))\n      \
    \  def genFibs(n : Long) : List[Long] = {\n            var fibs = new ListBuffer[Long]\n\
    \            fibs += (1l)\n            fibs += (2l)\n            for (i <- 2l\
    \ until n) {\n                fibs += (fibs(i.toInt - 1) + fibs(i.toInt - 2))\n\
    \            }\n            fibs.toList\n        }\n        // isPrime returns\
    \ whether n is prime or not\n        // >>> isPrime((1l))\n        // false\n\
    \        // >>> isPrime((2l))\n        // true\n        // >>> isPrime((3l))\n\
    \        // true\n        // >>> isPrime((4l))\n        // false\n        // >>>\
    \ isPrime((5l))\n        // true\n        // >>> isPrime((6l))\n        // false\n\
    \        // >>> isPrime((7l))\n        // true\n        // >>> isPrime((8l))\n\
    \        // false\n        // >>> isPrime((9l))\n        // false\n        //\
    \ >>> isPrime((10l))\n        // false\n        // >>> isPrime((11l))\n      \
    \  // true\n        // >>> isPrime((12l))\n        // false\n        // >>> isPrime((13l))\n\
    \        // true\n        // >>> isPrime((14l))\n        // false\n        //\
    \ >>> isPrime((15l))\n        // false\n        // >>> isPrime((16l))\n      \
    \  // false\n        // >>> isPrime((17l))\n        // true\n        // >>> isPrime((18l))\n\
    \        // false\n        // >>> isPrime((19l))\n        // true\n        //\
    \ >>> isPrime((20l))\n        // false\n        def isPrime(n : Long) : Boolean\
    \ = {\n            if (n == 1l) {\n                return false\n            }\n\
    \            val r = floor(sqrt(n))\n            for (i <- 2l", "        val result\
    \ = new ListBuffer[Long]();\n        var next = 2l;\n        while (result.length\
    \ < n) {\n            if (isPrime(next) && isFib(next)) {\n                result\
    \ += next;\n            }\n            next += 1;\n        }\n        return result(n.toInt\
    \ - 1);", "        val m = 200000\n        val primes = Prime.primes(m)\n    \
    \    val isPrime = Prime.primeArray(m)\n        val fib = new Array[Long](m)\n\
    \        fib(0) = 1l\n        fib(1) = 2l\n        var i = 2\n        while (fib(i\
    \ - 1) <= primes(primes.length - 1)) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        fib.take(i - 1).filter(f => isPrime(f.toInt)).apply(n.toInt\
    \ - 1)", "        val fibs = new Fibonacci(BigInt(\"1000000000\"))\n        return\
    \ fibs.toStream.filter(x => isPrime(x.toLong)).drop(n.toInt - 1).head.toLong",
  "        var primes = sieveOfAtkin(List[Long](2l, 3l, 5l, 7l), 100000000l, 100000000l)._1\n\
    \        var fibs = List[Long](2l, 3l, 5l)\n        var l = 3l\n        var c\
    \ = 5l\n        while (l < n) {\n            c = fibs(fibs.length - 1) + fibs(fibs.length\
    \ - 2)\n            fibs = fibs ++ List(c)\n            if (primes.contains(c))\
    \ l = l + 1\n        }\n        c", "        def primeFibIter(a : Long, b : Long,\
    \ n : Long, count : Long) : Long = if (n == count) b else if (BigInt(b).isProbablePrime(10))\
    \ primeFibIter(b, a + b, n, count + 1) else primeFibIter(b, a + b, n, count)\n\
    \        primeFibIter(0, 1, n, 1)", "        if (n == 1) {\n            return\
    \ 2l\n        }\n        if (n == 2) {\n            return 3l\n        }\n   \
    \     var a = 2l\n        var b = 3l\n        var i = 2l\n        while (i < n)\
    \ {\n            val tmp = a + b\n            a = b\n            b = tmp\n   \
    \         if (b.isPrime) {\n                i += 1\n            }\n        }\n\
    \        return b", "        val fib = new LazyList[Long]((1l) +: (2l) +: fib.zip(fib.tail).map(t\
    \ => t._1 + t._2))\n        val prime = new LazyList[Long](Stream.from(2).filter(BigInt(_).isProbablePrime(100)).map(_.toLong))\n\
    \        prime.filter(fib.contains(_)).drop((n - 1).toInt).head", "        def\
    \ isPrime(n : Long) : Boolean = {\n            def isPrimeR(i : Long) : Boolean\
    \ =\n                if (i <= 1)\n                    true\n                else\n\
    \                    n % i != 0 && isPrimeR(i - 1)\n            isPrimeR(n - 1)\n\
    \        }\n        def primeFibR(n : Long, c : Long, b : Long, a : Long) : Long\
    \ =\n            if (n == c)\n                a\n            else\n          \
    \      primeFibR(n, c + 1, a, b + a)\n        primeFibR(n, 1, 1, 1)", "      \
    \  if (n == 1) {\n            2\n        } else if (n == 2) {\n            3\n\
    \        } else {\n            var f : Long = 5;\n            var i : Long = 3;\n\
    \            while (i < n) {\n                {\n                    f = f + 2\
    \ * f - 3;\n                    while (f % 2 == 0 || f % 3 == 0) {\n         \
    \               f = f + 2;\n                    }\n                    i = i +\
    \ 1;\n                }\n            }\n            f\n        }", "        val\
    \ loop = Stream.iterate((2l, 3l, 5l))((x) => (x._2, x._3, x._1 + x._2 + x._3))\n\
    \        loop.find((x) => Helper.isPrime(x._3)).get._3", "        val ps = Utils.getPrimeStream()\n\
    \        return ps.filter(p => Utils.isFib(p)).drop(n.toInt - 1).head", "    \
    \    var count = 0l\n        var fn = 2l\n        var result = 0l\n        while\
    \ (count < n) {\n            if (BigInt(fn).isProbablePrime(1000)) {\n       \
    \         count += 1\n                result = fn\n            }\n           \
    \ fn = fn + nextFib(fn)\n        }\n        return result", "        var fib =\
    \ 2l\n        var curr = 2l\n        var next = 3l\n        var nth = 1l\n   \
    \     while (nth < n) {\n            fib = curr + next\n            curr = next\n\
    \            next = fib\n            if (fib.isPrime) nth += 1\n        }\n  \
    \      fib", "        def primeFibInner(i : Long, a : Long, b : Long, c : Long)\
    \ : Long = i match {\n            case 0 => b\n            case _ => primeFibInner(i\
    \ - 1, b, c, a + b + c)\n        }\n        primeFibInner(n - 1, 2, 3, 5)", " \
    \       var i = 1l\n        var a = 2l\n        var b = 3l\n        while (i <\
    \ n) {\n            val c = a + b\n            a = b\n            b = c\n    \
    \        if (c.isPrime) i += 1\n        }\n        return a", "        val cache\
    \ = mutable.Map(0l -> 2l, 1l -> 3l)\n        def fib(i : Long) : Long = cache.getOrElseUpdate(i,\
    \ fib(i - 1) + fib(i - 2))\n        def isPrime(n : Long) : Boolean = BigInt(n).isProbablePrime(10)\n\
    \        def loop(i : Long, result : Long) : Long = if (i >= n) result else if\
    \ (isPrime(fib(i))) loop(i + 1, fib(i)) else loop(i + 1, result)\n        loop(2,\
    \ 0)", "        var primes = 0\n        var fib = 1\n        var fib_prev = 1\n\
    \        var count = 2\n        while (primes < n) {\n            val next = fib\
    \ + fib_prev\n            if (isPrime(next)) {\n                primes += 1\n\
    \                fib_prev = fib\n                fib = next\n            }\n \
    \           count += 1\n        }\n        fib", "        var fib = new Fibonacci()\n\
    \        val size = 100000\n        val L = Array.fill(size)(2l)\n        for\
    \ (i <- 1 to size - 1) {\n            L(i) = fib.next()\n        }\n        L.filter(Lib.isPrime).drop(n.toInt\
    \ - 1).head", "        def primeFib(n : Long, prev : Long, cur : Long, count :\
    \ Long) : Long = {\n            if (count == n) cur\n            else if (BigInt(cur).isProbablePrime(10))\
    \ primeFib(n, cur, prev + cur, count + 1)\n            else primeFib(n, cur, prev\
    \ + cur, count)\n        }\n        primeFib(n, 2, 3, 2)", "        val pb = new\
    \ PrimeBuffer(10000)\n        var result = 1l\n        var count = 1l\n      \
    \  var fib = 0l\n        for (i <- 1 to n.toInt) {\n            if (i == 1) {\n\
    \                fib = 2l\n            } else if (i == 2) {\n                fib\
    \ = 3l\n            } else {\n                fib = fib + result\n           \
    \ }\n            if (pb.isPrime(fib)) {\n                result = fib\n      \
    \          count += 1\n            }\n        }\n        result", "        val\
    \ fibs = new ArrayBuffer[Long]();\n        fibs += 1l;\n        fibs += 2l;\n\
    \        var last = fibs(1);\n        var k = 2l;\n        while(fibs.length <\
    \ n) {\n            val now = fibs(k.toInt - 1) + fibs(k.toInt - 2);\n       \
    \     if(now.isProbablePrime(30)) {\n                fibs += now;\n          \
    \      last = now;\n            }\n            k += 1l;\n        }\n        return\
    \ last;", "        var cur : Long = 0l\n        var last1 : Long = 1l\n      \
    \  var last2 : Long = 1l\n        var count : Long = 2l\n        var i : Long\
    \ = 2l\n        while (count < n) {\n            i += 1\n            cur = last1\
    \ + last2\n            if (Utils.isPrime(cur)) count += 1\n            last2 =\
    \ last1\n            last1 = cur\n        }\n        return cur", "        lazy\
    \ val fibs : Stream[Long] = Stream.cons(1l, Stream.cons(2l, fibs.zip(fibs.tail).map(p\
    \ => p._1 + p._2)))\n        fibs.dropWhile(p => !p.isPrime).take(n.toInt).last",
  "        def primeFibIter(a : Long, b : Long, count : Long) : Long = {\n       \
    \     if (count == n) b\n            else if (b.isPrime) primeFibIter(b, a + b,\
    \ count + 1)\n            else primeFibIter(b, a + b, count)\n        }\n    \
    \    primeFibIter(1, 2, 1)", "        // primeFib returns n-th number that is\
    \ a Fibonacci number and it's also prime.\n        // >>> primeFib((1l))\n   \
    \     // (2l)\n        // >>> primeFib((2l))\n        // (3l)\n        // >>>\
    \ primeFib((3l))\n        // (5l)\n        // >>> primeFib((4l))\n        // (13l)\n\
    \        // >>> primeFib((5l))\n        // (89l)\n        def sieve(n : Long)\
    \ : Array[Long] = {\n            // >>> sieve((10l))\n            // array('0l,\
    \ '0l, '2l, '3l, '0l, '5l, '0l, '7l, '0l, '0l, '0l, '11l, '0l, '13l, '0l, '0l,\
    \ '0l, '17l, '0l, '19l, '0l, '0l, '0l, '23l, '0l, '0l, '0l, '0l, '0l, '29l, '0l,\
    \ '31l, '0l, '0l, '0l, '0l, '0l, '37l, '0l, '0l, '0l, '41l, '0l, '43l, '0l, '0l,\
    \ '0l, '47l, '0l, '0l, '0l, '0l, '0l, '53l, '0l, '0l, '0l, '0l, '0l, '59l, '0l,\
    \ '61l, '0l, '0l, '0l, '0l, '0l, '67l, '0l, '0l, '0l, '71l, '0l, '73l, '0l, '0l,\
    \ '0l, '0l, '0l, '79l, '0l, '0l, '0l, '83l, '0l, '0l, '0l, '0l, '0l, '89l, '0l,\
    \ '0l", "        def process(twoPreviousPrimes : List[Long], previousPrime : Long,\
    \ curr : Long, currPrimeCount : Long) : Long = {\n            val next = twoPreviousPrimes.head\
    \ + previousPrime\n            if (next % 2 == 0) process(twoPreviousPrimes.tail\
    \ :+ previousPrime, next, curr + 1, currPrimeCount)\n            else if (Utils.isPrime(next))\
    \ process(twoPreviousPrimes.tail :+ previousPrime, next, curr + 1, currPrimeCount\
    \ + 1)\n            else process(twoPreviousPrimes.tail :+ previousPrime, next,\
    \ curr + 1, currPrimeCount)\n        }\n        process(List(2l, 1l), 3l, 3l,\
    \ 2l)", "        var queue = new Queue[Long]();\n        var fn2 = 2l;\n     \
    \   var fn1 = 3l;\n        var fn = 5l;\n        queue.enqueue(fn2);\n       \
    \ queue.enqueue(fn1);\n        queue.enqueue(fn);\n        while (queue.length\
    \ < n) {\n            fn2 = fn1;\n            fn1 = fn;\n            fn = fn1\
    \ + fn2;\n            if (isPrime(fn)) {\n                queue.enqueue(fn);\n\
    \            }\n        }\n        return queue.dequeue();", "        val fibs\
    \ = Stream.cons(1l, Stream.cons(2l, fibs.zip(fibs.tail).map(p => p._1 + p._2)))\n\
    \        fibs.filter(Math.isPrime(_)).drop(n.toInt - 1).head", "        var max\
    \ = 1l\n        var i = 1l\n        while (i <= n) {\n            max = fib.fib(max)._1\n\
    \            if (prime.isPrime(max)) {\n                i += 1\n            }\n\
    \        }\n        return max", "        var i = 0l\n        var a = 2l\n   \
    \     var b = 3l\n        var c = 5l\n        while (i < n) {\n            val\
    \ c = a + b\n            if (Tools.isPrime(c)) {\n                i += 1\n   \
    \             a = b\n                b = c\n            } else {\n           \
    \     a = b\n                b = c\n            }\n        }\n        return a",
  "        val sieve = new SieveOfAtkin((10000000))\n        var i = 0l\n        var\
    \ x = 1l\n        var y = 1l\n        var z = 1l\n        while (i < n) {\n  \
    \          if (z == 1l) {\n                z = x + y\n                x = y\n\
    \                y = z\n            }\n            if (sieve.isPrime(z)) {\n \
    \               i += 1\n                z = 1l\n            }\n            else\
    \ {\n                z += 1\n            }\n        }\n        return z", "  \
    \      val ps = Stream.from(1).map(x => (2l + x)).filter(x => isPrime(x))\n  \
    \      val fs = ps.map(x => (1l, x)).map(x => (x._1 + x._2, x._2)).filter(x =>\
    \ isPrime(x._1))\n        val result = fs.drop((n - 1).toInt).head._1\n      \
    \  return result", "        def primeFib(s : Stream[Long]) : Stream[Long] = {\n\
    \            def isPrime(n : Long) : Boolean = {\n                if (n < 2) return\
    \ false\n                val limit = sqrt(n).toLong\n                for (i <-\
    \ (2l) to limit) {\n                    if (n % i == 0) return false\n       \
    \         }\n                return true\n            }\n            s match {\n\
    \                case Stream.Empty => Stream.empty\n                case x #::\
    \ xs => {\n                    if (isPrime(x)) x #:: primeFib(xs)\n          \
    \          else primeFib(xs)\n                }\n            }\n        }\n  \
    \      primeFib(fib(n)).head", "        def primeFibIter(n : Long, pre : Long,\
    \ cur : Long, count : Long) : Long = {\n            if (count == n) cur\n    \
    \        else {\n                if (prime.isPrime(cur)) primeFibIter(n, cur,\
    \ pre + cur, count + 1)\n                else primeFibIter(n, cur, pre + cur,\
    \ count)\n            }\n        }\n        primeFibIter(n, 0, 1, 1)", "     \
    \   def primeFib_tr(n : Long, fib : List[Long], prime : List[Long]) : Long = {\n\
    \            if (prime.length == n) fib.head\n            else {\n           \
    \     val f = fib.head + fib.tail.head\n                if (BigInt(f).isProbablePrime(100))\
    \ primeFib_tr(n, f :: fib, f :: prime)\n                else primeFib_tr(n, f\
    \ :: fib, prime)\n            }\n        }\n        primeFib_tr(n, List(2l, 3l),\
    \ List(2l, 3l))", "      //def fib(a : Long, b : Long, n : Long) : Long = if (n\
    \ == 0) 0 else if (n == 1) a else fib(b, a + b, n - 1)\n      val fib = Stream.iterate((0l,\
    \ 1l))((x) => (x._2, x._1 + x._2)).map((x) => x._1)\n      fib.dropWhile((x) =>\
    \ {\n        if (x % 2 == 0) false\n        else (3l to sqrt(x).toLong by 2).find((y)\
    \ => x % y == 0) == None\n      }).drop(n.toInt - 1).head", "        var fib =\
    \ new Fibonacci(50);\n        var ps = new PrimeSeq(100000000);\n        while\
    \ (true) {\n            var p = ps.nextPrime();\n            while (fib.fibonacci(n)\
    \ < p) {\n                n += 1;\n            }\n            if (fib.fibonacci(n)\
    \ == p) {\n                return p;\n            }\n        }\n        return\
    \ 0;", "        def isPrime(x : Long) : Boolean = {\n            if (x < 2) {\n\
    \                return false\n            }\n            for (i <- 2l to sqrt(x).toLong)\
    \ {\n                if (x % i == 0) {\n                    return false\n   \
    \             }\n            }\n            return true\n        }\n        def\
    \ fib(a : Long, b : Long, c : Long) : Long = {\n            if (c == n) {\n  \
    \              return b\n            }\n            if (isPrime(b)) {\n      \
    \          return fib(b, a + b, c + 1)\n            }\n            return fib(b,\
    \ a + b, c)\n        }\n        return fib(1, 1, 1)", "        var count = 0l\n\
    \        var i = 0l\n        var fibonacci = 0l\n        while (count != n) {\n\
    \            fibonacci = fibonacci + i\n            if (fibonacci.isPrime) count\
    \ = count + 1\n            i = fibonacci - i\n        }\n        fibonacci", " \
    \     def isPrime(n : Long) : Boolean = {\n        if (n < 2) return false\n \
    \       var i = 2l\n        while (i * i <= n) {\n          if (n % i == 0) return\
    \ false\n          i += 1\n        }\n        return true\n      }\n      def\
    \ isFib(n : Long) : Boolean = {\n        if (n == 0) return true\n        var\
    \ a = 5 * n * n + 4\n        var b = 5 * n * n - 4\n        var s = scala.math.sqrt(a).toLong\n\
    \        if (s * s == a) return true\n        s = scala.math.sqrt(b).toLong\n\
    \        if (s * s == b) return true\n        return false\n      }\n      var\
    \ i = 2l\n      var count = 0l\n      while (count != n) {\n        if (isPrime(i)\
    \ && isFib(i)) count += 1\n        i += 1\n      }\n      return i - 1", "   \
    \ \tval dp = Array.fill(n.toInt)(-1l)\n    \tdp(0) = 2\n    \tdp(1) = 3\n    \t\
    dp(2) = 5\n    \tvar i = 3\n    \twhile (i < n) {\n    \t\tvar num = dp(i - 1)\
    \ + dp(i - 2)\n    \t\twhile (!isPrime(num)) {\n    \t\t\tnum += 1\n    \t\t}\n\
    \    \t\tdp(i) = num\n    \t\ti += 1\n    \t}\n    \tdp(n.toInt - 1)", "     \
    \   var count = 0l\n        var fib = 2l\n        var first = 0l\n        var\
    \ second = 1l\n        while (count < n) {\n            if (isPrime(fib)) count\
    \ += 1\n            val next = first + second\n            first = second\n  \
    \          second = next\n            fib = next\n        }\n        fib", " \
    \       val ps = primeStream()\n        def i(p: Long, n: Long, result: List[Long]):\
    \ Long = if (n == 1) p else i(ps.takeWhile(_ < p).filter(BigInt(_).isProbablePrime(100)).toList.last,\
    \ n - 1, result)\n        i(ps.takeWhile(_ < 100).filter(BigInt(_).isProbablePrime(100)).toList.last,\
    \ n, List())", "        var (n, x, y) = (n, 2l, 3l)\n        while (n > 1) {\n\
    \            var (r, s) = (x + y, y)\n            while (!Prime.isPrime(r)) {\n\
    \                r += s\n                s = r - s\n            }\n          \
    \  (x, y) = (y, r)\n            n -= 1\n        }\n        return x", "      \
    \  require(n > 0)\n        var a = 2l\n        var b = 3l\n        var c = 5l\n\
    \        for (i <- 3l to n) {\n            a = b\n            b = c\n        \
    \    c = a + b\n            while (!isPrime(c)) c += 2\n        }\n        return\
    \ c", "    \tvar fib = fibonacci\n    \tvar prime = primes\n    \tvar temp = fib.next\n\
    \    \tvar answer = -1l\n    \tfor (i <- 1l to n) {\n    \t\twhile (!prime.contains(temp))\
    \ {\n    \t\t\ttemp = fib.next\n    \t\t}\n    \t\tanswer = temp\n    \t\ttemp\
    \ = fib.next\n    \t}\n    \treturn answer", "        var fib = fibonacci(n)\n\
    \        while (!fib.isProbablePrime(100)) {\n            fib = fibonacci(n)\n\
    \            n += 1\n        }\n        return fib", "        val primeSieve =\
    \ PrimeSieve(100)\n        def fib() : Stream[Long] = 0 #:: 1 #:: fib().zip(fib().tail).map(p\
    \ => p._1 + p._2)\n        def numberFilter(x : Long) : Boolean = primeSieve.isPrime(x)\n\
    \        fib().filter(numberFilter)(n.toInt)", "        var v_pre2 = 2l\n    \
    \    var v_pre1 = 3l\n        var count = 1l\n        while (count < n) {\n  \
    \          val v = v_pre2 + v_pre1\n            if (v.isPrime) {\n           \
    \     count += 1\n            }\n            v_pre2 = v_pre1\n            v_pre1\
    \ = v\n        }\n        return v_pre1", "        def primeFibHelper(n : Long,\
    \ a : Long, b : Long, i : Long) : Long = {\n            if (i == n) b\n      \
    \      else if (BigInt(b).isProbablePrime(5)) primeFibHelper(n, b, a + b, i +\
    \ 1)\n            else primeFibHelper(n, b, a + b, i)\n        }\n        primeFibHelper(n,\
    \ 1, 2, 1)", "        def compute(n : Long, prev : Long, cur : Long, index : Long)\
    \ : Long = {\n            if (index == n) return cur\n            else {\n   \
    \             val next = prev + cur\n                if (next.isPrime) compute(n,\
    \ cur, next, index + 1)\n                else compute(n, cur, next, index)\n \
    \           }\n        }\n        if (n == 1) return 2\n        else if (n ==\
    \ 2) return 3\n        else return compute(n, 2, 3, 3)", "        val a = new\
    \ ArrayBuffer[Long]\n        a += 2\n        a += 3\n        var i = 2\n     \
    \   while (a.length < n) {\n            a += (a(i - 1) + a(i - 2))\n         \
    \   i += 1\n        }\n        a(n.toInt - 1)", "        def generateFib(m : Long)\
    \ : Stream[Long] = Stream.cons(m, generateFib(m + 1).map(i => fib(i)))\n     \
    \   def primes(n : Int) : Stream[Int] = Stream.cons(n, primes(n + 1).filter(i\
    \ => isPrime(i)))\n        def isPrime(n : Int) : Boolean = primes(2).takeWhile(i\
    \ => i <= sqrt(n).toInt).forall(i => n % i != 0)\n        def fib(n : Long) :\
    \ Long = primes(1).map(i => i * i).takeWhile(i => i <= n).foldLeft(0l)((acc, i)\
    \ => acc + i)\n        primes(2).filter(i => generateFib(1).takeWhile(j => j <=\
    \ i).contains(i)).apply((n - 1).toInt)", "        if (n == 1) return 2\n     \
    \   if (n == 2) return 3\n        var fib : Long = 2\n        var c : Long = 3\n\
    \        var cnt : Long = 2\n        while (cnt < n) {\n            val newfib\
    \ : Long = fib + c\n            fib = c\n            c = newfib\n            if\
    \ (c.isPrime) cnt += 1\n        }\n        return c", "        var (f1, f2, f)\
    \ = (2l, 3l, 0l)\n        var i = 2l\n        while (i < n) {\n            f =\
    \ f1 + f2\n            f1 = f2\n            f2 = f\n            i += 1\n     \
    \   }\n        return f", "        def recurse(n : Long, x : Long, y : Long, i\
    \ : Long) : Long = {\n            if (i == n) {\n                return x\n  \
    \          }\n            else {\n                val newx = x + y\n         \
    \       val newy = x\n                if (Primes.isPrime(newx)) {\n          \
    \          return recurse(n, newx, newy, i + 1)\n                }\n         \
    \       else {\n                    return recurse(n, newx, newy, i)\n       \
    \         }\n            }\n        }\n        recurse(n, 2, 1, 1)", "       \
    \ val u = Memoization.unbounded[(Long, List[Long]), List[Long]](_ match {\n  \
    \          case (0, list) => list\n            case (1, list) => list\n      \
    \      case (m, list) => u((m - 1, list)) ::: u((m - 2, list))\n        })\n \
    \       (u((n, List(2, 3, 5, 13, 89))) ::: u((n + 1, List(2, 3, 5, 13, 89)))).head",
  "        def fib : Stream[Long] = 1 #:: 2 #:: fib.zip(fib.tail).map(p => p._1 +\
    \ p._2)\n        // fib.takeWhile(_ <= 89).filter(x => BigInt(x).isProbablePrime(10)).zipWithIndex.filter(_._2\
    \ == n).head._1\n        fib.filter(x => BigInt(x).isProbablePrime(10)).drop(n.toInt\
    \ - 1).head", "        // The result is less than 4e6\n        val limit = 4000000l\n\
    \        var fibs = new ArrayBuffer[Long]\n        fibs += 2\n        fibs +=\
    \ 3\n        var i = 2\n        while (fibs(i - 1) < limit) {\n            fibs\
    \ += fibs(i - 1) + fibs(i - 2)\n            i += 1\n        }\n        // Remove\
    \ non-prime numbers from fibs\n        var j = fibs.length - 1\n        while\
    \ (j >= 0) {\n            if (!List.range(2, fibs(j).toInt + 1).filter(x => fibs(j)\
    \ % x == 0).isEmpty) {\n                fibs.remove(j)\n            }\n      \
    \      j -= 1\n        }\n        fibs(n.toInt - 1)", "        var cnt = n\n \
    \       var n0 = 0l\n        var n1 = 1l\n        var n2 = 1l\n        while (cnt\
    \ > 0) {\n            val n3 = n1 + n2\n            n0 = n1\n            n1 =\
    \ n2\n            n2 = n3\n            if (n0 % 2 == 0) cnt -= 1\n        }\n\
    \        return n0", "        var a : Long = 2l;\n        var b : Long = 3l;\n\
    \        var c : Long = 5l;\n        var count : Long = 3l;\n        while (count\
    \ < n) {\n            a = b;\n            b = c;\n            c = a + b;\n   \
    \         if (isPrime(c)) {\n                count += 1l;\n            }\n   \
    \     }\n        return c;", "        var fibs = new ListBuffer[Long]();\n   \
    \     fibs += (1l);\n        fibs += (2l);\n        var i = 0;\n        while\
    \ (i < fibs.length) {\n            var f = fibs(i);\n            i += 1;\n   \
    \         if (f >= n) {\n                return f;\n            }\n          \
    \  var j = fibs.length - 1;\n            while (j >= 0) {\n                var\
    \ f2 = fibs(j);\n                j -= 1;\n                var f3 = f + f2;\n \
    \               fibs += f3;\n            }\n        }\n        throw new RuntimeException(\"\
    Should not reach here\");", "        val g = new MemoizedStream(1l, 2l) {\n  \
    \          override def next(i : Long) : Long = if (i == 1l) 2l else super.next(i)\n\
    \        }\n        val f = new MemoizedStream(1l, 1l) {\n            override\
    \ def next(i : Long) : Long = {\n                if (i == 1l) 1l\n           \
    \     else g.next(i - 1l) + g.next(i)\n            }\n        }\n        f.dropWhile(!_.isPrime).take(n.toInt).last",
  "        var i = 2l;\n        var fib = 2l;\n        var prev = 1l;\n        var\
    \ temp = 0l;\n        while (i <= n) {\n            temp = fib;\n            fib\
    \ += prev;\n            prev = temp;\n            if (fib.isPrime) {\n       \
    \         i += 1;\n            }\n        }\n        return fib;", "        var\
    \ r = 2l\n        val sieve = new Sieve((1000000).toInt)\n        var f = 1l\n\
    \        var c = 1l\n        while (n > 0) {\n            if (sieve.isPrime(f))\
    \ {\n                c += 1\n                if (c == n) r = f\n            }\n\
    \            val o = f\n            f += r\n            r = o\n        }\n   \
    \     return r", "        var i = 1l\n        var primeFib : Long = 0l\n     \
    \   while (i <= n) {\n            val fib = fibonacci((i))\n            if (Prime.isPrime(fib))\
    \ {\n                primeFib = fib\n                i += 1\n            }\n \
    \           i += 1\n        }\n        return primeFib", "        val upper =\
    \ BigInt(5 * ceil(pow(5 * n, 0.5)).toLong).pow(2)\n        var a = BigInt(1)\n\
    \        var b = BigInt(2)\n        var c = BigInt(3)\n        var f = BigInt(5)\n\
    \        var k = 4l\n        while (f < upper) {\n            a = b\n        \
    \    b = c\n            c = f\n            f = a + b + c\n            if (f.isProbablePrime(10))\
    \ k += 1\n            if (k == n) return f.toLong\n        }\n        return 0",
  "        def rec(a : Long, b : Long, c : Long, n : Long) : Long = {\n          \
    \  if (n == 0) b\n            else rec(b, a + b, c, n - 1)\n        }\n      \
    \  def isPrime(n : Long) : Boolean = {\n            if (n == 1) false\n      \
    \      else if (n < 4) true\n            else if (n % 2 == 0) false\n        \
    \    else if (n < 9) true\n            else if (n % 3 == 0) false\n          \
    \  else {\n                var r = floor(sqrt(n)).toLong\n                var\
    \ f = 5l\n                while (f <= r) {\n                    if (n % f == 0)\
    \ return false\n                    if (n % (f + 2) == 0) return false\n     \
    \               f += 6\n                }\n                true\n            }\n\
    \        }\n        def rec2(a : Long, b : Long, c : Long, d : Long, n : Long)\
    \ : Long = {\n            if (d == n) b\n            else if (isPrime(b)) rec2(b,\
    \ a + b, c, d + 1, n)\n            else rec2(b, a + b, c, d, n)\n        }\n \
    \       rec2(1, 1, 1, 2, n)", "    \tval lazyFib : Stream[BigInt] = BigInt(0)\
    \ #:: BigInt(1) #:: lazyFib.zip(lazyFib.tail).map(p => p._1 + p._2)\n    \tval\
    \ primeFib : Stream[BigInt] = lazyFib.filter(BigInt(_).isProbablePrime(10))\n\
    \    \tprimeFib(n.toInt).toLong", "        var rv : Long = 0\n        var i :\
    \ Long = 0\n        var numFib : Long = 0\n        var fib : Long = 0\n      \
    \  var nextFib : Long = 1\n        while (i < n) {\n            fib = nextFib\n\
    \            nextFib = fib + rv\n            rv = fib\n            if (rv.isPrime)\
    \ {\n                i = i + 1\n                numFib = rv\n            }\n \
    \       }\n        return numFib", "      val sieve = SieveOfEratosthenes(1000000)\n\
    \      var current = sieve.nextPrime()\n      var previous = current\n      var\
    \ count = 0l\n      while (true) {\n        current = sieve.nextPrime()\n    \
    \    if (isFib(current + previous)) count += 1\n        if (count == n) return\
    \ current + previous\n        previous = current\n      }\n      return 0", " \
    \       var prime : Vector[Long] = Vector(2l)\n        var fibo : Vector[Long]\
    \ = Vector(1l, 1l)\n        var candidate : Long = 2l\n        var i : Long =\
    \ 0l\n        var j : Long = 0l\n        while(i < n) {\n            candidate\
    \ += 1\n            while(j < prime.length && prime(j.toInt) <= sqrt(candidate))\
    \ {\n                if(candidate % prime(j.toInt) == 0) {\n                 \
    \   candidate += 1\n                    j = 0\n                } else {\n    \
    \                j += 1\n                }\n            }\n            if(j ==\
    \ prime.length) {\n                prime = prime :+ candidate\n              \
    \  fibo = fibo :+ (fibo(fibo.length - 1) + fibo(fibo.length - 2))\n          \
    \      if(prime.last == fibo.last) {\n                    i += 1\n           \
    \     }\n            }\n        }\n        return prime.last", "        def isPrime(x\
    \ : Long) : Boolean = {\n            val sqrtX = sqrt(x)\n            def f(i\
    \ : Long) : Boolean =\n                if (i > sqrtX) true\n                else\
    \ if (x % i == 0) false\n                else f(i + 1)\n            f(2)\n   \
    \     }\n        var fib : Long = 0\n        var count : Long = 0\n        while\
    \ (count != n) {\n            fib += 1\n            if (fib == 5) {\n        \
    \        fib = 8\n            }\n            if (isPrime(fib) && isPrime(fib.toString.map((c\
    \ : Char) => c.toLong - '0'.toLong).reduce((x : Long, y : Long) => x + y))) {\n\
    \                count += 1\n            }\n        }\n        fib", "       \
    \ require(n > 0)\n        var i = 1\n        var f1 = 2l\n        var f2 = 3l\n\
    \        var f = f1 + f2\n        while (i < n) {\n            i += 1\n      \
    \      f1 = f2\n            f2 = f\n            f = f1 + f2\n            while\
    \ (!(f.isPrime)) {\n                f1 = f2\n                f2 = f\n        \
    \        f = f1 + f2\n            }\n        }\n        return f", "        def\
    \ helper(n : Long, fibs : List[Long], ps : List[Long]) : Long = {\n          \
    \  if (n == 1) fibs.head\n            else {\n                val nextFib = fibs.head\
    \ + fibs.tail.head\n                val nextPs = ps.tail.filter(p => p * p <=\
    \ nextFib && nextFib % p != 0)\n                helper(n - 1, nextFib :: fibs,\
    \ nextPs)\n            }\n        }\n        helper(n, List(2, 3), List.range(3,\
    \ 10000, 2))", "      def primeFib0(n : Long, fib : Stream[Long]) : Long = {\n\
    \        fib match {\n          case Stream.Empty => throw new IllegalArgumentException\n\
    \          case f #:: _ if n == 1l => f\n          case f #:: fs if n > 1l &&\
    \ Prime.isPrime(f) => primeFib0(n - 1l, fs)\n          case _ #:: fs => primeFib0(n,\
    \ fs)\n        }\n      }\n      primeFib0(n, Fibonacci.fib())", "        var\
    \ fib : Long = 1\n        var fibn : Long = 1\n        var c : Long = 0\n    \
    \    var cnt : Long = 0\n        while (cnt < n) {\n            val tmp = fib\n\
    \            fib = fibn\n            fibn = tmp + fibn\n            if (fibn.isPrime)\
    \ {\n                cnt += 1\n                c = fibn\n            }\n     \
    \   }\n        return c", "        var i = 1l\n        var j = 1l\n        var\
    \ k = 2l\n        var m = 1l\n        while (m < n) {\n            k = i + j\n\
    \            if (isPrime(k)) {\n                m += 1\n            }\n      \
    \      i = j\n            j = k\n        }\n        return k", "    \tvar a =\
    \ 1l\n    \tvar b = 1l\n    \tvar c = 0l\n    \tvar p = 1l\n    \twhile(p < n)\
    \ {\n    \t\tc = a + b\n    \t\ta = b\n    \t\tb = c\n    \t\tif(b % 2 == 0) {\n\
    \    \t\t\tp += 1\n    \t\t}\n    \t}\n    \tif(b % 2 == 0) {\n    \t\treturn\
    \ b / 2\n    \t} else {\n    \t\treturn b\n    \t}", "        def isPrime(n :\
    \ Long) : Boolean = {\n            if (n < 2) false\n            else if (n ==\
    \ 2) true\n            else !(2l to sqrt(n).toLong).exists(d => n % d == 0)\n\
    \        }\n        def solve(a : Long, b : Long, n : Long) : Long = {\n     \
    \       if (n == 1) a\n            else if (isPrime(b)) solve(b, a + b, n - 1)\n\
    \            else solve(a, a + b, n)\n        }\n        solve(1, 1, n)", "  \
    \    var acc1 = 1l\n      var acc2 = 2l\n      var curr = 0l\n      var counter\
    \ = 1l\n      while (counter != n) {\n        curr = acc1 + acc2\n        acc1\
    \ = acc2\n        acc2 = curr\n        if (curr.isPrime) counter += 1\n      }\n\
    \      return curr", "        def primeFib(n : Long, fib : Long, fib_2 : Long,\
    \ primeCount : Long) : Long = {\n            if (primeCount == n) return fib\n\
    \            val next_fib = fib + fib_2\n            val next_fib_2 = fib\n  \
    \          val next_primeCount = if (BigInt(next_fib).isProbablePrime(100)) primeCount\
    \ + 1 else primeCount\n            primeFib(n, next_fib, next_fib_2, next_primeCount)\n\
    \        }\n        primeFib(n, 2, 1, 1)", "        var x = Array(2l, 3l, 5l,\
    \ 13l, 89l)\n        if (n <= 5) {\n            return x(n.toInt - 1)\n      \
    \  }\n        for (i <- 6l to n) {\n            var index = i - 1\n          \
    \  var fib : Long = 1\n            var m : Long = 0\n            while (true)\
    \ {\n                m = (index & 1) match {\n                    case 0 => ((index\
    \ + 1) / 2 - 1)\n                    case _ => ((index + 1) / 2)\n           \
    \     }\n                fib *= x(m.toInt)\n                if (index == 1) {\n\
    \                    break\n                }\n                index = m\n   \
    \         }\n            x = x :+ fib\n        }\n        return x(n.toInt - 1)",
  "        var i = 0l\n        var j = 1l\n        var count = 0l\n        while (count\
    \ < n) {\n            val k = i + j\n            i = j\n            j = k\n  \
    \          if (Library.isPrime(k)) count += 1\n        }\n        return i", " \
    \     var k : Long = 0\n      var a : Long = 0\n      var b : Long = 1\n     \
    \ var c : Long = a + b\n      while (k < n) {\n        if (isPrime(c)) {\n   \
    \       k = k + 1\n        }\n        a = b\n        b = c\n        c = a + b\n\
    \      }\n      return c", "        var f1 : Long = 2\n        var f2 : Long =\
    \ 3\n        var i : Long = 2\n        while(i < n) {\n            {\n       \
    \         var f : Long = f1 + f2\n                while(!BigInt(f).isProbablePrime(20))\
    \ {\n                    f += 1\n                }\n                f1 = f2\n\
    \                f2 = f\n                i += 1\n            }\n        }\n  \
    \      return f2", "        var i = 1l\n        var fib = new ArrayBuffer[Long]()\n\
    \        var prime = new ArrayBuffer[Long]()\n        var nth : Long = 0\n   \
    \     while (fib.length < n) {\n            val fibs = fibonacci(i)\n        \
    \    if (isPrime(fibs)) {\n                fib += fibs\n                prime\
    \ += fibs\n            }\n            i += 1\n        }\n        return prime(n.toInt\
    \ - 1)", "        var fibs = new Vector[Long]\n        fibs += 2\n        fibs\
    \ += 3\n        var i = 2l\n        var current : Long = 0\n        while (i <=\
    \ n) {\n            current = fibs(fibs.length - 1) + fibs(fibs.length - 2)\n\
    \            if (BigInt(current).isProbablePrime(100)) {\n                fibs\
    \ += current\n                i += 1\n            }\n        }\n        return\
    \ fibs(fibs.length - 1)", "        def fib(a : Long, b : Long, n : Long) : Long\
    \ = if (n == 0) a else fib(b, a + b, n - 1)\n        def isPrime(n : Long) : Boolean\
    \ = {\n            if (n == 2) true\n            else if (n < 2 || n % 2 == 0)\
    \ false\n            else {\n                def check(i : Long) : Boolean = if\
    \ (i > math.sqrt(n).toLong) true else if (n % i == 0) false else check(i + 2)\n\
    \                check(3)\n            }\n        }\n        def primeFibRec(i\
    \ : Long, n : Long) : Long = if (isPrime(fib(i, i + 1, n))) fib(i, i + 1, n) else\
    \ primeFibRec(i, n + 1)\n        primeFibRec(0, 0)", "        var count = 0l\n\
    \        var c = 1l\n        var nxt = 1l\n        var temp = 0l\n        while\
    \ (count < n) {\n            if (Library.isPrime(c)) {\n                count\
    \ += 1\n                if (count == n)\n                    return c\n      \
    \      }\n            temp = nxt\n            nxt = c + nxt\n            c = temp\n\
    \        }\n        0", "        def primeFib0(n : Long, a : Long, b : Long, count\
    \ : Long) : Long = {\n            if (count == n) {\n                return b\n\
    \            }\n            else {\n                if (Utils.isPrime(b)) {\n\
    \                    return primeFib0(n, b, a + b, count + 1)\n              \
    \  }\n                else {\n                    return primeFib0(n, b, a + b,\
    \ count)\n                }\n            }\n        }\n        primeFib0(n, 1,\
    \ 2, 1)", "        def primeFib_iter(n : Long, curr_nth : Long, prev : Long, curr\
    \ : Long) : Long = {\n            if (n == curr_nth) curr\n            else {\n\
    \                val next = prev + curr\n                if (isPrime(next)) primeFib_iter(n,\
    \ curr_nth + 1, curr, next)\n                else primeFib_iter(n, curr_nth, curr,\
    \ next)\n            }\n        }\n        if (n == 1) 2\n        else primeFib_iter(n,\
    \ 2, 1, 2)", "        // input = n;\n        // count = 0;\n        // result\
    \ = 0;\n        // for (i=1;;i++) {\n        //     if (isPrime(i) && isFib(i))\
    \ {\n        //         count += 1;\n        //         if (count == input) {\n\
    \        //             result = i;\n        //             break;\n        //\
    \         }\n        //     }\n        // }\n        // return result;\n     \
    \   var count = 0l\n        for (i <- 1l to Long.MaxValue) {\n            if (isPrime(i)\
    \ && isFib(i)) {\n                count += 1\n                if (count == n)\
    \ return i\n            }\n        }\n        0l", "        def primeFibRec(a\
    \ : Long, b : Long, n : Long, c : Long) : Long = {\n            if (n == c) return\
    \ b\n            if (Library.isPrime(b)) return primeFibRec(b, a + b, n, c + 1)\n\
    \            else return primeFibRec(b, a + b, n, c)\n        }\n        return\
    \ primeFibRec(1, 2, n, 1)", "        val cache = Map((0l, 2l), (1l, 3l))\n   \
    \     def helper(k : Long) : Long = {\n            if (cache.contains(k)) cache(k)\n\
    \            else {\n                val a = helper(k - 1)\n                val\
    \ b = helper(k - 2)\n                val r = a + b\n                cache(k) =\
    \ r\n                r\n            }\n        }\n        helper(n - 1)", "  \
    \      val sieve = PrimeSieve((n * 5).toInt)\n        def calc(i : Long, f1 :\
    \ Long, f2 : Long) : Long = {\n            if (i == n) f2\n            else {\n\
    \                if (sieve.isPrime(f2.toInt)) calc(i + 1, f2, f1 + f2)\n     \
    \           else calc(i, f2, f1 + f2)\n            }\n        }\n        calc(1,\
    \ 2, 3)", "        def primenumber(n : Long) : Boolean = {\n            if (n\
    \ <= 2) return (n == 2)\n            if (n % 2 == 0) return false\n          \
    \  var i = 3\n            while (i <= sqrt(n)) {\n                if (n % i ==\
    \ 0) return false\n                i += 2\n            }\n            return true\n\
    \        }\n        var d = 0\n        var f = 2\n        var s = 3\n        while\
    \ (d != n) {\n            var t = f + s\n            f = s\n            s = t\n\
    \            if (primenumber(s)) d += 1\n        }\n        return s", "     \
    \   val sieve = new Sieve(10000000)\n        var count = 0\n        var fib =\
    \ BigInt(1)\n        var prev = BigInt(0)\n        var temp = BigInt(0)\n    \
    \    while (count < n) {\n            temp = fib\n            fib += prev\n  \
    \          prev = temp\n            if (sieve.isPrime(fib.toLong)) count += 1\n\
    \        }\n        fib.toLong", "        def isPrime(n : Long) : Boolean = {\n\
    \            if (n == 1) {\n                return false\n            }\n    \
    \        val boundary = sqrt(n).toLong\n            (2l).to(boundary).forall(n\
    \ % _ != 0)\n        }\n        def fib(index : Long) : Long = {\n           \
    \ if (index == 1) {\n                return 1\n            }\n            else\
    \ if (index == 2) {\n                return 2\n            }\n            else\
    \ {\n                return fib(index - 1) + fib(index - 2)\n            }\n \
    \       }\n        var count = 0l\n        var i = 1l\n        while (count <\
    \ n) {\n            if (isPrime(fib(i))) {\n                count += 1\n     \
    \       }\n            i += 1\n        }\n        return fib(i - 1)", "      var\
    \ f1 : Long = 2\n      var f2 : Long = 3\n      var m : Long = 0\n      var count\
    \ : Long = 2\n      while (count < n) {\n        m = f1 + f2\n        f1 = f2\n\
    \        f2 = m\n        if (isPrime(m)) {\n          count += 1\n        }\n\
    \      }\n      return m", '      Stream.from(1).takeWhile(p => p <= n).map(primeFibSeq(n)).last',
  "        def primeFib(previous : Long, current : Long, n : Long) : Long = {\n  \
    \          if (n == 1)\n                return previous\n            val next\
    \ = previous + current\n            if (BigInt(next).isProbablePrime(10))\n  \
    \              return primeFib(current, next, n - 1)\n            else\n     \
    \           return primeFib(current, next, n)\n        }\n        return primeFib(2,\
    \ 3, n)", "        val ps = Primes.sequence(1000000000)\n        var i = 2l\n\
    \        var j = 3l\n        var count = 1l\n        while (count < n) {\n   \
    \         val temp = i + j\n            if (ps.isPrime(temp)) {\n            \
    \    count += 1\n                i = j\n                j = temp\n           \
    \ } else {\n                i = j\n                j = temp\n            }\n \
    \       }\n        return j", "        def isPrime(x : Long) : Boolean = {\n \
    \           if (x == 1) false\n            else if (x < 4) true\n            else\
    \ if (x % 2 == 0) false\n            else if (x < 9) true\n            else if\
    \ (x % 3 == 0) false\n            else {\n                val r = floor(sqrt(x)).toLong\n\
    \                var f = 5\n                while (f <= r) {\n               \
    \     if (x % f == 0) return false\n                    if (x % (f + 2) == 0)\
    \ return false\n                    f += 6\n                }\n              \
    \  true\n            }\n        }\n        var m = 1l\n        var a = 1l\n  \
    \      var b = 1l\n        while (m <= n) {\n            var c = a + b\n     \
    \       a = b\n            b = c\n            if (isPrime(c)) m += 1\n       \
    \ }\n        a", "        def prime(n : Long) : Boolean = {\n            if (n\
    \ == 1) return false\n            val sqrt = sqrt(n).toLong\n            for (i\
    \ <- 2l to sqrt) {\n                if (n % i == 0) return false\n           \
    \ }\n            return true\n        }\n        var fib = (1l, 1l)\n        var\
    \ primeCount = 0l\n        while (primeCount < n) {\n            fib = (fib._2,\
    \ fib._1 + fib._2)\n            if (prime(fib._2)) primeCount += 1\n        }\n\
    \        return fib._2", "        var sieve = new Sieve(1000000)\n        var\
    \ a = 2l\n        var b = 3l\n        var c = 5l\n        var i = 4l\n       \
    \ while (i <= n) {\n            if (sieve.isPrime(c.toInt)) {\n              \
    \  i += 1\n            }\n            a = b\n            b = c\n            c\
    \ = a + b\n        }\n        return c", "        var fs = new ArrayBuffer[Long]();\n\
    \        fs += 2;\n        fs += 3;\n        var p = 5;\n        while (fs.length\
    \ < n) {\n            var t = p;\n            var isPrime = true;\n          \
    \  while (t % 2 == 0) {\n                t /= 2;\n            }\n            var\
    \ m = 3;\n            while (m <= sqrt(t)) {\n                if (t % m == 0)\
    \ {\n                    isPrime = false;\n                    break;\n      \
    \          }\n                m += 2;\n            }\n            if (isPrime)\
    \ {\n                fs += p;\n            }\n            p += 2;\n        }\n\
    \        var a = fs(0);\n        var b = fs(1);\n        var i = 2;\n        while\
    \ (i < n) {\n            var tmp = a + b;\n            a = b;\n            b =\
    \ tmp;\n            i += 1;\n        }\n        b;", "        val m = n + n -\
    \ 1l\n        val magicNum = (5 * m * m + 14 * m + 1) / 4\n        magicNum",
  "        if (n < 1)\n            throw new Exception(\"n must be larger than 0.\"\
    )\n        val fib = new Fib(n)\n        var p = fib.next\n        while (!p.isPrime)\n\
    \            p = fib.next\n        p", "      //returns ((n-th prime number),\
    \ (n-th Fibonacci number))\n      def primeFibHelper(x : (Long, Long), y : (Long,\
    \ Long)) : (Long, Long) = {\n        val fib2 = x._2 + y._2\n        (nextPrime(y._1),\
    \ fib2)\n      }\n      // returns ((n-th prime number), (n-th Fibonacci number))\n\
    \      def nextPrime(p : Long) : Long = {\n        val f = prime_factor(p).last._1\n\
    \        if (f == 2) p + 1\n        else if (f == 3) p + 2\n        else p + 4\n\
    \      }\n      val t1 = Tuple2(2l, 1l)\n      val t2 = Tuple2(3l, 2l)\n     \
    \ streamFold(Tuple2(t1, t2), Tuple2(n + 1, 1l), primeFibHelper)._2", "       \
    \ def _primeFib(n : Long, n0 : Long, n1 : Long, count : Long) : Long = {\n   \
    \         val n2 = n0 + n1\n            if (count == n) n2\n            else if\
    \ (Library.isPrime(n2)) _primeFib(n, n1, n2, count + 1)\n            else _primeFib(n,\
    \ n1, n2, count)\n        }\n        _primeFib(n, 1, 2, 1)", "        val num\
    \ = new Array[Long](n.toInt)\n        num(0) = 2\n        num(1) = 3\n       \
    \ for (i <- 2 to n.toInt - 1) {\n            var index = 0\n            var flag\
    \ = true\n            while (flag && index < i) {\n                val n1 = num(index)\n\
    \                val n2 = num(i - index - 1)\n                val n3 = n1 + n2\n\
    \                if (n3 % 2 == 0) index += 1\n                else if (math.BigInt(n3).isProbablePrime(5))\
    \ {\n                    num(i) = n3\n                    flag = false\n     \
    \           }\n                else index += 1\n            }\n        }\n   \
    \     num(n.toInt - 1)", "        def pf(n : Long, f : Fibonacci) : Long = {\n\
    \            val u = f.val;\n            if (u > n && isPrime(u)) u else pf(n,\
    \ f.next)\n        }\n        pf(n, Fibonacci())", "        val sieve = new Sieve((1l\
    \ << 30).toInt)\n        var i = 1\n        var f = 1\n        var f1 = 1\n  \
    \      var f2 = 1\n        while (i < n) {\n            f = f1 + f2\n        \
    \    f1 = f2\n            f2 = f\n            if (sieve.isPrime(f)) i += 1\n \
    \       }\n        return f", "        //println(\"n: \" + n)\n        def primeFib(count\
    \ : Long, fib : Long, fibPrev : Long) : Long = {\n            //println(\"fib:\
    \ \" + fib)\n            if (fib > 100000000l) {\n                // too big\n\
    \                throw new Exception(\"fib: \" + fib + \" is too big\")\n    \
    \        }\n            if (count > n) {\n                fibPrev\n          \
    \  } else {\n                if (isPrime(fib)) {\n                    primeFib(count\
    \ + 1, fib + fibPrev, fib)\n                } else {\n                    primeFib(count,\
    \ fib + fibPrev, fib)\n                }\n            }\n        }\n        primeFib(1,\
    \ 2, 1)", "    \tval c = new Cache[Long, Long]()\n    \tc.update(0l, 0l)\n   \
    \ \tc.update(1l, 1l)\n    \tc.update(2l, 1l)\n    \tdef primeFib(n : Long, i :\
    \ Long, a : Long, b : Long) : Long = {\n    \t\tif (i < n) {\n    \t\t\tval c\
    \ = a + b\n    \t\t\tif (Problem.isPrime(c)) primeFib(n, i + 1, b, c)\n    \t\t\
    \telse primeFib(n, i, b, c)\n    \t\t}\n    \t\telse c(n)\n    \t}\n    \tprimeFib(n,\
    \ 3, 0, 1)", "        var dp = new Array[Long](n.toInt + 1)\n        dp(1) = 2\n\
    \        dp(2) = 3\n        for (i <- 3 to n.toInt) {\n            dp(i) = dp(i\
    \ - 1) + dp(i - 2)\n            if (!dp(i).isPrime) i -= 1\n        }\n      \
    \  return dp(n.toInt)", "        var primes = new ArrayBuffer[Long]();\n     \
    \   primes += 2l;\n        var fib = new ArrayBuffer[Long]();\n        fib +=\
    \ 2l;\n        fib += 3l;\n        def isPrime(n : Long) : Boolean = {\n     \
    \       val sqrtN = sqrt(n);\n            primes.forall(p => p <= sqrtN || n %\
    \ p != 0);\n        }\n        while (primes.length < n) {\n            var i\
    \ = fib.length - 1;\n            while (true) {\n                val f = fib(i)\
    \ + fib(i - 1);\n                fib += f;\n                if (isPrime(f)) {\n\
    \                    primes += f;\n                    if (primes.length == n)\
    \ return f;\n                }\n                i += 1;\n            }\n     \
    \   }\n        return primes(n.toInt - 1);", '        return 2', "        def\
    \ primeFib(primeFibs : List[Long], prime : Long, a : Long, b : Long) : Long =\
    \ {\n            if (primeFibs.length == n) primeFibs.last\n            else {\n\
    \                val c = a + b\n                if (BigInt(c).isProbablePrime(1000))\
    \ primeFib(primeFibs :+ c, c, b, c)\n                else primeFib(primeFibs,\
    \ prime, b, c)\n            }\n        }\n        primeFib(List[Long](), 2, 1,\
    \ 1)", "        val sieve = SieveOfEratosthenes(1000000)\n        val fibs = fibonacciNumbers(n,\
    \ sieve)\n        fibs(n.toInt - 1)", "        val fibs = scala.collection.mutable.Map((0l,\
    \ 2l), (1l, 3l))\n        def fib(n : Long) : Long = {\n            if (fibs.contains(n))\
    \ fibs(n)\n            else {\n                val result = fib(n - 1) + fib(n\
    \ - 2)\n                fibs(n) = result\n                result\n           \
    \ }\n        }\n        def nextPrime(n : Long) : Long = {\n            if (isPrime(n))\
    \ n\n            else nextPrime(n + 1)\n        }\n        def isPrime(n : Long)\
    \ : Boolean = {\n            if (n <= 1) false\n            else if (n == 2) true\n\
    \            else !(2l to sqrt(n).toLong).exists(n % _ == 0)\n        }\n    \
    \    nextPrime(fib(n))", "        var primes : List[Long] = List(2l)\n       \
    \ var fibs : List[Long] = List(2l, 3l)\n        var i : Long = 3l\n        var\
    \ count : Long = 1l\n        while (primes.length < n) {\n            if (fibs.contains(i))\
    \ {\n                primes = primes ++ List(i)\n                count += 1\n\
    \            }\n            fibs = fibs ++ List(i)\n            i += 1\n     \
    \   }\n        i - 1", "      val pb = new Problem(n)\n      pb.solve", "    \
    \    var i = 2l;\n        var a = 2l;\n        var b = 3l;\n        var c = 5l;\n\
    \        while (i < n) {\n            a = b;\n            b = c;\n           \
    \ c = a + b;\n            while (c % 2 == 0 || !Primes.isPrime(c)) {\n       \
    \         a = b;\n                b = c;\n                c = a + b;\n       \
    \     }\n            i += 1;\n        }\n        return c;", "        val p =\
    \ new PrimeGenerator\n        val f = new FibonacciGenerator\n        val s =\
    \ new Streamer\n        val zip = new ZipIterator(s, p)\n        val zip2 = new\
    \ ZipIterator(f, zip)\n        var i = 0l\n        var acc = 0l\n        while\
    \ (i < n) {\n            acc = zip2.next\n            i += 1\n        }\n    \
    \    acc", "        val arr = Array.fill(n.toInt + 1)(0l)\n        def f(i : Int)\
    \ : Long = {\n            if (i <= 2) return 1l\n            if (arr(i) == 0)\
    \ arr(i) = f(i - 1) + f(i - 2)\n            return arr(i)\n        }\n       \
    \ f(n.toInt)", "        def isPrime(n : Long) : Boolean = {\n            if (n\
    \ < 2) return false\n            if (n == 2) return true\n            if (n %\
    \ 2 == 0) return false\n            var i = 3\n            while (i <= sqrt(n))\
    \ {\n                if (n % i == 0) return false\n                i += 2\n  \
    \          }\n            return true\n        }\n        def isFib(n : Long)\
    \ : Boolean = {\n            def is_perfect_square(n : Long) : Boolean = {\n \
    \               val sqrt_n = sqrt(n).toLong\n                return sqrt_n * sqrt_n\
    \ == n\n            }\n            if (is_perfect_square(5 * n * n + 4) || is_perfect_square(5\
    \ * n * n - 4)) return true\n            return false\n        }\n        var\
    \ i = 1l\n        var cnt = 0l\n        while (cnt < n) {\n            if (isPrime(i)\
    \ && isFib(i)) cnt += 1\n            i += 1\n        }\n        return i - 1",
  "        var sieve = new Sieve(1000000);\n        var pre = 2l;\n        var cur\
    \ = 3l;\n        var k = 2l;\n        while (k <= n) {\n            var tmp =\
    \ cur;\n            cur = pre + cur;\n            pre = tmp;\n            if (sieve.isPrime(cur))\
    \ {\n                k += 1;\n            }\n        }\n        return cur;",
  "        var f = new Fib;\n        var p = new Prime;\n        var x = 1l;\n   \
    \     var i = 0l;\n        while (i < n) {\n            x = f.nextFib();\n   \
    \         while (!p.isPrime(x)) {\n                x = f.nextFib();\n        \
    \    }\n            i += 1l;\n        }\n        return x;", "        var i =\
    \ 0l\n        var f = 1l\n        var s = 1l\n        var count = 0l\n       \
    \ while (count < n) {\n            if (isPrime(f)) {\n                count +=\
    \ 1\n                i = f\n            }\n            val tmp = f\n         \
    \   f = s\n            s = tmp + s\n        }\n        i", "    \tval memo = new\
    \ scala.collection.mutable.HashMap[Long, Long]()\n    \tmemo += 1l -> 2l\n   \
    \ \tmemo += 2l -> 3l\n    \tmemo += 3l -> 5l\n    \tdef fibonacci(n : Long) :\
    \ Long = {\n    \t\tmemo.get(n) match {\n    \t\t\tcase Some(f) => f\n    \t\t\
    \tcase None => {\n    \t\t\t\tval f = fibonacci(n - 1) + fibonacci(n - 2)\n  \
    \  \t\t\t\tmemo += n -> f\n    \t\t\t\tf\n    \t\t\t}\n    \t\t}\n    \t}\n  \
    \  \tdef isPrime(x : Long) : Boolean = {\n    \t\tif (x == 2) return true\n  \
    \  \t\tfor (i <- 2l to x - 1) {\n    \t\t\tif (x % i == 0) return false\n    \t\
    \t}\n    \t\treturn true\n    \t}\n    \tvar count = 0l\n    \tvar i = 1l\n  \
    \  \twhile (count < n) {\n    \t\tval f = fibonacci(i)\n    \t\tif (isPrime(f))\
    \ count += 1\n    \t\ti += 1\n    \t}\n    \treturn fibonacci(i - 1)", "     \
    \   var m = 2l\n        var term = 3l\n        var curr = 0l\n        var prev\
    \ = 1l\n        while (m <= n) {\n            val next = curr + prev\n       \
    \     prev = curr\n            curr = next\n            if (curr.isPrime) {\n\
    \                m += 1\n                term = curr\n            }\n        }\n\
    \        term", "        def fib(n : Long) : Long = {\n            if (n <= 1)\
    \ {\n                1\n            } else {\n                fib(n - 1) + fib(n\
    \ - 2)\n            }\n        }\n        var i = 1\n        var cnt = 0\n   \
    \     while (cnt < n) {\n            i += 1\n            if (BigInt(fib(i)).isProbablePrime(10))\
    \ {\n                cnt += 1\n            }\n        }\n        fib(i)", "  \
    \      def primeFibR(n : Long, f : Long, s : Long, p : ArrayBuffer[Long]) : Long\
    \ = {\n            if (n == p.length) return s\n            val nf = f + s\n \
    \           if (isPrime(nf)) p += nf\n            primeFibR(n, s, nf, p)\n   \
    \     }\n        val p = ArrayBuffer[Long](2l, 3l)\n        primeFibR(n, 1l, 2l,\
    \ p)\n        p(n.toInt - 1)", "        // Your code here\n        null", "  \
    \      def primeFib0(n : Long, cur : Long, prev : Long, index : Long) : Long =\
    \ {\n            if (index == n) cur\n            else {\n                val\
    \ next = cur + prev\n                if (isPrime(next)) {\n                  \
    \  if (index == n - 1) next\n                    else primeFib0(n, next, cur,\
    \ index + 1)\n                }\n                else primeFib0(n, next, cur,\
    \ index)\n            }\n        }\n        primeFib0(n, 2, 1, 1)", "        var\
    \ a = 1l\n        var b = 1l\n        var i = 1l\n        while (i < n) {\n  \
    \          val c = a + b\n            a = b\n            b = c\n            if\
    \ (Library.isPrime(c)) {\n                i += 1\n            }\n        }\n \
    \       b", "        var f : BigInt = 2;\n        var f2 : BigInt = 1;\n     \
    \   var i : Long = 2;\n        while (i < n) {\n            {\n              \
    \  val temp : BigInt = f;\n                f = f + f2;\n                f2 = temp;\n\
    \                i = i + 1;\n            }\n        }\n        return f.toLong;",
  "        // fill in here\n        return (n);", "        val primes = HashSet[Long]()\n\
    \        val first = 2l\n        val second = 3l\n        primes += first\n  \
    \      primes += second\n        var fib = first + second\n        var index =\
    \ 1l\n        while (index < n) {\n            val (fib0, fib1) = primeFib_helper(fib,\
    \ primes)\n            fib = fib0 + fib1\n            index += 1\n        }\n\
    \        fib", "        var fib = Map(1l -> 2l, 2l -> 3l)\n        var primeCount\
    \ = 1\n        var i = 3l\n        while (primeCount < n) {\n            i +=\
    \ 1\n            val fibValue = fib(i - 1) + fib(i - 2)\n            fib += (i\
    \ -> fibValue)\n            if (Prime.isPrime(fibValue)) primeCount += 1\n   \
    \     }\n        fib(i)", "        val limit = 10000\n        val table = new\
    \ Array[Long](limit)\n        def isPrime(n : Long) : Boolean = {\n          \
    \  if (n < 2) return false\n            if (n == 2) return true\n            if\
    \ (n % 2 == 0) return false\n            val ub = sqrt(n).toLong\n           \
    \ for (i <- 3l to ub by 2) {\n                if (n % i == 0) return false\n \
    \           }\n            return true\n        }\n        table(0) = 2\n    \
    \    table(1) = 3\n        var idx = 1\n        var cur = 5\n        while (idx\
    \ < n) {\n            if (isPrime(cur)) {\n                idx += 1\n        \
    \        table(idx) = cur\n            }\n            cur += 2\n        }\n  \
    \      var i = idx\n        var j = 1\n        var p = 0l\n        var q = 0l\n\
    \        while (i > 0) {\n            q = table(i)\n            p = table(j)\n\
    \            if (q == p) {\n                i -= 1\n                j += 1\n \
    \           } else if (q < p) {\n                i -= 1\n            } else {\n\
    \                j += 1\n            }\n        }\n        return p", "      \
    \  var p = 1l\n        var t = (1l, 1l)\n        val sieve = new Sieve(1000000)\n\
    \        while (p <= n) {\n            t = (t._2, t._1 + t._2)\n            if\
    \ (sieve.isPrime(t._2)) p += 1\n        }\n        t._2", "    \t// pre-compute\
    \ the list of first 20000 prime numbers.\n    \tval primes = 2 #:: Stream.from(3,\
    \ 2).filter(x => List.range(2, x).forall(y => x % y != 0)).take(20000).toList\n\
    \    \tdef helper(fib : List[Long], prime : List[Long], count : Long) : Long =\
    \ fib match {\n    \t\tcase Nil => 0\n    \t\tcase head :: tail => if (count ==\
    \ n) head else helper(tail, prime, count + 1)\n    \t}\n    \thelper(fib.filter(n\
    \ => primes.contains(n)), primes, 1)", "        def primeFib(n : Long, m : Long,\
    \ a : Long, b : Long) : Long = {\n            if (n == m) a\n            else\
    \ if (Library.isPrime(b)) primeFib(n, m + 1, b, a + b)\n            else primeFib(n,\
    \ m, a, a + b)\n        }\n        primeFib(n, 1, 2, 3)", "        // assume n\
    \ >= 1\n        // assume n-th number is x\n        var m : Long = 0\n       \
    \ var fib : Long = 0\n        while (m < n) {\n            fib = fibonacci(m)\n\
    \            if (isPrime(fib)) m += 1\n        }\n        return fib", "     \
    \   var i = 0l\n        var p = 2l\n        var f = 1l\n        var f1 = 1l\n\
    \        var f2 = 1l\n        while (i != n) {\n            val f1f2sum = f1 +\
    \ f2\n            if (f1f2sum % 2 == 0) {\n                while (p * p <= f1f2sum)\
    \ {\n                    if (f1f2sum % p == 0) {\n                        f1 =\
    \ f1f2sum\n                        f2 = f\n                        p += 1\n  \
    \                      while (p % 2 == 0) p += 1\n                    } else p\
    \ += 1\n                }\n                i += 1\n                f = f1f2sum\n\
    \            } else {\n                f2 = f1\n                f1 = f1f2sum\n\
    \            }\n        }\n        f", "        def primeFib0(n : Long, fib :\
    \ Long, fib1 : Long, fib2 : Long, cnt : Long) : Long = {\n            if (cnt\
    \ == n) fib\n            else {\n                val fib3 = fib1 + fib2\n    \
    \            val cnt3 = if (isPrime(fib3)) cnt + 1 else cnt\n                primeFib0(n,\
    \ fib3, fib2, fib3, cnt3)\n            }\n        }\n        if (n == 1) 2\n \
    \       else primeFib0(n, 3, 2, 1, 2)", "        val fib = fibonacci(1, 1)\n \
    \       def search(n : Long, i : Long, seq : Stream[Long]) : Long = if (n == i)\n\
    \            seq.head\n        else {\n            val x = seq.head\n        \
    \    if (isPrime(x))\n                search(n, i + 1, seq.tail)\n           \
    \ else\n                search(n, i, seq.tail)\n        }\n        search(n, 1,\
    \ fib)", "        // >>> primeFib((5l))\n        // (89l)\n        //\n      \
    \  //     <-------x-----x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x------x",
  "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) {\n      \
    \          return false\n            }\n            else if (n == 2) {\n     \
    \           return true\n            }\n            else if (n % 2 == 0) {\n \
    \               return false\n            }\n            else {\n            \
    \    val m = math.sqrt(n).toLong\n                var i = 3l\n               \
    \ while (i <= m) {\n                    if (n % i == 0) {\n                  \
    \      return false\n                    }\n                    i = i + 2\n  \
    \              }\n                return true\n            }\n        }\n    \
    \    var f = 1l\n        var f_prev = 1l\n        var i = 1l\n        while (i\
    \ < n) {\n            val f_new = f + f_prev\n            f_prev = f\n       \
    \     f = f_new\n            if (isPrime(f)) {\n                i = i + 1\n  \
    \          }\n        }\n        return f", "        var a : Long = 2;\n     \
    \   var b : Long = 3;\n        while (true) {\n            if (n == 1) {\n   \
    \             return a;\n            }\n            if (Utils.isPrime(b)) {\n\
    \                n -= 1;\n            }\n            val c : Long = a + b;\n \
    \           a = b;\n            b = c;\n        }\n        return 0;", "     \
    \   def fib(n : Long) : Long = {\n            if (n == 1) return 1l\n        \
    \    if (n == 2) return 2l\n            else return fib(n - 1) + fib(n - 2)\n\
    \        }\n        def isPrime(n : Long) : Boolean = {\n            if (n ==\
    \ 1) return false\n            if (n == 2) return true\n            val top =\
    \ ceil(sqrt(n)).toLong\n            for (i <- 2l to top) {\n                if\
    \ (n % i == 0) return false\n            }\n            return true\n        }\n\
    \        val primes = ArrayBuffer[Long]()\n        var f = fib(1)\n        var\
    \ index = 0\n        while (primes.length < n) {\n            if (isPrime(f))\
    \ primes += f\n            index += 1\n            f = fib(index)\n        }\n\
    \        return primes(n.toInt - 1)", "        var i = 0l\n        var m = 0l\n\
    \        var a = 1l\n        var b = 1l\n        var c = 0l\n        while(i <\
    \ n) {\n            if(isPrime(c)) {\n                m = m + 1\n            \
    \    if(m == n) return c\n            }\n            c = a + b\n            a\
    \ = b\n            b = c\n            i = i + 1\n        }\n        return c",
  "        var a = 1l\n        var b = 1l\n        var count = 2l\n        var c =\
    \ 2l\n        while (count < n) {\n            c = a + b\n            if (BigInt(c).isProbablePrime(10000))\
    \ {\n                count += 1\n            }\n            a = b\n          \
    \  b = c\n        }\n        return c", "        var i = 0l\n        var c = 0l\n\
    \        val sieve = Sieve(1000000)\n        while (i < n) {\n            if (sieve.isPrime(c))\
    \ i += 1\n            c += 1\n        }\n        return sieve.getNthPrime(n)",
  "    \tvar found = 0l\n    \tvar fib = 1l\n    \tvar cur = 1l\n    \tvar last =\
    \ 0l\n    \tvar tmp = 0l\n    \twhile (found != n) {\n    \t\tif (cur.isPrime)\
    \ {\n    \t\t\tfound += 1\n    \t\t\tfib = cur\n    \t\t}\n    \t\ttmp = cur\n\
    \    \t\tcur += last\n    \t\tlast = tmp\n    \t}\n    \treturn fib", "      \
    \  val primes = Primes.getPrimesLessThan(100000)\n        var i = 1l\n       \
    \ var index = 0\n        var fib = 0l\n        var last = 0l\n        while (index\
    \ < n) {\n            fib = Fibonacci.get(i)\n            if (primes.contains(fib))\
    \ {\n                index += 1\n                last = fib\n            }\n \
    \           i += 1\n        }\n        return last", "        var i = 0l\n   \
    \     var j = 1l\n        var k = 0l\n        var p = 0l\n        while (true)\
    \ {\n            k = i + j\n            if (Utils.isPrime(k)) {\n            \
    \    p += 1\n                if (p == n) return k\n            }\n           \
    \ i = j\n            j = k\n        }\n        0", "        def isPrime(n : Long)\
    \ : Boolean = {\n            if (n < 2) {\n                return false\n    \
    \        }\n            else if (n == 2) {\n                return true\n    \
    \        }\n            else if (n % 2 == 0) {\n                return false\n\
    \            }\n            else {\n                var i : Long = 3\n       \
    \         while (i <= ceil(sqrt(n))) {\n                    if (n % i == 0) {\n\
    \                        return false\n                    }\n               \
    \     i += 2\n                }\n                return true\n            }\n\
    \        }\n        var x : Long = 0\n        var y : Long = 1\n        var count\
    \ : Long = 0\n        while (count < n) {\n            val temp : Long = x\n \
    \           x = y\n            y = temp + y\n            if (isPrime(x)) {\n \
    \               count += 1\n            }\n        }\n        return x", "   \
    \     val sieve = Array.fill(3 * 1000000 + 1)(true)\n        def isPrime(n : Int)\
    \ : Boolean = if (n < 2) false else sieve(n)\n        def setComposite(i : Int)\
    \ {\n            sieve(i) = false\n        }\n        for (i <- 2 to 3000000)\
    \ {\n            if (isPrime(i)) {\n                var k = i + i\n          \
    \      while (k <= 3000000) {\n                    setComposite(k)\n         \
    \           k += i\n                }\n            }\n        }\n        val primes\
    \ = (1 to 3000000).filter(isPrime)\n        val fibs = new ArrayBuffer[Long]()\n\
    \        fibs += 2l\n        fibs += 3l\n        var f = 5l\n        while (f\
    \ < 2147483647l) {\n            fibs += f\n            f = fibs(fibs.length -\
    \ 1) + fibs(fibs.length - 2)\n        }\n        val candidates = fibs.filter(primes.contains(_))\n\
    \        var cnt = 0\n        for (i <- 0 until candidates.length) {\n       \
    \     if (candidates(i) >= 1000000l) {\n                cnt += 1\n           \
    \     if (cnt == n) return candidates(i)\n            }\n        }\n        0l",
  "        val isPrime = new Array[Boolean](1000)\n        for (i <- 0 until 1000)\
    \ isPrime(i) = true\n        for (i <- 2 until 1000) {\n            if (isPrime(i))\
    \ {\n                var j = 2 * i\n                while (j < 1000) {\n     \
    \               isPrime(j) = false\n                    j += i\n             \
    \   }\n            }\n        }\n        val nums = new Array[Long](1000)\n  \
    \      nums(0) = 1\n        nums(1) = 1\n        for (i <- 2 until 1000) {\n \
    \           nums(i) = nums(i - 1) + nums(i - 2)\n        }\n        var count\
    \ = 0\n        var i = 0\n        while (count < n) {\n            if (isPrime(i))\
    \ count += 1\n            i += 1\n        }\n        return nums(i - 1)", "  \
    \      var count = 0l\n        var currentFib = 0l\n        var prevFib = 0l\n\
    \        while (count < n) {\n            currentFib = if (count == 0) 2l else\
    \ if (count == 1) 3l else currentFib + prevFib\n            if (NumberTheory.isPrime(currentFib))\
    \ {\n                count += 1\n            }\n            prevFib = currentFib\n\
    \        }\n        return currentFib", "        val fibs = Stream.from(1).scanLeft((0l,\
    \ 1l))((b, a) => (b._2, b._1 + b._2)).tail.map(_._2)\n        fibs.takeWhile(f\
    \ => f < 4000000l).filter(n => {\n            val a = (n - 1l) / 2l\n        \
    \    var flag = true\n            for (i <- 1l to (sqrt(a).toLong)) {\n      \
    \          if (a % i == 0l) {\n                    flag = false\n            \
    \        break\n                }\n            }\n            flag\n        })(n.toInt\
    \ - 1)", "        var fibs = new ArrayBuffer[Long]();\n        var memo = new\
    \ HashMap[Int, Long]();\n        fibs += 1l;\n        fibs += 2l;\n        memo\
    \ += (1 -> 1l);\n        memo += (2 -> 2l);\n        var i = 1;\n        while\
    \ (fibs.size < n) {\n            var next = fibs(i - 1) + fibs(i);\n         \
    \   memo += (i + 1 -> next);\n            fibs += next;\n            i += 1;\n\
    \        }\n        return fibs(n.toInt - 1);", "        val primeTable = BigInt(1e6.toInt)\n\
    \        var primeList = new ArrayBuffer[Long]()\n        var primeFibList = new\
    \ ArrayBuffer[Long]()\n        primeList += 2l\n        for (i <- 3l to primeTable.toLong\
    \ by 2) {\n            if (primeList.forall(p => i % p != 0)) {\n            \
    \    primeList += i\n            }\n        }\n        var current = 1l\n    \
    \    var last = 1l\n        var next = 1l\n        while (primeFibList.length\
    \ < n) {\n            next = current + last\n            if (primeList.exists(p\
    \ => next % p == 0)) {\n                primeFibList += next\n            }\n\
    \            last = current\n            current = next\n        }\n        return\
    \ primeFibList.last", "        assert(n >= 1)\n        var fibs = new Array[Long](n.toInt)\n\
    \        fibs(0) = 1\n        fibs(1) = 2\n        var i = 1\n        while (i\
    \ < n - 1) {\n            fibs(i + 1) = fibs(i) + fibs(i - 1)\n            i +=\
    \ 1\n        }\n        fibs(n.toInt - 1)", "        def isPrime(n : Long) : Boolean\
    \ = {\n            val sqrt = sqrt(n)\n            val factors = (2l to sqrt.toLong).filter(n\
    \ % _ == 0)\n            factors.isEmpty\n        }\n        var pfib = n\n  \
    \      var i = 2l\n        var fib = (1l, 1l)\n        while (pfib > 0) {\n  \
    \          if (isPrime(fib._1)) pfib -= 1\n            fib = (fib._2, fib._1 +\
    \ fib._2)\n        }\n        fib._1", "        var x = 2l;\n        var y = 3l;\n\
    \        for (i <- 1l to n) {\n            val z = x + y;\n            val zSqrt\
    \ = sqrt(z);\n            var isPrime = true;\n            for (j <- 2l to zSqrt.toLong)\
    \ {\n                if (z % j == 0) {\n                    isPrime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (isPrime) {\n                x = y;\n                y = z;\n            }\n\
    \        }\n        x;", "        var n_th_primeFib = 0l\n        var list = List(2l,\
    \ 3l)\n        var cnt = 0l\n        while (cnt < n) {\n            cnt += 1\n\
    \            val last_2 = list(list.length - 2)\n            val last_1 = list(list.length\
    \ - 1)\n            val next_primeFib = last_2 + last_1\n            if (Prime.isPrime(next_primeFib))\
    \ {\n                list = list :+ next_primeFib\n                n_th_primeFib\
    \ = next_primeFib\n            }\n        }\n        return n_th_primeFib", " \
    \       // TODO: Implement this\n        return 0l", "        var result : Long\
    \ = 0l\n        var count : Long = 0l\n        var cur : Long = 2l\n        while\
    \ (count < n) {\n            if (isPrime(cur) && isFib(cur)) {\n             \
    \   count += 1\n                result = cur\n            }\n            cur +=\
    \ 1\n        }\n        return result", "        def helper(i : Long, fib : Long,\
    \ primes : Set[Long]) : Long = {\n            if (i == n) fib\n            else\
    \ {\n                val nextFib = fib * 2 + 1\n                val nextPrimes\
    \ = if (primes.forall(p => nextFib % p != 0)) primes + nextFib else primes\n \
    \               helper(i + 1, nextFib, nextPrimes)\n            }\n        }\n\
    \        helper(1, 2, Set(2l, 3l, 5l, 13l, 89l))", "        def loop(a : Long,\
    \ b : Long, f : Long, i : Long) : Long = {\n            if (i == n) f\n      \
    \      else {\n                val next_a = b\n                val next_b = a\
    \ + b\n                if (isPrime(next_b)) loop(next_a, next_b, next_b, i + 1)\n\
    \                else loop(next_a, next_b, f, i)\n            }\n        }\n \
    \       loop(1, 2, 2, 1)", "        def recur(x : Long, acc : Long, n : Long)\
    \ : Long = {\n            if (acc == n) {\n                x\n            } else\
    \ {\n                recur(x + 1, acc + (if (numbers.BigInt(x).isPrime && numbers.BigInt(x).isFibonacci)\
    \ 1 else 0), n)\n            }\n        }\n        recur(1, 0, n)", "        def\
    \ fib(n : Long) : Long = if (n == 0) 1 else if (n == 1) 1 else fib(n - 1) + fib(n\
    \ - 2)\n        var ps = new PrimeSieve(fib(n).toInt)\n        var i = 2\n   \
    \     var last = 0l\n        while (i < n) {\n            last = fib(i)\n    \
    \        while (!ps.isPrime(last.toInt)) last += 1\n            i += 1\n     \
    \   }\n        last", "    \tvar i = 0l\n    \tvar x = 1l\n    \tvar y = 1l\n\
    \    \twhile(i < n) {\n    \t\tval z = x + y\n    \t\tx = y\n    \t\ty = z\n \
    \   \t\tif(z.isPrime) {\n    \t\t\ti += 1\n    \t\t}\n    \t}\n    \treturn x",
  "        def isPrime(n : Long) : Boolean = {\n            if (n <= 2) return n ==\
    \ 2\n            if (n % 2 == 0) return false\n            for (i <- 3l to sqrt(n).toLong\
    \ by 2) if (n % i == 0) return false\n            return true\n        }\n   \
    \     var nthFibPrime = 0l\n        var cntFib = 0l\n        var i = 0l\n    \
    \    while (cntFib < n) {\n            i += 1\n            if (isPrime(i) && isPrime(i\
    \ + 2)) {\n                cntFib += 1\n                nthFibPrime = i\n    \
    \        }\n        }\n        return nthFibPrime", "        if (n < 1) throw\
    \ new Exception(\"n cannot be less than 1!\")\n        var x : Long = 2\n    \
    \    var y : Long = 3\n        var m : Long = 1\n        var count : Long = 2\n\
    \        var result : Long = 0\n        while (count <= n) {\n            val\
    \ sum : Long = x + y\n            if (isPrime(sum)) {\n                count +=\
    \ 1\n                result = sum\n            }\n            m += 1\n       \
    \     x = y\n            y = sum\n        }\n        return result", "       \
    \ var fibs = ArrayBuffer[Long](2l, 3l)\n        var pcount = 1l\n        var fcount\
    \ = 2l\n        var fib = fibs(1)\n        var p = 3l\n        var i = 3l\n  \
    \      while (pcount < n) {\n            p = i\n            if (p.isPrime) {\n\
    \                pcount += 1\n                if (fibs.contains(p)) {\n      \
    \              fibs += p\n                    fib = p\n                    fcount\
    \ += 1\n                }\n            }\n            i += 2\n        }\n    \
    \    fib", "        if (n < 2) return 2l\n        var count = 1l\n        var\
    \ (a, b) = (2l, 3l)\n        while (count < n) {\n            val c = a + b\n\
    \            a = b\n            b = c\n            if (Utils.isPrime(b)) count\
    \ += 1\n        }\n        return b"]
stop_tokens:
- "\n    }\n"
