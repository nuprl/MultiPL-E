name: HumanEval_46_fib4
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n    // fib4(0) -> 0\n    // fib4(1) -> 0\n    // fib4(2)\
  \ -> 2\n    // fib4(3) -> 0\n    // fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3)\
  \ + fib4(n-4).\n    // Please write a function to efficiently compute the n-th element\
  \ of the fib4 number sequence.  Do not use recursion.\n    // >>> fib4((5l))\n \
  \   // (4l)\n    // >>> fib4((6l))\n    // (8l)\n    // >>> fib4((7l))\n    // (14l)\n\
  \    def fib4(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(fib4((5l)) == (4l));\n\
  \    assert(fib4((8l)) == (28l));\n    assert(fib4((10l)) == (104l));\n    assert(fib4((12l))\
  \ == (386l));\n    }\n\n}\n"
completions: ["        if (n < 0) throw new IllegalArgumentException(\"fib4(n) doesn't\
    \ support negative numbers.\")\n        else if (n == 0) 0\n        else if (n\
    \ == 1) 0\n        else if (n == 2) 2\n        else if (n == 3) 0\n        else\
    \ {\n            var fib1 = 0l\n            var fib2 = 0l\n            var fib3\
    \ = 2l\n            var fib4 = 0l\n            var i = 4l\n            while (i\
    \ <= n) {\n                val temp = fib1 + fib2 + fib3 + fib4\n            \
    \    fib1 = fib2\n                fib2 = fib3\n                fib3 = fib4\n \
    \               fib4 = temp\n                i += 1\n            }\n         \
    \   fib1 + fib2 + fib3 + fib4\n        }", "        if (n == 0l) 0l\n        else\
    \ if (n == 1l) 0l\n        else if (n == 2l) 2l\n        else if (n == 3l) 0l\n\
    \        else {\n            var a = 0l\n            var b = 0l\n            var\
    \ c = 2l\n            var d = 0l\n            var i = 4l\n            while (i\
    \ <= n) {\n                d = a + b + c + d\n                a = b\n        \
    \        b = c\n                c = d\n                i += 1\n            }\n\
    \            d\n        }", "        var (a, b, c, d) = (0L, 0L, 2L, 0L)\n   \
    \     var i = 0L\n        while (i < n) {\n            val x = a + b + c + d\n\
    \            d = c\n            c = b\n            b = a\n            a = x\n\
    \            i += 1\n        }\n        return b", "        // Fill up this function\
    \ body\n        // You may also define other functions to help you\n        ???",
  "        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        if (n <= 0) 0 else if (n == 1) 0 else if (n ==\
    \ 2) 2 else if (n == 3) 0 else {\n            var k:Long = 2\n            var\
    \ k1:Long = 0\n            var k2:Long = 2\n            var k3:Long = 0\n    \
    \        var k4:Long = 0\n            for (i <- 5 to n.toInt) {\n            \
    \    k4 = k3\n                k3 = k2\n                k2 = k1\n             \
    \   k1 = k\n                k = k1 + k2 + k3 + k4\n            }\n           \
    \ k\n        }", "        var n0 = 0l\n        var n1 = 0l\n        var n2 = 2l\n\
    \        var n3 = 0l\n        var current = 0l\n        var i = 0l\n        while\
    \ (i < n) {\n            current = n3 + n2 + n1 + n0\n            n0 = n1\n  \
    \          n1 = n2\n            n2 = n3\n            n3 = current\n          \
    \  i += 1\n        }\n        return current", "        var a : Long = 0\n   \
    \     var b : Long = 0\n        var c : Long = 2\n        var d : Long = 0\n \
    \       for (i <- 4 to n.toInt) {\n            d = a + b + c\n            a =\
    \ b\n            b = c\n            c = d\n        }\n        return d", "   \
    \     // Fill Up this function body\n        // `0` is the initial value of the\
    \ accumulator in your fold function\n        // `fib4Accumulator` is the accumulator\
    \ function\n        // `1l to n` is the list you are folding over\n        0l",
  "        // Fill Up this function body\n        // `0` is the default value for\
    \ `Long` and `Float`, you can change it according to your need\n        if (n\
    \ == 0) return 0\n        if (n == 1) return 0\n        if (n == 2) return 2\n\
    \        if (n == 3) return 0\n        var a = Array(0L, 0L, 2L, 0L)\n       \
    \ for (i <- 4 to n.toInt) {\n            var tmp = a(0)\n            a(0) = a(1)\n\
    \            a(1) = a(2)\n            a(2) = a(3)\n            a(3) = tmp + a(0)\
    \ + a(1) + a(2)\n        }\n        return a(3)", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var i = 0l\n        var prev1 = 0l\n        var prev2 = 0l\n        var prev3\
    \ = 0l\n        var prev4 = 0l\n        while (i < n) {\n          if (i == 0)\
    \ {\n            prev1 = 0\n          } else if (i == 1) {\n            prev2\
    \ = 0\n          } else if (i == 2) {\n            prev3 = 2\n          } else\
    \ if (i == 3) {\n            prev4 = 0\n          } else {\n            var temp\
    \ = prev4\n            prev4 = prev3 + prev2 + prev1 + prev4\n            prev1\
    \ = prev2\n            prev2 = prev3\n            prev3 = temp\n          }\n\
    \          i += 1\n        }\n        return prev4", "        // Fill up this\
    \ function body\n        // You may also define additional functions as needed\n\
    \        var fibs = ArrayBuffer(0, 0, 2, 0)\n        for (i <- 4 to n.toInt) {\n\
    \            var next = fibs(i - 1) + fibs(i - 2) + fibs(i - 3) + fibs(i - 4)\n\
    \            fibs += next\n        }\n        fibs(n.toInt)", "        var f1\
    \ : Long = 0\n        var f2 : Long = 0\n        var f3 : Long = 2\n        var\
    \ f4 : Long = 0\n        if (n < 4) {\n            return fib4((n.toInt))\n  \
    \      }\n        else {\n            f1 = fib4((n - 1))\n            f2 = fib4((n\
    \ - 2))\n            f3 = fib4((n - 3))\n            f4 = fib4((n - 4))\n    \
    \        return (f1 + f2 + f3 + f4)\n        }", "        // Fill up this function\
    \ body\n        // You may also define additional function(s) if needed\n    \
    \    0", "        val matrix = Array((1l, 0l, 0l, 0l), (0l, 1l, 0l, 0l), (0l,\
    \ 0l, 1l, 0l), (0l, 0l, 0l, 1l))\n        def pow(a : Array[Array[Long]], k :\
    \ Long) : Array[Array[Long]] = {\n            if (k == 0) return Array((1l, 0l,\
    \ 0l, 0l), (0l, 1l, 0l, 0l), (0l, 0l, 1l, 0l), (0l, 0l, 0l, 1l))\n           \
    \ else if (k % 2 == 0) {\n                val p = pow(a, k / 2)\n            \
    \    matrixMultiply(p, p)\n            }\n            else matrixMultiply(a, pow(a,\
    \ k - 1))\n        }\n        def matrixMultiply(a : Array[Array[Long]], b : Array[Array[Long]])\
    \ : Array[Array[Long]] = {\n            val c = Array.ofDim[Long](4, 4)\n    \
    \        for (i <- 0 until 4; j <- 0 until 4) {\n                c(i)(j) = 0\n\
    \                for (k <- 0 until 4) c(i)(j) += a(i)(k) * b(k)(j)\n         \
    \   }\n            c\n        }\n        var p = Array((1l, 0l, 0l, 0l), (0l,\
    \ 1l, 0l, 0l), (0l, 0l, 1l, 0l), (0l, 0l, 0l, 1l))\n        val power = Array(n,\
    \ n - 1, n - 2, n - 3)\n        for (i <- 0 until 4) p = matrixMultiply(p, pow(matrix,\
    \ power(i)))\n        p(0)(0)", "        var a = 0l\n        var b = 0l\n    \
    \    var c = 2l\n        var d = 0l\n        if (n <= 3) {\n            return\
    \ d\n        }\n        for (i <- 4l to n) {\n            d = a + b + c\n    \
    \        a = b\n            b = c\n            c = d\n        }\n        return\
    \ d", "        val A : Array[Long] = Array(0, 0, 2, 0)\n        for (i <- 4 to\
    \ n.toInt) {\n            A(3) = A(2) + A(1) + A(0)\n            A(0) = A(1)\n\
    \            A(1) = A(2)\n            A(2) = A(3)\n        }\n        A(3)", " \
    \       // Fill up this function body\n        // You may also define any auxiliary\
    \ functions you may need\n        fib4(n, 0, 0, 2, 0)", "        var a = 0l\n\
    \        var b = 0l\n        var c = 2l\n        var d = 0l\n        var temp\
    \ = 0l\n        if (n == 0) return 0\n        if (n == 1) return 0\n        if\
    \ (n == 2) return 2\n        if (n == 3) return 0\n        for (i <- 4l to n)\
    \ {\n            temp = a + b + c + d\n            a = b\n            b = c\n\
    \            c = d\n            d = temp\n        }\n        return d", "    \
    \    var s0 : Long = 0;\n        var s1 : Long = 0;\n        var s2 : Long = 2;\n\
    \        var s3 : Long = 0;\n        var n1 : Long = 3;\n        while (n1 <=\
    \ n) {\n            s3 = s0 + s1 + s2 + s3;\n            s0 = s1;\n          \
    \  s1 = s2;\n            s2 = s3;\n            n1 = n1 + 1;\n        }\n     \
    \   return s3;", "        // Fill up this function body\n        // You can add\
    \ another function as well, if required\n        var n1 = 0l\n        var n2 =\
    \ 0l\n        var n3 = 2l\n        var n4 = 0l\n        if (n == 0) return n1\n\
    \        if (n == 1) return n2\n        if (n == 2) return n3\n        if (n ==\
    \ 3) return n4\n        var i = 4l\n        while (i <= n) {\n            val\
    \ sum = n1 + n2 + n3 + n4\n            n1 = n2\n            n2 = n3\n        \
    \    n3 = n4\n            n4 = sum\n            i += 1\n        }\n        n4",
  "        // Fill up this function body\n        // You may also define any auxiliary\
    \ functions, variables, classes if needed\n        // As an example below we create\
    \ a class for storing 2 numbers\n        // You may use it if needed for storing\
    \ 4 numbers\n        // or you may create your own custom class or function\n\
    \        // It is also possible to use arrays or ArrayBuffers, lists, etc\n  \
    \      class Numbers(var a : Long, var b : Long)\n        val data = ArrayBuffer[Numbers]()\n\
    \        data += new Numbers(0, 0)\n        data += new Numbers(0, 0)\n      \
    \  data += new Numbers(2, 0)\n        data += new Numbers(0, 0)\n        for (i\
    \ <- 4 to n.toInt) {\n            val nd = new Numbers(0, 0)\n            nd.a\
    \ = data(i - 1).a + data(i - 2).a + data(i - 3).a + data(i - 4).a\n          \
    \  data += nd\n        }\n        data(n.toInt).a", "        // Insert your code\
    \ here\n        var seq = ArrayBuffer(0, 0, 2, 0, 0)\n        for (i <- 4 to n.toInt)\
    \ {\n            seq += seq(i - 1) + seq(i - 2) + seq(i - 3) + seq(i - 4)\n  \
    \      }\n        seq(n.toInt)", "        // Fill up this function body\n    \
    \    // You may also define any auxiliary functions you may need\n        if (n\
    \ < 0) {\n            return 0\n        }\n        if (n == 0) {\n           \
    \ return 0\n        }\n        if (n == 1) {\n            return 0\n        }\n\
    \        if (n == 2) {\n            return 2\n        }\n        if (n == 3) {\n\
    \            return 0\n        }\n        var fib4_prev_prev_prev = 0L\n     \
    \   var fib4_prev_prev = 0L\n        var fib4_prev = 2L\n        var fib4_curr\
    \ = 0L\n        for (i <- 4L to n) {\n            fib4_curr = fib4_prev_prev_prev\
    \ + fib4_prev_prev + fib4_prev\n            fib4_prev_prev_prev = fib4_prev_prev\n\
    \            fib4_prev_prev = fib4_prev\n            fib4_prev = fib4_curr\n \
    \       }\n        return fib4_curr", "        // Fill Up this function body\n\
    \        // You can add another function as well, if required\n        0", " \
    \       def loop(n : Long, current : Long, prev : Long, prev2 : Long, prev3 :\
    \ Long) : Long = {\n            if (n == 0) current\n            else loop(n -\
    \ 1, current + prev + prev2 + prev3, current, prev, prev2)\n        }\n      \
    \  loop(n, 0, 0, 2, 0)", "        // Fill up this function body\n        // You\
    \ may also define any auxiliary functions as needed\n        var fibMap = new\
    \ HashMap[Long, Long]()\n        fibMap += (0L -> 0L)\n        fibMap += (1L ->\
    \ 0L)\n        fibMap += (2L -> 2L)\n        fibMap += (3L -> 0L)\n        return\
    \ fibHelper(n, fibMap)", "        // fib4(7) = fib4(6) + fib4(5) + fib4(4) + fib4(3)\n\
    \        //         = 8   + 4   + 2   + 0\n        //         = 14\n        if\
    \ (n < 3) return n match {\n            case 0 => 0\n            case 1 => 0\n\
    \            case 2 => 2\n        }\n        var f2 = 1l;\n        var f1 = 1l;\n\
    \        var f = 2l;\n        for (i <- 3l to n) {\n            f2 = f1;\n   \
    \         f1 = f;\n            f = f1 + f2 + 2l;\n        }\n        f", "   \
    \     if (n < 3) return n*2\n        var a = 0l\n        var b = 0l\n        var\
    \ c = 2l\n        var d = 0l\n        for (i <- 3l to n) {\n            d = a\
    \ + b + c + d\n            a = b\n            b = c\n            c = d\n     \
    \   }\n        return d", "        if (n == 0) 0\n        else if (n == 1) 0\n\
    \        else if (n == 2) 2\n        else if (n == 3) 0\n        else {\n    \
    \        var a = 0l\n            var b = 0l\n            var c = 2l\n        \
    \    var d = 0l\n            var i = 4l\n            while (i <= n) {\n      \
    \          val temp = a + b + c + d\n                a = b\n                b\
    \ = c\n                c = d\n                d = temp\n                i += 1\n\
    \            }\n            a + b + c + d\n        }", "        if (n < 3) n\n\
    \        else {\n            var a = 0l\n            var b = 0l\n            var\
    \ c = 2l\n            var d = 0l\n            for (i <- 3l to n) {\n         \
    \       d = a + b + c\n                a = b\n                b = c\n        \
    \        c = d\n            }\n            d\n        }", "        val arr = ArrayBuffer[Long](0,\
    \ 0, 2, 0)\n        if (n < 4) return arr(n.toInt)\n        for (i <- 4 to n.toInt)\
    \ {\n            val temp = arr(3)\n            arr(3) = arr(0) + arr(1) + arr(2)\
    \ + arr(3)\n            arr(0) = arr(1)\n            arr(1) = arr(2)\n       \
    \     arr(2) = temp\n        }\n        return arr(3)", "        // Fill up this\
    \ function body\n        // You can add another function as well, if required\n\
    \        var f0 = 0l\n        var f1 = 0l\n        var f2 = 2l\n        var f3\
    \ = 0l\n        var f4 = f3 + f2 + f1 + f0\n        for (i <- 4l to n) {\n   \
    \         f0 = f1\n            f1 = f2\n            f2 = f3\n            f3 =\
    \ f4\n            f4 = f3 + f2 + f1 + f0\n        }\n        return f4", "   \
    \     if (n == 0) return 0\n        if (n == 1) return 0\n        if (n == 2)\
    \ return 2\n        if (n == 3) return 0\n        var f1 = 0l\n        var f2\
    \ = 0l\n        var f3 = 2l\n        var f4 = 0l\n        var i = 3l\n       \
    \ while (i < n) {\n            var fn = f4 + f3 + f2 + f1\n            f1 = f2\n\
    \            f2 = f3\n            f3 = f4\n            f4 = fn\n            i\
    \ += 1\n        }\n        return f4 + f3 + f2 + f1", "        val a = Array.fill(4)(0)\n\
    \        a(0) = 0\n        a(1) = 0\n        a(2) = 2\n        a(3) = 0\n    \
    \    for (i <- 4l to n) {\n            val temp = a(0)\n            a(0) = a(1)\n\
    \            a(1) = a(2)\n            a(2) = a(3)\n            a(3) = temp + a(0)\
    \ + a(1) + a(2)\n        }\n        a(3)", "        val a = ArrayBuffer[Long](0,\
    \ 0, 2, 0)\n        for (i <- 4 to n.toInt) {\n            a += a(i - 1) + a(i\
    \ - 2) + a(i - 3) + a(i - 4)\n        }\n        a(n.toInt)", "        // Fill\
    \ up this function body\n        // You may also define other functions as needed\n\
    \        return 0", "        var a = 0l\n        var b = 0l\n        var c = 2l\n\
    \        var d = 0l\n        var result = 0l\n        if (n == 0) return 0\n \
    \       if (n == 1) return 0\n        if (n == 2) return 2\n        if (n == 3)\
    \ return 0\n        for (i <- 4 to n.toInt) {\n            result = a + b + c\
    \ + d\n            a = b\n            b = c\n            c = d\n            d\
    \ = result\n        }\n        return result", "        if (n == 0) 0\n      \
    \  else if (n == 1) 0\n        else if (n == 2) 2\n        else if (n == 3) 0\n\
    \        else {\n            val array = ArrayBuffer[Long](0, 0, 2, 0)\n     \
    \       for (i <- 4 to n.toInt) {\n                array += array(i - 1) + array(i\
    \ - 2) + array(i - 3) + array(i - 4)\n            }\n            array(n.toInt)\n\
    \        }", "        var a = 0l\n        var b = 0l\n        var c = 2l\n   \
    \     var d = 0l\n        for (i <- 3 to n.toInt) {\n            d = a + b + c\
    \ + d\n            a = b\n            b = c\n            c = d\n        }\n  \
    \      return d", "        if (n == 0) 0\n        else if (n == 1) 0\n       \
    \ else if (n == 2) 2\n        else if (n == 3) 0\n        else {\n           \
    \ var a = 0l\n            var b = 0l\n            var c = 2l\n            var\
    \ d = 0l\n            var i = 4l\n            while (i <= n) {\n             \
    \   val t = a + b + c + d\n                a = b\n                b = c\n    \
    \            c = d\n                d = t\n                i += 1\n          \
    \  }\n            d\n        }", "        var a = 0l\n        var b = 0l\n   \
    \     var c = 2l\n        var d = 0l\n        for (i <- 3l to n) {\n         \
    \   var e = a + b + c + d\n            a = b\n            b = c\n            c\
    \ = d\n            d = e\n        }\n        d", "        /**\n        *   Fib4(n)\
    \ = a*Fib4(n-1) + b*Fib4(n-2) + c*Fib4(n-3) + d*Fib4(n-4)\n        *   Fib4(n-1)\
    \ = a*Fib4(n-2) + b*Fib4(n-3) + c*Fib4(n-4) + d*Fib4(n-5)\n        *   Fib4(n-2)\
    \ = a*Fib4(n-3) + b*Fib4(n-4) + c*Fib4(n-5) + d*Fib4(n-6)\n        *   Fib4(n-3)\
    \ = a*Fib4(n-4) + b*Fib4(n-5) + c*Fib4(n-6) + d*Fib4(n-7)\n        *   Fib4(n-4)\
    \ = a*Fib4(n-5) + b*Fib4(n-6) + c*Fib4(n-7) + d*Fib4(n-8)\n        *   \n    \
    \    *   Fib4(n) - a*Fib4(n-1) - b*Fib4(n-2) - c*Fib4(n-3) = d*Fib4(n-4)\n   \
    \     *   Fib4(n-1) - a*Fib4(n-2) - b*Fib4(n-3) - c*Fib4(n-4) = d*Fib4(n-5)\n\
    \        *   Fib4(n-2) - a*Fib4(n-3) - b*Fib4(n-4) - c*Fib4(n-5) = d*Fib4(n-6)\n\
    \        *   Fib4(n-3) - a*Fib4(n-4) - b*Fib4(n-5) - c*Fib4(n-6) = d*Fib4(n-7)\n\
    \        *   Fib4(n-4) - a*", "\tvar matrix = ((0L, 0L, 2L, 0L), (1L, 0L, 0L,\
    \ 0L), (0L, 1L, 0L, 0L), (0L, 0L, 0L, 1L))\n\tvar res = (1L, 0L, 0L, 0L)\n\tvar\
    \ nb = n\n\twhile (nb > 0) {\n\t    if (nb % 2 == 1) {\n\t\tres = res * matrix\n\
    \t    }\n\t    matrix = matrix * matrix\n\t    nb = nb / 2\n\t}\n\tres._1", " \
    \       // Fill in body\n        var a = 0l\n        var b = 0l\n        var c\
    \ = 2l\n        var d = 0l\n        var e = 0l\n        for (i <- 4l to n) {\n\
    \            e = a + b + c + d\n            a = b\n            b = c\n       \
    \     c = d\n            d = e\n        }\n        e", "        var a0 = 0l\n\
    \        var a1 = 0l\n        var a2 = 2l\n        var a3 = 0l\n        if (n\
    \ == 0) return a0\n        if (n == 1) return a1\n        if (n == 2) return a2\n\
    \        for (i <- 4 to n.toInt) {\n            val a4 = a0 + a1 + a2 + a3\n \
    \           a0 = a1\n            a1 = a2\n            a2 = a3\n            a3\
    \ = a4\n        }\n        return a3", "        // Fill up this function body\n\
    \        // You may also define new functions\n        var a = 0L\n        var\
    \ b = 0L\n        var c = 2L\n        var d = 0L\n        for (i <- 1 to n.toInt\
    \ - 1) {\n            d = a + b + c\n            a = b\n            b = c\n  \
    \          c = d\n        }\n        d", '        return 0', "        // Fill\
    \ up this function body\n        // You may also define other functions as you\
    \ wish\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n       \
    \ if (n == 2) return 2;\n        if (n == 3) return 0;\n        var i: Long =\
    \ 4;\n        var a: Long = 0;\n        var b: Long = 0;\n        var c: Long\
    \ = 2;\n        var d: Long = 0;\n        var total: Long = 4;\n        while\
    \ (i <= n) {\n            var temp: Long = a;\n            a = b;\n          \
    \  b = c;\n            c = d;\n            d = total;\n            total = temp\
    \ + b + c + d;\n            i += 1;\n        }\n        return total;", "    \
    \    var a = 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n\
    \        for (i <- 4l to n) {\n            d = a + b + c + d\n            a =\
    \ b\n            b = c\n            c = d\n        }\n        return d", "   \
    \     if (n == 0) {\n            0\n        } else if (n == 1) {\n           \
    \ 0\n        } else if (n == 2) {\n            2\n        } else if (n == 3) {\n\
    \            0\n        } else {\n            var a = 0l\n            var b =\
    \ 0l\n            var c = 2l\n            var d = 0l\n            var i = 4l\n\
    \            while (i <= n) {\n                val bb = b\n                val\
    \ dd = d\n                b = a\n                d = c\n                a = bb\n\
    \                c = dd\n                i += 1\n            }\n            a\
    \ + b + c + d\n        }", "        var xs = new Array[Long](4)\n        xs(0)\
    \ = 0; xs(1) = 0; xs(2) = 2; xs(3) = 0\n        var ys = new Array[Long](4)\n\
    \        ys(0) = 0; ys(1) = 0; ys(2) = 0; ys(3) = 1\n        var result = xs\n\
    \        var nbit = n\n        while (nbit > 0) {\n            if ((nbit & 1)\
    \ == 1) {\n                var r0 = result(0); var r1 = result(1); var r2 = result(2);\
    \ var r3 = result(3)\n                result(0) = r0 * ys(0) + r1 * ys(2) + r2\
    \ * ys(3) + r3 * ys(1)\n                result(1) = r0 * ys(1) + r1 * ys(3) +\
    \ r2 * ys(0) + r3 * ys(2)\n                result(2) = r0 * ys(2) + r1 * ys(0)\
    \ + r2 * ys(1) + r3 * ys(3)\n                result(3) = r0 * ys(3) + r1 * ys(1)\
    \ + r2 * ys(2) + r3 * ys(0)\n            }\n            var r0 = ys(0); var r1\
    \ = ys(1); var r2 = ys(2); var r3 = ys(3)\n            ys(0) = r0 * ys(0) + r1\
    \ * ys(2) + r2 * ys(3) + r3 * ys(1)\n            ys(1) = r0 * ys(1) + r1 * ys(3)\
    \ + r2 * ys(0) + r3 * ys(2)\n            ys(2) = r0 * ys(2) + r1 * ys(0) + r2\
    \ * ys(1) + r3 * ys(3)\n            ys(3) = r0 *", "        // Fill up this function\
    \ body\n        // You may also define any auxillary functions or values that\
    \ you may need.\n        var a = 0l\n        var b = 0l\n        var c = 2l\n\
    \        var d = 0l\n        var x = 0l\n        for (x <- 3l to n) {\n      \
    \      d = a + b + c + d\n            a = b\n            b = c\n            c\
    \ = d\n        }\n        d", "        val m = (MutableList(0l, 0l, 2l, 0l) /:\
    \ (4l to n))((l, i) => {l += l(i.toInt - 1) + l(i.toInt - 2) + l(i.toInt - 3)\
    \ + l(i.toInt - 4); l})\n        m(n.toInt)", "        if (n == 0) return 0\n\
    \        var result = new Array[Long](n.toInt)\n        result(0) = 0\n      \
    \  result(1) = 0\n        result(2) = 2\n        result(3) = 0\n        for (i\
    \ <- 4 to n.toInt - 1) result(i) = result(i - 1) + result(i - 2) + result(i -\
    \ 3) + result(i - 4)\n        return result(n.toInt - 1)", "        // Fill up\
    \ this function body\n        // You can add another function as well, if required\n\
    \        0", "        // Fill up this function body\n        // You can add another\
    \ function as well, if required\n        0", "    \tval a = 1l\n    \tval b =\
    \ 1l\n    \tval c = 1l\n    \tval d = 1l\n    \tval e = 1l\n    \tval f = 1l\n\
    \    \tval g = 1l\n    \tval h = 1l\n    \tval i = 1l\n    \tval j = 1l\n    \t\
    val k = 1l\n    \tval l = 1l\n    \tval m = 1l\n    \tval o = 1l\n    \tval p\
    \ = 1l\n    \tval q = 1l\n    \tval r = 1l\n    \tval s = 1l\n    \tval t = 1l\n\
    \    \tval u = 1l\n    \tval v = 1l\n    \tval w = 1l\n    \tval x = 1l\n    \t\
    val y = 1l\n    \tval z = 1l\n    \tval aa = 1l\n    \tval ab = 1l\n    \tval\
    \ ac = 1l\n    \tval ad = 1l\n    \tval ae = 1l\n    \tval af = 1l\n    \tval\
    \ ag = 1l\n    \tval ah = 1l\n    \tval ai = 1l\n    \tval aj = 1l\n    \tval\
    \ ak = 1l\n    \tval al = 1l\n    \tval am = 1l\n    \tval an = 1l\n    \tval\
    \ ao = 1l\n    \tval ap = 1l\n    \tval aq = 1l\n    \tval ar = 1l\n    \tval\
    \ as = 1l\n    \tval at = 1l\n    \tval au = 1l\n    \tval av = 1l\n    \tval\
    \ aw = 1l\n    \tval ax = 1l\n    \tval ay = 1l\n    \tval az = 1l\n    \tval\
    \ ba = 1l\n    \tval bb = 1l\n    \tval bc = 1l\n    \tval bd = 1l\n    \tval\
    \ be = 1l\n    \tval bf = 1l\n    \tval bg = 1l\n    \tval bh = 1l\n    \tval\
    \ bi = 1l\n    \tval bj = 1l\n    \tval bk = 1l\n    \t", "        if (n == 0)\
    \ 0\n        else if (n == 1) 0\n        else if (n == 2) 2\n        else if (n\
    \ == 3) 0\n        else {\n            var _n = n\n            var a = 0l\n  \
    \          var b = 0l\n            var c = 2l\n            var d = 0l\n      \
    \      var current = 0l\n            _n -= 4\n            while (_n > 0) {\n \
    \               current = a + b + c + d\n                a = b\n             \
    \   b = c\n                c = d\n                d = current\n              \
    \  _n -= 1\n            }\n            a + b + c + d\n        }", "        val\
    \ A = Array(0, 0, 2, 0)\n        for (i <- 4 to n.toInt) {\n            A(i %\
    \ 4) = A(0) + A(1) + A(2) + A(3)\n        }\n        A(n.toInt % 4)", "      \
    \  val n2 = n - 2\n        val n3 = n - 3\n        val n4 = n - 4\n        //\
    \ Now, if n > 3, then fib4(n) is the sum of these 4 numbers:\n        // 1) fib4(n-1)\n\
    \        // 2) fib4(n-2)\n        // 3) fib4(n-3)\n        // 4) fib4(n-4)\n \
    \       // If n <= 3, the answer is trivial.\n        if (n == 0) 0\n        else\
    \ if (n == 1) 0\n        else if (n == 2) 2\n        else if (n == 3) 0\n    \
    \    else {\n            // So, we need to compute all these 4 values, and the\
    \ best way to do that is to\n            // use the matrix-exponentiation method.\n\
    \            // First, we need to create the transformation matrix, which is:\n\
    \            // 1 1 1 1\n            // 1 0 0 0\n            // 0 1 0 0\n    \
    \        // 0 0 1 0\n            val matrix = Array(Array(1, 1, 1, 1), Array(1,\
    \ 0, 0, 0), Array(0, 1, 0, 0), Array(0, 0, 1, 0))\n            // Now, we need\
    \ to raise it to the power of n2, which is:\n            //   1     1     1  \
    \   1\n            //   1     0     0     0\n            //   0     1     0  \
    \   0\n            //   0     0     1     0\n            //   *     *     *  \
    \   *\n            //   n2    n2    n2    n2\n            // So, all we need to\
    \ do is compute that dot product, which is the sum of the values in the last column.\n\
    \            val (sum1, sum2, sum3, sum4) = (BigInt(0), BigInt(0), BigInt(0),\
    \ BigInt(0))\n            matrix.map(sum1 += _(0))\n            matrix.map(sum2\
    \ += _(1))\n            matrix.map(sum3 += _(2))\n            matrix.map(sum4\
    \ += _(3))\n            val sums = Array(sum1, sum2, sum3, sum4)\n           \
    \ val sum", "        // Fill up this function body\n        // You may also define\
    \ other functions\n        n", "        if (n == 0) return 0\n        if (n ==\
    \ 1) return 0\n        if (n == 2) return 2\n        if (n == 3) return 0\n  \
    \      var f0 = 0l\n        var f1 = 0l\n        var f2 = 2l\n        var f3 =\
    \ 0l\n        var f4 = 0l\n        var i = 4l\n        while (i <= n) {\n    \
    \        f4 = f0 + f1 + f2 + f3\n            f0 = f1\n            f1 = f2\n  \
    \          f2 = f3\n            f3 = f4\n            i += 1\n        }\n     \
    \   return f4", "        if (n == 0) 0\n        else if (n == 1) 0\n        else\
    \ if (n == 2) 2\n        else if (n == 3) 0\n        else if (n == 4) 2\n    \
    \    else {\n            var m = n - 1\n            var a = 0l\n            var\
    \ b = 0l\n            var c = 2l\n            var d = 0l\n            while (m\
    \ >= 4) {\n                val e = d\n                d = d + c + b + a\n    \
    \            a = b\n                b = c\n                c = e\n           \
    \     m -= 1\n            }\n            d\n        }", "        if (n == 0) 0\n\
    \        else if (n == 1) 0\n        else if (n == 2) 2\n        else if (n ==\
    \ 3) 0\n        else {\n            var F0 = 0\n            var F1 = 0\n     \
    \       var F2 = 2\n            var F3 = 0\n            var F4 = 0\n         \
    \   for (k <- 4l to n) {\n                F4 = F3 + F2 + F1 + F0\n           \
    \     F0 = F1\n                F1 = F2\n                F2 = F3\n            \
    \    F3 = F4\n            }\n            F4\n        }", "        // Fill up this\
    \ function body\n        // You may also define new functions as you wish\n  \
    \      def fib4Iter(n : Long, a : Long, b : Long, c : Long, d : Long) : Long =\
    \ {\n            if (n == 0)\n                return a\n            else if (n\
    \ == 1)\n                return b\n            else if (n == 2)\n            \
    \    return c\n            else if (n == 3)\n                return d\n      \
    \      else\n                return fib4Iter(n - 1, b, c, d, a + b + c + d)\n\
    \        }\n        return fib4Iter(n, 0, 0, 2, 0)", "        // fill in the solution\
    \ here\n        var arr = Array(0, 0, 2, 0)\n        if (n < 4) {\n          \
    \  return arr(n.toInt)\n        }\n        var index = 4\n        while (index\
    \ <= n) {\n            var val1 = arr(0)\n            var val2 = arr(1)\n    \
    \        var val3 = arr(2)\n            var val4 = arr(3)\n            arr(0)\
    \ = val2\n            arr(1) = val3\n            arr(2) = val4\n            arr(3)\
    \ = val1 + val2 + val3 + val4\n            index += 1\n        }\n        return\
    \ arr(3)", "        // Your code here\n        1", "        // Fill up this function\
    \ body\n        // You may also define new functions as required\n        if (n\
    \ == 0) return 0\n        else if (n == 1) return 0\n        else if (n == 2)\
    \ return 2\n        else if (n == 3) return 0\n        else {\n            var\
    \ a = 0l\n            var b = 0l\n            var c = 2l\n            var d =\
    \ 0l\n            var newValue = 0l\n            for (i <- 4l to n) {\n      \
    \          newValue = a + b + c + d\n                a = b\n                b\
    \ = c\n                c = d\n                d = newValue\n            }\n  \
    \          return newValue\n        }", "        var a = 0l\n        var b = 0l\n\
    \        var c = 2l\n        var d = 0l\n        if (n <= 3) c else\n        (4\
    \ to n.toInt).foreach(i => {\n            d = a + b + c + d\n            a = b\n\
    \            b = c\n            c = d\n        })\n        d", "        // Fill\
    \ Up this function body\n        // `0` is the default value!\n        var a =\
    \ 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n        if (n\
    \ == 0l) return a\n        if (n == 1l) return b\n        if (n == 2l) return\
    \ c\n        if (n == 3l) return d\n        for (i <- 0l until n-3l) {\n     \
    \       val e = a + b + c + d\n            a = b\n            b = c\n        \
    \    c = d\n            d = e\n        }\n        return d", "        var a =\
    \ 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n        var\
    \ e = 0l\n        var f = 0l\n        var g = 0l\n        var h = 0l\n       \
    \ var i = 0l\n        var j = 0l\n        var k = 0l\n        var l = 0l\n   \
    \     for (i <- 0l until n) {\n            l = d + a + b + c\n            k =\
    \ c\n            j = b\n            i = a\n            h = d\n            g =\
    \ c\n            f = b\n            e = a\n            d = l\n            c =\
    \ g\n            b = f\n            a = e\n        }\n        return l", '        ???',
  "        var a = 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n\
    \        for (i <- 4l to n) {\n            val e = a + b + c + d\n           \
    \ a = b\n            b = c\n            c = d\n            d = e\n        }\n\
    \        return a + b + c + d", "        var prev = Array(0l, 0l, 2l, 0l)\n  \
    \      if (n < prev.length) return prev(n.toInt)\n        for (i <- prev.length\
    \ to n.toInt) {\n            val newPrev = prev(1) + prev(2) + prev(3) + prev(0)\n\
    \            prev(0) = prev(1)\n            prev(1) = prev(2)\n            prev(2)\
    \ = prev(3)\n            prev(3) = newPrev\n        }\n        return prev(3)",
  "        var a = 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n\
    \        var k = 4l\n        while (k <= n) {\n            val a1 = a + b + c\
    \ + d\n            a = b\n            b = c\n            c = d\n            d\
    \ = a1\n            k += 1\n        }\n        if (n == 1) b\n        else if\
    \ (n == 2) c\n        else if (n == 3) d\n        else a + b + c + d", "     \
    \   if (n == 0) 0\n        else if (n == 1) 0\n        else if (n == 2) 2\n  \
    \      else if (n == 3) 0\n        else {\n            var x = Array(0l, 0l, 2l,\
    \ 0l)\n            var i = 4\n            while (i <= n) {\n                val\
    \ temp = x(3)\n                x(3) = x(2) + x(1) + x(0) + x(3)\n            \
    \    x(0) = x(1)\n                x(1) = x(2)\n                x(2) = temp\n \
    \               i += 1\n            }\n            x(3)\n        }", "       \
    \ // Fill up this function body\n        // You may also define new functions\
    \ or classes as per your need\n        n match {\n            case 0 => 0\n  \
    \          case 1 => 0\n            case 2 => 2\n            case 3 => 0\n   \
    \         case _ => fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n        }",
  "        val m = Array(Array(1l, 1l, 1l, 1l), Array(0l, 0l, 0l, 1l))\n        pow(m,\
    \ n)(0)(0)", "        if (n < 3) return n\n        val first = ArrayBuffer[Long](0,\
    \ 0, 2)\n        val (m, y, z) = (n - 3, 2, 1)\n        for (i <- 0 to m) {\n\
    \            val n = 3 * first(y) + 2 * first(z)\n            first += n\n   \
    \         y = (y + 1) % 3\n            z = (z + 1) % 3\n        }\n        first(3)",
  "        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        0", "        var i = 0l\n        var a = 0l\n\
    \        var b = 0l\n        var c = 2l\n        var d = 0l\n        while (i\
    \ < n) {\n            d = a + b + c + d\n            a = b\n            b = c\n\
    \            c = d\n            i += 1\n        }\n        return a", "      \
    \  // Fill up this function body\n        // You may also define new functions\
    \ as and where required\n        0", "        var last5 = List(0l, 0l, 2l, 0l,\
    \ 0l)\n        for (i <- 0 until n - 4) {\n            last5 = (last5(0) + last5(1)\
    \ + last5(2) + last5(3)) :: last5.take(4)\n        }\n        last5(4)", "   \
    \     var a = 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n\
    \        for (i <- 3l to n) {\n            var temp = d\n            d = a + b\
    \ + c + d\n            a = b\n            b = c\n            c = temp\n      \
    \  }\n        return d", "        val a = 0l\n        val b = 0l\n        val\
    \ c = 2l\n        val d = 0l\n        var p = a\n        var q = b\n        var\
    \ r = c\n        var s = d\n        var i = 4l\n        while (i <= n) {\n   \
    \         p = q\n            q = r\n            r = s\n            s = p + q +\
    \ r + s\n            i += 1\n        }\n        s", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ return 0l", "        // Fill up this function body\n        // You may also\
    \ define other functions\n        // -----\n        // -----\n        n", "  \
    \      // Fill up this function body\n        // You may also define other supporting\
    \ functions\n        0", "        // Fill up this function body\n        // You\
    \ can add another function as well, if required\n        0", '        return 0;',
  "        var fib1 = 0L\n        var fib2 = 0L\n        var fib3 = 2L\n        var\
    \ fib4 = 0L\n        if (n <= 3) return fib3\n        for (i <- 4 to n.toInt)\
    \ {\n            fib4 = fib1 + fib2 + fib3 + fib4\n            fib1 = fib2\n \
    \           fib2 = fib3\n            fib3 = fib4\n        }\n        return fib4",
  "        if (n < 3) return n * 2;\n        var prev = Array(2L, 2L, 0L, 1L);\n \
    \       for (i <- 3L to n) {\n            val temp = prev(3);\n            prev(3)\
    \ = prev(0) + prev(1) + prev(2) + prev(3);\n            prev(0) = prev(1);\n \
    \           prev(1) = prev(2);\n            prev(2) = temp;\n        }\n     \
    \   return prev(3);", "        var a = 0L\n        var b = 0L\n        var c =\
    \ 2L\n        var d = 0L\n        for (i <- 3 to n.toInt) {\n            d = a\
    \ + b + c + d\n            a = b\n            b = c\n            c = d\n     \
    \   }\n        d", "        // Fill Up this function body\n        // `0` is already\
    \ implemented for you\n        if (n == 0) return 0\n        if (n == 1) return\
    \ 0\n        if (n == 2) return 2\n        if (n == 3) return 0\n        var last_element_value\
    \ = 0l\n        var last_last_element_value = 0l\n        var last_last_last_element_value\
    \ = 2l\n        var last_last_last_last_element_value = 0l\n        var new_element_value\
    \ = 0l\n        var i = 4l\n        while (i <= n) {\n            new_element_value\
    \ = last_element_value + last_last_element_value + last_last_last_element_value\
    \ + last_last_last_last_element_value\n            last_last_last_last_element_value\
    \ = last_last_last_element_value\n            last_last_last_element_value = last_last_element_value\n\
    \            last_last_element_value = last_element_value\n            last_element_value\
    \ = new_element_value\n            i += 1\n        }\n        new_element_value",
  "        def fib4(n : Long, f0 : Long, f1 : Long, f2 : Long, f3 : Long) : Long =\
    \ {\n            if (n == 0) f0\n            else if (n == 1) f1\n           \
    \ else if (n == 2) f2\n            else if (n == 3) f3\n            else fib4(n\
    \ - 1, f1, f2, f3, f0 + f1 + f2 + f3)\n        }\n        fib4(n, 0, 0, 2, 0)",
  "        var fib4n : Array[Long] = Array.fill(4)(0l)\n        fib4n(0) = 0\n   \
    \     fib4n(1) = 0\n        fib4n(2) = 2\n        fib4n(3) = 0\n        var fib4nm1\
    \ : Array[Long] = Array.fill(4)(0l)\n        fib4nm1(0) = 0\n        fib4nm1(1)\
    \ = 0\n        fib4nm1(2) = 2\n        fib4nm1(3) = 0\n        var fib4nm2 : Array[Long]\
    \ = Array.fill(4)(0l)\n        fib4nm2(0) = 0\n        fib4nm2(1) = 0\n      \
    \  fib4nm2(2) = 2\n        fib4nm2(3) = 0\n        var fib4nm3 : Array[Long] =\
    \ Array.fill(4)(0l)\n        fib4nm3(0) = 0\n        fib4nm3(1) = 0\n        fib4nm3(2)\
    \ = 2\n        fib4nm3(3) = 0\n        var fib4nm4 : Array[Long] = Array.fill(4)(0l)\n\
    \        fib4nm4(0) = 0\n        fib4nm4(1) = 0\n        fib4nm4(2) = 2\n    \
    \    fib4nm4(3) = 0\n        var i : Long = 4\n        while (i <= n) {\n    \
    \        fib4nm4 = fib4nm3\n            fib4nm3 = fib4nm2\n            fib4nm2\
    \ = fib4nm1\n            fib4nm1 = fib4n\n            fib4n = Array.fill(4)(0l)\n\
    \            fib4n(0) = fib4nm1(0) + fib4nm2(0) + fib4nm3(0) + fib4nm4(0)\n  \
    \          fib4n(1) = fib4nm1(1) + fib4nm2(1) + fib4nm3(1) + fib4nm4(1)\n    \
    \        fib4n(2) = fib4nm1(2) + fib4nm2(2) + fib4nm3(2)", "        // Fill up\
    \ this function body\n        // You may also define any auxillary functions that\
    \ you may need\n        0l", "        // Fill up this function body\n        //\
    \ You may also define other helper functions if needed\n        0", "        //\
    \ Fill up this function body\n        // You may also define new functions as\
    \ you wish\n        def pisanoLength(m : Long) : Long = {\n            if (m ==\
    \ 1)\n                return 1\n            var a = 0\n            var b = 1\n\
    \            var c = a + b\n            for (i <- 2 to 1000000) {\n          \
    \      c = (a + b) % m\n                a = b\n                b = c\n       \
    \         if (a == 0 && b == 1)\n                    return i\n            }\n\
    \            return 0\n        }\n        def fibmod(n : Long, m : Long) : Long\
    \ = {\n            if (n <= 1)\n                return n\n            var a =\
    \ 0\n            var b = 1\n            var c = 0\n            for (i <- 2 to\
    \ n.toInt) {\n                c = (a + b) % m\n                a = b\n       \
    \         b = c\n            }\n            return c\n        }\n        if (n\
    \ <= 1)\n            return n\n        var pisano = pisanoLength(10)\n       \
    \ var b = fibmod(n % pisano, 10)\n        var c = fibmod((n - 1) % pisano, 10)\n\
    \        var d = fibmod((n - 2) % pisano, 10)\n        var e = fibmod((n - 3)\
    \ % pisano, 10)\n        return (4 * b - 3 * c - 2 * d - e) % 10", "        var\
    \ i = 0l\n        var j = 0l\n        var k = 2l\n        var l = 0l\n       \
    \ for (m <- 3l to n) {\n            l = i + j + k + l\n            i = j\n   \
    \         j = k\n            k = l\n        }\n        return l", "        //\
    \ Fill Up this function body\n        // `0` is already implemented for you\n\
    \        var result : Long = 0\n        if (n == 0) {\n            result = 0\n\
    \        } else if (n == 1) {\n            result = 0\n        } else if (n ==\
    \ 2) {\n            result = 2\n        } else if (n == 3) {\n            result\
    \ = 0\n        } else {\n            var arr : Array[Long] = new Array[Long](n.toInt\
    \ + 1)\n            arr(0) = 0\n            arr(1) = 0\n            arr(2) = 2\n\
    \            arr(3) = 0\n            for (i <- 4 to n.toInt) {\n             \
    \   arr(i) = arr(i - 1) + arr(i - 2) + arr(i - 3) + arr(i - 4)\n            }\n\
    \            result = arr(n.toInt)\n        }\n        return result", "     \
    \   var a = 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n \
    \       if (n == 0) return 0\n        if (n == 1) return 0\n        if (n == 2)\
    \ return 2\n        if (n == 3) return 0\n        for (i <- 4l to n) {\n     \
    \       d = a + b + c\n            a = b\n            b = c\n            c = d\n\
    \        }\n        return d", "        // Fill in your solution here\n      \
    \  val modulo = pow(10, 9).toLong + 7\n        val f = new Array[Long](n.toInt\
    \ + 1)\n        f(0) = 0\n        f(1) = 0\n        f(2) = 2\n        f(3) = 0\n\
    \        for (i <- 4 to n.toInt) {\n            f(i) = f(i - 1) + f(i - 2) + f(i\
    \ - 3) + f(i - 4)\n            f(i) %= modulo\n        }\n        f(n.toInt)",
  "        // Fill Up this function body\n        // `0` is already implemented for\
    \ you\n        if (n == 0) return 0\n        var a = 0l\n        var b = 0l\n\
    \        var c = 2l\n        var d = 0l\n        var e = 0l\n        var f = 0l\n\
    \        for (i <- 3l to n) {\n            e = a + b + c + d\n            a =\
    \ b\n            b = c\n            c = d\n            d = e\n        }\n    \
    \    return e", "        // Fill up this function body\n        // You may also\
    \ define any auxillary functions if required\n        0", "    \tval matrix =\
    \ Array(Array(1l, 1l, 1l, 1l), Array(1l, 0l, 0l, 0l), Array(0l, 1l, 0l, 0l), Array(0l,\
    \ 0l, 1l, 0l))\n    \tval matrixN = powMatrix(matrix, n - 3)\n    \tmatrixN(0)(0)\
    \ * 2 + matrixN(0)(3)", "        var a : Long = 0\n        var b : Long = 0\n\
    \        var c : Long = 2\n        var d : Long = 0\n        for (i <- 4 to n.toInt)\
    \ {\n            d = a + b + c\n            a = b\n            b = c\n       \
    \     c = d\n        }\n        return d", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        if (n <\
    \ 0) {\n            return 0\n        }\n        if (n == 0) {\n            return\
    \ 0\n        }\n        if (n == 1) {\n            return 0\n        }\n     \
    \   if (n == 2) {\n            return 2\n        }\n        if (n == 3) {\n  \
    \          return 0\n        }\n        var a : Long = 0\n        var b : Long\
    \ = 0\n        var c : Long = 2\n        var d : Long = 0\n        var i : Long\
    \ = 4\n        while (i <= n) {\n            d = a + b + c + d\n            a\
    \ = b\n            b = c\n            c = d\n            i += 1\n        }\n \
    \       return d", "        // Fill up this function body\n        // You may\
    \ also define new functions as and where required\n        var a = 0.toLong\n\
    \        var b = 0.toLong\n        var c = 2.toLong\n        var d = 0.toLong\n\
    \        var fib4n = 0.toLong\n        for (i <- 4 to n.toInt) {\n          fib4n\
    \ = a + b + c + d\n          a = b\n          b = c\n          c = d\n       \
    \   d = fib4n\n        }\n        fib4n", "        // Fill Up this function body\n\
    \        // You can add another function as well, if required\n        0", " \
    \       // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        def f(n : Long, \n              f0 : Long, f1\
    \ : Long, \n              f2 : Long, f3 : Long) : Long = n match {\n         \
    \   case 0 => f0\n            case 1 => f1\n            case 2 => f2\n       \
    \     case 3 => f3\n            case _ => f(n - 1, f1, f2, f3, f0 + f1 + f2 +\
    \ f3)\n        }\n        f(n, 0, 0, 2, 0)", "        var m = new Array[Long](n.toInt\
    \ + 1)\n        m(0) = 0\n        m(1) = 0\n        m(2) = 2\n        m(3) = 0\n\
    \        for (i <- 4 to n.toInt) {\n            m(i) = m(i - 1) + m(i - 2) + m(i\
    \ - 3) + m(i - 4)\n        }\n        return m(n.toInt)", "        // Fill up\
    \ this function body\n        // You can add another function as well, if required\n\
    \        0", "        var fib4 = (1l)\n        var fib3 = (0l)\n        var fib2\
    \ = (2l)\n        var fib1 = (0l)\n        for (i <- (4l) to n) {\n          \
    \  val tmp = fib4\n            fib4 = fib4 + fib3 + fib2 + fib1\n            fib1\
    \ = fib2\n            fib2 = fib3\n            fib3 = tmp\n        }\n       \
    \ return fib4", "        // Fill Up this function body\n        // `0` is already\
    \ implemented for you\n        var n0 = 0l\n        var n1 = 0l\n        var n2\
    \ = 2l\n        var n3 = 0l\n        var n4 = 0l\n        if (n==0)\n        \
    \  return n0\n        else if (n==1)\n          return n1\n        else if (n==2)\n\
    \          return n2\n        else if (n==3)\n          return n3\n        for\
    \ (i <- 4l to n) {\n          n4 = n0 + n1 + n2 + n3\n          n0 = n1\n    \
    \      n1 = n2\n          n2 = n3\n          n3 = n4\n        }\n        return\
    \ n4", "        // Fill up this function body\n        // You may also define\
    \ new functions as and where required\n        def matrixMul(a : List[List[Long]],\
    \ b : List[List[Long]]) : List[List[Long]] = {\n            def zero() : List[List[Long]]\
    \ = List(List(0, 0), List(0, 0))\n            def add(c : List[List[Long]], d\
    \ : List[List[Long]]) : List[List[Long]] = {\n                List(List(c(0)(0)\
    \ + d(0)(0), c(0)(1) + d(0)(1)), List(c(1)(0) + d(1)(0), c(1)(1) + d(1)(1)))\n\
    \            }\n            def mulRowCol(x : List[Long], y : List[Long]) : List[List[Long]]\
    \ = {\n                val m = x(0) * y(0)\n                val n = x(0) * y(1)\
    \ + x(1) * y(0)\n                val p = x(1) * y(1)\n                List(List(m,\
    \ n), List(n, p))\n            }\n            def mul(a : List[List[Long]], b\
    \ : List[List[Long]]) : List[List[Long]] = {\n                def helper(b : List[List[Long]],\
    \ r : Int, c : Int, acc : List[List[Long]]) : List[List[Long]] = {\n         \
    \           if (r == a.length) acc\n                    else {\n             \
    \           val d = mulRowCol(a(r), b(c))\n                        helper(b, r\
    \ + 1, c + 1, add(acc, d))\n                    }\n                }\n       \
    \         helper(b, 0, 0, zero())\n            }\n            def helper(c : List[List[Long]],\
    \ d : List[List[Long]], x : Int, y : Int, acc : List[List[Long]]) : List[List[Long]]\
    \ = {\n                if (x == c.length) acc\n                else {\n      \
    \              val p = mul(c, d)\n                    helper(c, d, x + 1, y +\
    \ 1,", "        // O(1)\n        def calc(n : Long) : Long = {\n            def\
    \ _calc(n : Long) : Long = {\n                if (n == 0) 0\n                else\
    \ if (n == 1) 0\n                else if (n == 2) 2\n                else if (n\
    \ == 3) 0\n                else {\n                    val mod = n % 4\n     \
    \               if (mod == 0) 0\n                    else if (mod == 1) 2\n  \
    \                  else if (mod == 2) 0\n                    else 4\n        \
    \        }\n            }\n            _calc(n) + _calc(n-1) + _calc(n-2) + _calc(n-3)\n\
    \        }\n        calc(n)", "        var a = 0l\n        var b = 0l\n      \
    \  var c = 2l\n        var d = 0l\n        for (i <- 4l to n) {\n            d\
    \ = a + b + c + d\n            a = b\n            b = c\n            c = d\n \
    \       }\n        d", "        // Fill up this function body\n        // You\
    \ can add another function as well, if required\n        var n1 = (1, 1, 0, 0)\n\
    \        var n2 = (1, 1, 0, 0)\n        for (i <- 0 until n) {\n            n2\
    \ = (n1._1 + n1._2 + n1._3 + n1._4, n1._1, n1._2, n1._3)\n            n1 = n2\n\
    \        }\n        n2._1", "        // Fill up this function body\n        //\
    \ You can add another function as well, if required\n        return -1", '        return
    1', "        // Implement me!\n        if (n == 0 || n == 1) 0\n        else if\
    \ (n == 2) 2\n        else if (n == 3) 0\n        else fib4(n - 1) + fib4(n -\
    \ 2) + fib4(n - 3) + fib4(n - 4)", "        // Fill up this function body\n  \
    \      // You may also define new functions as and where required\n        //\
    \ Do not use recursion\n        // Return the appropriate Long value for the n-th\
    \ element of the fib4 number sequence\n        var i = 4\n        var res = Array(0,\
    \ 0, 2, 0)\n        while (i <= n) {\n            res = Array(res(1), res(2),\
    \ res(3), res(0) + res(1) + res(2) + res(3))\n            i += 1\n        }\n\
    \        return res(3)", "        var t2 = 0l\n        var t1 = 0l\n        var\
    \ t0 = 2l\n        var acc = 0l\n        var result = 0l\n        if (n == 0)\
    \ return 0\n        if (n == 1) return 0\n        if (n == 2) return 2\n     \
    \   if (n == 3) return 0\n        for (i <- 4l to n) {\n            result = t0\
    \ + t1 + t2 + acc\n            acc = t0\n            t2 = t1\n            t1 =\
    \ t0\n            t0 = result\n        }\n        return result", "        def\
    \ fib4(n: Long, a : Long, b : Long, c : Long, d : Long) : Long = n match {\n \
    \           case 0 => a\n            case 1 => b\n            case 2 => c\n  \
    \          case 3 => d\n            case _ => fib4(n - 1, b, c, d, a + b + c +\
    \ d)\n        }\n        fib4(n, 0, 0, 2, 0)", "        if (n < 3) return n *\
    \ 2\n        var a = 0l\n        var b = 0l\n        var c = 2l\n        var d\
    \ = 0l\n        for (i <- 4l to n) {\n            d = a + b + c + d\n        \
    \    a = b\n            b = c\n            c = d\n        }\n        return d",
  "    \tval base = List(0l, 0l, 2l, 0l)\n    \tval mat = Array(Array(0l, 1l, 0l,\
    \ 0l), Array(0l, 0l, 1l, 0l), Array(0l, 0l, 0l, 1l), Array(1l, 1l, 1l, 1l))\n\
    \    \tval matA = matrixPower(mat, n - 3)\n    \tmultiplyMatrixByVector(matA,\
    \ base).last", "        val fib = new Fib4(n)\n        fib.fib(n)", "\t// Fill\
    \ Up this function body\n        // You can add another function as well, if required\n\
    \        val mat = Array.ofDim[Long](4,4)\n        for (i <- 0 to 3) {\n     \
    \       for (j <- 0 to 3) {\n                if (i == j) mat(i)(j) = 1\n     \
    \           else mat(i)(j) = 0\n            }\n        }\n        mat(0)(1) =\
    \ 1\n        mat(0)(2) = 1\n        mat(0)(3) = 1\n        mat(1)(2) = 1\n   \
    \     mat(2)(3) = 1\n        val (result, _) = pow(mat, n)\n        result(0)(0)",
  "        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        if (n == 0) return 0\n        if (n == 1) return\
    \ 0\n        if (n == 2) return 2\n        if (n == 3) return 0\n        var f1\
    \ = 0\n        var f2 = 0\n        var f3 = 2\n        var f4 = 0\n        var\
    \ fn = 0\n        for (i <- 4 to n.toInt) {\n            fn = f1 + f2 + f3 + f4\n\
    \            f1 = f2\n            f2 = f3\n            f3 = f4\n            f4\
    \ = fn\n        }\n        return fn", "        val m = n.toInt\n        var a\
    \ = 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n        for\
    \ (i <- 4 to m) {\n            val x = a + b + c + d\n            a = b\n    \
    \        b = c\n            c = d\n            d = x\n        }\n        return\
    \ d", "        if (n == 0) 0\n        else if (n == 1) 0\n        else if (n ==\
    \ 2) 2\n        else if (n == 3) 0\n        else {\n            val f1 = 0l\n\
    \            val f2 = 0l\n            val f3 = 2l\n            val f4 = 0l\n \
    \           var f5 = 0l\n            for (i <- 4l to n) {\n                f5\
    \ = f1 + f2 + f3 + f4\n                f1 = f2\n                f2 = f3\n    \
    \            f3 = f4\n                f4 = f5\n            }\n            f5\n\
    \        }", "        if (n == 0) 0 else if (n == 1) 0 else if (n == 2) 2 else\
    \ if (n == 3) 0 else\n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)", "    \t// Fill Up this function body\n        // `0` indicate replacing\
    \ this value with logic\n        0", "        // Fill up this function body\n\
    \        // You can add another function as well, if required", "        var a\
    \ = 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n        var\
    \ e = 0l\n        for (i <- 0 until n.toInt) {\n            a = b\n          \
    \  b = c\n            c = d\n            d = a + b + c + d\n        }\n      \
    \  d", "        var a = 0l\n        var b = 0l\n        var c = 2l\n        var\
    \ d = 0l\n        for (i <- 4l to n) {\n            var tmp = d\n            d\
    \ = a + b + c + d\n            a = b\n            b = c\n            c = tmp\n\
    \        }\n        return d", "        // Define fib4(n) = f(n)\n        // f(0)\
    \ = 0\n        // f(1) = 0\n        // f(2) = 2\n        // f(3) = 0\n       \
    \ // f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n        // f(n) = f(n-1) + f(n-2)\
    \ + f(n-3) + f(n-4)\n        // f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n   \
    \     // f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n        // f(n) = f(n-1) +\
    \ f(n-2) + f(n-3) + f(n-4)\n        // f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n\
    \        // f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n        // f(n) = f(n-1)\
    \ + f(n-2) + f(n-3) + f(n-4)\n        // f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n\
    \        // f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n        // f(n) = f(n-1)\
    \ + f(n-2) + f(n-3) + f(n-4)\n        // f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n\
    \        // f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n        // f(n", "     \
    \   // Recursion is very expensive.\n        // We have to use memoization.\n\
    \        // In the end we can use the closed-form formula to compute the n-th\
    \ element of the fib4 number sequence.\n        var previous = new ListBuffer[Long]()\n\
    \        previous += 0l\n        previous += 0l\n        previous += 2l\n    \
    \    previous += 0l\n        for (i <- 4l to n) {\n            val result = previous(0)\
    \ + previous(1) + previous(2) + previous(3)\n            previous.prepend(result)\n\
    \            previous.remove(4)\n        }\n        previous(0)", "        //\
    \ Fill in here\n        val a = Array(0l, 0l, 2l, 0l)\n        for (i <- 4 to\
    \ n.toInt) {\n            val b = a(3)\n            a(3) = a(2)\n            a(2)\
    \ = a(1)\n            a(1) = a(0)\n            a(0) = a(1) + a(2) + a(3) + b\n\
    \        }\n        return a(0)", "        var result : Long = 0\n        // IMPLEMENT\n\
    \        return result", "        if (n < 4) return n - 1;\n        var a = 0L;\n\
    \        var b = 1L;\n        var c = 2L;\n        var d = 2L;\n        for (i\
    \ <- 4L to n) {\n            val e = d + a + b + c;\n            a = b;\n    \
    \        b = c;\n            c = d;\n            d = e;\n        }\n        return\
    \ d;", "        var a = 0l\n        var b = 0l\n        var c = 2l\n        var\
    \ d = 0l\n        for (i <- 4l to n) {\n            d = a + b + c + d\n      \
    \      a = b\n            b = c\n            c = d\n        }\n        return\
    \ d", "        // Fill up this function body\n        // You may also define other\
    \ support functions\n\tif (n == 0) 0\n\telse if (n == 1) 0\n\telse if (n == 2)\
    \ 2\n\telse if (n == 3) 0\n\telse fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)",
  "        var a = 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n\
    \        var m = 3l\n        while (m <= n) {\n            d = a + b + c + d\n\
    \            a = b\n            b = c\n            c = d\n            m += 1\n\
    \        }\n        d", "        if (n < 4) {\n            n\n        } else {\n\
    \            val f0 = 0l\n            val f1 = 0l\n            val f2 = 2l\n \
    \           val f3 = 0l\n            var f4 = 2l\n            for (i <- 4l to\
    \ n) {\n                f4 = f4 + f3 + f2 + f1\n                f3 = f2\n    \
    \            f2 = f1\n                f1 = f0\n                f0 = f4\n     \
    \       }\n            f4\n        }", "        var q2 = 0l\n        var q1 =\
    \ 0l\n        var q0 = 2l\n        var p2 = 0l\n        var p1 = 0l\n        var\
    \ p0 = 0l\n        for (i <- 3l to n) {\n            val tempQ2 = q2\n       \
    \     val tempQ1 = q1\n            val tempQ0 = q0\n            q2 = p2\n    \
    \        q1 = p1\n            q0 = p0\n            p2 = tempQ2\n            p1\
    \ = tempQ1\n            p0 = tempQ0\n            q0 += p0 + p1 + p2\n        }\n\
    \        q0", "        // Fill up this function body\n        // You may also\
    \ define new functions as you wish\n        0", "        var fib = Array.fill(4)(0L)\n\
    \        fib(0) = 0\n        fib(1) = 0\n        fib(2) = 2\n        fib(3) =\
    \ 0\n        if (n < 4) return fib(n.toInt)\n        var nn = n - 4\n        while\
    \ (nn >= 0) {\n            val sum = fib.sum\n            fib(0) = fib(1)\n  \
    \          fib(1) = fib(2)\n            fib(2) = fib(3)\n            fib(3) =\
    \ sum\n            nn -= 1\n        }\n        fib(3)", "        if (n < 2) n\n\
    \        else {\n            var a = 0l\n            var b = 0l\n            var\
    \ c = 2l\n            var d = 0l\n            for (i <- 4l to n) {\n         \
    \       d = a + b + c\n                a = b\n                b = c\n        \
    \        c = d\n            }\n            d\n        }", "        // Fill up\
    \ this function body\n        // You may also define new functions as you wish\n\
    \        // But you cannot use recursion\n        val a = Array.fill(n.toInt +\
    \ 1)(0l)\n        a(0) = 0\n        a(1) = 0\n        a(2) = 2\n        a(3) =\
    \ 0\n        if (n < 4) return a(n.toInt)\n        var i = 4\n        while (i\
    \ <= n) {\n          a(i) = a(i - 1) + a(i - 2) + a(i - 3) + a(i - 4)\n      \
    \    i += 1\n        }\n        a(n.toInt)", "        val start = Array(0l, 0l,\
    \ 2l, 0l)\n        if (n < 4) return start(n.toInt)\n        val result = Array.fill(4)(0l)\n\
    \        val matrix = Array.ofDim[Long](4, 4)\n        matrix(0)(0) = 1\n    \
    \    matrix(0)(1) = 1\n        matrix(0)(2) = 1\n        matrix(0)(3) = 1\n  \
    \      matrix(1)(0) = 1\n        matrix(2)(1) = 1\n        matrix(3)(2) = 1\n\
    \        result(0) = 1\n        var nn = n - 4\n        var exp = matrix\n   \
    \     while (nn > 0) {\n            if (nn % 2 == 1) {\n                var temp\
    \ = Array.ofDim[Long](4, 4)\n                for (i <- 0 until 4) {\n        \
    \            for (j <- 0 until 4) {\n                        temp(i)(j) = result(i)\n\
    \                        result(i) = 0\n                        for (k <- 0 until\
    \ 4) result(i) += temp(i)(k) * exp(k)(j)\n                    }\n            \
    \    }\n            }\n            var temp = Array.ofDim[Long](4, 4)\n      \
    \      for (i <- 0 until 4) {\n                for (j <- 0 until 4) {\n      \
    \              temp(i)(j) = exp(i)(j)\n                    exp(i)(j) = 0\n   \
    \                 for (k <- 0 until 4) exp(i)(j) += temp(i)(k) * temp(k)(j)\n\
    \                }\n            }\n            nn /= 2\n        }\n        var\
    \ ret = 0l\n        for (i <- 0 until 4) ret += result(i) * start(i)\n       \
    \ ret", "        // Fill up this function body\n        // You may also define\
    \ new functions as and where required\n        // Do not use recursion\n     \
    \   // Hint: http://en.wikipedia.org/wiki/Exponentiation_by_squaring\n       \
    \ 0", "        // Fill up this function body\n        // You may also define auxiliary\
    \ functions as needed\n        var a = 0l\n        var b = 0l\n        var c =\
    \ 2l\n        var d = 0l\n        var i = 0l\n        var temp:Long = 0l\n   \
    \     if(n==1){\n            return 0\n        }\n        else if(n==2){\n   \
    \         return 2\n        }\n        else{\n            for(i <- 3l to n){\n\
    \                 d = a + b + c\n                 temp = d\n                 a\
    \ = b\n                 b = c\n                 c = temp\n            }\n    \
    \        return d\n        }", "        def fib4(n : Long, i : Long, k : Long,\
    \ j : Long, h : Long) : Long = {\n            if (n == i) {\n                k\n\
    \            } else {\n                fib4(n, i + 1, j, h, k + j + h)\n     \
    \       }\n        }\n        fib4(n, 3, 0, 2, 0)", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ return 0", "        // Fill up this function body\n        // You may also define\
    \ any auxillary functions and variables that you may need.\n        var a = 0l\n\
    \        var b = 0l\n        var c = 2l\n        var d = 0l\n        if (n ==\
    \ 0) return 0\n        if (n == 1) return 0\n        if (n == 2) return 2\n  \
    \      if (n == 3) return 0\n        else {\n            for (i <- 4l to n) {\n\
    \                d = a + b + c\n                a = b\n                b = c\n\
    \                c = d\n            }\n        }\n        return d", "       \
    \ if (n < 4) n\n        else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)", "        val f4 = Array.fill(4)(0l)\n        f4(2) = 2\n        var i\
    \ = 3\n        while (i <= n) {\n            f4(i % 4) = f4((i - 1) % 4) + f4((i\
    \ - 2) % 4) + f4((i - 3) % 4) + f4((i - 4) % 4)\n            i += 1\n        }\n\
    \        f4(n % 4)", "        if (n == 0) return 0\n        if (n == 1) return\
    \ 0\n        if (n == 2) return 2\n        if (n == 3) return 0\n        var a\
    \ = 0l\n        var b = 0l\n        var c = 2l\n        var d = 0l\n        for\
    \ (i <- 4l to n) {\n            var tmp = a + b + c + d\n            a = b\n \
    \           b = c\n            c = d\n            d = tmp\n        }\n       \
    \ return d", "        if (n == 0) 0\n        else if (n == 1) 0\n        else\
    \ if (n == 2) 2\n        else if (n == 3) 0\n        else {\n            var n2\
    \ = 0l\n            var n3 = 0l\n            var n4 = 0l\n            var n5 =\
    \ 2l\n            for (i <- 4 to n.toInt) {\n                val temp = n5\n \
    \               n5 = n5 + n4 + n3 + n2\n                n2 = n3\n            \
    \    n3 = n4\n                n4 = temp\n            }\n            n5\n     \
    \   }", "        val a = (1l, 0l, 0l, 0l)\n        val b = (1l, 1l, 1l, 1l)\n\
    \        val (a1, a2, a3, a4) = powm(b, n, (1l, 0l, 0l, 0l))\n        return a1",
  "        val m = n - 1\n        var previous = 0l\n        var current = 0l\n  \
    \      var prev2 = 2l\n        var prev3 = 0l\n        for (i <- 2l to m) {\n\
    \            val next = previous + current + prev2 + prev3\n            previous\
    \ = current\n            current = next\n            prev2 = previous\n      \
    \      prev3 = current\n        }\n        current", "        // Fill up this\
    \ function body\n        // You can add another function as well, if required\n\
    \        1", "        val fib4 = new Array[Long](4)\n        fib4(0) = 0\n   \
    \     fib4(1) = 0\n        fib4(2) = 2\n        fib4(3) = 0\n        fib4Seq(n,\
    \ fib4)", "        // Fill Up this function body\n        // `0` is already implemented\
    \ for you\n        var a1 = 0l\n        var a2 = 0l\n        var a3 = 2l\n   \
    \     var a4 = 0l\n        if (n == 0) 0\n        else if (n == 1) 0\n       \
    \ else if (n == 2) 2\n        else if (n == 3) 0\n        else {\n           \
    \ for (i <- 4 to n.toInt) {\n                var temp = a4\n                a4\
    \ = a3 + a2 + a1 + a4\n                a1 = a2\n                a2 = a3\n    \
    \            a3 = temp\n            }\n            a4\n        }", "        if\
    \ (n == 0) return 0\n        if (n == 1) return 0\n        if (n == 2) return\
    \ 2\n        if (n == 3) return 0\n        var a = 0l\n        var b = 0l\n  \
    \      var c = 2l\n        var d = 0l\n        for (i <- 4l to n) {\n        \
    \    var x = a + b + c + d\n            a = b\n            b = c\n           \
    \ c = d\n            d = x\n        }\n        return d", '        return 0l',
  "        if (n < 0) throw new IllegalArgumentException(\"n must be a positive integer\"\
    )\n        else if (n < 4) n else {\n            val n1 = pow(sqrt(5), n).toLong\n\
    \            val n2 = pow(sqrt(5), n + 1).toLong\n            val n3 = (2 * sqrt(5)).toLong\n\
    \            ((n1 + n2) / n3).toLong\n        }", "        var a = 0l\n      \
    \  var b = 0l\n        var c = 2l\n        var d = 0l\n        var e = 0l\n  \
    \      var i = 3l\n        while (i <= n) {\n            e = a + b + c + d\n \
    \           a = b\n            b = c\n            c = d\n            d = e\n \
    \           i += 1\n        }\n        return e", "        // Fill Up this function\
    \ body\n        // `0` is already defined for you.\n        // Do not delete or\
    \ modify it.\n        // `1` is already defined for you.\n        // Do not delete\
    \ or modify it.\n        // `2` is already defined for you.\n        // Do not\
    \ delete or modify it.\n        // `3` is already defined for you.\n        //\
    \ Do not delete or modify it.\n        // `4` is already defined for you.\n  \
    \      // Do not delete or modify it.\n        // `5` is already defined for you.\n\
    \        // Do not delete or modify it.\n        // `6` is already defined for\
    \ you.\n        // Do not delete or modify it.\n        // `7` is already defined\
    \ for you.\n        // Do not delete or modify it.\n        if (n == 0) 0\n  \
    \      else if (n == 1) 0\n        else if (n == 2) 2\n        else if (n == 3)\
    \ 0\n        else if (n == 4) 1\n        else if (n == 5) 4\n        else if (n\
    \ == 6) 8\n        else if (n == 7) 14\n        else fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)", "        var z = 0l\n        var o = 0l\n        var t = 2l\n\
    \        var q = 0l\n        var p = 0l\n        for (i <- 4 to n.toInt) {\n \
    \           p = q\n            q = z\n            z = o\n            o = t\n \
    \           t = p + q + z + o\n        }\n        return t", "        // Fill\
    \ up this function body\n        // You may also define additional auxiliary functions\n\
    \        def fib4Helper(n : Long, fn_1 : Long, fn_2 : Long, fn_3 : Long, fn_4\
    \ : Long) : Long = {\n            if (n == 0) fn_1\n            else if (n ==\
    \ 1) fn_2\n            else if (n == 2) fn_3\n            else if (n == 3) fn_4\n\
    \            else fib4Helper(n - 1, fn_2, fn_3, fn_4, fn_1 + fn_2 + fn_3 + fn_4)\n\
    \        }\n        fib4Helper(n, 0, 0, 2, 0)", "        // Fill up this function\
    \ body\n        // You may also define new functions as and where required\n \
    \       var counter : Long = 0\n        var a : Long = 0\n        var b : Long\
    \ = 0\n        var c : Long = 2\n        var d : Long = 0\n        if (n==0 ||\
    \ n==1)\n            return 0\n        if (n==2)\n            return 2\n     \
    \   while (counter<n-3) {\n            d = a + b + c\n            a = b\n    \
    \        b = c\n            c = d\n            counter = counter + 1\n       \
    \ }\n        return d", "        var i = 0\n        var f0 = 0l\n        var f1\
    \ = 0l\n        var f2 = 2l\n        var f3 = 0l\n        var f4 = 0l\n      \
    \  while (i < n) {\n            f4 = f0 + f1 + f2 + f3\n            f0 = f1\n\
    \            f1 = f2\n            f2 = f3\n            f3 = f4\n            i\
    \ += 1\n        }\n        f4", "        def fib4Internal(n : Long, b : Long,\
    \ c : Long, d : Long, e : Long) : Long = {\n            if (n <= 0) b\n      \
    \      else if (n == 1) c\n            else if (n == 2) d\n            else if\
    \ (n == 3) e\n            else fib4Internal(n - 1, c, d, e, b + c + d + e)\n \
    \       }\n        fib4Internal(n, 0, 0, 2, 0)", "        def fib4_acc(n : Long,\
    \ a : Long, b : Long, c : Long, d : Long) : Long = n match {\n            case\
    \ 0 => a\n            case 1 => b\n            case 2 => c\n            case 3\
    \ => d\n            case _ => fib4_acc(n - 1, b, c, d, d + c + b + a)\n      \
    \  }\n        fib4_acc(n, 0, 0, 2, 0)", "        // Fill up this function body\n\
    \        // You may also define any auxiliary functions as needed\n        0",
  "        // Fill Up this function body\n        // `0` is the default return value\
    \ and will not be evaluated\n        var i = 2l\n        var j = 0l\n        var\
    \ k = 0l\n        var l = 0l\n        var m = 2l\n        if (n == 0l) {\n   \
    \         return 0l\n        }\n        if (n == 1l) {\n            return 0l\n\
    \        }\n        if (n == 2l) {\n            return 2l\n        }\n       \
    \ while (i < n) {\n            l = j\n            j = k\n            k = m\n \
    \           m = j + k + l + m\n            i += 1\n        }\n        return m",
  "        if (n < 0) throw new IllegalArgumentException(\"fib4: Cannot perform fib4\
    \ on negative number\")\n        val f = new Array[Long](n.toInt + 1)\n      \
    \  f(0) = 0\n        f(1) = 0\n        f(2) = 2\n        f(3) = 0\n        for\
    \ (i <- 4 to n.toInt) {\n            f(i) = f(i - 1) + f(i - 2) + f(i - 3) + f(i\
    \ - 4)\n        }\n        f(n.toInt)", "        // EDGE CASES:\n        if (n\
    \ == 0) return 0\n        if (n == 1) return 0\n        if (n == 2) return 2\n\
    \        if (n == 3) return 0\n        // CODE:\n        var n1 = 0l\n       \
    \ var n2 = 0l\n        var n3 = 2l\n        var n4 = 0l\n        var n5 = 0l\n\
    \        for (i <- 5l to n) {\n            n5 = n1 + n2 + n3 + n4\n          \
    \  n1 = n2\n            n2 = n3\n            n3 = n4\n            n4 = n5\n  \
    \      }\n        return n5", "    \t// Fill Up this function body\n         \
    \       // `0` denotes the fact that the function is not evaluated at all\n  \
    \      lazy val fib: Stream[Long] = 0 #:: fib.scanLeft(0l)(_ + _)\n        fib(n).toLong",
  "        if (n == 0) 0\n        else if (n == 1) 0\n        else if (n == 2) 2\n\
    \        else if (n == 3) 0\n        else {\n            val a = (0l, 0l, 2l,\
    \ 0l)\n            val b = (1l, 1l, 1l, 1l)\n            val q = (n - 3l) / 4l\n\
    \            val r = (n - 3l) % 4l\n            val c = pow(b, q)._1 * a\n   \
    \         (0l until r).foldLeft(c)((acc, x) => {\n                val tmp = ArrayBuffer(acc._1,\
    \ acc._2, acc._3, acc._4)\n                val x2 = acc._2 + acc._3 + acc._4\n\
    \                val x3 = acc._3 + acc._4\n                val x4 = acc._4\n \
    \               (x2, x3, x4, tmp(0) + x2 + x3 + x4)\n            })._4\n     \
    \   }", "        // Fill up this function body\n        // You can add another\
    \ function as well, if required\n        if (n == 0) return 0\n        if (n ==\
    \ 1) return 0\n        if (n == 2) return 2\n        if (n == 3) return 0\n  \
    \      var a = 0L\n        var b = 0L\n        var c = 2L\n        var d = 0L\n\
    \        var i = 4L\n        while (i <= n) {\n            val temp = a + b +\
    \ c + d\n            a = b\n            b = c\n            c = d\n           \
    \ d = temp\n            i += 1\n        }\n        return d", "        if (n ==\
    \ 0) return 0\n        if (n == 1) return 0\n        if (n == 2) return 2\n  \
    \      if (n == 3) return 0\n        var buffer = Array(0l, 0l, 2l, 0l)\n    \
    \    for (i <- 4l to n) {\n            val temp = buffer(0) + buffer(1) + buffer(2)\
    \ + buffer(3)\n            buffer(0) = buffer(1)\n            buffer(1) = buffer(2)\n\
    \            buffer(2) = buffer(3)\n            buffer(3) = temp\n        }\n\
    \        buffer(3)", "        // Fill up this function body\n        // You may\
    \ also define new functions as you wish\n        0l", "        val a = Array(0l,\
    \ 0l, 2l, 0l)\n        if (n <= 3) return a(n.toInt)\n        for (i <- 4 to n.toInt)\
    \ {\n            a(0) = a(1)\n            a(1) = a(2)\n            a(2) = a(3)\n\
    \            a(3) = a(0) + a(1) + a(2) + a(3)\n        }\n        return a(3)",
  "        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        0", "        val matrix = Array.ofDim[Long](4,\
    \ 4)\n        for (i <- 0 until 4) matrix(i)(i) = 1\n        val result = fastexp(matrix,\
    \ n - 3)\n        result(0)(0) + result(0)(1) + result(0)(2) + result(0)(3)",
  "        val arr = ArrayBuffer[Long](0, 0, 2, 0)\n        for (i <- 4 to n.toInt)\
    \ {\n            arr.append(arr(i - 1) + arr(i - 2) + arr(i - 3) + arr(i - 4))\n\
    \        }\n        arr(n.toInt)", "        var a : Long = 0;\n        var b :\
    \ Long = 0;\n        var c : Long = 2;\n        var d : Long = 0;\n        var\
    \ e : Long = 0;\n        if (n < 4) return n match {\n            case 0 => 0\n\
    \            case 1 => 0\n            case 2 => 2\n            case 3 => 0\n \
    \       }\n        var i : Long = 0;\n        for (i <- 4l to n) {\n         \
    \   e = a + b + c + d;\n            a = b;\n            b = c;\n            c\
    \ = d;\n            d = e;\n        }\n        return e;", "        // Fill up\
    \ this function body\n        // You may also define new functions\n        0",
  "        // Fill up this function body\n        // You may also define new functions\n\
    \t\tvar A = Array(0l, 0l, 2l, 0l, 0l)\n\t\tfor (i <- 4 to n.toInt) {\n\t\t\tvar\
    \ ans = 0l\n\t\t\tfor (j <- 0 to 3) {\n\t\t\t\tans += A(j)\n\t\t\t}\n\t\t\tA =\
    \ A.drop(1)\n\t\t\tA = A :+ ans\n\t\t}\n\t\tA(4)", "        // Fill up this function\
    \ body\n        // You may also define new functions\n        return 0", "   \
    \     if (n < 0) throw new IllegalArgumentException\n        var p1 = 0l\n   \
    \     var p2 = 0l\n        var p3 = 2l\n        var p4 = 0l\n        for (i <-\
    \ 3 to n.toInt) {\n            val cur = p1 + p2 + p3 + p4\n            p1 = p2\n\
    \            p2 = p3\n            p3 = p4\n            p4 = cur\n        }\n \
    \       p4", "        if (n < 4) 0\n        else {\n            var x = 0l\n \
    \           var y = 0l\n            var z = 2l\n            var p = 0l\n     \
    \       for (i <- 4 to n.toInt) {\n                p = x + y + z\n           \
    \     x = y\n                y = z\n                z = p\n            }\n   \
    \         p\n        }", "        var a = 0l\n        var b = 0l\n        var\
    \ c = 2l\n        var d = 0l\n        for (i <- 4l to n) {\n            val e\
    \ = d + c + b + a\n            a = b\n            b = c\n            c = d\n \
    \           d = e\n        }\n        d", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        if (n ==\
    \ 0) 0\n        else if (n == 1) 0\n        else if (n == 2) 2\n        else if\
    \ (n == 3) 0\n        else if (n == 4) 2\n        else fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4)", "        // Fill up this function body\n        // You\
    \ may also define other functions as you wish\n        // No recursion allowed\n\
    \        0", "        val init = new Array[Long](4)\n        init(0) = 0\n   \
    \     init(1) = 0\n        init(2) = 2\n        init(3) = 0\n        return Stream.iterate(init)(x\
    \ => Array(x(1), x(2), x(3), x(0) + x(1) + x(2) + x(3))).drop(n.toInt).head(0)"]
stop_tokens:
- "\n    }\n"
