name: HumanEval_123_get_odd_collatz
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return a sorted list that has the odd numbers\
  \ in collatz sequence.\n    // The Collatz conjecture is a conjecture in mathematics\
  \ that concerns a sequence defined\n    // as follows: start with any positive integer\
  \ n. Then each term is obtained from the \n    // previous term as follows: if the\
  \ previous term is even, the next term is one half of \n    // the previous term.\
  \ If the previous term is odd, the next term is 3 times the previous\n    // term\
  \ plus 1. The conjecture is that no matter what value of n, the sequence will always\
  \ reach 1.\n    // Note: \n    // 1. Collatz(1) is [1].\n    // 2. returned list\
  \ sorted in increasing order.\n    // For example:\n    // get_odd_collatz(5) returns\
  \ [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers\
  \ are only 1, and 5.\n    // >>> getOddCollatz((5l))\n    // (List[Long](1l.toLong,\
  \ 5l.toLong))\n    def getOddCollatz(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong,\
  \ 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong,\
  \ 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        if (n == 1) return List(1l)\n        var result = new ListBuffer[Long]\n\
    \        result += 1l\n        var m = n\n        while (m != 1) {\n         \
    \   if (m % 2 == 1) result += m\n            m = if (m % 2 == 0) m / 2 else 3\
    \ * m + 1\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var current = n\n        while (current != 1) {\n            if (current\
    \ % 2 == 1) result = current :: result\n            current = if (current % 2\
    \ == 0) current / 2 else current * 3 + 1\n        }\n        result.reverse",
  "        val seq = ArrayBuffer[Long]()\n        var num = n\n        while (num\
    \ != 1) {\n            seq += num\n            if (num % 2 == 0) num /= 2\n  \
    \          else num = num * 3 + 1\n        }\n        seq += 1\n        seq.toList.filter(x\
    \ => x % 2 == 1)", "        if (n == 1) return List(1)\n        val lst = ListBuffer(n)\n\
    \        var x = n\n        while (x != 1) {\n            if (x % 2 == 0) x /=\
    \ 2\n            else x = 3 * x + 1\n            lst += x\n        }\n       \
    \ lst.filter(x => x % 2 == 1).toList.sorted", "        var x = n\n        var\
    \ result = List[Long]()\n        while (x != 1) {\n            result = if (x\
    \ % 2 == 1) x :: result else result\n            x = if (x % 2 == 0) x / 2 else\
    \ x * 3 + 1\n        }\n        result = 1l :: result\n        result", "    \
    \    def loop(n : Long, acc : List[Long]) : List[Long] = {\n            if (n\
    \ <= 1) acc.reverse\n            else if (n % 2 == 0) loop(n / 2, acc)\n     \
    \       else loop(3 * n + 1, n :: acc)\n        }\n        loop(n, List[Long]())",
  "        def helper(l : List[Long], x : Long) : List[Long] = {\n            if (x\
    \ == 1) l else if (x % 2 == 0) helper(l, x / 2) else helper(x :: l, 3 * x + 1)\n\
    \        }\n        helper(List(), n).reverse", "        // Once a number is seen,\
    \ it is always seen.\n        val known_numbers = new HashMap[Long, Boolean]\n\
    \        def collatz_helper(m : Long) : List[Long] = {\n            if (m == 1)\
    \ {\n                List[Long](1)\n            } else if (m % 2 == 0) {\n   \
    \             val next = m / 2\n                if (known_numbers.contains(next))\
    \ {\n                    List[Long](next)\n                } else {\n        \
    \            known_numbers += (next -> true)\n                    next :: collatz_helper(next)\n\
    \                }\n            } else {\n                val next = 3 * m + 1\n\
    \                if (known_numbers.contains(next)) {\n                    List[Long](next)\n\
    \                } else {\n                    known_numbers += (next -> true)\n\
    \                    next :: collatz_helper(next)\n                }\n       \
    \     }\n        }\n        known_numbers += (n -> true)\n        n :: collatz_helper(n)",
  "        val p = new Problem()\n        p.getOddCollatz(n, new ListBuffer[Long]()).toList",
  "        if (n == 1) return List(1)\n        var seq = new ListBuffer[Long]()\n\
    \        var temp = n\n        while (temp != 1) {\n            if (temp % 2 ==\
    \ 1) seq += temp\n            temp = collatz(temp)\n        }\n        seq +=\
    \ 1\n        seq.toList", "        var seq = ListBuffer[Long]()\n        var m\
    \ = n\n        while (m != 1) {\n            seq += m\n            if (m % 2 ==\
    \ 0) m /= 2\n            else m = 3 * m + 1\n        }\n        seq += 1\n   \
    \     return seq.filter(_ % 2 == 1).toList", "        var odd = List[Long]()\n\
    \        var cur = n\n        while (cur != 1) {\n            odd = odd :+ cur\n\
    \            if (cur % 2 == 0) cur /= 2\n            else cur = cur * 3 + 1\n\
    \        }\n        odd", "        val s = Stack[Long]()\n        var count =\
    \ 0\n        var x = n\n        s.push(x)\n        while (x != 1) {\n        \
    \    if (x % 2 == 0) x = x / 2\n            else x = 3 * x + 1\n            s.push(x)\n\
    \        }\n        s.toList.filter(_ % 2 == 1)", "      val ls = n :: getCollatz(n)\n\
    \      val result = ls.filter(i => i % 2 == 1)\n      result", "        if (n\
    \ == 1) return List(1)\n        val buff = new ArrayBuffer[Long]\n        buff\
    \ += n\n        var m = n\n        var c = 0\n        do {\n            if (m\
    \ % 2 == 0) m /= 2\n            else m = 3 * m + 1\n            if (m % 2 == 1)\
    \ buff += m\n            c += 1\n        } while (m != 1)\n        buff.toList",
  "        // For example:\n        // Given n = 5:\n        // after one round: 5\
    \ -> 16 -> 8 -> 4 -> 2 -> 1\n        // then, odd numbers: 5, 1\n        // keep\
    \ repeated numbers\n        var res = ListBuffer[Long]()\n        var temp = n\n\
    \        res += temp\n        while (temp != 1) {\n            if (temp % 2 ==\
    \ 0) temp /= 2\n            else temp = 3 * temp + 1\n            res += temp\n\
    \        }\n        // println(res)\n        var oddRes = ListBuffer[Long]()\n\
    \        var cnt = 0\n        while (cnt < res.length) {\n            if (res(cnt)\
    \ % 2 == 1) oddRes += res(cnt)\n            cnt += 1\n        }\n        oddRes.toList",
  "        var oddCollatz = scala.collection.mutable.Set[Long]()\n        def helper(n\
    \ : Long) : Unit = {\n            if (n == 1) {\n                oddCollatz +=\
    \ 1\n                return\n            }\n            if (n % 2 == 1) oddCollatz\
    \ += n\n            helper(if (n % 2 == 0) n / 2 else 3 * n + 1)\n        }\n\
    \        helper(n)\n        oddCollatz.toList.sorted", "        def iter(x : Long,\
    \ acc : List[Long]) : List[Long] = x match {\n            case x if x == 1 =>\
    \ acc.reverse\n            case x if x % 2 == 0 => iter(x / 2, acc)\n        \
    \    case x if x % 2 == 1 => iter(3 * x + 1, x :: acc)\n        }\n        iter(n,\
    \ List[Long]())", "        if (n <= 0) throw new IllegalArgumentException(\"n\
    \ must be greater than zero\")\n        var result = ListBuffer[Long]()\n    \
    \    var number = n\n        while (number != 1) {\n            if (number % 2\
    \ == 1) result += number\n            number = if (number % 2 == 0) number / 2\
    \ else 3 * number + 1\n        }\n        result += 1\n        result.toList",
  "        val numbers = ListBuffer[Long]()\n        var i = n\n        while (i !=\
    \ 1) {\n            if (i % 2 == 1) numbers += i\n            i = getNextCollatz(i)\n\
    \        }\n        numbers += 1\n        numbers.sorted.toList", "        val\
    \ table = scala.collection.mutable.Map[Long, Long]()\n        table += (1l ->\
    \ 1l)\n        def helper(n : Long) : Long = {\n            table.get(n) match\
    \ {\n                case Some(num) => num\n                case None => {\n \
    \                   val rst = if (n % 2 == 0) helper(n / 2) else helper(3 * n\
    \ + 1)\n                    table += (n -> rst)\n                    rst\n   \
    \             }\n            }\n        }\n        val collatz = helper(n)\n \
    \       var rst = List[Long]()\n        for (i <- collatz to 1 by -1) {\n    \
    \        if (i % 2 == 1) rst ::= i\n        }\n        rst", "        if (n ==\
    \ 1) return List(1)\n        var cur = n\n        var result = List[Long]()\n\
    \        while (cur != 1) {\n            if (cur % 2 == 1) result = result :+\
    \ cur\n            cur = if (cur % 2 == 0) cur / 2 else cur * 3 + 1\n        }\n\
    \        result = result :+ 1\n        result.sortWith(_ < _)", "        var l\
    \ = ArrayBuffer[Long]()\n        l += n\n        while (n != 1) {\n          \
    \  n = if (n % 2 == 0) n / 2 else 3 * n + 1\n            l += n\n        }\n \
    \       l.reverse.filter(x => x % 2 == 1).toList", "        if (n <= 0) return\
    \ List[Long]()\n        var l = new ListBuffer[Long]()\n        def helper(x :\
    \ Long) : Unit = {\n            l += x\n            if (x != 1) {\n          \
    \      if (x % 2 == 0) helper(x / 2)\n                else helper(3 * x + 1)\n\
    \            }\n        }\n        helper(n)\n        l.toList.distinct.sorted",
  "        var result = new ListBuffer[Long]\n        var i = n\n        while (i\
    \ > 1) {\n            if (i % 2 == 1) result += i\n            i = if (i % 2 ==\
    \ 0) i / 2 else 3 * i + 1\n        }\n        result += 1\n        result.toList",
  "        def recur(n : Long, lst : List[Long]) : List[Long] = n match {\n      \
    \      case n if n == 1 => lst\n            case n if n % 2 == 0 => recur(n /\
    \ 2, lst)\n            case n if n % 2 == 1 => recur(3 * n + 1, n :: lst)\n  \
    \      }\n        recur(n, List()).sorted", "        val bf = ListBuffer[Long]()\n\
    \        var current : Long = n\n        while (current != 1) {\n            if\
    \ (current % 2 == 1) bf += current\n            current = (if (current % 2 ==\
    \ 0) current / 2 else current * 3 + 1)\n        }\n        bf += 1\n        bf.toList",
  "        var collatzList = ListBuffer[Long]()\n        collatzList += n\n      \
    \  var i = n\n        while (i != 1) {\n            if (i % 2 == 0) i /= 2\n \
    \           else i = i * 3 + 1\n            collatzList += i\n        }\n    \
    \    collatzList.toList.filter(_ % 2 == 1)", "        // Write your code here\n\
    \        return null;", "        if (n == 1) {\n            return List(1)\n \
    \       }\n        val lst = new ListBuffer[Long]()\n        lst += n\n      \
    \  val x = getCollatz(n)\n        x.map(v => if (v % 2 == 1) lst += v)\n     \
    \   lst.toList.sorted", "        var oddNumbers = new ListBuffer[Long]\n     \
    \   var current = n\n        while (current != 1) {\n            oddNumbers +=\
    \ current\n            if (current % 2 == 0) current /= 2\n            else current\
    \ = 3 * current + 1\n        }\n        oddNumbers += 1\n        oddNumbers.toList",
  "        require(n > 0)\n        var result = ListBuffer[Long]()\n        result\
    \ += n\n        while (n != 1) {\n            if (n % 2 == 0) n /= 2\n       \
    \     else n = 3 * n + 1\n            if (n % 2 == 1) result += n\n        }\n\
    \        result.sorted.toList", "        val oddList = new ListBuffer[Long]\n\
    \        if (n == 1) {\n            oddList += 1\n            return oddList.toList\n\
    \        }\n        var tempN = n\n        while (tempN != 1) {\n            if\
    \ (tempN % 2 == 1) {\n                oddList += tempN\n            }\n      \
    \      tempN = if (tempN % 2 == 0) tempN / 2 else tempN * 3 + 1\n        }\n \
    \       oddList += 1\n        oddList.toList", "        val m = new HashMap[Long,\
    \ List[Long]]\n        m.put(1l, List(1l))\n        def getCollatz(x : Long) :\
    \ List[Long] = {\n            if (m.contains(x)) m(x)\n            else {\n  \
    \              val collatz = if (x % 2 == 0) x / 2 else 3 * x + 1\n          \
    \      m.put(x, x :: getCollatz(collatz))\n                m(x)\n            }\n\
    \        }\n        val collatzList = getCollatz(n)\n        collatzList.filter(x\
    \ => x % 2 == 1)", "        if (n == 1) {\n            List(1)\n        } else\
    \ {\n            var list = ListBuffer[Long]()\n            var next = if (n %\
    \ 2 == 0) {\n                n / 2\n            } else {\n                3 *\
    \ n + 1\n            }\n            while (next != 1) {\n                if (next\
    \ % 2 == 1) {\n                    list += next\n                }\n         \
    \       next = if (next % 2 == 0) {\n                    next / 2\n          \
    \      } else {\n                    3 * next + 1\n                }\n       \
    \     }\n            list += 1\n            list.toList.sorted\n        }", " \
    \       var result = new ListBuffer[Long]\n        var next = n\n        while\
    \ (next != 1) {\n            if (next % 2 == 1) result += next\n            next\
    \ = if (next % 2 == 0) next / 2 else 3 * next + 1\n        }\n        result +=\
    \ 1\n        result.toList", "        var q = n\n        var result = List[Long]()\n\
    \        while (q != 1) {\n            if (q % 2 == 1) result = result :+ q\n\
    \            q = if (q % 2 == 0) q / 2 else 3 * q + 1\n        }\n        result\
    \ = result :+ 1\n        result", "        var result = ListBuffer[Long]()\n \
    \       var m = n\n        while (m != 1) {\n            if (m % 2 == 1) {\n \
    \               result += m\n            }\n            m = if (m % 2 == 0) m\
    \ / 2 else m * 3 + 1\n        }\n        result += 1\n        result.toList",
  "        if (n == 1) return List(1l)\n        val m = if (n % 2 == 0) n / 2 else\
    \ 3 * n + 1\n        getOddCollatz(m) :+ n", "        var x = n\n        var oddList\
    \ = List[Long]()\n        while (x != 1) {\n            if (x % 2 == 1) {\n  \
    \              oddList = oddList :+ x\n            }\n            x = if (x %\
    \ 2 == 0) x / 2 else x * 3 + 1\n        }\n        oddList :+ 1", "        var\
    \ list = new ListBuffer[Long]()\n        def rec(num : Long) : Unit = {\n    \
    \        if (num == 1) return\n            if (num % 2 == 1) list += num\n   \
    \         if (num % 2 == 0) rec(num / 2)\n            else rec(num * 3 + 1)\n\
    \        }\n        rec(n)\n        list.toList", "        if (n == 1) return\
    \ List(1)\n        var res = new ListBuffer[Long]\n        var curr = n\n    \
    \    while (curr != 1) {\n            if (curr % 2 == 1) res += curr\n       \
    \     curr = curr / 2\n        }\n        return (1 :: res.toList).sorted", " \
    \       // Fill up this function body\n        // 'n' is the input argument\n\
    \        var x = n\n        var result = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        while (x > 1) {\n            if (x % 2 == 1) {\n                result\
    \ += x\n            }\n            x = if (x % 2 == 0) {\n                x /\
    \ 2\n            } else {\n                3 * x + 1\n            }\n        }\n\
    \        result += 1\n        result.toList", "    \tval path = HashMap[Long,\
    \ List[Long]]()\n    \tdef t(x : Long) : List[Long] = path.get(x) match {\n  \
    \  \t\tcase Some(v) => v\n    \t\tcase None => {\n    \t\t\tval v = if (x % 2\
    \ == 0) t(x / 2) else t(3 * x + 1)\n    \t\t\tpath += (x -> (x :: v))\n    \t\t\
    \tv\n    \t\t}\n    \t}\n    \tt(n).reverse.filter(x => x % 2 == 1)", "      \
    \  var list = ListBuffer[Long]()\n        var x = n\n        while (x != 1) {\n\
    \            list += x\n            if (x % 2 == 0) x /= 2\n            else x\
    \ = 3 * x + 1\n        }\n        list += 1\n        list.toList.filter(_ % 2\
    \ == 1)", "        val set = new HashSet[Long]\n        var x = n\n        while\
    \ (x != 1) {\n            if (x % 2 == 1) {\n                set += x\n      \
    \      }\n            x = x match {\n                case x if x % 2 == 0 => x\
    \ / 2\n                case x if x % 2 == 1 => 3 * x + 1\n            }\n    \
    \    }\n        set.toList.sorted", "        if (n == 1) return List(1)\n    \
    \    var s : MutableList[Long] = MutableList()\n        var m : Long = n\n   \
    \     while (m != 1) {\n            if (m % 2 == 1) s += m\n            m = if\
    \ (m % 2 == 0) m / 2 else 3 * m + 1\n        }\n        s += 1\n        s.toList.sorted",
  "        val lst = ListBuffer[Long]()\n        var result = n\n        while (result\
    \ != 1) {\n            if (result % 2 == 1) {\n                lst += result\n\
    \            }\n            result = if (result % 2 == 0) result / 2 else 3 *\
    \ result + 1\n        }\n        lst += 1\n        lst.toList", "        def collatz(n\
    \ : Long) : Stream[Long] = n #:: {\n            if (n == 1) Stream.empty\n   \
    \         else if (n % 2 == 0) collatz(n / 2)\n            else collatz(3 * n\
    \ + 1)\n        }\n        collatz(n).filter(x => x % 2 == 1).toList", "     \
    \ val result = ListBuffer[Long]()\n      def aux(m : Long) : Unit = {\n      \
    \  result += m\n        if (m == 1) return\n        else if (m % 2 == 0) aux(m\
    \ / 2)\n        else aux(3 * m + 1)\n      }\n      aux(n)\n      result.toList",
  "        var list = List[Long]()\n        list", "        require(n > 0)\n     \
    \   val list = ListBuffer[Long]()\n        list += n\n        var cur = n\n  \
    \      while (cur != 1) {\n            if (cur % 2 == 0) cur /= 2\n          \
    \  else cur = cur * 3 + 1\n            if (cur % 2 == 1) list += cur\n       \
    \ }\n        list.toList", "        var k = n\n        var odds = List[Long]()\n\
    \        while (k != 1) {\n            if (k % 2 == 1) odds = k :: odds\n    \
    \        k = if (k % 2 == 0) k / 2 else 3 * k + 1\n        }\n        odds.reverse",
  "        var collatz : List[Long] = List(n)\n        while (collatz.last != 1) {\n\
    \            if (collatz.last % 2 == 0) collatz = collatz.init :+ (collatz.last\
    \ / 2)\n            else collatz = collatz.init :+ (3 * collatz.last + 1)\n  \
    \      }\n        collatz.filter(_ % 2 == 1)", "        def collatz(n : Long)\
    \ : List[Long] = {\n            if (n == 1) List(1)\n            else if (n %\
    \ 2 == 0) n :: collatz(n / 2)\n            else n :: collatz(3 * n + 1)\n    \
    \    }\n        collatz(n).filter(_ % 2 == 1).distinct.sorted", "        val cache\
    \ = HashMap[Long, List[Long]]()\n        val collatz = ListBuffer[Long]()\n  \
    \      cache += (1L -> List(1L))\n        def collatzToOne(n : Long) : List[Long]\
    \ = {\n            if (cache.contains(n)) return cache(n)\n            if (n %\
    \ 2 == 0) {\n                val prev = collatzToOne(n / 2)\n                cache\
    \ += (n -> (n :: prev))\n                return n :: prev\n            }\n   \
    \         else {\n                val prev = collatzToOne(3 * n + 1)\n       \
    \         cache += (n -> (n :: prev))\n                return n :: prev\n    \
    \        }\n        }\n        collatzToOne(n).reverse.filter(_ % 2 == 1)", " \
    \       val l = new ListBuffer[Long]\n        if (n == 1) l += 1\n        else\
    \ {\n            var m = n\n            while (m != 1) {\n                if (m\
    \ % 2 == 1) l += m\n                m = if (m % 2 == 0) m / 2 else 3 * m + 1\n\
    \            }\n            l += 1\n        }\n        l.toList", "        var\
    \ memo = scala.collection.mutable.Map[Long, Boolean]()\n        def collatz(n\
    \ : Long) : Long = {\n            val seq = ArrayBuffer[Long]()\n            seq\
    \ += n\n            def helper(n : Long) : Long = {\n                if (n ==\
    \ 1) 1\n                else if (n % 2 == 0) {\n                    val next =\
    \ n / 2\n                    seq += next\n                    if (memo.contains(next))\
    \ {\n                        next\n                    } else {\n            \
    \            helper(next)\n                    }\n                } else {\n \
    \                   val next = n * 3 + 1\n                    seq += next\n  \
    \                  if (memo.contains(next)) {\n                        next\n\
    \                    } else {\n                        helper(next)\n        \
    \            }\n                }\n            }\n            val m = helper(n)\n\
    \            for (i <- 0 until seq.length) {\n                memo += (seq(i)\
    \ -> true)\n            }\n            m\n        }\n        collatz(n)\n    \
    \    var result = List[Long]()\n        for (n <- 1 to n.toInt) {\n          \
    \  if (memo.contains(n)) {\n                result = n :: result\n           \
    \ }\n        }\n        result", "        def getCollatzSeq(n : Long) : List[Long]\
    \ = {\n            var ret = List[Long]()\n            var num = n\n         \
    \   while (num != 1) {\n                ret = num :: ret\n                if (num\
    \ % 2 == 0) num /= 2\n                else num = num * 3 + 1\n            }\n\
    \            num :: ret\n        }\n        getCollatzSeq(n).filter(x => x % 2\
    \ == 1)", "        def getCollatzList(m : Long) : List[Long] = {\n           \
    \ m match {\n                case 1 => List(1)\n                case _ => {\n\
    \                    val newValue = if (m % 2 == 0) m / 2 else 3 * m + 1\n   \
    \                 m :: getCollatzList(newValue)\n                }\n         \
    \   }\n        }\n        getCollatzList(n).filter(_ % 2 == 1).distinct.sorted",
  "        if (n == 1) List(1)\n        else {\n            val m = if (n % 2 == 0)\
    \ n / 2 else 3 * n + 1\n            getOddCollatz(m) :+ n\n        }", "     \
    \   if (n == 1) return List(1)\n        var numbers = new ListBuffer[Long]()\n\
    \        numbers += n\n        while (numbers.last != 1) {\n            if (numbers.last\
    \ % 2 == 0) numbers += numbers.last / 2\n            else numbers += 3 * numbers.last\
    \ + 1\n        }\n        numbers.filter(x => x % 2 == 1).toList", "        def\
    \ getOddCollatzHelper(n : Long, list : List[Long]) : List[Long] = {\n        \
    \    if (n == 1) {\n                if (list.last == 1) list\n               \
    \ else list :+ 1\n            }\n            else if (n % 2 == 0) getOddCollatzHelper(n\
    \ / 2, list)\n            else getOddCollatzHelper(3 * n + 1, list :+ n)\n   \
    \     }\n        getOddCollatzHelper(n, List())", "        var ans = List[Long]()\n\
    \        var cur = n\n        while (cur != 1) {\n            if (cur % 2 == 1)\
    \ {\n                ans = cur :: ans\n            }\n            cur = nextCollatz(cur)\n\
    \        }\n        ans = 1l :: ans\n        ans.reverse", "        var oddNumbers\
    \ = List[Long]()\n        if (n <= 0) return oddNumbers\n        oddNumbers +:=\
    \ n\n        var temp = n\n        while (temp != 1) {\n            temp = if\
    \ (temp % 2 == 0) {\n                temp / 2\n            } else {\n        \
    \        3 * temp + 1\n            }\n            if (temp % 2 != 0) {\n     \
    \           oddNumbers +:= temp\n            }\n        }\n        oddNumbers.sorted",
  "        def iter(m : Long, res : List[Long]) : List[Long] = {\n            if (m\
    \ == 1) return res\n            else if (m % 2 == 0) iter(m / 2, res)\n      \
    \      else iter(3 * m + 1, m :: res)\n        }\n        iter(n, List[Long]())",
  "        val m = scala.collection.mutable.Map[Long, List[Long]]()\n        def get(n\
    \ : Long) : List[Long] = {\n            if (n == 1) {\n                m += (n\
    \ -> List(1))\n                return List(1)\n            }\n            else\
    \ if (m.contains(n)) {\n                return m(n)\n            }\n         \
    \   else {\n                var l : List[Long] = Nil\n                if (n %\
    \ 2 == 0) {\n                    l = n :: get(n / 2)\n                }\n    \
    \            else {\n                    l = n :: get(3 * n + 1)\n           \
    \     }\n                m += (n -> l)\n                return l\n           \
    \ }\n        }\n        get(n).filter(v => v % 2 == 1)", "        var sequence\
    \ = ListBuffer[Long]()\n        var current = n\n        while (current != 1)\
    \ {\n            sequence += current\n            if (current % 2 == 0) current\
    \ /= 2\n            else current = current * 3 + 1\n        }\n        sequence\
    \ += 1\n        val odd_sequence = sequence.filter(x => x % 2 == 1)\n        odd_sequence.toList",
  "        // TODO: find/merge duplicates\n        val list = ListBuffer[Long]()\n\
    \        var num = n\n        while (num != 1) {\n            list += num\n  \
    \          if (num % 2 == 0) {\n                num /= 2\n            } else {\n\
    \                num = num * 3 + 1\n            }\n        }\n        list +=\
    \ 1\n        list.toList.filter(x => x % 2 == 1).sorted", "        if (n <= 0)\
    \ {\n            return List[Long]()\n        }\n        val result = new ListBuffer[Long]()\n\
    \        var num = n\n        while (num != 1) {\n            if (num % 2 == 1)\
    \ {\n                result += num\n            }\n            num = collatz(num)\n\
    \        }\n        result += 1\n        result.toList", "        val l = ListBuffer[Long]()\n\
    \        var i = n\n        while (i != 1) {\n            if (i % 2 == 1) {\n\
    \                l += i\n            }\n            i = if (i % 2 == 0) i / 2\
    \ else 3 * i + 1\n        }\n        l += 1\n        l.toList", "        var result\
    \ = List[Long]()\n        var m = n\n        while (m != 1) {\n            if\
    \ (m % 2 == 1) result ::= m\n            m = (if (m % 2 == 0) m / 2 else 3 * m\
    \ + 1)\n        }\n        result.reverse", "        var i = n\n        var result\
    \ = new ListBuffer[Long]()\n        while (i != 1) {\n            if (i % 2 ==\
    \ 1) {\n                result += i\n            }\n            i = if (i % 2\
    \ == 0) { i / 2 } else { 3 * i + 1 }\n        }\n        result += 1\n       \
    \ result.toList", "        def getCollatz(n : Long) : List[Long] = {\n       \
    \     if (n == 1) {\n                List(1)\n            } else {\n         \
    \       var result = List[Long]()\n                var n1 = n\n              \
    \  while (n1 != 1) {\n                    result = n1 :: result\n            \
    \        if (n1 % 2 == 0) {\n                        n1 = n1 / 2\n           \
    \         } else {\n                        n1 = 3 * n1 + 1\n                \
    \    }\n                }\n                result = 1 :: result\n            \
    \    result\n            }\n        }\n        getCollatz(n).filter(_ % 2 == 1)",
  "        var res = new ListBuffer[Long]\n        var c = n\n        res += c\n \
    \       while (c != 1) {\n            c = if (c % 2 == 0) {\n                c\
    \ / 2\n            } else {\n                3 * c + 1\n            }\n      \
    \      if (c % 2 == 1) {\n                res += c\n            }\n        }\n\
    \        return res.toList", "        var map = new HashMap[Long, Long]\n    \
    \    def collatz(n : Long) : Long = {\n            if (n == 1) return 1\n    \
    \        if (map.contains(n)) return map(n)\n            if (n % 2 == 0) return\
    \ collatz(n / 2)\n            else {\n                val m = collatz(3 * n +\
    \ 1)\n                map += n -> m\n                return m\n            }\n\
    \        }\n        var nn = n\n        var count = 0\n        while (nn != 1)\
    \ {\n            count += 1\n            nn = collatz(nn)\n        }\n       \
    \ var result = new ListBuffer[Long]\n        nn = n\n        while (nn != 1) {\n\
    \            result += nn\n            nn = collatz(nn)\n        }\n        result\
    \ += 1\n        return result.toList", "        if (n == 1) return List(1)\n \
    \       var answer = new ListBuffer[Long]()\n        var num = n\n        while\
    \ (num != 1) {\n            if (num % 2 == 1) answer += num\n            num =\
    \ if (num % 2 == 0) num / 2 else num * 3 + 1\n        }\n        answer += 1\n\
    \        answer.toList", "        // First, we can use the following algorithm\
    \ to output the collatz sequence of any given integer n:\n        // If n is 1,\
    \ then return 1.\n        // while n > 1,\n        //     if n is even:\n    \
    \    //         Print n\n        //         n = n / 2\n        //     else:\n\
    \        //         Print n\n        //         n = 3n + 1\n        // Return\
    \ n\n        // Then, we can use another recursive function to get the odd numbers\
    \ in the sequence.\n        def getOddCollatzRecursive(n : Long, odd : List[Long])\
    \ : List[Long] = {\n            if (n <= 1) return 1 :: odd\n            if (n\
    \ % 2 == 0) getOddCollatzRecursive(n / 2, odd)\n            else getOddCollatzRecursive(3\
    \ * n + 1, n :: odd)\n        }\n        getOddCollatzRecursive(n, Nil).sorted",
  "        var result = ListBuffer[Long]()\n        var cur = n\n        while (cur\
    \ != 1) {\n            result += cur\n            if (cur % 2 == 0) cur /= 2\n\
    \            else cur = cur * 3 + 1\n        }\n        result += 1\n        result.toList",
  "        def helper(n : Long, result : List[Long]) : List[Long] = {\n          \
    \  if (n == 1) {\n                result\n            } else {\n             \
    \   val next = if (n % 2 == 0) n / 2 else n * 3 + 1\n                if (next\
    \ % 2 == 1) helper(next, next :: result) else helper(next, result)\n         \
    \   }\n        }\n        helper(n, List(n)).reverse", "        var ans = List[Long]()\n\
    \        var num = n\n        while (num != 1) {\n            if (num % 2 == 1)\
    \ ans = num :: ans\n            num = if (num % 2 == 0) num / 2 else num * 3 +\
    \ 1\n        }\n        ans = 1l :: ans\n        ans", "        val map = Map[Long,\
    \ List[Long]]().withDefaultValue(List[Long]())\n        val result = ListBuffer[Long]()\n\
    \        def recur(x : Long) : Unit = {\n            val cache = map(x)\n    \
    \        if (cache.isEmpty) {\n                if (x == 1) {\n               \
    \     result += 1\n                    map(x) = result.toList\n              \
    \  } else {\n                    if (x % 2 == 0) {\n                        recur(x\
    \ / 2)\n                    } else {\n                        result += x\n  \
    \                      recur(3 * x + 1)\n                    }\n             \
    \       map(x) = result.toList\n                }\n            } else result ++=\
    \ cache\n        }\n        recur(n)\n        result.toList", "        // Given\
    \ a positive integer n, return the next term in collatz sequence.\n        def\
    \ getNextCollatz(n : Long) : Long = {\n            if (n == 1) 1 else\n      \
    \      if (n % 2 == 0) n / 2 else\n            3 * n + 1\n        }\n        //\
    \ Given a positive integer n, return true if n is odd, otherwise false.\n    \
    \    def isOdd(n : Long) : Boolean = {\n            n % 2 == 1\n        }\n  \
    \      var result = new ListBuffer[Long]\n        var n1 = n\n        while (n1\
    \ != 1) {\n            n1 = getNextCollatz(n1)\n            if (isOdd(n1)) result\
    \ += n1\n        }\n        result += 1\n        result.toList.sorted", "    \
    \    var l = List[Long]()\n        var num = n\n        while (num != 1) {\n \
    \           if (num % 2 == 1) l = num :: l\n            num = if (num % 2 == 0)\
    \ num / 2 else num * 3 + 1\n        }\n        1 :: l", "        var result =\
    \ List[Long]()\n        val map = new HashMap[Long, Long]()\n        for (i <-\
    \ 1l to n) {\n            var s = i\n            var temp = List[Long]()\n   \
    \         while (s != 1) {\n                if (map.contains(s)) {\n         \
    \           s = map(s)\n                } else {\n                    if (s %\
    \ 2 == 0) s /= 2\n                    else s = 3 * s + 1\n                   \
    \ temp = s :: temp\n                }\n            }\n            temp = temp.reverse\n\
    \            var temp2 = List[Long]()\n            for (j <- temp.indices) {\n\
    \                if (j % 2 == 0) {\n                    temp2 = temp(j) :: temp2\n\
    \                }\n                map += temp(j) -> temp2(0)\n            }\n\
    \            result = (temp2 ::: result).sorted\n        }\n        result", " \
    \       var number = n\n        var collatzSequence = ListBuffer[Long]()\n   \
    \     while (number != 1) {\n            collatzSequence += number\n         \
    \   if (number % 2 == 0) number /= 2\n            else number = 3 * number + 1\n\
    \        }\n        collatzSequence += 1\n        return collatzSequence.filter(number\
    \ => number % 2 == 1).toList", "        var oddNumbers = new ListBuffer[Long]\n\
    \        def getOddCollatz0(n : Long) : Unit = {\n            if (n == 1) {\n\
    \                return\n            }\n            if (n % 2 == 1) {\n      \
    \          oddNumbers += n\n            }\n            getOddCollatz0(if (n %\
    \ 2 == 0) n / 2 else 3 * n + 1)\n        }\n        getOddCollatz0(n)\n      \
    \  oddNumbers.toList.sortWith(_ < _)", "        var collatz = List[Long]()\n \
    \       var odd = List[Long]()\n        var temp = n\n        collatz = collatz.+:(temp)\n\
    \        while (temp != 1) {\n            if (temp % 2 == 0) temp = temp / 2\n\
    \            else temp = 3 * temp + 1\n            collatz = collatz.+:(temp)\n\
    \        }\n        for (e <- collatz) {\n            if (e % 2 == 1) odd = odd.+:(e)\n\
    \        }\n        return odd", "        var oddCollatz = new ListBuffer[Long]()\n\
    \        var current = n\n        while (current != 1) {\n            if (current\
    \ % 2 == 1) oddCollatz += current\n            current = current % 2 match {\n\
    \                case 0 => current / 2\n                case 1 => 3 * current\
    \ + 1\n            }\n        }\n        oddCollatz += 1\n        oddCollatz.toList",
  "        var seq = n :: List()\n        var m = n\n        while (m != 1) {\n  \
    \          if (m % 2 == 0) m /= 2\n            else m = 3 * m + 1\n          \
    \  seq = seq :+ m\n        }\n        var result = List[Long]()\n        for (i\
    \ <- seq.indices) {\n            if (seq(i) % 2 == 1) result = result :+ seq(i)\n\
    \        }\n        result", "        var m = n\n        var ans = List[Long]()\n\
    \        while (m != 1) {\n            if (m % 2 == 1) ans = m :: ans\n      \
    \      m = if (m % 2 == 0) m / 2 else 3 * m + 1\n        }\n        ans = 1 ::\
    \ ans\n        ans", "        // Since the input is positive, and the Collatz\
    \ sequence will always reach 1, so the sequence length is\n        // at most\
    \ 100,000,000.\n        val collatz = new Array[Long](100000000)\n        collatz(0)\
    \ = 1\n        var tmp : Long = n\n        var oddCollatz : List[Long] = List()\n\
    \        while (tmp != 1) {\n            if (tmp % 2 == 1) {\n               \
    \ oddCollatz = tmp :: oddCollatz\n            }\n            tmp = if (tmp % 2\
    \ == 0) tmp / 2 else 3 * tmp + 1\n        }\n        oddCollatz", "        var\
    \ h = HashMap[Long, Long]()\n        var b = ListBuffer[Long]()\n        h(1)\
    \ = 1\n        val f = (i : Long) => {\n            h(i) = i\n            if (i\
    \ % 2 == 0) i / 2 else 3 * i + 1\n        }\n        def g(i : Long) : List[Long]\
    \ = {\n            if (h.contains(i)) {\n                var x = i\n         \
    \       var l = List[Long]()\n                while (x != 1) {\n             \
    \       l = x :: l\n                    x = h(x)\n                }\n        \
    \        return l\n            }\n            else {\n                var c =\
    \ i\n                while (h.contains(c) == false) {\n                    c =\
    \ f(c)\n                }\n                var l = List[Long]()\n            \
    \    var p = i\n                while (p != c) {\n                    l = p ::\
    \ l\n                    p = f(p)\n                }\n                g(c) :::\
    \ l\n            }\n        }\n        var x = n\n        var l = List[Long]()\n\
    \        while (x != 1) {\n            l = x :: l\n            x = f(x)\n    \
    \    }\n        l.filter(x => x % 2 == 1).sorted", "        // Recursively go\
    \ through the collatz sequence of n, and return the odds.\n        // TODO: optimize\n\
    \        var result = ListBuffer[Long]()\n        def getOddCollatzHelper(n :\
    \ Long) : List[Long] = {\n            if (n != 1l) {\n                if (n %\
    \ 2 == 1) {\n                    result += n\n                    getOddCollatzHelper((3l\
    \ * n + 1l) / 2l)\n                } else {\n                    getOddCollatzHelper(n\
    \ / 2l)\n                }\n            } else {\n                result += 1l\n\
    \                result.toList\n            }\n        }\n        if (n == 1l)\
    \ List(1l) else getOddCollatzHelper(n)", "        var collatz : List[Long] = List(n)\n\
    \        var current = n\n        while (current != 1) {\n            current\
    \ = if (current % 2 == 0) current / 2 else 3 * current + 1\n            collatz\
    \ :+= current\n        }\n        collatz.filter(x => x % 2 == 1)", "        if\
    \ (n <= 0) return List()\n        var lst = List(n)\n        while (lst.last !=\
    \ 1) {\n            val current = lst.last\n            lst = if (current % 2\
    \ == 0) current / 2 :: lst else (current * 3 + 1) :: lst\n        }\n        return\
    \ lst.filter(a => a % 2 == 1).sorted", "        var lst = List[Long]()\n     \
    \   while (n != 1) {\n            if (n % 2 == 1) {\n                lst = n ::\
    \ lst\n            }\n            n = if (n % 2 == 0) n / 2 else n * 3 + 1\n \
    \       }\n        lst = 1 :: lst\n        lst", "        // We first precompute\
    \ the collatz sequence for 1 ~ 1000000\n        val collatzMap = new HashMap[Long,\
    \ List[Long]]\n        val oddCollatzMap = new HashMap[Long, List[Long]]\n   \
    \     for (i <- 1 to 1000000) {\n            var temp = i\n            var collatzList\
    \ = List[Long]()\n            while (temp != 1) {\n                collatzList\
    \ = collatzList :+ temp\n                if (temp % 2 == 0) temp /= 2\n      \
    \          else temp = 3 * temp + 1\n            }\n            collatzList =\
    \ collatzList :+ 1\n            collatzMap(i) = collatzList\n            oddCollatzMap(i)\
    \ = collatzList.filter(x => x % 2 == 1)\n        }\n        // Now we compute\
    \ the odd collatz sequence for n\n        val oddCollatz = ListBuffer[Long]()\n\
    \        var temp = n\n        while (temp != 1) {\n            oddCollatz +=\
    \ temp\n            if (temp % 2 == 0) temp /= 2\n            else temp = 3 *\
    \ temp + 1\n        }\n        oddCollatz += 1\n        oddCollatz.toList", " \
    \       if (n <= 0) throw new IllegalArgumentException(\"n must be positive\"\
    );\n        val seq = new ListBuffer[Long]();\n        var x = n;\n        while\
    \ (x != 1) {\n            seq += x;\n            if (x % 2 == 0) x /= 2;\n   \
    \         else x = 3 * x + 1;\n        }\n        seq += 1;\n        seq.toList.filter(k\
    \ => k % 2 == 1);", "        var collatz = ArrayBuffer(n)\n        var last =\
    \ n\n        var stop = false\n        while(!stop) {\n            val newItem\
    \ = last match {\n                case x if x % 2 == 0 => x / 2\n            \
    \    case _ => 3 * last + 1\n            }\n            collatz += newItem\n \
    \           if (newItem == 1) stop = true\n            last = newItem\n      \
    \  }\n        collatz.toList.sorted.filter(x => x % 2 == 1)", "        // We need\
    \ to generate the collatz sequence.\n        // We must solve the problem for\
    \ all the lower cases, and then build the solution for the new case.\n       \
    \ // This is a dynamic programming technique, in which we will build the solution\
    \ with memoization.\n        // Since we need to build the solution for any lower\
    \ case and for any case, we will put them all in a map.\n        // The map will\
    \ have key as the number, and the value as the list of odd collatz numbers.\n\
    \        // There will be two functions. One will start the search and the other\
    \ will be a recursive function that will build the solution.\n        val map\
    \ = new HashMap[Long, List[Long]]\n        val oddCollatzFinder = (n : Long) =>\
    \ {\n            // This function will check the map and see if the solution exists.\
    \ If it does, it will be returned.\n            // Else, the recursion will start\
    \ and the solution will be saved in the map.\n            if (map.contains(n))\
    \ {\n                map(n)\n            } else {\n                val list =\
    \ getOddCollatzRecursive(n, map)\n                map += (n -> list)\n       \
    \         list\n            }\n        }\n        oddCollatzFinder(n)", "    \
    \    val collatz = new HashMap[Long, List[Long]]\n        def collatzHelper(n\
    \ : Long) : List[Long] = {\n            val result = collatz.get(n)\n        \
    \    if (result != None) result.get\n            else {\n                if (n\
    \ == 1) List(1)\n                else if (n % 2 == 0) n :: collatzHelper(n / 2)\n\
    \                else n :: collatzHelper(3 * n + 1)\n            }\n        }\n\
    \        collatzHelper(n).filter(_ % 2 == 1)", '        return recurOddCollatz(n,
    List(n))', "        var lst = List[Long]()\n        if (n <= 0) return lst\n \
    \       var m = n\n        while (m != 1) {\n            if (m % 2 == 1) lst =\
    \ m :: lst\n            m = if (m % 2 == 0) m / 2 else 3 * m + 1\n        }\n\
    \        lst = 1 :: lst\n        lst", "        def h(n : Long, acc : List[Long])\
    \ : List[Long] = {\n            if (n == 1) acc\n            else if (n % 2 ==\
    \ 0) h(n / 2, acc)\n            else h(3 * n + 1, n :: acc)\n        }\n     \
    \   h(n, List()).reverse", "        val stack = new Stack[Long]\n        stack.push(n)\n\
    \        var current = n\n        var next = 0L\n        while (current != 1)\
    \ {\n            if (current % 2 == 0) next = current / 2\n            else next\
    \ = 3 * current + 1\n            stack.push(next)\n            current = next\n\
    \        }\n        stack.toList.sorted", "        def tail(n : Long, l : List[Long])\
    \ : List[Long] = {\n            val next = if (n % 2 == 0) n / 2 else 3 * n +\
    \ 1\n            if (next == 1) l\n            else tail(next, l :+ next)\n  \
    \      }\n        tail(n, List(n)).filter(x => x % 2 == 1)", "        var list\
    \ = ListBuffer[Long]()\n        var curr = n\n        while (curr != 1) {\n  \
    \          list += curr\n            if (curr % 2 == 0) curr /= 2\n          \
    \  else curr = 3 * curr + 1\n        }\n        list += 1\n        list.toList.filter(x\
    \ => x % 2 == 1).sorted", "        var list = new ListBuffer[Long]()\n       \
    \ list += n\n        var i = n\n        while (i != 1) {\n            if (i %\
    \ 2 == 0) i /= 2\n            else i = i * 3 + 1\n            if (i % 2 == 1)\
    \ list += i\n        }\n        list.toList", "        def getOddCollatz(n : Long,\
    \ acc : List[Long]) : List[Long] = {\n            if (n == 1) acc\n          \
    \  else if (n % 2 == 0) getOddCollatz(n / 2, acc)\n            else getOddCollatz(3\
    \ * n + 1, n :: acc)\n        }\n        getOddCollatz(n, List())", "        def\
    \ isOdd(n : Long) : Boolean = n % 2 == 1\n        def getCollatz(n : Long) : Long\
    \ = {\n            if (n == 1) return 1l\n            if (isOdd(n)) 3 * n + 1\
    \ else n / 2\n        }\n        def getCollatzSeq(n : Long) : List[Long] = {\n\
    \            def getCollatzSeq(n : Long, seq : List[Long]) : List[Long] = {\n\
    \                if (n == 1) return seq\n                getCollatzSeq(getCollatz(n),\
    \ n :: seq)\n            }\n            getCollatzSeq(n, List())\n        }\n\
    \        getCollatzSeq(n).filter(isOdd).distinct.sorted", "      val collatz =\
    \ new ListBuffer[Long]()\n      collatz += n\n      def helper(n : Long) : List[Long]\
    \ = {\n        collatz += n\n        if (n == 1) collatz.toList\n        else\
    \ {\n          if (n % 2 == 0) helper(n / 2)\n          else helper(3 * n + 1)\n\
    \        }\n      }\n      helper(n)", "        var l = List[Long]()\n       \
    \ var m = n\n        while (m != 1) {\n            if (m % 2 == 1) l = m :: l\n\
    \            m = (if (m % 2 == 0) m / 2 else 3 * m + 1)\n        }\n        l\
    \ = 1 :: l\n        l.sorted", "        def f(l : List[Long], c : Long) : List[Long]\
    \ = {\n            if (c == 1) {\n                l\n            } else {\n  \
    \              if (c % 2 == 0) {\n                    f(l, c / 2)\n          \
    \      } else {\n                    f(c :: l, (3 * c + 1) / 2)\n            \
    \    }\n            }\n        }\n        f(List(n), n).sorted", "        val\
    \ ret = ListBuffer[Long]()\n        var x = n\n        while (x != 1) {\n    \
    \        ret += x\n            if (x % 2 == 0) x /= 2\n            else x = 3\
    \ * x + 1\n        }\n        ret += 1\n        return ret.toList.filter(x =>\
    \ x % 2 == 1)", "        val list = MutableList[Long]()\n        var a = n\n \
    \       while (a != 1) {\n            if (a % 2 == 1) list += a\n            a\
    \ = if (a % 2 == 0) a / 2 else 3 * a + 1\n        }\n        list += 1\n     \
    \   list.toList", "    \tif (n == 1) return List(1l)\n    \tvar collatz : List[Long]\
    \ = new ListBuffer[Long]() += n\n    \twhile (collatz.last != 1) {\n    \t\tif\
    \ (collatz.last % 2 == 0) collatz += collatz.last / 2\n    \t\telse collatz +=\
    \ collatz.last * 3 + 1\n    \t}\n    \tcollatz.filter(_ % 2 == 1).toList", " \
    \       def helper(n : Long, result : List[Long]) : List[Long] = {\n         \
    \   if (n == 1) {\n                result.reverse\n            } else {\n    \
    \            val next = if (n % 2 == 0) {\n                    n / 2\n       \
    \         } else {\n                    n * 3 + 1\n                }\n       \
    \         helper(next, (if (n % 2 == 1) n else -1) :: result)\n            }\n\
    \        }\n        helper(n, List[Long]()).filter(_ > 0)", "        val map =\
    \ Map[Long, List[Long]]()\n        val oddNumbers = new ListBuffer[Long]()\n \
    \       def getOddCollatz(n : Long) : List[Long] = {\n            if (n == 1)\
    \ List(1)\n            else if (map.contains(n)) {\n                oddNumbers\
    \ ++= map(n).filter(_ % 2 == 1)\n                map(n)\n            }\n     \
    \       else {\n                val result = if (n % 2 == 0) getOddCollatz(n /\
    \ 2)\n                else getOddCollatz(3 * n + 1)\n                map += (n\
    \ -> result)\n                oddNumbers ++= result.filter(_ % 2 == 1)\n     \
    \           result\n            }\n        }\n        getOddCollatz(n)\n     \
    \   oddNumbers.toList.sorted", "        var collatz = List[Long]()\n        var\
    \ current = n\n        if (current == 1) collatz ::= 1\n        while (current\
    \ != 1) {\n            if (current % 2 == 1) collatz ::= current\n           \
    \ current = if (current % 2 == 0) current / 2 else current * 3 + 1\n        }\n\
    \        collatz.reverse", "        def loop(n : Long, res : List[Long]) : List[Long]\
    \ = {\n            if (n == 1)\n                return res\n            val next\
    \ = if (n % 2 == 0) (n / 2) else (3 * n + 1)\n            loop(next, if (next\
    \ % 2 == 1) next :: res else res)\n        }\n        loop(n, List[Long]())",
  "        var collatzN : Long = n\n        var collatzSequence : List[Long] = List()\n\
    \        if (n == 1) return List(1)\n        while (collatzN != 1) {\n       \
    \     if (collatzN % 2 == 0) collatzN /= 2\n            else collatzN = collatzN\
    \ * 3 + 1\n            collatzSequence = collatzN :: collatzSequence\n       \
    \ }\n        collatzSequence.filter(x => x % 2 == 1)", "        var sequence =\
    \ new ListBuffer[Long]()\n        var number = n\n        while (number != 1)\
    \ {\n            if (number % 2 == 1) {\n                sequence += number\n\
    \            }\n            number = if (number % 2 == 0) number / 2 else 3 *\
    \ number + 1\n        }\n        sequence += 1\n        sequence.toList", "  \
    \      var l = new ListBuffer[Long]()\n        l += n\n        var m = n\n   \
    \     while (m != 1) {\n            if (m % 2 == 0) {\n                m = m /\
    \ 2\n            } else {\n                m = 3 * m + 1\n            }\n    \
    \        l += m\n        }\n        l.filter(_ % 2 == 1).toList", "        var\
    \ odds = ArrayBuffer[Long]()\n        var current = n\n        while (current\
    \ != 1) {\n            odds += current\n            current = if (current % 2\
    \ == 0) current / 2 else current * 3 + 1\n        }\n        odds += 1\n     \
    \   return odds.filter(_ % 2 == 1).toList", "        var result = ListBuffer[Long]()\n\
    \        var t = n\n        while (t != 1) {\n            if (t % 2 == 1) result\
    \ += t\n            t = if (t % 2 == 0) t / 2 else t * 3 + 1\n        }\n    \
    \    result += 1\n        result.toList", "        var collatz : List[Long] =\
    \ List(n)\n        var n_acc = n\n        while (n_acc != 1) {\n            if\
    \ (n_acc % 2 == 0) {\n                n_acc = n_acc / 2\n            } else {\n\
    \                n_acc = 3 * n_acc + 1\n            }\n            collatz = collatz\
    \ :+ n_acc\n        }\n        collatz = collatz.filter((x : Long) => x % 2 ==\
    \ 1)\n        collatz", "        // Solution 1: dp.\n        // Calc collatz sequence\
    \ up to the limit and keep track of the odd numbers.\n        // Time: O(n)\n\
    \        // Space: O(n)\n        def dp() : List[Long] = {\n            val dp\
    \ = new Array[Long]((1e9).toInt)\n            dp(1) = 1\n            val odds\
    \ = new ListBuffer[Long]\n            odds += 1\n            var i = 2\n     \
    \       while (i < dp.length) {\n                var n = i\n                val\
    \ seq = new ListBuffer[Long]\n                while (n > 1 && n < dp.length &&\
    \ dp(n) == 0) {\n                    seq += n\n                    if (n % 2 ==\
    \ 0) n /= 2\n                    else n = 3 * n + 1\n                }\n     \
    \           val k = if (n < dp.length) dp(n) else dp(seq.last / 2)\n         \
    \       for (j <- seq.length - 1 to 0 by -1) {\n                    dp(seq(j))\
    \ = k + seq.length - j\n                    if (seq(j) % 2 == 1) odds += seq(j)\n\
    \                }\n                i += 1\n            }\n            odds.toList.sorted\n\
    \        }\n        // Solution 2: dp.\n        // Calc collatz sequence.\n  \
    \      // Time: O(n)\n        // Space: O(n)\n        def dp2() : List[Long] =\
    \ {\n            val seq = new ListBuffer[Long]\n            var n = n\n     \
    \       while (n > 1) {\n                seq += n\n                if (n % 2 ==\
    \ 0) n /= 2\n                else n = 3 * n + 1\n            }\n            seq\
    \ += 1\n            seq.toList.filter(_ % 2 == 1)\n        }\n        // Solution\
    \ 3: recursion.\n        // Calc collatz sequence.\n        // Time: O(n)\n  \
    \      // Space: O(n)\n        def recursion() : List[Long] = {\n            def\
    \ calc(n : Long) : List[Long] = {\n                if (n == 1) return List(1)\n\
    \                val", "        // Algorithm:\n        // Just run till you hit\
    \ 1.\n        // Because of this sequence property (odds), it is guaranteed to\
    \ hit 1.\n        var current = n\n        var collatz : List[Long] = Nil\n  \
    \      while (current != 1) {\n            collatz = current :: collatz\n    \
    \        if (current % 2 == 0) current /= 2\n            else current = current\
    \ * 3 + 1\n        }\n        return collatz", "        var result = List[Long]()\n\
    \        var tmp = n\n        while (tmp != 1) {\n            if (tmp % 2 == 1)\
    \ {\n                result = result :+ tmp\n            }\n            tmp =\
    \ (if (tmp % 2 == 0) tmp / 2 else 3 * tmp + 1)\n        }\n        result = result\
    \ :+ 1\n        result", "        // Fill up this function body\n        // 'result'\
    \ is a list of the odd numbers in collatz sequence.\n        // 'result' should\
    \ be in sorted order.\n        var result = List[Long]()\n        var temp = n\n\
    \        while (temp != 1) {\n            result = result :+ temp\n          \
    \  if (temp % 2 == 0) {\n                temp = temp / 2\n            } else {\n\
    \                temp = 3 * temp + 1\n            }\n        }\n        result\
    \ = result :+ 1\n        result.distinct.sorted", "        def getCollatz(num\
    \ : Long) : List[Long] = {\n            def helper(n : Long, acc : List[Long])\
    \ : List[Long] = {\n                if (n == 1) acc\n                else if (n\
    \ % 2 == 0) helper(n / 2, n :: acc)\n                else helper(3 * n + 1, n\
    \ :: acc)\n            }\n            helper(num, List())\n        }\n       \
    \ getCollatz(n).filter(p => p % 2 == 1)", "        def helper(num : Long, list\
    \ : List[Long]) : List[Long] = {\n            val x = if (num % 2 == 0) num /\
    \ 2 else num * 3 + 1\n            if (x == 1) list :+ x\n            else helper(x,\
    \ list :+ x)\n        }\n        helper(n, List()).filter(_ % 2 == 1).reverse",
  "        def getOddCollatz0(n : Long, acc : List[Long]) : List[Long] = {\n     \
    \       if (n == 1) acc\n            else if (n % 2 == 0) getOddCollatz0(n / 2,\
    \ acc)\n            else getOddCollatz0(3 * n + 1, n :: acc)\n        }\n    \
    \    getOddCollatz0(n, List[Long]()).sorted", "    \tval collatz = new mutable.ArrayBuffer[Long]()\n\
    \    \tvar i = n\n    \twhile (i != 1) {\n    \t\tcollatz += i\n    \t\tif (i\
    \ % 2 == 0) i /= 2\n    \t\telse i = 3 * i + 1\n    \t}\n    \tcollatz += 1\n\
    \    \tcollatz.filter(_ % 2 == 1).toList", "        require(n > 0)\n        var\
    \ results = ListBuffer[Long]()\n        val seq = Stream.iterate(n)(x => if (x\
    \ % 2 == 0) x / 2 else 3 * x + 1)\n        seq.takeWhile(_ != 1).foreach(x =>\
    \ if (x % 2 == 1) results += x)\n        results += 1\n        results.toList",
  "        var collatz = new ArrayBuffer[Long]()\n        collatz += n\n        var\
    \ num = n\n        while (num != 1) {\n            num = if (num % 2 == 0) num\
    \ / 2 else num * 3 + 1\n            collatz += num\n        }\n        collatz.filter(x\
    \ => x % 2 == 1).toList", "        if (n <= 0) return List()\n        var set\
    \ = List[Long]()\n        var x = n\n        while (x != 1) {\n            if\
    \ (x % 2 == 1) set = x :: set\n            x = if (x % 2 == 0) x / 2 else 3 *\
    \ x + 1\n        }\n        set = 1 :: set\n        set.sorted", "        def\
    \ f(n : Long, res : List[Long]) : List[Long] = {\n            if (n == 1) res.reverse\n\
    \            else if (n % 2 == 0) f(n / 2, res)\n            else f(3 * n + 1,\
    \ n :: res)\n        }\n        f(n, List())", "        val queue = new ListBuffer[Long]()\n\
    \        val oddNums = new ListBuffer[Long]()\n        if (n <= 0) return List[Long]()\n\
    \        queue += n\n        while (!queue.isEmpty) {\n            val curr =\
    \ queue.remove(0)\n            if (curr % 2 == 1) oddNums += curr\n          \
    \  val next = if (curr % 2 == 0) curr / 2 else curr * 3 + 1\n            if (next\
    \ != 1) queue += next\n        }\n        return oddNums.toList", "        val\
    \ collatz = new HashMap[Long, List[Long]]\n        collatz += (1l -> List(1l))\n\
    \        def next(x : Long) : Long = {\n            if (x % 2 == 0) x / 2\n  \
    \          else 3 * x + 1\n        }\n        def listCollatz(x : Long) : List[Long]\
    \ = {\n            if (collatz.contains(x)) collatz(x)\n            else {\n \
    \               val collatzNext = listCollatz(next(x))\n                collatz\
    \ += (x -> (x :: collatzNext))\n                collatz(x)\n            }\n  \
    \      }\n        collatz(n).filter(x => x % 2 == 1)", '        return getOddCollatz(List[Long](n)).reverse',
  "        if (n == 1) List(1)\n        else {\n            var oddList = List[Long]()\n\
    \            var currentNum = n\n            while (currentNum != 1) {\n     \
    \           if (currentNum % 2 == 1) {\n                    oddList = oddList\
    \ :+ currentNum\n                }\n                currentNum = if (currentNum\
    \ % 2 == 0) currentNum / 2 else 3 * currentNum + 1\n            }\n          \
    \  oddList = oddList :+ 1\n            oddList.sorted\n        }", "        def\
    \ recurse(c : Long, m : Long) : Long = {\n            if (c % 2 == 0) recurse(c\
    \ / 2, m)\n            else recurse(3 * c + 1, m + 1)\n        }\n        def\
    \ recurse2(c : Long, l : List[Long]) : List[Long] = {\n            if (c % 2 ==\
    \ 0) recurse2(c / 2, l)\n            else if (c == 1) l\n            else recurse2(3\
    \ * c + 1, c :: l)\n        }\n        recurse2(n, List[Long]())", "        var\
    \ list = List[Long]()\n        var m = n\n        while (m != 1) {\n         \
    \   if (m % 2 == 1) list = list :+ m\n            m = m / 2\n        }\n     \
    \   list = list :+ 1\n        list", "        var l = List[Long]()\n        if\
    \ (n < 1) return l\n        var m = n\n        while (m != 1) {\n            if\
    \ (m % 2 == 1) l = m :: l\n            m = nextCollatz(m)\n        }\n       \
    \ l = 1 :: l\n        l.reverse", "        def getSequence(n : Long) : List[Long]\
    \ = {\n            if (n == 1) List(1)\n            else if (n % 2 == 0) n ::\
    \ getSequence(n / 2)\n            else n :: getSequence(3 * n + 1)\n        }\n\
    \        getSequence(n).filter(_ % 2 == 1)", "        def collatz(n : Long) :\
    \ List[Long] = {\n            val l = new ListBuffer[Long]\n            var a\
    \ = n\n            l += a\n            while (a != 1) {\n                if (a\
    \ % 2 == 0) a = a / 2\n                else a = 3 * a + 1\n                l +=\
    \ a\n            }\n            l.toList\n        }\n        var l = new ListBuffer[Long]\n\
    \        collatz(n).filter(x => x % 2 == 1).distinct.sorted", "        val list\
    \ = ListBuffer[Long]()\n        var m = n\n        list += 1\n        while (m\
    \ != 1) {\n            if (m % 2 == 0) m /= 2\n            else {\n          \
    \      list += m\n                m = 3 * m + 1\n            }\n        }\n  \
    \      list.toList.sorted", "        var result = ListBuffer[Long]()\n       \
    \ var x = n\n        while (x != 1) {\n            if (x % 2 == 1) result += x\n\
    \            x = if (x % 2 == 0) x / 2 else 3 * x + 1\n        }\n        result\
    \ += 1\n        result.toList", "        var set = Set[Long]()\n        var x\
    \ = n\n        while (x != 1) {\n            set += x\n            if (x % 2 ==\
    \ 0) x /= 2\n            else x = 3 * x + 1\n        }\n        set.toList.sorted",
  "        var oddCollatz = new ListBuffer[Long]()\n        val sequence = new ListBuffer[Long]()\n\
    \        var current = n\n        do {\n            sequence += current\n    \
    \        if (current % 2 == 1) {\n                oddCollatz += current\n    \
    \        }\n            current = if (current % 2 == 0) current / 2 else current\
    \ * 3 + 1\n        } while (current != 1)\n        sequence += 1\n        oddCollatz\
    \ += 1\n        oddCollatz.toList", "        def getOddCollatz0(n : Long, m :\
    \ List[Long]) : List[Long] = n match {\n            case 1 => 1 :: m\n       \
    \     case _ => if (n % 2 == 0) getOddCollatz0(n / 2, m) else getOddCollatz0(3\
    \ * n + 1, n :: m)\n        }\n        def removeDuplicates(arr : List[Long])\
    \ : List[Long] = arr match {\n            case Nil => Nil\n            case head\
    \ :: tail => head :: removeDuplicates(tail.filter(_ != head))\n        }\n   \
    \     removeDuplicates(getOddCollatz0(n, Nil)).sorted", "        var l = List[Long]()\n\
    \        var t = n\n        while (t != 1) {\n            l = l :+ t\n       \
    \     if (t % 2 == 0) t = t / 2\n            else t = 3 * t + 1\n        }\n \
    \       l = l :+ 1\n        l.filter(_ % 2 == 1)", "        var dic = new scala.collection.mutable.HashMap[Long,\
    \ List[Long]]()\n        def collatz(n : Long) : List[Long] = {\n            if\
    \ (n == 1) {\n                List(1)\n            } else if (n % 2 == 0) {\n\
    \                n :: collatz(n / 2)\n            } else {\n                n\
    \ :: collatz(3 * n + 1)\n            }\n        }\n        if (n % 2 == 0) collatz(n).filter(x\
    \ => x % 2 == 1)\n        else collatz(n).filter(x => x % 2 == 1)", "        //\
    \ 1. Base case\n        if (n == 1) {\n            List(1l)\n        }\n     \
    \   // 2. Return odd numbers in collatz sequence\n        else {\n           \
    \ var list = List[Long]()\n            var num = n\n            while (num !=\
    \ 1) {\n                if (num % 2 == 1) {\n                    list = list :+\
    \ num\n                }\n                num = if (num % 2 == 0) {\n        \
    \            num / 2\n                }\n                else {\n            \
    \        3 * num + 1\n                }\n            }\n            list.reverse\n\
    \        }", "        var oddList = new ListBuffer[Long]\n        if (n == 1)\
    \ return 1l :: Nil\n        var current_num = n\n        while (current_num !=\
    \ 1) {\n            if (current_num % 2 == 1) {\n                oddList += current_num\n\
    \            }\n            current_num = if (current_num % 2 == 0) current_num\
    \ / 2 else current_num * 3 + 1\n        }\n        return oddList.toList.sortWith(_\
    \ < _)", "        // 1st implementation - it uses a mutable list. And is correct\
    \ only if we order the odd numbers\n        // correctly.\n        // TODO: a\
    \ = a - 1; if(a % 2 == 0) { a = a / 2; } else { a = 3 * a + 1; }\n        def\
    \ getOddCollatzRec(a : Long, sofar : ListBuffer[Long]) : List[Long] = {\n    \
    \        if(a == 1) {\n                return sofar.toList;\n            }\n \
    \           else {\n                if(a % 2 == 0) {\n                    getOddCollatzRec(a\
    \ / 2, sofar)\n                }\n                else {\n                   \
    \ sofar += a;\n                    getOddCollatzRec(3 * a + 1, sofar)\n      \
    \          }\n            }\n        }\n        getOddCollatzRec(n, ListBuffer[Long]())",
  "        if (n == 1) return List(1)\n        var collatz = List[Long]()\n      \
    \  var m = n\n        while (m != 1) {\n            collatz = m :: collatz\n \
    \           if (m % 2 == 0) m = m / 2\n            else m = 3 * m + 1\n      \
    \  }\n        collatz = 1 :: collatz\n        var odd_collatz = List[Long]()\n\
    \        for (i <- collatz) {\n            if (i % 2 == 1) odd_collatz = i ::\
    \ odd_collatz\n        }\n        odd_collatz.sortWith(_ < _)", "        val list\
    \ = ListBuffer[Long]()\n        var i = n\n        while (i != 1) {\n        \
    \    list += i\n            if (i % 2 == 0) i /= 2\n            else i = 3 * i\
    \ + 1\n        }\n        list += 1\n        return list.filter(_ % 2 == 1).toList",
  "        var nn = n\n        var lst = new ListBuffer[Long]()\n        while (nn\
    \ != 1) {\n            if (nn % 2 == 1) {\n                lst += nn\n       \
    \     }\n            nn = if (nn % 2 == 0) nn / 2 else 3 * nn + 1\n        }\n\
    \        return lst.toList", "        var current = n\n        var result = List[Long]()\n\
    \        while (current != 1) {\n            result = result :+ current\n    \
    \        if (current % 2 == 0) current /= 2\n            else current = current\
    \ * 3 + 1\n        }\n        result = result :+ 1\n        result = result.filter(x\
    \ => x % 2 == 1)\n        result.sorted", "        var odd = List[Long]()\n  \
    \      def collatz(n : Long) : Long = if (n == 1) 1 else if (n % 2 == 0) collatz(n\
    \ / 2) else collatz(3 * n + 1)\n        for (i <- 1 to n.toInt) if (collatz(i)\
    \ % 2 == 1) odd = odd :+ i\n        odd", "        var list = List[Long]()\n \
    \       if (n == 1) {\n            list :+ 1\n        } else {\n            var\
    \ input = n\n            while (input != 1) {\n                if (input % 2 ==\
    \ 0) {\n                    input = input / 2\n                } else {\n    \
    \                input = 3 * input + 1\n                    list :+ input\n  \
    \              }\n            }\n            list :+ 1\n        }", "        if\
    \ (n == 1) return List(1)\n        val collatz = ArrayBuffer[Long]()\n       \
    \ var current : Long = n\n        collatz += current\n        while (current !=\
    \ 1) {\n            if (current % 2 == 0) current /= 2\n            else current\
    \ = 3 * current + 1\n            collatz += current\n        }\n        val result\
    \ = ListBuffer[Long]()\n        collatz.foreach {x => if (x % 2 == 1) result +=\
    \ x}\n        result.toList", "        require(n > 0)\n        var list = ListBuffer[Long]()\n\
    \        var m = n\n        while (m != 1) {\n            list += m\n        \
    \    if (m % 2 == 0) m /= 2\n            else m = 3 * m + 1\n        }\n     \
    \   list += 1\n        list.filter(_ % 2 == 1).toList", "        val odd = new\
    \ ListBuffer[Long]\n        var x = n\n        while (x != 1) {\n            odd\
    \ += x\n            x = if (x % 2 == 0) x / 2 else 3 * x + 1\n        }\n    \
    \    odd += 1\n        odd.toList", "        if (n <= 0) return Nil\n        var\
    \ collatzList = new ListBuffer[Long]\n        collatzList += n\n        var x\
    \ = n\n        while (x != 1) {\n            collatzList += (x / 2)\n        \
    \    x = x / 2\n        }\n        val oddList = new ListBuffer[Long]\n      \
    \  for (i <- collatzList.indices) {\n            if (collatzList(i) % 2 == 1)\
    \ oddList += collatzList(i)\n        }\n        return oddList.toList", "    \
    \    // O(n)\n        def collatzOdd(n : Long, result : List[Long]) : List[Long]\
    \ = {\n            if (n == 1) result\n            else {\n                if\
    \ (n % 2 == 0) collatzOdd(n / 2, result)\n                else collatzOdd(3 *\
    \ n + 1, n :: result)\n            }\n        }\n        collatzOdd(n, List[Long]()).reverse",
  "        var list = new ListBuffer[Long]()\n        var x = n\n        while (x\
    \ != 1) {\n            if (x % 2 == 1) list += x\n            x = if (x % 2 ==\
    \ 0) x / 2 else 3 * x + 1\n        }\n        list += 1\n        list.toList",
  "        var result = List[Long]()\n        var number = n\n        while (number\
    \ != 1) {\n            if (number % 2 == 1) result = result :+ number\n      \
    \      number = if (number % 2 == 0) number / 2 else 3 * number + 1\n        }\n\
    \        result = result :+ 1\n        result", "        var currentNumber = n\n\
    \        var oddCollatzNumbers = List[Long]()\n        while (currentNumber !=\
    \ 1) {\n            if (currentNumber % 2 == 1) {\n                oddCollatzNumbers\
    \ = oddCollatzNumbers :+ currentNumber\n            }\n            currentNumber\
    \ = currentNumber / 2\n        }\n        oddCollatzNumbers = oddCollatzNumbers\
    \ :+ 1\n        oddCollatzNumbers.sorted", "        var collatzList = List[Long]()\n\
    \        var collatzQueue = Queue[Long]()\n        collatzQueue.enqueue(n)\n \
    \       while (!collatzQueue.isEmpty) {\n            var value = collatzQueue.dequeue\n\
    \            if (value == 1) {\n                collatzList = collatzList :+ value\n\
    \            } else {\n                if (value % 2 == 1) {\n               \
    \     collatzList = collatzList :+ value\n                    collatzQueue.enqueue(value\
    \ * 3 + 1)\n                } else {\n                    collatzQueue.enqueue(value\
    \ / 2)\n                }\n            }\n        }\n        collatzList.sorted",
  "        def helper(i : Long, l : List[Long]) : List[Long] = {\n            if (i\
    \ == 1) {\n                l\n            } else {\n                if (i % 2\
    \ == 0) helper(i / 2, l)\n                else helper(3 * i + 1, i :: l)\n   \
    \         }\n        }\n        if (n == 1) List(1)\n        else {\n        \
    \    val l = helper(n, List())\n            // remove duplicates\n           \
    \ var result = new ListBuffer[Long]()\n            result += l.head\n        \
    \    for (i <- 1 until l.length) {\n                if (l(i) != l(i - 1)) result\
    \ += l(i)\n            }\n            result.toList\n        }", "        var\
    \ collatz = List[Long]()\n        if (n == 1) {\n            collatz = 1 :: collatz\n\
    \        } else {\n            while (n != 1) {\n                if (n % 2 ==\
    \ 0) {\n                    n = n / 2\n                } else {\n            \
    \        n = 3 * n + 1\n                }\n                if (n % 2 != 0) {\n\
    \                    collatz = n :: collatz\n                }\n            }\n\
    \        }\n        collatz.reverse", "        // start with n\n        // if\
    \ n is even, divide by 2\n        // if n is odd, multiply by 3 and add 1\n  \
    \      // Stop when n is 1.\n        var result = new ListBuffer[Long]\n     \
    \   var num = n\n        while (num != 1) {\n            if (num % 2 == 1) {\n\
    \                // odd\n                result += num\n                num =\
    \ num * 3 + 1\n            } else {\n                // even\n               \
    \ num = num / 2\n            }\n        }\n        // add 1\n        result +=\
    \ 1\n        result.toList", "        // Iterative\n        if (n <= 0) return\
    \ Nil\n        if (n == 1) return List(1)\n        var current : Long = n\n  \
    \      var list : List[Long] = Nil\n        while (current != 1) {\n         \
    \   if (current % 2 == 1) list = current :: list\n            current = (if (current\
    \ % 2 == 0) current / 2 else current * 3 + 1)\n        }\n        return (1 ::\
    \ list).reverse\n        // Recursive\n        // if (n <= 0) return Nil\n   \
    \     // if (n == 1) return List(1)\n        // var current : Long = n\n     \
    \   // var list : List[Long] = Nil\n        // while (current != 1) {\n      \
    \  //     if (current % 2 == 1) list = current :: list\n        //     current\
    \ = (if (current % 2 == 0) current / 2 else current * 3 + 1)\n        // }\n \
    \       // return (1 :: list).reverse", "      var x = n\n      var list = List[Long]()\n\
    \      while (x != 1) {\n        if (x % 2 == 1) list = list :+ x\n        if\
    \ (x % 2 == 0) x = x / 2\n        else x = 3 * x + 1\n      }\n      list = list\
    \ :+ 1\n      list", "      def getOddCollatzImp(n : Long, cur : Long, acc : List[Long])\
    \ : List[Long] = {\n        if (cur == 1) {\n          return acc\n        }\n\
    \        if (cur % 2 == 1) {\n          val new_acc = cur :: acc\n          return\
    \ getOddCollatzImp(n, 3 * cur + 1, new_acc)\n        }\n        getOddCollatzImp(n,\
    \ cur / 2, acc)\n      }\n      val acc = List[Long]()\n      getOddCollatzImp(n,\
    \ n, acc)", "        var result = List[Long]()\n        var num = n\n        while\
    \ (num != 1) {\n            if (num % 2 == 1) result = num :: result\n       \
    \     num = if (num % 2 == 0) num / 2 else 3 * num + 1\n        }\n        result\
    \ = 1 :: result\n        result", "        var c : Long = n\n        var oddCollatz\
    \ : HashSet[Long] = HashSet.empty[Long]\n        while (c != 1) {\n          \
    \  if (c % 2 == 1) {\n                oddCollatz += c\n            }\n       \
    \     c = if (c % 2 == 0) {\n                c / 2\n            } else {\n   \
    \             c * 3 + 1\n            }\n        }\n        oddCollatz.toList.sorted",
  "        var list = new ArrayBuffer[Long]\n        var curr = n\n        while (curr\
    \ != 1) {\n            list += curr\n            if (curr % 2 == 0) curr /= 2\n\
    \            else curr = 3 * curr + 1\n        }\n        list += 1\n        list.filter(x\
    \ => x % 2 == 1).toList", "        if (n == 1) return List(1)\n        val sequence\
    \ = collatz(n)\n        var result = new ListBuffer[Long]\n        for (i <- sequence)\
    \ if (i % 2 == 1) result += i\n        result.toList", "        // If n = 0, return\
    \ List[Long]().\n        if (n == 0) return List[Long]()\n        // If n = 1,\
    \ return List[Long](1).\n        if (n == 1) return List[Long](1)\n        //\
    \ If n = 2, return List[Long](1).\n        if (n == 2) return List[Long](1)\n\
    \        // If n is even, the collatz sequence is (n)\n        // If n is odd,\
    \ the collatz sequence is (n, 3 * n + 1, n / 2).\n        // If n is odd, the\
    \ odds are (n, n / 2).\n        val s = new Stack[Long]()\n        s.push(n)\n\
    \        while (s.top != 1) {\n            if (s.top % 2 == 0) s.push(s.top /\
    \ 2)\n            else s.push(3 * s.top + 1)\n        }\n        // Now we have\
    \ the stack containing all the numbers in collatz sequence.\n        // Get all\
    \ the odd numbers by popping the odd numbers.\n        val oddList = new ListBuffer[Long]()\n\
    \        while (!s.isEmpty) {\n            val n = s.pop\n            if (n %\
    \ 2 == 1) oddList += n\n        }\n        oddList.toList", "        val L = new\
    \ ListBuffer[Long]()\n        var m = n\n        while (m != 1) {\n          \
    \  if (m % 2 == 1) {\n                L += m\n            }\n            m = (if\
    \ (m % 2 == 0) m / 2 else 3 * m + 1)\n        }\n        L += 1\n        L.toList",
  "        var hash = HashMap[Long, Boolean]()\n        hash += (1l -> true)\n   \
    \     var collatz = List[Long](1l)\n        var i = 1l\n        while (i < n)\
    \ {\n            var number = i\n            var last_odd = i\n            while\
    \ (number != 1) {\n                if (number % 2 == 0) number /= 2\n        \
    \        else {\n                    number = 3 * number + 1\n               \
    \     if (number <= n) {\n                        hash += (number -> true)\n \
    \                       last_odd = number\n                    }\n           \
    \     }\n            }\n            i += 1\n        }\n        hash.keySet.toList.sorted",
  "      var counter = n\n      var numbers = List[Long]()\n      while (counter !=\
    \ 1) {\n        if (counter % 2 == 1) {\n          numbers = counter :: numbers\n\
    \        }\n        counter = if (counter % 2 == 0) counter / 2 else counter *\
    \ 3 + 1\n      }\n      numbers.reverse", "        // Returns all numbers in Collatz\
    \ sequence starting from n, until it reaches 1.\n        def collatz(n : Long)\
    \ : List[Long] = {\n            var sequence = List[Long]()\n            var m\
    \ = n\n            while (m != 1) {\n                sequence = m :: sequence\n\
    \                if (m % 2 == 0) {\n                    m = m / 2\n          \
    \      } else {\n                    m = m * 3 + 1\n                }\n      \
    \      }\n            sequence = 1l :: sequence\n            sequence\n      \
    \  }\n        collatz(n).filter(e => e % 2 == 1)", "        var res = List[Long]()\n\
    \        var c = n\n        res = res :+ c\n        var prev = c\n        do {\n\
    \            c = if (c % 2 == 0) c / 2 else c * 3 + 1\n            if (c % 2 ==\
    \ 1) {\n                res = res :+ c\n                prev = c\n           \
    \ }\n        } while (c != 1)\n        return res", "    \tvar seq = List[Long]()\n\
    \    \tvar last = n\n    \twhile (last != 1) {\n    \t\tif (last % 2 == 1) seq\
    \ = last :: seq\n    \t\tlast = if (last % 2 == 0) last / 2 else last * 3 + 1\n\
    \    \t}\n    \tseq.reverse", "        val oddCollatz = ListBuffer[Long]()\n \
    \       def getOddCollatz(n : Long) : Unit = {\n            if (n == 1) {\n  \
    \              oddCollatz += 1\n            } else {\n                oddCollatz\
    \ += n\n                if (n % 2 == 0) {\n                    getOddCollatz(n\
    \ / 2)\n                } else {\n                    getOddCollatz(3 * n + 1)\n\
    \                }\n            }\n        }\n        getOddCollatz(n)\n     \
    \   oddCollatz.toList", "      var result = List[Long]()\n      var temp = n\n\
    \      while (temp != 1) {\n        if (temp % 2 == 1) {\n          result = result\
    \ :+ temp\n        }\n        temp = if (temp % 2 == 0) temp / 2 else 3 * temp\
    \ + 1\n      }\n      result = result :+ 1\n      result", "        var even =\
    \ true\n        var collatz = new ListBuffer[Long]()\n        var current = n\n\
    \        while (current != 1) {\n            if (even) {\n                current\
    \ = current / 2\n                even = false\n            } else {\n        \
    \        collatz += current\n                current = 3 * current + 1\n     \
    \           even = true\n            }\n        }\n        collatz += 1\n    \
    \    collatz.toList.sorted", "        val oddList = ListBuffer[Long]()\n     \
    \   val queue = Queue[Long]()\n        queue.enqueue(n)\n        while (!queue.isEmpty)\
    \ {\n            val a = queue.dequeue\n            if (a % 2 == 1) {\n      \
    \          oddList += a\n            }\n            val b = a * 3 + 1\n      \
    \      if (b > 1) queue.enqueue(b)\n            if (a % 2 == 0) {\n          \
    \      val c = a / 2\n                if (c > 1) queue.enqueue(c)\n          \
    \  }\n        }\n        oddList.toList.sortWith(_ < _)", "        if (n == 1)\
    \ List(1)\n        else if (n % 2 == 0) getOddCollatz(n / 2)\n        else List(n)\
    \ ::: getOddCollatz(3 * n + 1)", "        var lst = new ListBuffer[Long]()\n \
    \       if (n <= 0) return lst.toList\n        var cur = n\n        while (cur\
    \ != 1) {\n            if (cur % 2 == 1) lst += cur\n            cur = collatz(cur)\n\
    \        }\n        lst += 1\n        lst.toList", "        if (n == 1) return\
    \ List(1)\n        val oddNumberList = ListBuffer[Long]()\n        val queue =\
    \ new Queue[Long]()\n        queue.enqueue(n)\n        while (!queue.isEmpty)\
    \ {\n            val nextNumber = queue.dequeue\n            if (nextNumber %\
    \ 2 == 1) {\n                oddNumberList += nextNumber\n                queue.enqueue(nextNumber\
    \ * 3 + 1)\n            }\n            if (nextNumber % 2 == 0) {\n          \
    \      queue.enqueue(nextNumber / 2)\n            }\n        }\n        oddNumberList.toList.sorted",
  "        def helper(n : Long, acc : List[Long]) : List[Long] = {\n        \tif (n\
    \ == 1) {\n        \t\treturn 1 :: acc\n        \t}\n        \telse if (n % 2\
    \ == 0) {\n        \t\thelper(n / 2, acc)\n        \t}\n        \telse {\n   \
    \     \t\thelper(3 * n + 1, n :: acc)\n        \t}\n        }\n        helper(n,\
    \ Nil).reverse", "    \tval stack = Stack[Long]()\n    \tvar num = n\n    \twhile\
    \ (num != 1) {\n    \t\tif (num % 2 == 1) {\n    \t\t\tstack.push(num)\n    \t\
    \t}\n    \t\tnum = if (num % 2 == 0) {\n    \t\t\tnum / 2\n    \t\t} else {\n\
    \    \t\t\tnum * 3 + 1\n    \t\t}\n    \t}\n    \tstack.toList.sorted", "    \
    \    val lst = new ListBuffer[Long]\n        var n2 = n\n        while (n2 !=\
    \ 1) {\n            if (n2 % 2 == 1) {\n                lst += n2\n          \
    \  }\n            n2 = if (n2 % 2 == 0) n2 / 2 else 3 * n2 + 1\n        }\n  \
    \      lst += 1\n        lst.toList.sorted"]
stop_tokens:
- "\n    }\n"
