name: HumanEval_85_add
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a non-empty list of integers lst. add the even elements that are at\
  \ odd indices..\n    // Examples:\n    // >>> add((List[Long](4l.toLong, 2l.toLong,\
  \ 6l.toLong, 7l.toLong)))\n    // (2l)\n    def add(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(add((List[Long](4l.toLong,\
  \ 88l.toLong))) == (88l));\n    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));\n    assert(add((List[Long](4l.toLong,\
  \ 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));\n    assert(add((List[Long](4l.toLong,\
  \ 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));\n    }\n\n}\n"
completions: ['        lst.zipWithIndex.foldLeft(0l)((a, b) => if (b._2 % 2 == 1)
    a + b._1 else a)', "        val a = for {i <- 0 until lst.length if i % 2 == 1}\
    \ yield lst(i)\n        a.sum", '        lst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).sum',
  "        // Fill up this function body\n        // '0' denotes an empty list (scala\
    \ representation for an empty list)\n        val lst_even = lst.zipWithIndex.filter(x\
    \ => (x._2 % 2 == 1) && (x._1 % 2 == 0)).map(x => x._1)\n        lst_even.sum",
  "        var ans = 0l\n        for (i <- 0 until lst.length) {\n            if (i\
    \ % 2 == 1 && lst(i) % 2 == 0) ans += lst(i)\n        }\n        ans", '        return
    lst.zipWithIndex.filter(x => (x._2 % 2) == 1).map(x => x._1).sum', '        lst.zipWithIndex.map(x
    => if (x._2 % 2 == 1) x._1 else 0l).sum', "        if (lst.length == 0) return\
    \ 0\n        if (lst.length == 1) return 0\n        lst(1) + add(lst.drop(2))",
  '        lst.zipWithIndex.map(x => x._1).filter(x => x % 2 == 0).reduceLeft(_ +
    _)', '        return 0l', "        val result : Long = 0\n        for (i <- 0\
    \ until lst.length) {\n            if (i % 2 == 1) {\n                if (lst(i)\
    \ % 2 == 0) {\n                    result + lst(i)\n                }\n      \
    \      }\n        }\n        return result", "        if (lst.length < 2) return\
    \ 0l\n        else if (lst.length == 2) {\n            if (lst(0) % 2 == 0) return\
    \ lst(0)\n            else return 0l\n        }\n        else {\n            var\
    \ sum = 0l\n            for (i <- 1 until lst.length by 2) {\n               \
    \ if (lst(i) % 2 == 0) sum += lst(i)\n            }\n            return sum\n\
    \        }", '        lst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).sum', " \
    \       var sum = 0l\n        for (i <- lst.indices if i % 2 == 1) sum += lst(i)\n\
    \        sum", "        var sum = 0l\n        lst.zipWithIndex.foreach {case (a,\
    \ i) => if (i % 2 == 1) sum += a}\n        sum", '        lst.zipWithIndex.filter(t
    => t._2 % 2 == 1).map(t => t._1).sum', '        return lst.zipWithIndex.filter(x
    => x._2 % 2 == 1).map(x => x._1).filter(x => x % 2 == 0).sum', '        return
    lst.zipWithIndex.filter{case (num, index) => num % 2 == 0 && index % 2 == 1}.map{case
    (num, index) => num}.sum', '        (lst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).sum)',
  "        var result : Long = 0\n        for (i <- 0 until lst.length) {\n      \
    \      if (i % 2 == 1 && lst(i) % 2 == 0) {\n                result += lst(i)\n\
    \            }\n        }\n        return result", "        // Fill in the code\
    \ here\n        return 0l;", '        lst.zipWithIndex.filter(p => (p._2 + 1)
    % 2 == 0).map(p => p._1).sum', "\tlst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).filter(_\
    \ % 2 == 0).reduceLeft(_ + _)", "      def inner(lst : List[Long], sum : Long)\
    \ : Long = lst match {\n        case Nil => sum\n        case hd :: Nil => sum\n\
    \        case hd :: tail => inner(tail, if (hd % 2 == 0) sum + hd else sum)\n\
    \      }\n      inner(lst, 0)", "        var result = 0l\n        for (i <- 0\
    \ until lst.length) {\n            if (i % 2 == 1 && lst(i) % 2 == 0) result +=\
    \ lst(i)\n        }\n        result", "\tif (lst.length == 0) return 0\n\tvar\
    \ sum = 0l\n\tfor (i <- 0 until lst.length) if (i % 2 == 1) sum += lst(i)\n\t\
    sum", "\t\tlst.zipWithIndex.foldLeft(0l)((x, y) => if (y._2 % 2 == 1) x + y._1\
    \ else x)", '        lst.zipWithIndex.filter(x => x._2 % 2 == 1).map(x => x._1).sum',
  "        var sum : Long = 0\n        for (i <- 0 until lst.length) {\n         \
    \   if (i % 2 == 1 && lst(i) % 2 == 0) {\n                sum += lst(i)\n    \
    \        }\n        }\n        return sum", "        var i = 0\n        var sum\
    \ = 0\n        while (i < lst.length) {\n            if (i % 2 == 1) {\n     \
    \           sum += lst(i)\n            }\n            i += 1\n        }\n    \
    \    return sum", '        lst.indices.filter(i => i % 2 == 1).map(lst(_)).sum',
  '        lst.foldLeft(0l)((a,b) => a + (if (b % 2 == 0) b else 0))', "        //\
    \ Start with \"0\"\n        var sum : Long = 0\n        // Iterate over the list.\n\
    \        for (i <- 0 until lst.length) {\n            if (i % 2 == 1 && lst(i)\
    \ % 2 == 0) {\n                sum += lst(i)\n            }\n        }\n     \
    \   // Return the final value\n        return sum", "        var sum = 0l\n  \
    \      for (i <- 1 until lst.length by 2) {\n            if (lst(i) % 2 == 0)\
    \ {\n                sum += lst(i)\n            }\n        }\n        return sum",
  '      return 0', "        //return lst.map(_ % 2).zipWithIndex.filter(_._1 % 2\
    \ == 0).map(_._2).sum\n        return lst.map(_ % 2).zipWithIndex.filter(_._1\
    \ == 0).map(_._2).sum", '        // your code here', "        def addHelper(lst\
    \ : List[Long], sum : Long, addFlag : Boolean) : Long = {\n            if (lst.isEmpty)\
    \ sum\n            else if (addFlag && lst.head % 2 == 0) addHelper(lst.tail,\
    \ sum + lst.head, !addFlag)\n            else addHelper(lst.tail, sum, !addFlag)\n\
    \        }\n        addHelper(lst, 0, true)", "        var sum : Long = 0\n  \
    \      for (i <- 1 until lst.length by 2) {\n            if (lst(i) % 2 == 0)\
    \ {\n                sum += lst(i)\n            }\n        }\n        return sum",
  '        return lst.zipWithIndex.filter(e => e._2 % 2 == 1).map(e => e._1).sum',
  "        var sum = 0l\n        for (i <- 0 until lst.length) if (i % 2 == 1) sum\
    \ += lst(i)\n        sum", "        var sum : Long = 0\n        for (i <- 0 until\
    \ lst.length) {\n            if (i % 2 == 1 && lst(i) % 2 == 0) {\n          \
    \      sum += lst(i)\n            }\n        }\n        return sum", "       \
    \ if (lst.length == 0) 0\n        else if (lst.length == 1) {\n            if\
    \ (lst(0) % 2 == 0) lst(0)\n            else 0\n        }\n        else if (lst.length\
    \ == 2) {\n            if (lst(1) % 2 == 0) lst(1)\n            else 0\n     \
    \   }\n        else lst(0) + add(lst.slice(2, lst.length))", '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 1).map(x => x._1).sum', "        var sum = 0l\n        for (i <-\
    \ 0 until lst.length) {\n            if (i % 2 == 1 && lst(i) % 2 == 0) {\n  \
    \              sum += lst(i)\n            }\n        }\n        return sum", " \
    \       var sum : Long = 0l\n        for (i <- 0 until lst.length) {\n       \
    \     if (i % 2 == 1 && lst(i) % 2 == 0) {\n                sum += lst(i)\n  \
    \          }\n        }\n        return sum", "        var sum = 0l;\n       \
    \ for (e <- lst) {\n            if (lst.indexOf(e) % 2 == 1) {\n             \
    \   sum += e;\n            }\n        }\n        return sum;", "        // None\
    \ of the standard solutions will work in addition because the common element\n\
    \        // in the list is Long, not Int. Also, we need to iterate over the list\
    \ and collect\n        // the even numbers whose indices are odd.\n        //\n\
    \        // We can use a for-comprehension (or the equivalent foreach loop) to\
    \ iterate over \n        // the list. If we want to keep track of the indices,\
    \ we can use the zipWithIndex\n        // method on the list.\n        //\n  \
    \      //def add(lst : List[Long]) : Long = {\n        //    var sum = 0l\n  \
    \      //    for ((v, i) <- lst.zipWithIndex if i % 2 == 1 && v % 2 == 0) {\n\
    \        //        sum += v\n        //    }\n        //    sum\n        //}\n\
    \        //\n        // But, this has a problem. \"sum\" is a mutable variable.\
    \ We cannot use it on the\n        // site. Fortunately, we can use the foldLeft\
    \ function (or foldRight), to pass\n        // the accumulator along.\n      \
    \  //\n        //def add(lst : List[Long]) : Long = {\n        //    lst.zipWithIndex.foldLeft(0l)\
    \ { case (acc, (v, i)) =>\n        //        if (i % 2 == 1 && v % 2 == 0) acc\
    \ + v else acc\n        //    }\n        //}\n        //\n        // foldLeft\
    \ and foldRight are powerful, but they are not the most efficient. They\n    \
    \    // can easily run into StackOverflows. We can use \"while\" to iterate over\
    \ the\n        // list and get the result.\n        var i = 0\n        var sum\
    \ = 0l\n        while (i < lst.length) {\n            val v = lst(i)\n       \
    \     if (i % 2 == 1 && v % 2 == 0) sum += v\n            i += 1\n        }\n\
    \        sum", '        lst.zipWithIndex.filter(_._2 % 2 == 1).filter(_._1 % 2
    == 0).map(_._1).sum', "        var res = 0l\n        for (i <- lst.indices) {\n\
    \            if (i % 2 == 1 && lst(i) % 2 == 0) res += lst(i)\n        }\n   \
    \     res", '        lst.zipWithIndex.filter(e => e._2 % 2 == 1).map(e => e._1).filter(e
    => e % 2 == 0).sum', '        return lst.zipWithIndex.filter(x => x._2 % 2 ==
    1).map(x => x._1).filter(x => x % 2 == 0).sum', '        return lst.zipWithIndex.filter(x
    => x._2 % 2 == 1).map(x => x._1).sum', '        lst.zipWithIndex.filter( { case
    (x, i) => i % 2 == 1 } ).map( { case (x, i) => x } ).sum', '        lst.filter((i:
    Long) => i % 2 == 0).filter((i: Long) => lst.indexOf(i) % 2 == 1).sum', "    \
    \    var sum = 0l\n        for (i <- 0 until lst.length) if (i % 2 == 1) sum +=\
    \ lst(i)\n        sum", "        // Recursive solution\n        lst match {\n\
    \            case Nil => 0\n            case x :: xs => if (x % 2 == 0) x + add(xs.tail)\
    \ else add(xs.tail)\n        }", '        lst.zipWithIndex.filter(x => x._2 %
    2 == 1).map(x => x._1).sum', "        var result : Long = 0l\n        var index\
    \ : Int = 0\n        for (i <- lst) {\n            if (index % 2 == 1 && i % 2\
    \ == 0) {\n                result += i\n            }\n            index += 1\n\
    \        }\n        return result", "\t\tif (lst.length % 2 == 0) {\n\t\t\tlst.zipWithIndex.filter(x\
    \ => x._2 % 2 == 1).map(x => x._1).sum\n\t\t} else {\n\t\t\tlst.zipWithIndex.filter(x\
    \ => x._2 % 2 == 0).map(x => x._1).sum\n\t\t}", "        def sum(k : Int, sum\
    \ : Long) : Long = {\n            if (k == lst.length) sum\n            else if\
    \ (k % 2 == 0) sum(k + 1, sum + lst(k))\n            else sum(k + 1, sum)\n  \
    \      }\n        sum(0, 0)", '        lst.zipWithIndex.filter( (pair) => pair._2
    % 2 == 1 && pair._1 % 2 == 0).map(_._1).sum', "        var sum : Long = 0l\n \
    \       for (i <- lst.indices if (i % 2 == 1)) {\n            sum += lst(i)\n\
    \        }\n        return sum", "        def loop(lst : List[Long], ind : Int,\
    \ acc : Long) : Long = lst match {\n            case Nil => acc\n            case\
    \ (x :: xs) => {\n                if (ind % 2 == 1) loop(xs, ind + 1, acc + x)\n\
    \                else loop(xs, ind + 1, acc)\n            }\n        }\n     \
    \   loop(lst, 0, 0)", '        lst.zipWithIndex.map(x => if (x._2 % 2 == 1) x._1
    else 0).sum', '        lst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).sum',
  "        var sum : Long = 0\n        for (i <- 0 until lst.length) {\n         \
    \   if (i % 2 == 1) {\n                sum += lst(i)\n            }\n        }\n\
    \        return sum", '        return lst.zipWithIndex.foldLeft(0L)((a, b) =>
    {if (b._2 % 2 == 1) return a + b._1 else return a})', "\t    var index = 1\n\t\
    \    var sum = 0l\n\t    for (n <- lst) {\n\t        if (index % 2 == 1) sum +=\
    \ n\n\t        index += 1\n\t    }\n\t    sum", '        lst.zipWithIndex.filter({case
    (x,y) => y % 2 == 1}).filter({case (x,y) => x % 2 == 0}).map({case (x,y) => x}).sum',
  '        lst.zipWithIndex.map(x => if (x._2 % 2 == 1) x._1 else 0l).sum', "    \
    \    var sum : Long = 0l\n        var count : Int = 0\n        for (i <- lst)\
    \ {\n            if (count % 2 == 1) {\n                sum += i\n           \
    \ }\n            count += 1\n        }\n        return sum", "        var ans\
    \ = 0l;\n        for (i <- 0 until lst.length) {\n            if (i % 2 == 1 &&\
    \ lst(i) % 2 == 0) {\n                ans += lst(i);\n            }\n        }\n\
    \        return ans;", '        return lst.zipWithIndex.filter(i => i._2 % 2 ==
    1).filter(i => i._1 % 2 == 0).foldLeft(0l)((r, c) => r + c._1)', '        lst.zipWithIndex.filter(p
    => p._2 % 2 == 1).map(x => x._1).foldLeft(0l)(_ + _)', "        // lst.filter(x\
    \ => x % 2 == 0).sum\n        lst.foldLeft(0l.toLong){(acc, x) => if (x % 2 ==\
    \ 0) acc + x else acc}", "        var x = 0.toLong\n        for (i <- 0 until\
    \ lst.length) {\n            if (i % 2 == 1) {\n                if (lst(i) % 2\
    \ == 0) {\n                    x += lst(i)\n                }\n            }\n\
    \        }\n        return x", "        lst.zipWithIndex.foldLeft(0l)((acc, pair)\
    \ => pair match {\n            case (x, y) => if (y % 2 == 1) acc + x else acc\n\
    \        })", '        return lst.indices.filter(x => x % 2 == 1).map(x => lst(x)).filter(x
    => x % 2 == 0).sum', "        var sum : Long = 0\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 2 == 1) sum += lst(i)\n        }\n        return sum",
  '        lst.zipWithIndex.map(x => (x._1, x._2 % 2)).filter(x => x._2 == 0).map(x
    => x._1).sum', "        var acc : Long = 0\n        for (i <- 0 until lst.length\
    \ by 2) {\n            acc += lst(i)\n        }\n        return acc", "      \
    \  var sum = 0l\n        for (i <- 1 until lst.length by 2) {\n            sum\
    \ += lst(i)\n        }\n        return sum", '        return lst.zipWithIndex.map(x
    => if (x._2 % 2 == 1) x._1 else 0).sum', "        // Write your code here\n  \
    \      var s : Long = 0\n        for (i <- 0 until lst.length) {\n           \
    \ if (i % 2 == 1) s += lst(i)\n        }\n        s", '        lst.zipWithIndex.map(x
    => if (x._2 % 2 == 1) x._1 else 0).sum', '        lst.filter((x, i) => i % 2 ==
    1).filter(_ % 2 == 0).sum', '        lst.zipWithIndex.map(x => if (x._2 % 2 ==
    1) x._1 else 0).sum', "        val idx = lst.indices.map(i => (i + 1) % 2 == 0)\n\
    \        val even = lst.filter(x => x % 2 == 0)\n        val result = for {i <-\
    \ idx; j <- even} yield ((i, j))\n        result.filter(t => t._1).map(t => t._2).sum",
  '        return lst.filter((x : Long) => {x % 2 == 0}).reduce((x : Long, y : Long)
    => {x + y})', "        var sum = 0L\n        for (i <- 1 until lst.length by 2)\
    \ {\n            if (lst(i) % 2 == 0) {\n                sum += lst(i)\n     \
    \       }\n        }\n        return sum", "        // Fill up this function body\n\
    \        // `0` is the code for an anonymous function that takes an argument x\
    \ and returns 0.\n        lst.filter((x) => (x % 2) == 0).reduceLeft(_ + _)",
  "        var res : Long = 0l\n        for (i <- 0 until lst.length by 2) {\n   \
    \         res += lst(i)\n        }\n        return res", "        if (lst.length\
    \ == 0) return 0l\n        var sum = 0l\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 2 == 1 && lst(i) % 2 == 0) {\n                sum +=\
    \ lst(i)\n            }\n        }\n        return sum", "        def addHelper(lst\
    \ : List[Long], n : Long) : Long = {\n            lst match {\n              \
    \  case Nil => n\n                case head :: tail => addHelper(tail, n + head)\n\
    \            }\n        }\n        addHelper(lst.zipWithIndex.filter(t => t._2\
    \ % 2 == 1 && t._1 % 2 == 0).map(t => t._1), 0)", '        return lst.zipWithIndex.filter{case(x,
    y) => y % 2 == 1}.map{_._1}.sum', "        var sum : Long = 0\n        for (i\
    \ <- 1 until lst.length by 2) {\n            if (lst(i) % 2 == 0) sum += lst(i)\n\
    \        }\n        return sum", "        var sum : Long = 0l\n        for (i\
    \ <- 0 until lst.length) {\n            if (i % 2 == 1 && lst(i) % 2 == 0) sum\
    \ += lst(i)\n        }\n        return sum", '        return 0l', "        val\
    \ l = lst.length\n        var sum = 0l\n        for (i <- (0 to l-1)) {\n    \
    \        if (i % 2 == 1) sum += lst(i)\n        }\n        return sum", '        lst.zipWithIndex.filter({case
    (x, y) => (y + 1) % 2 == 0}).filter({case (x, y) => x % 2 == 0}).map(_._1).sum',
  "        var ret : Long = 0l\n        for(i <- 0 until lst.length) {\n         \
    \   if (i % 2 == 1 && lst(i) % 2 == 0) {\n                ret += lst(i)\n    \
    \        }\n        }\n        return ret", '        return lst.zipWithIndex.filter(x
    => x._2 % 2 == 1).map(x => x._1).sum', "        var (i, total) = (0l, 0l)\n  \
    \      for (i <- 0 until lst.length) {\n            if (i % 2 == 1 && lst(i.toInt)\
    \ % 2 == 0) total += lst(i.toInt)\n        }\n        return total", "       \
    \ var result : Long = 0\n        for (i <- 0 until lst.length) {\n           \
    \ if (i % 2 == 1 && lst(i) % 2 == 0) {\n                result += lst(i)\n   \
    \         }\n        }\n        return result", "        var s : Long = 0\n  \
    \      for (i <- 0 until lst.length) {\n            if (i % 2 == 1) {\n      \
    \          s += lst(i)\n            }\n        }\n        return s", "       \
    \ // Pattern match on the list\n        // One item\n        // No items\n   \
    \     lst match {\n            case Nil => 0l\n            case x :: Nil => x\n\
    \            case x :: y :: xs => if (x % 2 == 0 && y % 2 == 1) x + add(y :: xs)\
    \ else add(y :: xs)\n        }", "        var sum : Long = 0\n        for (i <-\
    \ 0 until lst.length) {\n            if (i % 2 == 1) {\n                sum +=\
    \ lst(i)\n            }\n        }\n        return sum", "        var s : Long\
    \ = 0l\n        for (i <- 1 until lst.length by 2) s += lst(i)\n        s", "\t\t\
    lst.zipWithIndex.map(p => p._1.toInt).filter(n => (n % 2 == 0) && (n % 2 == 0)).sum",
  "        var even = lst.filter((x: Long) => (x % 2) == 0)\n        even.foldLeft(0l)((x:\
    \ Long, y: Long) => x + y)", '        return lst.zipWithIndex.filter(l => l._2
    % 2 == 1).map(l => l._1).filter(l => l % 2 == 0).sum', "        // Fill up this\
    \ function body\n        // `0l` for Scala-js since it doesn't have a default\
    \ Long\n        // value.\n        0l", '        return lst.zipWithIndex.filter(x
    => (x._2 + 1) % 2 == 0).filter(x => x._1 % 2 == 0).map(x => x._1).sum', '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 1).map(x => x._1).sum', '        return lst.zipWithIndex.filter(x
    => x._2 % 2 == 1).map(x => x._1).sum', '        lst.zipWithIndex.filter(e => e._2
    % 2 == 1).map(e => e._1).filter(e => e % 2 == 0).sum', '        return lst.filter(x
    => x % 2 == 0).zipWithIndex.filter(y => y._2 % 2 == 1).map(x => x._1).sum', '        lst.zipWithIndex.filter(p
    => (p._2 % 2 == 1 && p._1 % 2 == 0)).map(p => p._1).reduce((a, b) => a + b)',
  "        val oddEven = lst.zipWithIndex.filter(x => (x._2 + 1) % 2 == 0)\n     \
    \   oddEven.map(x => x._1).filter(x => x % 2 == 0).sum", "        val isOdd =\
    \ (num : Long) => (num & 1) == 1\n        val isEven = (num : Long) => (num &\
    \ 1) == 0\n        val isOddIndex = (lst : List[Long], idx : Int) => isOdd(idx)\n\
    \        val isEvenNumber = (lst : List[Long], idx : Int) => isEven(lst(idx))\n\
    \        val add = (lst : List[Long], idx : Int) => lst(idx)\n        lst.zipWithIndex.filter(p\
    \ => isOddIndex(lst, p._2) && isEvenNumber(lst, p._2)).map(p => add(lst, p._2)).sum",
  "        // This would be much easier with functional programming\n        val odds\
    \ = lst.indices.filter(_ % 2 == 1)\n        val evens = lst.indices.filter(_ %\
    \ 2 == 0)\n        var evens_at_odds = ArrayBuffer[Long]()\n        var odds_at_evens\
    \ = ArrayBuffer[Long]()\n        for (even <- evens) {\n            odds_at_evens\
    \ += lst(even)\n        }\n        for (odd <- odds) {\n            evens_at_odds\
    \ += lst(odd)\n        }\n        evens_at_odds.sum + odds_at_evens.sum", "  \
    \      val r = lst.filter(_ % 2 == 0).filter(_ % 2 != 0).sum\n        return r",
  '        lst.zipWithIndex.filter(Function.tupled((a, b) => b % 2 == 1 && a % 2 ==
    0)).map(_._1).sum', '        lst.zipWithIndex.filter(e => e._2 % 2 == 1).map(f
    => f._1).sum', '        lst.zipWithIndex.map(x => if(x._2 % 2 == 1) x._1 else
    0).sum', "\tvar result : Long = 0l\n\tfor (i <- 0 until lst.length) {\n\t    if\
    \ (i % 2 == 1 && lst(i) % 2 == 0) {\n\t\tresult += lst(i)\n\t    }\n\t}\n\tresult",
  '        return lst.zipWithIndex.filter(p => p._2 % 2 == 1).map(x => x._1).filter(x
    => x % 2 == 0).sum', '        ???', "        var result : Long = 0\n        if\
    \ (lst.size % 2 == 0) {\n            for (i <- 0 until lst.size / 2) {\n     \
    \           result += lst(2 * i)\n            }\n        } else {\n          \
    \  for (i <- 0 until (lst.size - 1) / 2) {\n                result += lst(2 *\
    \ i)\n            }\n        }\n        return result", "        var res : Long\
    \ = 0\n        for (i <- 0 until lst.length) {\n            if (i % 2 == 1 &&\
    \ lst(i) % 2 == 0) {\n                res += lst(i)\n            }\n        }\n\
    \        return res", "        val list = lst.zipWithIndex.filter(t => t._2 %\
    \ 2 == 1 && t._1 % 2 == 0).map(t => t._1)\n        return list.sum", "       \
    \ // It is possible to do so in O(n) by using a running sum\n        var add =\
    \ lst(0) + lst(1)\n        // Iterate through the list, incrementing by 2 each\
    \ time\n        for (i <- 2 until lst.length by 2) {\n            // If it is\
    \ the last element, add it\n            if (i == lst.length - 1) {\n         \
    \       add += lst(i)\n            } else {\n                // Otherwise, add\
    \ the current element and the one after it\n                add += lst(i) + lst(i\
    \ + 1)\n            }\n        }\n        return add", "        def _add(lst :\
    \ List[Long], acc : Long) : Long = {\n            lst match {\n              \
    \  case Nil => acc\n                case h :: Nil => acc\n                case\
    \ h :: h2 :: t => _add(h2 :: t, acc + h)\n            }\n        }\n        _add(lst,\
    \ 0)", '        lst.zipWithIndex.filter(x => x._2 % 2 == 1).map(x => x._1).sum',
  "        var a = lst.zipWithIndex.filter(p => p._2 % 2 == 1 && p._1 % 2 == 0).map(p\
    \ => p._1).sum\n        return a", "        var i = 0\n        var sum = 0l\n\
    \        while (i < lst.length) {\n            if (i % 2 == 1) {\n           \
    \     sum += lst(i)\n            }\n            i += 1\n        }\n        return\
    \ sum", '        lst.zipWithIndex.filter((x: Tuple2[Long, Int]) => x._2 % 2 ==
    1 && x._1 % 2 == 0).map(_._1).sum', '        lst.zipWithIndex.filter((x) => x._2
    % 2 == 1).map((x) => x._1).sum', '        lst.zipWithIndex.filter(x => (x._2 %
    2) == 1).map(x => x._1).sum', "        // This solution is suboptimal because\
    \ the divisions by 2 and modulo 2 will result in\n        // a performance penalty.\n\
    \        // lst.zipWithIndex.map(x => if (x._2 % 2 == 0 && x._1 % 2 == 0) Some(x._1)\
    \ else None).flatten.sum\n        var index = 0\n        var sum = 0l\n      \
    \  while (index < lst.length) {\n            if (index % 2 == 0 && lst(index)\
    \ % 2 == 0) {\n                sum += lst(index)\n            }\n            index\
    \ += 1\n        }\n        sum", '        lst.filter((i, index) => i % 2 == 0
    && index % 2 == 1).sum', "        return lst.zipWithIndex.foldLeft(0l) { (b, v)\
    \ =>\n            if (v._2 % 2 == 1) {\n                b + v._1\n           \
    \ } else {\n                b\n            }\n        }", "        var sum : Long\
    \ = 0\n        for (i <- 0 until lst.length) if (i % 2 == 1) sum += lst(i)\n \
    \       return sum", '        lst.zipWithIndex.filter(x => (x._2 + 1) % 2 == 0
    && x._1 % 2 == 0).map(x => x._1).sum', "        var sum : Long = 0l\n        var\
    \ i : Int = 1\n        for (element <- lst) {\n            if (i % 2 == 1) {\n\
    \                sum += element\n            }\n            i += 1\n        }\n\
    \        return sum", '        lst.filter((x, index) => index % 2 == 1 && x %
    2 == 0).sum', '        lst.zipWithIndex.filter(pair => pair._2 % 2 == 1).map(pair
    => pair._1).sum', "        val A = lst.zipWithIndex.filter(x => x._2 % 2 == 1).map(x\
    \ => x._1).filter(x => x % 2 == 0)\n        A.sum", "        var sum = 0l;\n \
    \       for (i <- 1 until lst.length by 2) {\n            sum += lst(i);\n   \
    \     }\n        return sum;", "        if (lst.length == 0) 0\n        else if\
    \ (lst.length == 1) lst(0)\n        else lst(0) + add(lst.drop(2))", "       \
    \ val lstLength = lst.length\n        // Convert lst to a array\n        val lstArray\
    \ = lst.toArray\n        var total = 0L\n        var i = 0\n        while (i <\
    \ lstLength) {\n            if (i % 2 == 1) {\n                if (lstArray(i)\
    \ % 2 == 0) {\n                    total += lstArray(i)\n                }\n \
    \           }\n            i += 1\n        }\n        total", '        lst.zipWithIndex.filter(e
    => (e._2 + 1) % 2 == 0 && e._1 % 2 == 0).map(e => e._1).sum', '        lst.zipWithIndex.filter(_._2
    % 2 == 1).map(_._1).sum', '        lst.zipWithIndex.map(e => if (e._2 % 2 == 1)
    e._1 else 0).sum', "\t\treturn lst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).filter(_\
    \ % 2 == 0).sum", "        var sum : Long = 0\n        for (i <- 1 until lst.length\
    \ by 2) {\n            sum += lst(i)\n        }\n        return sum", "      \
    \  var sum : Long = 0\n        for (i <- lst.indices if (i % 2 != 0)) {\n    \
    \        sum += lst(i)\n        }\n        return sum", "        val evens = lst.zipWithIndex.filter(x\
    \ => x._2 % 2 == 1 && x._1 % 2 == 0).map(x => x._1)\n        evens.sum", '        return
    lst.zipWithIndex.filter(x => x._2 % 2 == 1).map(x => x._1).sum', "        var\
    \ sum = 0l\n        for (i <- 0 until lst.length) {\n            if (i % 2 ==\
    \ 1 && lst(i) % 2 == 0) sum += lst(i)\n        }\n        return sum", "     \
    \   var sum = 0.toLong\n        for (x <- 0 to lst.length - 1) {\n           \
    \ if (x % 2 == 1) {\n                sum += lst(x)\n            }\n        }\n\
    \        return sum", '        return lst.zipWithIndex.filter(x => x._2 % 2 ==
    1).map(x => x._1).foldLeft(0l)(_ + _)', "        var sum : Long = 0\n        for\
    \ (i <- 0 until lst.length) {\n            if (i % 2 == 1) {\n               \
    \ sum += lst(i)\n            }\n        }\n        return sum", "        var sum\
    \ : Long = 0\n        for (i <- lst.indices) {\n            if (i % 2 == 1) {\n\
    \                sum += lst(i)\n            }\n        }\n        return sum",
  "        val sum = 0l\n        for (i <- 0 until lst.length if (i % 2 == 1)) {\n\
    \            sum + lst(i)\n        }\n        sum", "        val res = lst.grouped(2).toList.foldLeft(List[Long]())((acc,\
    \ l) => acc :+ l.head)\n        res.sum", "        var sum = 0l\n        for (i\
    \ <- 1 until lst.length by 2) {\n            if (lst(i) % 2 == 0) sum += lst(i)\n\
    \        }\n        sum", "\t    var ret : Long = 0\n\t    for (i <- 0 until lst.length)\
    \ {\n\t    \tif (i % 2 == 1 && lst(i) % 2 == 0) {\n\t    \t\tret += lst(i)\n\t\
    \    \t}\n\t    }\n\t    ret", '        return lst.zipWithIndex.filter{case (e,
    i) => i % 2 == 1}.map{case (e, i) => e}.filter{x => x % 2 == 0}.sum', "      \
    \  // >>> (List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)).zipWithIndex.filter(x\
    \ => (x._2 % 2 == 1)).map(x => x._1).reduceLeft(_ + _)\n        // (2l)\n    \
    \    // >>> (List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)).zipWithIndex.filter(x\
    \ => (x._2 % 2 == 1)).map(x => x._1).reduceLeft(_ + _)\n        // (2l)\n    \
    \    // >>> (List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)).zipWithIndex.filter(x\
    \ => (x._2 % 2 == 1)).map(x => x._1).reduceLeft(_ + _)\n        // (2l)\n    \
    \    // >>> (List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)).zipWithIndex.filter(x\
    \ => (x._2 % 2 == 1)).map(x => x._1).reduceLeft(_ + _)\n        // (2l)\n    \
    \    // >>> (List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)).zipWithIndex.filter(x\
    \ => (x._2 % 2 == 1)).map(x => x._1).reduceLeft(_ + _)\n        // (2l)\n    \
    \    // >>> (List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)).zipWithIndex.filter(x\
    \ => (x._2 % 2 == 1)).map(x => x._1).reduceLeft(_ + _)\n        // (2l)\n    \
    \    // >>> (List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)).zipWithIndex.filter(x\
    \ => (x._2 % 2 == 1)).map(x => x._1).reduceLeft(_ + _)\n        // (2l)\n    \
    \    // >>> (List[Long", "        var res = 0l\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 2 == 1 && lst(i) % 2 == 0) {\n                res +=\
    \ lst(i)\n            }\n        }\n        res", "        var odd = 0\n     \
    \   var sum = 0l\n        for (i <- lst) {\n            if (odd % 2 == 1) {\n\
    \                sum += i\n            }\n            odd += 1\n        }\n  \
    \      return sum", "        var result = 0l\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 2 == 1 && lst(i) % 2 == 0) result += lst(i)\n       \
    \ }\n        result", "        var output : Long = 0l\n        lst.foreach { case\
    \ (elem : Long) => if (elem % 2 == 0) output += elem }\n        return output",
  '        (for (i <- lst.indices if (i % 2 == 1)) yield lst(i)).sum', "\t\tval s\
    \ = lst.zipWithIndex.filter {case (e, i) => (i + 1) % 2 == 0}.map {case (e, i)\
    \ => e}.filter {_ % 2 == 0}.sum\n\t\ts", "        val lst2 = lst.zipWithIndex.filter\
    \ { case (x, y) => (y % 2 == 1) && (x % 2 == 0) }.map { case (x, y) => x }\n \
    \       if (lst2.length == 0) 0 else lst2.reduceLeft { (x, y) => x + y }", " \
    \       val g: List[Long] = lst.zipWithIndex.filter(e => e._2 % 2 == 1 && e._1\
    \ % 2 == 0).map(e => e._1)\n        if (g.length != 0) g.foldLeft(0l)((a, b) =>\
    \ a + b) else 0l", '        lst.zipWithIndex.filter(x => (x._2 & 1) == 1).map(x
    => x._1).filter(x => (x & 1) == 0).sum', "        if (lst.length == 0) return\
    \ 0\n        var sum = 0l\n        for (i <- 1 until lst.length by 2) {\n    \
    \        if (lst(i) % 2 == 0) {\n                sum += lst(i)\n            }\n\
    \        }\n        return sum", "        var s = 0l\n        for (i <- lst.indices)\
    \ {\n            if (i % 2 == 1 && lst(i) % 2 == 0) {\n                s += lst(i)\n\
    \            }\n        }\n        s", '        lst.zipWithIndex.filter(x => x._2
    % 2 == 1).filter(x => x._1 % 2 == 0).map(x => x._1).reduceLeft(_ + _)', "    \
    \    var total : Long = 0l\n        for (i <- 1 until lst.length by 2) {\n   \
    \         if (lst(i) % 2 == 0) {\n                total += lst(i)\n          \
    \  }\n        }\n        return total", "        val even = lst.zipWithIndex.filter(e\
    \ => e._2 % 2 == 1 && e._1 % 2 == 0).map(e => e._1)\n        even.sum", '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 1).map(x => x._1).sum', '        lst.zipWithIndex.filter(x => x._2
    % 2 == 1).map(x => x._1).sum', '        lst.zipWithIndex.filter(x => x._2 % 2
    == 1).filter(x => x._1 % 2 == 0).map(x => x._1).sum', "        val new_list =\
    \ lst.zipWithIndex.filter(x => ((x._2 % 2) == 1) && ((x._1 % 2) == 0))\n     \
    \   val reduced = new_list.reduceLeft((x, y) => (x._1 + y._1, x._2 + y._2))\n\
    \        return reduced._1", "        var odds : List[Long] = List[Long]()\n \
    \       var evens : List[Long] = List[Long]()\n        lst.foreach( (el : Long)\
    \ => {\n            if (el % 2 == 0) {\n                evens = evens :+ el\n\
    \            } else {\n                odds = odds :+ el\n            }\n    \
    \    })\n        return evens.sum + odds.sum", "        var result : Long = 0\n\
    \        for (i <- 0 until lst.length by 2) {\n            if (lst(i) % 2 == 0)\
    \ {\n                result += lst(i)\n            }\n        }\n        return\
    \ result", "        val odds = lst.indices.filter((i) => {i % 2 == 1})\n     \
    \   lst.zipWithIndex.filter((tuple) => {tuple._2 % 2 == 1}).map((tuple) => {tuple._1}).sum",
  '        return ((lst.zipWithIndex filter(x => x._2 % 2 == 1) map(x => x._1) filter(x
    => x % 2 == 0)).sum)', "        return lst.foldLeft(0l) {(m, i) => \n        \
    \    if (i % 2 == 0) m + i else m\n        }", "        var sum : Long = 0l\n\
    \        var index : Int = 0\n        while (index < lst.length) {\n         \
    \   if (index % 2 == 1) {\n                sum += lst(index)\n            }\n\
    \            index += 1\n        }\n        return sum", "        var sum = 0l\n\
    \        for (i <- 0 until lst.length by 2) {\n            if (lst(i) % 2 == 0)\
    \ {\n                sum += lst(i)\n            }\n        }\n        return sum",
  "        var sum = 0l\n        for (i <- lst.indices) {\n            if (i % 2 ==\
    \ 1 && lst(i) % 2 == 0) sum += lst(i)\n        }\n        sum", '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 1).map(x => x._1).sum', "        var sum : Long = 0l\n        for\
    \ (i <- lst.indices) {\n            if (i % 2 == 1 && lst(i) % 2 == 0) {\n   \
    \             sum += lst(i)\n            }\n        }\n        return sum", " \
    \       var result : Long = 0\n        for (i <- 0 until lst.length) {\n     \
    \       if (i % 2 == 1 && lst(i) % 2 == 0) result += lst(i)\n        }\n     \
    \   return result"]
stop_tokens:
- "\n    }\n"
