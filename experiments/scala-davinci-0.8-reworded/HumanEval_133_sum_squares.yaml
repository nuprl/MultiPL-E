name: HumanEval_133_sum_squares
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of numbers.\n    // You need to return the sum of squared\
  \ numbers in the given list,\n    // round each element in the list to the upper\
  \ int(Ceiling) first.\n    // Examples:\n    // >>> lst((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat)))\n    // (14l)\n    // >>> lst((List[Float](1.0f.toFloat,\
  \ 4.0f.toFloat, 9.0f.toFloat)))\n    // (98l)\n    // >>> lst((List[Float](1.0f.toFloat,\
  \ 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))\n    // (84l)\n    // >>> lst((List[Float](1.4f.toFloat,\
  \ 4.2f.toFloat, 0.0f.toFloat)))\n    // (29l)\n    // >>> lst((List[Float](-2.4f.toFloat,\
  \ 1.0f.toFloat, 1.0f.toFloat)))\n    // (6l)\n    def sumSquares(lst : List[Float])\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));\n    assert(sumSquares((List[Float](1.4f.toFloat,\
  \ 4.2f.toFloat, 0.0f.toFloat))) == (29l));\n    assert(sumSquares((List[Float](-2.4f.toFloat,\
  \ 1.0f.toFloat, 1.0f.toFloat))) == (6l));\n    assert(sumSquares((List[Float](100.0f.toFloat,\
  \ 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));\n    assert(sumSquares((List[Float](10000.0f.toFloat,\
  \ 10000.0f.toFloat))) == (200000000l));\n    assert(sumSquares((List[Float](-1.4f.toFloat,\
  \ 4.6f.toFloat, 6.3f.toFloat))) == (75l));\n    assert(sumSquares((List[Float](-1.4f.toFloat,\
  \ 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));\n    assert(sumSquares((List[Float](0.0f.toFloat)))\
  \ == (0l));\n    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));\n   \
  \ assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) ==\
  \ (2l));\n    }\n\n}\n"
completions: ["        // Write your code here\n        lst.map(x => pow(ceil(x).toInt,\
    \ 2).toLong).sum", "        // Write your code here\n        var result : Long\
    \ = 0;\n        for (i <- lst) {\n            result += scala.math.ceil(i).toLong\
    \ * scala.math.ceil(i).toLong;\n        }\n        return result;", '        return
    lst.map(x => ceil(x).toLong).map(x => x * x).sum', '      lst.map(x => round(x)).map(x
    => x*x).sum.toLong', '        return lst.map(e => ceil(e).toInt).map(e => e *
    e).sum', '        lst.map((i : Float) => (ceil(i).toInt * ceil(i).toInt)).reduce((i
    : Int, j : Int) => (i + j))', '        lst.map(x => ceil(x).toLong).map(x => x
    * x).sum', "        // your code goes here\n        return lst.map(x => ceil(x).toLong).map(x\
    \ => x * x).sum", "        // Fill up this function body\n        // `0l` is just\
    \ a placeholder for compilation\n        // REMOVE THE PLACEHOLDER AND WRITE YOUR\
    \ CODE HERE\n        var x = 0\n        var squareList:List[Float] = List()\n\
    \        var temp:Float = 0\n        for(x <- 0 to lst.length-1){\n          \
    \  temp = ceil(lst(x))\n            squareList = temp*temp :: squareList\n   \
    \     }\n        var sum = 0\n        for(x <- 0 to squareList.length-1){\n  \
    \          sum = sum + squareList(x).toInt\n        }\n        return sum", '        lst.map(x
    => Math.round(x)).map(x => x * x).sum.toLong', "        val upper_lst = lst.map(e\
    \ => ceil(e).toLong)\n        upper_lst.map(x => x * x).sum", "        // The\
    \ following line is the solution.\n        // Edit this line to test other solutions.\n\
    \        lst.map(x => Math.ceil(x).toInt).map(x => Math.pow(x, 2).toLong).sum",
  "        val result = lst.map(x => ceil(x).toLong * ceil(x).toLong).reduce((x, y)\
    \ => x + y)\n        return result", '        lst.map(x => Math.ceil(x).toLong).map(x
    => x * x).sum', '        (for (i <- lst) yield (ceil(i).toLong * ceil(i).toLong)).sum',
  "        val lst2 = lst.map(x => (ceil(x).toInt * ceil(x).toInt))\n        val sum\
    \ = lst2.reduce((x, y) => x + y)\n        return sum", "        val newLst = lst.map((e\
    \ : Float) => ceil(e).toInt).map((e : Int) => e * e)\n        newLst.foldLeft(0l)((acc\
    \ : Long, e : Int) => acc + e)", "        // Your Code Here\n        lst.map(a\
    \ => ceil(a).toLong * ceil(a).toLong).sum", '        lst.map(i => ceil(i).toLong
    * ceil(i).toLong).sum', "        var result : Long = 0\n        for (x <- lst)\
    \ {\n            result += math.pow(math.ceil(x).toInt, 2).toLong\n        }\n\
    \        return result", "        if (lst.isEmpty) return 0\n        else {\n\
    \            val r = round(lst.head).toInt\n            return r * r + sumSquares(lst.tail)\n\
    \        }", '        lst.map(x => ceil(x).toLong).map(x => x * x).sum', "   \
    \     // println(lst.map(a => pow(ceil(a).toInt, 2).toLong).sum)\n        lst.map(a\
    \ => pow(ceil(a).toInt, 2).toLong).sum", '        lst.map(v => ceil(v).toLong
    * ceil(v).toLong).sum', "        // your code here\n        0l", "        // your\
    \ answer here\n        (lst.map(ceil(_)).map(math.pow(_, 2).toInt).sum).toLong",
  "        val lst_floor : List[Int] = lst.map(x => Math.ceil(x).toInt)\n        lst_floor.map(x\
    \ => x * x).sum.toLong", "        var a = 0f\n        var b = ListBuffer[Float]()\n\
    \        for (i <- lst) {\n            a = ceil(i).toFloat\n            b += a\
    \ * a\n        }\n        var c = 0l\n        for (i <- b) {\n            c +=\
    \ i.toLong\n        }\n        return c", "        // Start your code here\n \
    \       lst.map(i => ceil(i).toLong).map(i => i * i).sum", "        // Since all\
    \ numbers will be positive,\n        // we can find the max value in the list\n\
    \        // and use its ceiling as the new square value.\n        // The values\
    \ in the list will be rounded before\n        // we square them.\n        // This\
    \ keeps the square value much lower\n        // than if we just used the original\
    \ value.\n        val max = lst.max\n        var sum : Long = 0\n        lst.foreach(num\
    \ => sum += ceil(num).toLong * ceil(num).toLong)\n        return sum", '        lst.map(x
    => ceil(x).toLong).map(x => x * x).sum', '        (lst map (x => pow(ceil(x).toInt,
    2).toLong)).sum', "        var ret = 0l\n        for (e <- lst) {\n          \
    \  ret += math.ceil(e).toLong * math.ceil(e).toLong\n        }\n        ret",
  '        0', "        // Write your solution here\n        def helper(lst : List[Float],\
    \ sum : Long) : Long = {\n            if (lst.length == 0) {\n               \
    \ sum\n            } else {\n                helper(lst.tail, sum + scala.math.pow(lst.head.ceil.toLong,\
    \ 2).toLong)\n            }\n        }\n        helper(lst, 0)", "        var\
    \ result : Long = 0\n        // Write your code here\n        lst.foreach(e =>\
    \ result += math.ceil(e).toLong * math.ceil(e).toLong)\n        return result",
  '        return lst.map(x => ceil(x).toLong).map(x => x * x).sum', "        var\
    \ result : Long = 0\n        for (a <- lst) {\n            result += a.ceil.toLong\
    \ * a.ceil.toLong\n        }\n        return result", "        // your code here\n\
    \        return 0l", '        lst.map(x => ceil(x).toLong * ceil(x).toLong).sum',
  '        return (0l)', "        // Write your code here.\n        val a = lst.map(ceil(_).toLong).map(x\
    \ => x * x).sum\n        a", "        // Your Code Here\n        return 0;", " \
    \       var res : Long = 0\n        for (i <- lst) res += i.toInt*i.toInt\n  \
    \      res", "        // Write your logic here.\n        var ret : Long = 0;\n\
    \        for (i <- lst) {\n            var temp : Int = ceil(i).toInt;\n     \
    \       ret += temp * temp;\n        }\n        return ret;", '        lst.map(Math.ceil(_).toInt).map(x
    => x * x).sum.toLong', "        // your code here.\n        // your code here.\n\
    \        def cal(lst : List[Float]) : List[Long] = {\n            if (lst.length\
    \ == 0) List[Long]()\n            else {\n                var rst : List[Long]\
    \ = List[Long]()\n                for (num <- lst) {\n                    rst\
    \ = ceil(num).toLong :: rst\n                }\n                rst\n        \
    \    }\n        }\n        var lst2 : List[Long] = cal(lst)\n        def sum(lst\
    \ : List[Long]) : Long = {\n            var rst : Long = 0\n            for (num\
    \ <- lst) {\n                rst += pow(num, 2).toLong\n            }\n      \
    \      rst\n        }\n        sum(lst2)", "        // This is a function you\
    \ have to fill in\n        val squaredList = lst.map(x => math.ceil(x).toInt)\n\
    \        squaredList.map(x => x * x).sum", "        var result : Long = 0\n  \
    \      for (x <- lst) result += math.ceil(x).toLong * math.ceil(x).toLong\n  \
    \      return result", "        // Your code here\n        return 0l", '        lst.map(x
    => (ceil(x).toLong) * (ceil(x).toLong)).sum', "        //Write your solution here\n\
    \        lst.map(x => x.toInt).map(x => x*x).sum", "        val lst2 = lst.map(x\
    \ => ceil(x).toLong)\n        return lst2.map(x => x * x).sum", "        // Write\
    \ your code here\n        var sum = 0.0\n        for (i <- lst) sum += pow(i,\
    \ 2)\n        sum.toLong", '        lst.map(x => ceil(x).toLong * ceil(x).toLong).sum',
  "        // Write your code here\n        return lst.map((x) => ceil(x).toLong).map((x)\
    \ => x * x).sum", "        var res = 0L\n        for (i <- lst) res += ceil(i).toLong\
    \ * ceil(i).toLong\n        res", "        // Type your solution here\n      \
    \  var result = 0l\n        for (i <- lst) {\n            result += ceil(i).toLong\
    \ * ceil(i).toLong\n        }\n        result", "        // This is wrong answer,\
    \ because Float -> Long is not safe\n        // wrong: lst.map(x => x.ceil.toLong).map(x\
    \ => x * x).sum\n        // Correct:\n        var ceil = new Array[Float](lst.length)\n\
    \        for (i <- 0 until lst.length) ceil(i) = ceil(lst(i)).toFloat\n      \
    \  ceil.map(x => x * x).sum.toLong", '        lst.map(x => ceil(x).toLong).map(x
    => x * x).sum', "        // Your Code Here\n        return null;", "        var\
    \ ret : Long = 0\n        for (a <- lst) {\n            ret += pow(ceil(a).toInt,\
    \ 2).toLong\n        }\n        return ret", "        // An integer constant is\
    \ an expression consisting of a sequence of digits,\n        // with an optional\
    \ leading - sign. The digits may be separated by `_' characters\n        // (for\
    \ readability); they may not be separated by any other character.\n        //\
    \ A floating-point constant is an expression consisting of a whole number,\n \
    \       // a decimal point, a fraction, and an exponent. The whole number, the\
    \ fraction,\n        // and the exponent all contain decimal digits. The decimal\
    \ point and the exponent\n        // begin with an optional plus or minus sign.\
    \ The exponent uses the letter `e' or `E'\n        // to introduce the exponent,\
    \ which may itself be an expression.\n        // lst(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat))\n        // (List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat)).map((x : Float) => {\n        //     Math.ceil(x)\n        //\
    \ }).map((x : Double) => {\n        //     x.toLong * x.toLong\n        // }).sum\n\
    \        // ceil(1.0) = 1.0\n        // 1.0.toLong * 1.0.toLong = 1\n        //\
    \ ceil(2.0) = 2.0\n        // 2.0.toLong * 2.0.toLong = 4\n        // ceil(3.0)\
    \ = 3.0\n        // 3.0.toLong * 3.0.toLong = 9\n        // 1 + 4 + 9 = 14\n \
    \       // lst(List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat))\n      \
    \  // (List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat)).map((x : Float)\
    \ => {\n        //     Math.ceil(x)\n        // }).map((x : Double) => {\n   \
    \     //     x.toLong * x.toLong\n        // }).sum\n        // ceil(1.0) = 1.0\n\
    \        // 1.0.toLong *", '        lst.map(x => ceil(x).toLong).map(x => x *
    x).sum', "        // var result : Long = 0\n        // for (n <- lst) {\n    \
    \    //     result += pow(ceil(n).toLong, 2).toLong\n        // }\n        //\
    \ return result\n        lst.map(n => pow(ceil(n).toLong, 2).toLong).sum", " \
    \       var result : Long = 0l\n        for (i <- lst) {\n            result +=\
    \ ceil(i).toLong * ceil(i).toLong\n        }\n        return result", "      \
    \  // Write your code here\n        lst.map(x => ceil(x).toLong).map(x => x *\
    \ x).sum", '        return lst.map(x => (ceil(x).toInt * ceil(x).toInt)).sum',
  '        lst.map(f => ceil(f)).map(f => pow(f, 2).toLong).sum', "        // Write\
    \ your code here\n        lst.map(a => a.ceil.toLong).map(a => a * a).sum", " \
    \     var result : Long = 0\n      for (i <- lst) {\n        result += (ceil(i)).toLong\
    \ * (ceil(i)).toLong\n      }\n      return result", '        return lst.map(x
    => ceil(x).toInt).map(x => x*x).sum', '        lst.map(x => math.pow(math.ceil(x).toInt,
    2).toLong).sum', '        lst.map((el : Float) => ceil(el).toLong).map((el : Long)
    => el * el).sum', '        lst.map(x => ceil(x).toLong).map(x => x * x).sum',
  "        // Insert your code here.\n        0", "        // your answer here\n \
    \       return (0l)", "        // math.pow(x, 2)\n        lst.map(x => math.pow(math.ceil(x).toFloat,\
    \ 2).toLong).sum", "        val x = lst.map(ceil(_)).map(pow(_, 2))\n        x.sum.toLong",
  '        lst.map(x => ceil(x).toLong).map(x => x * x).sum', "\t\treturn (0l)", " \
    \       // your code here\n        var s: Long = 0\n        for (i <- lst) {\n\
    \            s += scala.math.ceil(i).toLong * scala.math.ceil(i).toLong\n    \
    \    }\n        s", "        val l = lst.map(x => (ceil(x)).toInt)\n        l.map(x\
    \ => x * x).reduceLeft(_ + _)", "        var result : Long = 0\n        for (i\
    \ <- lst) {\n            result += pow(ceil(i).toInt, 2).toLong\n        }\n \
    \       return result", '        lst.map(x => ceil(x).toLong).map(x => x * x).sum',
  "        val x = lst.map(x => math.ceil(x).toInt).map(x => x * x).sum\n        return\
    \ x", "        var ret : Long = 0\n        for (e <- lst) {\n            ret +=\
    \ pow(ceil(e).toFloat, 2).toLong\n        }\n        return ret", "        //\
    \ This will scale the list with the input from the problem\n        // When you\
    \ solve the problem with a function lst with the input from the problem\n    \
    \    // this will get called and will test your solution for us.\n        val\
    \ scaledList = lst.map(x => x * 1e3f)\n        // This is the solution.\n    \
    \    ???", "        // Write your code here\n        // Return the sum of squared\
    \ numbers in the given list,\n        // round each element in the list to the\
    \ upper int(Ceiling) first.\n        lst.map(x => pow(ceil(x).toInt, 2).toLong).sum",
  '        lst.map(x => ceil(x).toLong).map(x => x * x).reduceLeft(_ + _)', "    \
    \    // Write your code here\n        lst.map(x => ceil(x).toLong).map(x => x\
    \ * x).sum", "        // Initialize variable to store the answer.\n        var\
    \ answer : Long = 0l\n        // Iterate through each element in the list.\n \
    \       for (element <- lst) {\n            // Use the pattern matching to handle\
    \ negative/positive numbers.\n            element match {\n                //\
    \ Handle the negative numbers.\n                case element if element < 0.0f\
    \ => {\n                    // Round the element to the upper int(Ceiling).\n\
    \                    val roundedElement : Int = ceil(element).toInt\n        \
    \            // Square the rounded element.\n                    val squareElement\
    \ : Int = pow(roundedElement, 2).toInt\n                    // Sum the squared\
    \ elements.\n                    answer += squareElement\n                }\n\
    \                // Handle the positive numbers.\n                case element\
    \ if element >= 0.0f => {\n                    // Round the element to the upper\
    \ int(Ceiling).\n                    val roundedElement : Int = ceil(element).toInt\n\
    \                    // Square the rounded element.\n                    val squareElement\
    \ : Int = pow(roundedElement, 2).toInt\n                    // Sum the squared\
    \ elements.\n                    answer += squareElement\n                }\n\
    \            }\n        }\n        // Return the answer.\n        return answer",
  '        return lst.map(x => ceil(x).toInt).map(x => x * x).sum', "        // Write\
    \ your code here\n        var sum = 0.0f\n        for (i <- lst) {\n         \
    \   sum += pow(ceil(i).toFloat, 2).toFloat\n        }\n        return sum.toLong",
  "        var sum : Long = 0\n        for (n <- lst) {\n            sum += round(n)\
    \ * round(n)\n        }\n        return sum", '        (lst.map((n) => ceil(n))).map((n)
    => n*n).sum.toLong', '        lst.map(n => n.toInt).map(n => n*n).sum', "    \
    \    var sum = 0L\n        for (e <- lst) {\n            sum += pow(ceil(e).toInt,\
    \ 2).toLong\n        }\n        return sum", '        lst.map(f => (f.toInt) *
    (f.toInt)).sum', '        return lst.map(ceil(_).toInt).map(x => x * x).sum.toLong',
  "        // your implementation\n        val l = lst.map((elem) => ceil(elem).toInt).map((elem)\
    \ => elem * elem)\n        l.foldLeft(0l)((acc, elem) => acc + elem)", '        lst.map(x
    => math.ceil(x).toLong).map(x => x * x).sum', "        var sum : Long = 0;\n \
    \       var list = lst.map(item => {\n            sum += ceil(item).toLong * ceil(item).toLong;\n\
    \        });\n        return sum;", "        def f(x : Float) : Long = (ceil(x)\
    \ * ceil(x)).toLong\n        lst.map(f).sum", "        lst.map(((x : Float) =>\
    \ (x - x.floor).compare(0.5f) match {\n            case 1 => x.ceil.toLong\n \
    \           case 0 => x.floor.toLong\n            case -1 => x.floor.toLong\n\
    \        })).map(((x : Long) => x * x)).sum", '        lst.map(ceil(_).toLong).map(x
    => x * x).sum', "        // your code here\n        return 0;", '        ???',
  "        // Write your code here\n        val lst2 = lst.map(x => ceil(x).toLong)\n\
    \        lst2.map(x => x * x).sum", "        // Write your code here.\n      \
    \  0l", '        lst.map(x => ceil(x).toLong).map(x => x * x).reduce(_ + _)',
  "        // TODO: Write your code here\n        0l", "        def _sumSquares(lst\
    \ : List[Float], result : Long) : Long = {\n            if (lst.isEmpty) result\n\
    \            else {\n                val num = ceil(lst.head).toLong\n       \
    \         _sumSquares(lst.tail, result + num * num)\n            }\n        }\n\
    \        _sumSquares(lst, 0)", "        // This is a template method for solving\
    \ all the problems\n        // on www.codingame.com\n        // It uses the CodinGame\
    \ API to interact with the website\n        // and is based on a pre-existing\
    \ solution whose source code\n        // is available on the website\n       \
    \ def encodeMove(move: Int) = Console.err.println(move)\n        def decodeLine()\
    \ = {\n            val line = readLine()\n            if (line != null) line.toFloat\
    \ else null\n        }\n        ////////////////////////////\n        val lst2\
    \ = lst.map(ceil(_).toLong)\n        val res = lst2.map(x => x * x).sum\n    \
    \    res", "        var result : Long = 0\n        for (x <- lst) result += pow(ceil(x).toInt,\
    \ 2).toLong\n        return result", "        // your code here\n        var ret\
    \ : Long = 0;\n        for (i <- lst) {\n            ret += pow(ceil(i).toFloat,\
    \ 2.0f).toLong;\n        }\n        return ret;", "        // Your code here\n\
    \        lst.map(_.ceil.toLong).map(x => x * x).sum", "        val l = lst.map(_.ceil.toInt)\n\
    \        return l.map(x => x * x).sum", '        return lst.map(x => Math.ceil(x).toLong
    * Math.ceil(x).toLong).sum', "        // Write your code here\n        lst.map((x\
    \ : Float) => ceil(x).toLong * ceil(x).toLong).sum", "        // Fill up this\
    \ function body\n        // `lst` is a list of floats\n        // You need to\
    \ return the sum of squared numbers\n        // of each element in the list\n\
    \        val l = for(i <- lst) yield ceil(i).toLong\n        return l.map(x =>\
    \ x*x).sum", "        // your code goes here\n        lst.map(x => math.ceil(x).toLong).map(x\
    \ => x * x).sum", "        val lst2 = lst.map((_ + 0.99999999f))\n        val\
    \ lst3 = lst2.map((floor(_).toLong))\n        lst3.map((_ * _)).sum", "      \
    \  // Type your code here\n        return lst.map(x => math.ceil(x).toLong).map(y\
    \ => y * y).sum", "        val x = lst.map(x => pow(ceil(x).toFloat, 2).toLong).reduceLeft(_\
    \ + _)\n        return x", "        // Fill up this function body\n        //\
    \ `sum` and `sumBy` are prohibited\n        // You can use `sumBy` or `sum` in\
    \ the solution of the test cases.\n        // It means that use of `sumBy` or\
    \ `sum` is allowed in the test cases, but not in the function `sumSquares` above.\n\
    \        val lst2 = lst.map(a => ceil(a).toLong).map(a => a * a)\n        val\
    \ result = lst2.sum\n        result", "        // Fill up this function body\n\
    \        // `lst` is a list of float numbers\n        // Do the ceiling operation\
    \ on each of the elements in the list\n        // and store the list back in `lst`\
    \ itself\n        // calculate and return the sum of squares of all the numbers\
    \ in the list\n        // you may use a loop to iterate over the list\n      \
    \  // you may use the function pow(x,y)\n        // x is the base and y is the\
    \ exponent\n        // you may use the built-in round(x)\n        // x is the\
    \ float number, this function returns the nearest integer to the given float number\n\
    \        var sum = 0l\n        for (i <- lst) {\n            sum += pow(round(i),\
    \ 2).toLong\n        }\n        sum", "        val lst_squared = lst.map(x =>\
    \ ceil(x).toLong * ceil(x).toLong)\n        return lst_squared.sum", "       \
    \ // your code goes here\n        lst.map(a => ceil(a).toLong).map(b => b * b).reduceLeft(_\
    \ + _)", "        var res = 0l\n        lst.foreach((num : Float) => {\n     \
    \       res += pow(ceil(num).toInt, 2).toLong\n        })\n        res", '        (for
    (x <- lst) yield ceil(x).toLong).foldLeft(0L)((a, b) => a + b * b)', '        return
    (ceil(lst.map(n => pow(n, 2)).sum) toLong)', "        var sum = 0L\n        for\
    \ (i <- lst) {\n            sum += ceil(i).toLong * ceil(i).toLong\n        }\n\
    \        return sum", "        var result : Long = 0\n        for (num <- lst)\
    \ {\n            result += pow(ceil(num).toLong, 2).toLong\n        }\n      \
    \  return result", "        // lst.map(ceil(_)).map(pow(_, 2).toInt).sum\n   \
    \     lst.map(ceil(_).toInt).map(pow(_, 2).toInt).sum", '        lst.map(x =>
    ceil(x).toLong).map(x => x * x).sum', '        return 0', "        // (1) Compute\
    \ result\n        lst.map(e => ceil(e).toInt).map(e => pow(e, 2).toLong).sum",
  "        // Write your code here\n        var sum = 0L\n        lst.foreach(element\
    \ => sum += pow(ceil(element).toInt, 2).toLong)\n        sum", "        // Your\
    \ Code Here\n        0l", "        // Your code here\n        0l", "\tval res\
    \ = for (i <- lst) yield {\n\t    math.pow(math.ceil(i), 2).toLong\n\t}\n\tres.sum",
  "        // Write your code here\n        lst.map(x => ceil(x).toLong).map(x =>\
    \ x * x).sum", '        lst.map(math.pow(_.ceil.toInt, 2)).sum.toLong', "    \
    \    def f(acc : Long, x : Float) : Long = acc + x.toInt * x.toInt\n        return\
    \ lst.foldLeft(0l)(f)", "        //Code Here\n        return lst.map(x => x.toInt\
    \ * x.toInt).reduceLeft(_ + _)", '        return lst.map(x => ceil(x).toLong *
    ceil(x).toLong).sum', '        return lst.map(x => x.ceil.toLong).map(x => x *
    x).sum', "        var sum = 0l\n        for (i <- lst) {\n            sum += (ceil(i).toInt\
    \ * ceil(i).toInt)\n        }\n        return sum", "        // Your code here\n\
    \        def temp(x : Float) : Long = {\n            Math.ceil(x).toLong * Math.ceil(x).toLong\n\
    \        }\n        lst.map(temp).sum", '        lst.map(x => ceil(x)).map(y =>
    y * y).sum.toLong', "        var result : Long = 0\n        for (i <- lst) {\n\
    \            result += pow(ceil(i).toInt, 2).toLong\n        }\n        return\
    \ result", "\t    // Type your code here\n\t    var sum : Long = 0\n\t    for\
    \ (x <- lst) {\n\t\t    sum += scala.math.ceil(x).toLong * scala.math.ceil(x).toLong\n\
    \t    }\n\t    return sum", '        return lst.map(x => ceil(x).toLong).map(x
    => x * x).sum', "        var sum = 0l\n        for (i <- lst) {\n            sum\
    \ += pow(ceil(i).toInt, 2).toLong\n        }\n        return sum", "        //\
    \ Your code here\n        lst.map(x => pow(ceil(x).toInt, 2).toLong).sum", " \
    \       // Type your solution here.\n        var sum = 0.0\n        for (i <-\
    \ lst) {\n            sum += ceil(i) * ceil(i)\n        }\n        sum.toLong",
  "        var a : Long = 0;\n        for (i <- lst) {\n            a += ceil(i).toLong\
    \ * ceil(i).toLong;\n        }\n        return a;", "        // Add your code\
    \ here\n        return 0l", '        lst.map(i => pow(ceil(i).toInt, 2).toLong).sum',
  "        val rounded_up = lst.map(e => ceil(e).toLong)\n        val squared = rounded_up.map(e\
    \ => e * e)\n        squared.sum", '        lst.map(n => ceil(n).toLong).map(n
    => n * n).sum', '        lst.map(x => pow(ceil(x).toInt, 2).toLong).sum', "  \
    \      // Your code here\n        var sum : Float = 0.0f.toFloat\n        for\
    \ (i <- lst) {\n            sum += pow(i, 2).toFloat\n        }\n        return\
    \ sum.toLong", "        var result : Long = 0l\n        for (i <- lst) result\
    \ += pow(ceil(i).toInt, 2).toLong\n        return result", "        // Sum of\
    \ squares\n        return lst.map((_:Float)).map((x:Float) => Math.ceil(x).toLong).map((x:Long)\
    \ => x * x).sum", "        def loop(lst : List[Float], acc : Long) : Long = {\n\
    \            lst match {\n                case Nil => acc\n                case\
    \ h :: t => loop(t, acc + (ceil(h).toInt * ceil(h).toInt))\n            }\n  \
    \      }\n        loop(lst, 0)", '        lst.map(ceil(_).toLong * ceil(_).toLong).sum',
  "        val tmp = lst.map(x => ceil(x).toInt).map(x => x * x)\n        return tmp.sum",
  '        return lst.map(x => ceil(x).toLong).map(y => y * y).sum', "        var\
    \ result : Long = 0\n        for (e <- lst) result += ceil(e).toLong * ceil(e).toLong\n\
    \        return result", '        lst.map(x => ceil(x).toLong).map(x => x * x).sum',
  '        lst.map(i => ceil(i).toLong * ceil(i).toLong).sum', "        // your code\
    \ here\n        var sum : Long = 0\n        for (i <- lst) {\n            sum\
    \ += ceil(i).toLong * ceil(i).toLong\n        }\n        return sum", "      \
    \  val squares = lst.map(x => ceil(x).toLong).map(x => x * x)\n        squares.sum",
  "      // Build the list of rounded ints\n      val intList = lst.map((f : Float)\
    \ => Math.ceil(f).toInt)\n      // Squaring each element in the list\n      val\
    \ sqList = intList.map((i : Int) => i * i)\n      // Returing the sum of the list\n\
    \      return sqList.sum", "        val l = lst.map(x => x.ceil)\n        l.map(x\
    \ => x * x).sum.toLong", "        // your code here\n        var res : Long =\
    \ 0\n        for (item <- lst) res += pow(ceil(item).toInt, 2).toLong\n      \
    \  res", "        //\n        // YOUR CODE HERE\n        //\n        lst.map(ceil(_).toLong).map(x\
    \ => x * x).sum", "        // Solution with the 'fancy' Scala way\n        //\
    \ lst.map(x => pow(ceil(x).toInt, 2).toLong).sum\n\n        // Solution without\
    \ the 'fancy' Scala way\n        var sum = 0l\n        for (i <- lst) {\n    \
    \        sum += pow(ceil(i).toInt, 2).toLong\n        }\n        sum", '        lst.map(e
    => pow(ceil(e).toInt, 2).toLong).sum', '        return lst.map(x => Math.ceil(x).toLong).map(x
    => x * x).sum', '        lst.map(e => Math.ceil(e).toLong).map(e => e * e).sum',
  "        // Write your code here\n        lst.map(ceil(_).toLong).map(pow(_, 2).toLong).sum",
  "        // Implmentation goes here...\n        var total = 0.0f\n        for (i\
    \ <- lst) {\n            total += (ceil(i) * ceil(i))\n        }\n        return\
    \ total.toLong", "        var l = lst.map(x => ceil(x))\n        l.map(x => x*x).sum.toLong",
  '        lst.map(x => ceil(x).toLong).map(x => x * x).sum', "        // your code\
    \ here\n        var result : Long = 0;\n        for (i <- lst) {\n           \
    \ var temp : Long = ceil(i).toLong;\n            result += temp * temp;\n    \
    \    }\n        return result;", '        lst.map(x => math.pow(math.ceil(x).toInt,
    2).toLong).sum', "        // Write your code here\n        return lst.map((a)\
    \ => ceil(a).toLong).map((a) => a * a).sum", '        lst.map(x => ceil(x).toLong).map(x
    => x * x).sum', "        val list = lst.map( x => ceil(x).toLong)\n        list.map(x\
    \ => x * x).sum", '        lst.map(el => math.ceil(el).toLong * math.ceil(el).toLong).sum',
  '        return lst.map(x => pow(ceil(x).toFloat, 2).toLong).sum', '        return
    lst.map(x => ceil(x).toLong * ceil(x).toLong).sum', "        // Your code goes\
    \ here.\n        // Hint: You can define an inner function to calculate the squared\
    \ value,\n        // then call the inner function for each element in the list.\n\
    \        def sum(lst: List[Float]): Long = lst match {\n            case Nil =>\
    \ 0\n            case x :: xs => Math.round(x).toLong * Math.round(x).toLong +\
    \ sum(xs)\n        }\n        sum(lst)", "        def compute(lst : List[Float])\
    \ : Long = {\n            if (lst.isEmpty) 0 else {\n                val f = ceil(lst.head)\n\
    \                f * f + compute(lst.tail)\n            }\n        }\n       \
    \ compute(lst)", "        // Your code here\n        lst.map(a => ceil(a).toLong).map(a\
    \ => a * a).sum", "        val squaredList = lst.map(math.ceil(_).toInt).map(math.pow(_,\
    \ 2).toLong)\n        squaredList.foldLeft(0L)(_ + _)", "        var sum = 0.0\n\
    \        lst.foreach(x => sum += pow(ceil(x).toFloat, 2.0f))\n        sum.toLong"]
stop_tokens:
- "\n    }\n"
