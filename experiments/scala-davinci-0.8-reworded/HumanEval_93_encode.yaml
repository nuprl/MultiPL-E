name: HumanEval_93_encode
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a message, and encodes in such a \n    // way\
  \ that it swaps case of all letters, replaces all vowels in \n    // the message\
  \ with the letter that appears 2 places ahead of that \n    // vowel in the english\
  \ alphabet. \n    // Assume only letters. \n    // Examples:\n    // >>> encode((\"\
  test\"))\n    // (\"TGST\")\n    // >>> encode((\"This is a message\"))\n    //\
  \ (\"tHKS KS C MGSSCGG\")\n    def encode(message : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
  )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n\
  \    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is\
  \ a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw\
  \ WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
completions: ["        val vowels = \"aeiou\"\n        val replacements = \"cdfghjklmnpqrstvwxyz\"\
    \n        val mapping = new String(vowels.toArray).zip(replacements.toArray).toMap\n\
    \        new String(message.toLowerCase.toArray.map(c => if (vowels.contains(c))\
    \ mapping(c) else c))", "        var arr = new Array[Char](message.length)\n \
    \       for (i <- 0 until message.length) {\n            val index = message(i)\n\
    \            val r = if (index <= 'Z') if (index <= 'M') index + 13 else index\
    \ - 13\n                else if (index <= 'm') index + 13 else index - 13\n  \
    \          arr(i) = r\n        }\n        arr.map(i => if (i == 'a') 'c' else\
    \ if (i == 'e') 'g' else if (i == 'i') 'k' else if (i == 'o') 'q' else if (i ==\
    \ 'u') 'w' else i).mkString", "        // Write your solution here\n        def\
    \ encodeChar(c : Char) : Char = {\n            val letter = \"abcdefghijklmnopqrstuvwxyz\"\
    \n            val index = if (letter.indexOf(c.toLower) >= 0) letter.indexOf(c.toLower)\
    \ else 0\n            val encode = if (index <= 22) index + 2 else index - 24\n\
    \            if (c.isUpper) letter(encode).toUpper else letter(encode)\n     \
    \   }\n        def encodeInner(message : String, index : Int) : String = {\n \
    \           if (index == message.length) \"\"\n            else {\n          \
    \      if (message(index).isLetter) encodeChar(message(index)).toString + encodeInner(message,\
    \ index + 1)\n                else message(index).toString + encodeInner(message,\
    \ index + 1)\n            }\n        }\n        encodeInner(message, 0)", "  \
    \      return message.map(x => x match {\n                case 'a' => 'c'\n  \
    \              case 'e' => 'g'\n                case 'i' => 'k'\n            \
    \    case 'o' => 'q'\n                case 'u' => 'y'\n                case 'A'\
    \ => 'C'\n                case 'E' => 'G'\n                case 'I' => 'K'\n \
    \               case 'O' => 'Q'\n                case 'U' => 'Y'\n           \
    \     case _ => if (x.isUpper) x.toLower else x.toUpper\n            })", "  \
    \      // Assumes only letters.\n        // Assumes a-z is contiguous.\n     \
    \   // Assumes punctuation and spaces stay the same.\n        var alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var vowels = \"aeiou\"\n        var encoded = new StringBuilder\n  \
    \      for (c <- message) {\n            if (vowels.contains(c.toLower)) {\n \
    \               val off = alpha.indexOf(c.toLower) + 2\n                val newC\
    \ = alpha.charAt(off % alpha.length)\n                encoded += newC.toUpper\n\
    \            } else {\n                val newC = if (c.isUpper) c.toLower else\
    \ c.toUpper\n                encoded += newC\n            }\n        }\n     \
    \   encoded.toString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n  \
    \      val shift = 2\n        val encoded = message.map(ch => \n            if\
    \ (vowels.contains(ch.toLower)) {\n                val shiftedCh = (ch.toLower\
    \ + shift) match {\n                    case 'y' => 'a'\n                    case\
    \ 'z' => 'b'\n                    case _ => (ch.toLower + shift).toChar\n    \
    \            }\n                (if (ch.isUpper) shiftedCh.toUpper else shiftedCh).toChar\n\
    \            } else if (ch.isUpper) ch.toLower else ch.toUpper)\n        encoded",
  "        var temp = message.map(x => x match {\n            case 'a' => 'c'\n  \
    \          case 'e' => 'g'\n            case 'i' => 'k'\n            case 'o'\
    \ => 'q'\n            case 'u' => 'w'\n            case 'A' => 'C'\n         \
    \   case 'E' => 'G'\n            case 'I' => 'K'\n            case 'O' => 'Q'\n\
    \            case 'U' => 'W'\n            case x if (x.isUpper) => x.toLower\n\
    \            case x if (x.isLower) => x.toUpper\n            case _ => x\n   \
    \     })\n        return temp.mkString", "        // Make a list of vowels\n \
    \       var vowels = List(\"a\", \"e\", \"i\", \"o\", \"u\")\n        // Loop\
    \ through each character in the string and \n        // swap the case and modify\
    \ the vowels\n        var s = \"\"\n        for (c <- message) {\n           \
    \ // For each character make the case change\n            if (c.isUpper) {\n \
    \               // Make it lower case\n                s += c.toLower\n      \
    \      } else {\n                // Make it upper case\n                s += c.toUpper\n\
    \            }\n            // Now check if the character is in the list of vowels\n\
    \            if (vowels.contains(s.last.toString)) {\n                // Get the\
    \ vowel index\n                var index = vowels.indexOf(s.last.toString)\n \
    \               // Remove the last character\n                s = s.dropRight(1)\n\
    \                // Add the new character after incrementing the index\n     \
    \           s += vowels((index + 2) % 5)\n            }\n        }\n        //\
    \ Return the encoded string\n        return s", "        val lowerAlpha : Array[Char]\
    \ = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n        val upperAlpha : Array[Char]\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray\n        val vowelIndices : Array[Int]\
    \ = Array(0, 4, 8, 14, 20)\n        val vowels : Array[Char] = \"AEIOU\".toCharArray\n\
    \        var result : String = \"\"\n        for (i <- 0 until message.length)\
    \ {\n            if (vowelIndices.contains(message(i))) {\n                val\
    \ charIndex : Int = lowerAlpha.indexOf(message(i).toLower)\n                val\
    \ newIndex : Int = (charIndex + 2) % 26\n                result += vowels(newIndex\
    \ / 5)\n            } else {\n                result += message(i)\n         \
    \   }\n        }\n        result", "      val message_array = message.toCharArray\n\
    \      val letter_dict = Array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n\
    \      var new_message = \"\"\n      for (c <- message_array) {\n        if (c.isLetter)\
    \ {\n          if (c.isUpper) {\n            new_message += letter_dict((letter_dict.indexOf(c.toLower)\
    \ + 2) % 26).toUpper\n          } else {\n            new_message += letter_dict((letter_dict.indexOf(c)\
    \ + 2) % 26)\n          }\n        } else {\n          new_message += c\n    \
    \    }\n      }\n      new_message", "        val vowels = \"aeiouAEIOU\"\n  \
    \      val vowels2 = \"cgjkqsCGFJKQS\"\n        val map = Map() ++ vowels.zip(vowels2)\n\
    \        var sb = new StringBuilder()\n        message.foreach(c => {\n      \
    \      if (vowels.contains(c)) {\n                sb += map(c)\n            }\
    \ else {\n                sb += c.toUpper\n            }\n        })\n       \
    \ sb.toString", "        // TODO\n        return \"\";", "        val vowels =\
    \ ('a' to 'z').filter(c => Set('a', 'e', 'i', 'o', 'u') contains c)\n        val\
    \ frequencies = ('a' to 'z').groupBy(c => c).map(x => (x._1, x._2.length))\n \
    \       val swaps = ('a' to 'z').map(c => (c, if (c.isUpper) c.toLower else c.toUpper))\n\
    \        val map = ('a' to 'z').zip(1 to 26).toMap\n        val shiftMap = ('a'\
    \ to 'z').zip(vowels).toMap\n        val shift = ('a' to 'z').map(c => map(c)\
    \ + 2).map(n => (n % 26).toString).map(s => s.replace(\"0\", \"26\")).map(s =>\
    \ if (s.length == 1) \"0\" + s else s).map(s => s.toInt)\n        val map2 = shift.zip(vowels).toMap\n\
    \        var res = \"\"\n        val s = message.toLowerCase\n        for (i <-\
    \ 0 until s.length) {\n            if (swaps.map(x => x._1).contains(s(i))) res\
    \ += swaps.find(x => x._1 == s(i)).get._2.toString\n            else if (shiftMap.map(x\
    \ => x._1).contains(s(i))) res += map2(map(s(i))).toString\n            else res\
    \ += s(i).toString\n        }\n        res", '        "TGST"', "        val chars\
    \ = ArrayBuffer[Char]()\n        val vowels = ArrayBuffer[Char]('a', 'e', 'i',\
    \ 'o', 'u')\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                chars += vowel(c)\n            } else if (Character.isUpperCase(c))\
    \ {\n                chars += Character.toLowerCase(c)\n            } else {\n\
    \                chars += Character.toUpperCase(c)\n            }\n        }\n\
    \        return chars.mkString", "        var result = \"\"\n        var v = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        for (x <- message) {\n            var\
    \ found = false\n            for (y <- v) {\n                if (y == x.toLowerCase.toString)\
    \ {\n                    var index = (message.indexOf(x) + 2) % message.length\n\
    \                    result += message(index)\n                    found = true\n\
    \                }\n            }\n            if (!found) {\n               \
    \ if (x.isUpper) result += x.toLower else result += x.toUpper\n            }\n\
    \        }\n        result", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        message.toLowerCase.map(c => {\n            if (vowels contains c) {\n\
    \                val nextVowel = {\n                    val next = vowels.toList.indexOf(c)\
    \ + 1\n                    if (next >= vowels.size) vowels.toList(0)\n       \
    \             else vowels.toList(next)\n                }\n                val\
    \ nextnextVowel = {\n                    val next = vowels.toList.indexOf(nextVowel)\
    \ + 1\n                    if (next >= vowels.size) vowels.toList(0)\n       \
    \             else vowels.toList(next)\n                }\n                if\
    \ (nextnextVowel == 'u') 'a'\n                else (nextnextVowel + 1).toChar\n\
    \            }\n            else {\n                if (c == 'z') 'a'\n      \
    \          else (c + 1).toChar\n            }\n        }).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "\t\t\treturn message.map(i => {\n\t\t\t\
    \tval letter = (i.toUpper - 65 + 2) % 26 + 65\n\t\t\t\tif (i.isUpper) letter.toChar\
    \ else (letter + 32).toChar\n\t\t\t})\n\t\t}\n\t\t\n\t\t// Write a function that\
    \ takes two objects and returns true \n\t\t// if they have the same value and\
    \ are of the same type.\n\t\t// Examples:\n\t\t// >>> equals(2, 2)\n\t\t// >>>\
    \ true\n\t\t// >>> equals(2, 3)\n\t\t// >>> false\n\t\t// >>> equals(\"test\"\
    , \"test\")\n\t\t// >>> true\n\t\t// >>> equals(\"test\", \"Test\")\n\t\t// >>>\
    \ false\n\t\t// >>> equals(true, true)\n\t\t// >>> true\n\t\t// >>> equals(false,\
    \ true)\n\t\t// >>> false\n\t\tdef equals(a : Any, b : Any) : Boolean = {\n\t\t\
    \treturn a == b\n\t\t}\n\t\t\n\t\t// Write a function that takes two parameters,\
    \ an array of \n\t\t// integers, and a target integer. It will return true if\
    \ \n\t\t// any two integers in the array sum to the target value.\n\t\t// Examples:\n\
    \t\t// >>> sum([1, 2, 3, 4, 5], 9)\n\t\t// >>> true\n\t\t// >>> sum([1, 2, 3,\
    \ 4, 5], 10)\n\t\t// >>> false\n\t\t// >>> sum([1, 2, 3, 4, 5], 8)\n\t\t// >>>\
    \ true\n\t\t// >>> sum([1, 2, 3, 4, 5], 7)\n\t\t// >>> true\n\t\t// >>> sum([1,\
    \ 2, 3, 4, 5], 6)\n\t\t// >>> true\n\t\t// >>> sum([1, 2, 3, 4, 5], 5)\n\t\t//\
    \ >>> true\n\t\t// >>> sum([1, 2, 3, 4, 5], 4)\n\t\t// >>> true\n\t\t// >>> sum([1,\
    \ 2, 3, 4, 5], 3)\n\t\t// >>> true\n\t\t// >>> sum([1, 2", "        return message.map(c\
    \ => (c.toLower match {\n            case 'a' => 'c'\n            case 'e' =>\
    \ 'g'\n            case 'i' => 'k'\n            case 'o' => 'q'\n            case\
    \ 'u' => 'y'\n            case _ => c.toUpper\n        })).mkString", "      \
    \  return message.map(c => {\n            if (c.isLower) c.toUpper else c.toLower\n\
    \        }).map(c => {\n            if (c == 'A') 'C'\n            else if (c\
    \ == 'E') 'G'\n            else if (c == 'I') 'K'\n            else if (c == 'O')\
    \ 'Q'\n            else if (c == 'U') 'W'\n            else c\n        })", " \
    \       val zipped = for (letter <- message) yield {\n            if (letter.isLower)\
    \ {\n                letter.toUpper\n            } else {\n                letter.toLower\n\
    \            }\n        }\n        val vowels = Set(\"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n        val map = HashMap(\"a\" -> \"c\", \"e\" -> \"g\", \"i\" -> \"\
    k\", \"o\" -> \"q\", \"u\" -> \"s\")\n        val encoded = for (letter <- zipped)\
    \ yield {\n            if (vowels.contains(letter.toLower)) {\n              \
    \  map(letter.toLower).toUpper\n            } else {\n                letter\n\
    \            }\n        }\n        encoded.mkString", "        val data = message.toUpperCase.map\
    \ {\n            c => if (\"AEIOU\".contains(c)) (c + 2).toChar else c\n     \
    \   }\n        data.map {c => if (c >= 'Z') (c - 24).toChar else c}.map {\n  \
    \          c => if (c.isUpper) c.toLower else c.toUpper\n        }.mkString",
  "    \tval alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    \tval mcase = message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper)\n    \tval mvowel = mcase.map(c\
    \ => if (\"aeiou\".contains(c)) alphabet(alphabet.indexOf(c) + 2) else c)\n  \
    \  \treturn mvowel", "        def isVowel(c : Char) : Boolean = {\n          \
    \  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n       \
    \ }\n        var sb = new StringBuilder\n        for (c <- message) {\n      \
    \      if (isVowel(c)) sb.append(c.toInt + 2)\n            else if (c.isUpper)\
    \ sb.append(c.toLower)\n            else sb.append(c.toUpper)\n        }\n   \
    \     return sb.toString", "        def encodeChar(c : Char) : Char = {\n    \
    \        val charIndex = c.toInt\n            if (charIndex >= 97 && charIndex\
    \ <= 122)\n                return ((c.toInt + 2 - 97) % 26 + 97).toChar\n    \
    \        else if (charIndex >= 65 && charIndex <= 90)\n                return\
    \ ((c.toInt + 2 - 65) % 26 + 65).toChar\n            else\n                return\
    \ c\n        }\n        val l = message.length\n        val result = new Array[Char](l)\n\
    \        for (i <- 0 until l) {\n            val c = message(i)\n            result(i)\
    \ = encodeChar(c)\n        }\n        return result.mkString", "        message.map(char\
    \ => char match {\n            case x if (x.isLower) => x.toUpper\n          \
    \  case x if (x.isUpper) => x.toLower\n            case x if (x == 'a') => 'c'\n\
    \            case x if (x == 'e') => 'g'\n            case x if (x == 'i') =>\
    \ 'k'\n            case x if (x == 'o') => 'q'\n            case x if (x == 'u')\
    \ => 'y'\n            case x if (x == 'A') => 'C'\n            case x if (x ==\
    \ 'E') => 'G'\n            case x if (x == 'I') => 'K'\n            case x if\
    \ (x == 'O') => 'Q'\n            case x if (x == 'U') => 'Y'\n            case\
    \ x => x\n        })", "        var result = \"\"\n        for (ch <- message)\
    \ {\n            var new_ch = ch\n            if (ch >= 'a' && ch <= 'z') {\n\
    \                new_ch = 'A' + (ch - 'a')\n            } else if (ch >= 'A' &&\
    \ ch <= 'Z') {\n                new_ch = 'a' + (ch - 'A')\n            }\n   \
    \         if (new_ch == 'a') {\n                new_ch = 'c'\n            } else\
    \ if (new_ch == 'e') {\n                new_ch = 'g'\n            } else if (new_ch\
    \ == 'i') {\n                new_ch = 'k'\n            } else if (new_ch == 'o')\
    \ {\n                new_ch = 'q'\n            } else if (new_ch == 'u') {\n \
    \               new_ch = 'y'\n            } else if (new_ch == 'A') {\n      \
    \          new_ch = 'C'\n            } else if (new_ch == 'E') {\n           \
    \     new_ch = 'G'\n            } else if (new_ch == 'I') {\n                new_ch\
    \ = 'K'\n            } else if (new_ch == 'O') {\n                new_ch = 'Q'\n\
    \            } else if (new_ch == 'U') {\n                new_ch = 'Y'\n     \
    \       }\n            result += new_ch\n        }\n        result", "       \
    \ var result = \"\"\n        val vowels = Set('a', 'e', 'i', 'o', 'u')\n     \
    \   for (letter <- message) {\n            val isVowel = vowels.contains(letter.toLower)\n\
    \            val encoded = if (isVowel) {\n                val index = (vowels.indexOf(letter.toLower)\
    \ + 2) % vowels.size\n                if (letter.isUpper) vowels.toList(index).toUpper\
    \ else vowels.toList(index)\n            } else if (letter.isUpper) letter.toLower\
    \ else letter.toUpper\n            result += encoded\n        }\n        result",
  "        var encoded = \"\"\n        for (letter <- message) {\n            if (isVowel(letter))\
    \ {\n                val index = getVowelIndex(letter)\n                if (index\
    \ < 0) encoded += letter\n                else {\n                    val next\
    \ = nextVowel(index)\n                    encoded += next\n                }\n\
    \            }\n            else encoded += letter\n        }\n        return\
    \ encoded", "        val result = new StringBuilder\n        val alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n        val vowels = List('a', 'e', 'i', 'o', 'u')\n\
    \        val encodedVowels = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q',\
    \ 'u' -> 'y')\n        val reverseEncodedVowels = Map('c' -> 'a', 'g' -> 'e',\
    \ 'k' -> 'i', 'q' -> 'o', 'y' -> 'u')\n        val reverseMap = vowels.map(c =>\
    \ {(encodedVowels(c), c)}).toMap\n        val encodedAlphabet = alphabet.map(c\
    \ => if (reverseEncodedVowels.contains(c)) reverseEncodedVowels(c) else c)\n \
    \       message.foreach(c => {\n            val lowerC = c.toLower\n         \
    \   val shiftC = if (vowels.contains(lowerC)) encodedVowels(lowerC) else c\n \
    \           val shiftIndex = alphabet.indexOf(shiftC)\n            val encodedIndex\
    \ = if (shiftIndex == -1) {shiftIndex} else {(shiftIndex + 2) % alphabet.length}\n\
    \            val encodedC = if (encodedIndex == -1) {lowerC} else {encodedAlphabet(encodedIndex)}\n\
    \            result.append(if (c.isUpper) encodedC.toUpper else encodedC)\n  \
    \      })\n        result.toString", "\t\t// shift 1st a, then e, then i, then\
    \ o, then u\n\t\t// shift A, then E, then I, then O, then U\n\t\tdef encoder(c\
    \ : Char) : Char = {\n\t\t\tvar map = Map(\n\t\t\t\t'a' -> 'c',\n\t\t\t\t'e' ->\
    \ 'g',\n\t\t\t\t'i' -> 'k',\n\t\t\t\t'o' -> 'q',\n\t\t\t\t'u' -> 'y',\n\t\t\t\t\
    'A' -> 'C',\n\t\t\t\t'E' -> 'G',\n\t\t\t\t'I' -> 'K',\n\t\t\t\t'O' -> 'Q',\n\t\
    \t\t\t'U' -> 'Y'\n\t\t\t)\n\t\t\tif (map.contains(c)) map(c) else c\n\t\t}\n\t\
    \tval sb = new StringBuilder\n\t\tfor (c <- message) {\n\t\t\tval e = encoder(c)\n\
    \t\t\tval r = if (c.isUpper) e.toUpper else e.toLower\n\t\t\tsb.append(r)\n\t\t\
    }\n\t\tsb.toString", "        //encode(\"test\") should be(\"TGST\")\n       \
    \ var res = \"\"\n        val vowels = Map(\"a\" -> \"c\", \"e\" -> \"g\", \"\
    i\" -> \"k\", \"o\" -> \"q\", \"u\" -> \"w\")\n        for (i <- 0 until message.length)\
    \ {\n            if (message(i).isUpper) {\n                val c = message(i).toLower\n\
    \                if (vowels.contains(c.toString)) res += vowels(c.toString).toUpper\n\
    \                else res += c.toUpper\n            }\n            else {\n  \
    \              val c = message(i)\n                if (vowels.contains(c.toString))\
    \ res += vowels(c.toString)\n                else res += c\n            }\n  \
    \      }\n        res", "      val vowels = Set('a', 'e', 'i', 'o', 'u')\n   \
    \   message.map(x => if (vowels contains x.toLower) (((x.toLower - 96 + 2) % 26)\
    \ + 96).toChar else x)\n                .map(x => if (x.isLower) x.toUpper else\
    \ x.toLower)", "        val vowels = \"aeiouAEIOU\"\n        val alphabet = \"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        def step(c : Char)\
    \ : Char = {\n            c match {\n                case 'z' => 'b'\n       \
    \         case 'Z' => 'B'\n                case _ => alphabet((alphabet.indexOf(c)\
    \ + 2) % 52)\n            }\n        }\n        message.map(c => if (vowels.contains(c))\
    \ step(c) else c)", "\t\tval map = new HashMap[Char,Char]()\n\t\tfor (i <- 0 until\
    \ 26) {\n\t\t\tmap += (('a' + i).toChar -> ('c' + i).toChar)\n\t\t\tmap += (('A'\
    \ + i).toChar -> ('C' + i).toChar)\n\t\t}\n\t\tfor (i <- 0 until 26) {\n\t\t\t\
    map += (('c' + i).toChar -> ('e' + i).toChar)\n\t\t\tmap += (('C' + i).toChar\
    \ -> ('E' + i).toChar)\n\t\t}\n\t\tfor (i <- 0 until 26) {\n\t\t\tmap += (('e'\
    \ + i).toChar -> ('g' + i).toChar)\n\t\t\tmap += (('E' + i).toChar -> ('G' + i).toChar)\n\
    \t\t}\n\t\tfor (i <- 0 until 26) {\n\t\t\tmap += (('g' + i).toChar -> ('i' + i).toChar)\n\
    \t\t\tmap += (('G' + i).toChar -> ('I' + i).toChar)\n\t\t}\n\t\tfor (i <- 0 until\
    \ 26) {\n\t\t\tmap += (('i' + i).toChar -> ('k' + i).toChar)\n\t\t\tmap += (('I'\
    \ + i).toChar -> ('K' + i).toChar)\n\t\t}\n\t\tfor (i <- 0 until 26) {\n\t\t\t\
    map += (('k' + i).toChar -> ('m' + i).toChar)\n\t\t\tmap += (('K' + i).toChar\
    \ -> ('M' + i).toChar)\n\t\t}\n\t\tfor (i <- 0 until 26) {\n\t\t\tmap += (('m'\
    \ + i).toChar -> ('o' + i).toChar)\n\t\t\tmap += (('M' + i).toChar -> ('O' + i).toChar)\n\
    \t\t}\n\t\tfor (i <- 0 until 26) {\n\t\t\tmap += (('o' + i).toChar -> ('q' + i).to",
  "        message.map(c => if (c.isUpper) c.toLower else c.toUpper)\n           \
    \ .map(c => if (c.isLetter)\n                (c.toInt + 2).toChar\n          \
    \  else\n                c)", "        val vowelMap = Map('A' -> 'C', 'E' -> 'G',\
    \ 'I' -> 'K', 'O' -> 'Q', 'U' -> 'Y')\n        val charList = message.toCharArray\n\
    \        for (i <- 0 until charList.length) {\n            if (charList(i).isLetter)\
    \ {\n                charList(i) = charList(i).toUpper\n                charList(i)\
    \ = if (charList(i).isLower) charList(i).toUpper else charList(i).toLower\n  \
    \              charList(i) = if (vowelMap.contains(charList(i))) vowelMap(charList(i))\
    \ else charList(i)\n            }\n        }\n        charList.mkString", "  \
    \      val vowels = \"aeiou\"\n        message.map(x => if (vowels.contains(x.toLower))\
    \ vowels((vowels.indexOf(x.toLower) + 2) % 5) else x)", "        val alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray.map(_.toString)\n        val vowels\
    \ = List(\"A\", \"E\", \"I\", \"O\", \"U\")\n        val message_up = message.toUpperCase\n\
    \        message_up.map(ch => if (vowels.contains(ch.toString)) alphabet((alphabet.indexOf(ch.toString)\
    \ + 2) % 26) else ch.toString).map(ch => if (ch.isUpper) ch.toLowerCase else ch.toUpperCase).mkString",
  "        message.map(c => {\n            if (c.isUpper) {\n                if (c\
    \ == 'Z') 'B'\n                else if (c == 'Y') 'A'\n                else {\n\
    \                    c match {\n                        case 'A' => 'C'\n    \
    \                    case 'E' => 'G'\n                        case 'I' => 'K'\n\
    \                        case 'O' => 'Q'\n                        case 'U' =>\
    \ 'W'\n                        case _ => c + 2\n                    }\n      \
    \          }\n            }\n            else {\n                if (c == 'z')\
    \ 'b'\n                else if (c == 'y') 'a'\n                else {\n      \
    \              c match {\n                        case 'a' => 'c'\n          \
    \              case 'e' => 'g'\n                        case 'i' => 'k'\n    \
    \                    case 'o' => 'q'\n                        case 'u' => 'w'\n\
    \                        case _ => c + 2\n                    }\n            \
    \    }\n            }\n        })", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        // must pad\n        val\
    \ padding = message.length % 5\n        val padded = message + (\" \" * padding)\n\
    \        val letterStream = padded.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                alphabet(((alphabet.indexOf(c.toLower) + 2) % 26))\n    \
    \        } else {\n                c\n            }\n        })\n        val (a,\
    \ b, c, d, e) = (letterStream(0), letterStream(1), letterStream(2), letterStream(3),\
    \ letterStream(4))\n        val encoded = padded.zipWithIndex.map(i => {\n   \
    \         val p = i._2 % 5\n            if (p == 0) {\n                if (i._1.isUpper)\
    \ b.toUpper else b\n            } else if (p == 1) {\n                if (i._1.isUpper)\
    \ c.toUpper else c\n            } else if (p == 2) {\n                if (i._1.isUpper)\
    \ d.toUpper else d\n            } else if (p == 3) {\n                if (i._1.isUpper)\
    \ e.toUpper else e\n            } else {\n                if (i._1.isUpper) a.toUpper\
    \ else a\n            }\n        })\n        encoded.mkString", '        return
    ""', "        message.map {\n            case c if c.isUpper => c.toLower\n  \
    \          case c if c.isLower => c.toUpper\n            case c => c\n       \
    \ }.map {\n            case c if c.isLetter =>\n                val newLetterIndex\
    \ = (c.toInt + 2 - 'a'.toInt) % 26 + 'a'.toInt\n                newLetterIndex.toChar\n\
    \            case c => c\n        }", "        // Swap case\n        // Replace\
    \ all vowels\n        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        def charAt(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = (vowels.indexOf(c) + 2) % vowels.length\n   \
    \             vowels(index)\n            } else if (alphabet.contains(c)) {\n\
    \                val index = (alphabet.indexOf(c) + 2) % alphabet.length\n   \
    \             alphabet(index)\n            } else c\n        }\n        message.map(c\
    \ => charAt(c.toLower))", "        val vowelMap = Map('a' -> 'c', 'e' -> 'g',\
    \ 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val letterMap = message.map(c =>\
    \ if (c.isLower) c.toUpper else c.toLower)\n        val encoded = letterMap.map(c\
    \ => if (vowelMap.contains(c)) vowelMap(c) else c)\n        encoded", "      \
    \  var letterSet = \"abcdefghijklmnopqrstuvwxyz\"\n        var encodedMessage\
    \ = \"\"\n        for (i <- 0 until message.length) {\n            val c = message(i)\n\
    \            if (c == ' ') {\n                encodedMessage += ' '\n        \
    \    } else {\n                var newIndex = (letterSet.indexOf(c.toLower) +\
    \ 2) % 26\n                encodedMessage += (if (c.isUpper) letterSet(newIndex).toUpper\
    \ else letterSet(newIndex))\n            }\n        }\n        encodedMessage",
  "      var res = \"\";\n      for (c <- message) {\n        res += encode(c);\n\
    \      }\n      return res;", "      val swapCase = message.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper)\n      val plainVowels = List(\"a\", \"e\", \"i\"\
    , \"o\", \"u\")\n      val cipherVowels = List(\"c\", \"g\", \"k\", \"o\", \"\
    s\")\n      swapCase.map(c => {\n        val index = plainVowels.indexOf(c.toLower.toString)\n\
    \        if (index != -1) {\n          cipherVowels(index)\n        } else {\n\
    \          c\n        }\n      })", "        var result = new StringBuilder\n\
    \        for (c <- message) c match {\n            case 'a' => result += 'c'\n\
    \            case 'A' => result += 'C'\n            case 'e' => result += 'g'\n\
    \            case 'E' => result += 'G'\n            case 'i' => result += 'k'\n\
    \            case 'I' => result += 'K'\n            case 'o' => result += 'q'\n\
    \            case 'O' => result += 'Q'\n            case 'u' => result += 'y'\n\
    \            case 'U' => result += 'Y'\n            case x if (x >= 'A' && x <=\
    \ 'Z') => result += ((x + 2 - 'A') % 26 + 'A').toChar\n            case x if (x\
    \ >= 'a' && x <= 'z') => result += ((x + 2 - 'a') % 26 + 'a').toChar\n       \
    \     case _ => result += c\n        }\n        result.toString", "        //\
    \ Solution method provided.\n        // This function applies two functions to\
    \ a character and returns\n        // the character.\n        def modify(c : Char,\
    \ f1 : Char => Char, f2 : Char => Char) : Char = {\n            if (isUpper(c))\
    \ { f1(c) } else { f2(c) }\n        }\n        // This function maps a character,\
    \ to the next character that\n        // follows it, with respect to its case\
    \ (Upper or Lower)\n        def shift(c : Char) : Char = {\n            val alphabet\
    \ : String = \"abcdefghijklmnopqrstuvwxyz\"\n            modify(c, \n        \
    \           { c => alphabet((alphabet.indexOf(c.toLower) + 2) % 26).toUpper },\n\
    \                   { c => alphabet((alphabet.indexOf(c) + 2) % 26) })\n     \
    \   }\n        // This function converts a character to its upper or lower case\n\
    \        // equivalent, depending on its current case.\n        def swap(c : Char)\
    \ : Char = {\n            modify(c, { toLower(_) }, { toUpper(_) })\n        }\n\
    \        // This function iterates through the message, and applies two \n   \
    \     // functions to each character, to transform it.\n        def transform(message\
    \ : String, f1 : Char => Char, f2 : Char => Char) : String = {\n            message.map(c\
    \ => modify(c, f1, f2))\n        }\n        // First, we apply the swap function\
    \ to all characters in the message\n        // Then, we apply the shift function\
    \ to all vowels in the modified message\n        transform(transform(message,\
    \ { swap(_) }, { swap(_) }), { shift(_) }, { a => a })", '        null', "   \
    \     val vowels = List(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var map =\
    \ new HashMap[String, String]()\n        map += \"a\" -> \"c\"\n        map +=\
    \ \"e\" -> \"g\"\n        map += \"i\" -> \"k\"\n        map += \"o\" -> \"q\"\
    \n        map += \"u\" -> \"y\"\n        return message.toList.map(x => {\n  \
    \          if (vowels.contains(x.toString.toLowerCase)) {\n                if\
    \ (map.contains(x.toString.toLowerCase))\n                    map(x.toString.toLowerCase)\n\
    \                else if (x.isUpper) {\n                    x.toString.toLowerCase\n\
    \                } else {\n                    x.toString.toUpperCase\n      \
    \          }\n            } else {\n                if (x.isUpper) {\n       \
    \             x.toString.toLowerCase\n                } else {\n             \
    \       x.toString.toUpperCase\n                }\n            }\n        }).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        def encode(c : Char)\
    \ : Char = {\n            if (vowels.contains(c)) {\n                val n = (c.toInt\
    \ + 2) % 'z'\n                if (n > 'z' - 2) n + 'a' - 'z' + 1 else n\n    \
    \        } else {\n                if (c.isUpper) c.toLower else c.toUpper\n \
    \           }\n        }\n        message.map(encode(_))", "        var res =\
    \ message.map(c => {\n            if (c.isUpper) c.toLower else c.toUpper\n  \
    \      })\n        res = res.map(c => {\n            if (\"aeiou\".contains(c))\
    \ {\n                val index = \"aeiou\".indexOf(c)\n                val next\
    \ = \"aeiou\".charAt((index + 2) % 5)\n                if (c.isUpper) next.toUpper\
    \ else next\n            } else c\n        })\n        res", "        val vowels\
    \ = \"AEIOUaeiou\"\n        val alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \n        // Map<Char, Char> map = new HashMap<Char, Char>();\n        val map\
    \ = HashMap[Char, Char]()\n        vowels.zipWithIndex.foreach(x => {\n      \
    \      map(x._1) = vowels((x._2 + 2) % vowels.length)\n        })\n        message.map(x\
    \ => {\n            if (vowels.contains(x)) map(x)\n            else if (alphabet.contains(x))\
    \ alphabet((alphabet.indexOf(x) + alphabet.length / 2) % alphabet.length)\n  \
    \          else x\n        })", "    \tdef swapCase(c : Char) : Char = if (c.isUpper)\
    \ c.toLower else c.toUpper\n    \tdef encodeVowel(c : Char) : Char = c match {\n\
    \    \t\tcase 'a' => 'c'\n    \t\tcase 'e' => 'g'\n    \t\tcase 'i' => 'k'\n \
    \   \t\tcase 'o' => 'q'\n    \t\tcase 'u' => 'w'\n    \t\tcase _ => c\n    \t\
    }\n    \tmessage.map(swapCase).map(encodeVowel)", "\t\t// TODO\n\t\treturn null",
  "        val map = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',\
    \ 'y' -> 'a')\n        val buffer = new StringBuilder\n        for (c <- message)\
    \ {\n            if (map.contains(c.toLower)) buffer.append(map(c.toLower))\n\
    \            else buffer.append(c)\n        }\n        buffer.toString", "   \
    \     var a = Array(\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"\
    O\", \"U\")\n        val s = message.map(ch => {\n            if (a.contains(ch.toString))\
    \ {\n                var c = a.indexOf(ch.toString) + 2\n                if (c\
    \ > 9) {\n                    c = c - 5\n                }\n                a(c)\n\
    \            } else {\n                if (ch.isUpper) {\n                   \
    \ ch.toLower.toString\n                } else {\n                    ch.toUpper.toString\n\
    \                }\n            }\n        })\n        s.mkString", "        var\
    \ encodeMessage = \"\"\n        val vowels = Array('a', 'e', 'i', 'o', 'u')\n\
    \        for (character <- message) {\n            if (vowels.contains(character.toLower))\
    \ {\n                val newChar = getNthLetter(character, 2)\n              \
    \  encodeMessage += newChar\n            } else {\n                encodeMessage\
    \ += character\n            }\n        }\n        return encodeMessage", "   \
    \     val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        val codes =\
    \ for (c <- message) yield c match {\n            case 'a' => 'c'\n          \
    \  case 'e' => 'g'\n            case 'i' => 'k'\n            case 'o' => 'q'\n\
    \            case 'u' => 's'\n            case x if ('a' to 'z').contains(x) =>\
    \ (x - 'a' + 2) % 26 + 'a'\n            case x if ('A' to 'Z').contains(x) =>\
    \ (x - 'A' + 2) % 26 + 'A'\n            case x => x\n        }\n        codes.mkString",
  "        val alphabets = \"abcdefghijklmnopqrstuvwxyz\"\n        val vowels = \"\
    aeiou\"\n        val map = new HashMap[Char, Int]()\n        for (i <- 0 until\
    \ alphabets.length) {\n            map(alphabets(i)) = i\n        }\n        val\
    \ vowelsIndex = new HashMap[Char, Int]()\n        for (i <- 0 until vowels.length)\
    \ {\n            vowelsIndex(vowels(i)) = i\n        }\n        def mapToChar(i\
    \ : Int) : Char = {\n            map.toSeq.sortBy(_._2).toMap.toList(i)._1\n \
    \       }\n        message.map(e => {\n            if (!map.contains(e)) e\n \
    \           else if (e.isUpper) mapToChar(map(e.toLower) + 13).toUpper\n     \
    \       else if (vowelsIndex.contains(e)) mapToChar(vowelsIndex(e) + 2)\n    \
    \        else mapToChar(map(e) + 13)\n        })", "        message.map(c => {\n\
    \            if (c.isUpper) c.toLower\n            else if (c.isLower) c.toUpper\n\
    \            else c\n        }).map(c => {\n            if (c == 'a') 'c'\n  \
    \          else if (c == 'e') 'g'\n            else if (c == 'i') 'k'\n      \
    \      else if (c == 'o') 'q'\n            else if (c == 'u') 'y'\n          \
    \  else c\n        })", "\tval vowelMap = (('a', 'c'), ('e', 'g'), ('i', 'k'),\
    \ ('o', 'q'), ('u', 'w'))\n\tvar encodedString = \"\"\n\tvar i = 0\n\twhile (i\
    \ < message.length) {\n\t    if (message(i).isLetter) {\n\t\tif (message(i).isUpper)\
    \ {\n\t\t    if (vowelMap.exists(c => c._1 == message(i).toLower)) {\n\t\t\tencodedString\
    \ += vowelMap.find(c => c._1 == message(i).toLower).get._2.toUpper\n\t\t    }\
    \ else {\n\t\t\tencodedString += message(i).toLower\n\t\t    }\n\t\t} else {\n\
    \t\t    if (vowelMap.exists(c => c._1 == message(i))) {\n\t\t\tencodedString +=\
    \ vowelMap.find(c => c._1 == message(i)).get._2\n\t\t    } else {\n\t\t\tencodedString\
    \ += message(i).toUpper\n\t\t    }\n\t\t}\n\t    } else {\n\t\tencodedString +=\
    \ message(i)\n\t    }\n\t    i += 1\n\t}\n\tencodedString", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val mapping = Map('e' -> 'g', 'o' ->\
    \ 'q', 'a' -> 'c', 'i' -> 'k', 'u' -> 'w')\n        message.toLowerCase.map(c\
    \ => {\n            if (vowels.contains(c)) {\n                mapping(c)\n  \
    \          } else {\n                c\n            }\n        }).mkString(\"\"\
    )", '        // your code here', "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        def encodeChar(c : Char) : Char = {\n            val offset =\
    \ if (vowels.contains(c.toLower)) 2 else 0\n            ((c.toLower + offset)\
    \ % 'z').toChar\n        }\n        message.map(encodeChar)", "        val vowelMap\
    \ = List('a', 'e', 'i', 'o', 'u')\n        var result = new StringBuilder(\"\"\
    )\n        for (c <- message) {\n            if (vowelMap.contains(c.toLower))\
    \ {\n                val index = (vowelMap.indexOf(c.toLower) + 2) % 5\n     \
    \           if (c.isUpper) result += vowelMap(index).toUpper else result += vowelMap(index)\n\
    \            } else if (c.isUpper) result += c.toLower else result += c.toUpper\n\
    \        }\n        result.toString", "        // Fill in the code here\n    \
    \    return \"\";", "        message.toUpperCase().map(ch => if(ch.isUpper) {\n\
    \        \tif(ch >= 'A' && ch <= 'M') (ch + 2).toChar\n        \telse if(ch >=\
    \ 'N' && ch <= 'Z') (ch - 24).toChar\n        \telse if(ch == 'A') 'C'\n     \
    \   \telse if(ch == 'E') 'G'\n        \telse if(ch == 'I') 'K'\n        \telse\
    \ if(ch == 'O') 'Q'\n        \telse if(ch == 'U') 'S'\n        \telse ch\n   \
    \     } else {\n        \tif(ch >= 'a' && ch <= 'm') (ch + 2).toChar\n       \
    \ \telse if(ch >= 'n' && ch <= 'z') (ch - 24).toChar\n        \telse if(ch ==\
    \ 'a') 'c'\n        \telse if(ch == 'e') 'g'\n        \telse if(ch == 'i') 'k'\n\
    \        \telse if(ch == 'o') 'q'\n        \telse if(ch == 'u') 's'\n        \t\
    else ch\n        })", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n  \
    \      val alpha = List('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n\
    \        val alphaMap = (alpha zip alpha.tail).toMap\n        val alphaMap2 =\
    \ (alpha zip alpha.tail.tail).toMap\n        def encodeLetter(l : Char) : Char\
    \ = {\n            if (vowels.contains(l)) alphaMap2(l)\n            else alphaMap(l)\n\
    \        }\n        val encoded = message.map(l => if (l.isUpper) encodeLetter(l.toLower).toUpper\
    \ else encodeLetter(l))\n        encoded", '        // your code goes here', " \
    \       val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var output = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val pos = alphabet.indexOf(c.toLower)\n                output\
    \ += alphabet(if (pos + 2 > alphabet.length - 1) pos + 2 - alphabet.length else\
    \ pos + 2)\n            } else {\n                output += c.toLower\n      \
    \      }\n        }\n        output.toUpperCase", "        def shift(c : Char)\
    \ : Char = (if (c.isUpper) 'A' else 'a') + ((c - (if (c.isUpper) 'A' else 'a')\
    \ + 2) % 26)\n        def map(c : Char) : Char = if (Set('a', 'e', 'i', 'o', 'u',\
    \ 'A', 'E', 'I', 'O', 'U').contains(c)) shift(c) else c\n        message.map(map(_)).map(if\
    \ (_.isUpper) _.toLower else _.toUpper)", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        message.toLowerCase.map(c\
    \ => {\n            if (vowels.contains(c.toString)) alphabet((alphabet.indexOf(c)\
    \ + 2) % alphabet.length)\n            else c\n        }).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        var s = \"\"\n        for (c <-\
    \ message) {\n            if (c >= 'a' && c <= 'z') {\n                s += ('A'\
    \ + c - 'a').toChar\n            } else if (c >= 'A' && c <= 'Z') {\n        \
    \        s += ('a' + c - 'A').toChar\n            } else {\n                s\
    \ += c\n            }\n        }\n        var t = \"\"\n        for (c <- s) {\n\
    \            if (c == 'a') {\n                t += 'c'\n            } else if\
    \ (c == 'e') {\n                t += 'g'\n            } else if (c == 'i') {\n\
    \                t += 'k'\n            } else if (c == 'o') {\n              \
    \  t += 'q'\n            } else if (c == 'u') {\n                t += 'y'\n  \
    \          } else {\n                t += c\n            }\n        }\n      \
    \  t", "        var result = \"\"\n        for (c <- message) {\n            if\
    \ (c.isLetter) {\n                val charAsInt = c.toInt\n                val\
    \ res = if (c.isUpper) {\n                    (charAsInt + 13) % 65 % 26 + 65\n\
    \                } else {\n                    (charAsInt + 13) % 97 % 26 + 97\n\
    \                }\n                if (isVowel(res.toChar)) {\n             \
    \       val num = (res + 2) % 26\n                    result += num.toChar\n \
    \               } else {\n                    result += res.toChar\n         \
    \       }\n            } else {\n                result += c\n            }\n\
    \        }\n        result", "        // \"vowels\" is a set of all vowels\n \
    \       val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        // \"special_chars\"\
    \ is a set of all special characters\n        val special_chars = Set(\" \", \"\
    '\", \".\")\n        // \"alphabet\" is a map of all alphabet letters to corresponding\
    \ letters\n        val alphabet = Map(\"a\" -> \"c\", \"b\" -> \"d\", \"c\" ->\
    \ \"e\", \"d\" -> \"f\", \"e\" -> \"g\",\n                           \"f\" ->\
    \ \"h\", \"g\" -> \"i\", \"h\" -> \"j\", \"i\" -> \"k\", \"j\" -> \"l\",\n   \
    \                        \"k\" -> \"m\", \"l\" -> \"n\", \"m\" -> \"o\", \"n\"\
    \ -> \"p\", \"o\" -> \"q\",\n                           \"p\" -> \"r\", \"q\"\
    \ -> \"s\", \"r\" -> \"t\", \"s\" -> \"u\", \"t\" -> \"v\",\n                \
    \           \"u\" -> \"w\", \"v\" -> \"x\", \"w\" -> \"y\", \"x\" -> \"z\", \"\
    y\" -> \"a\",\n                           \"z\" -> \"b\")\n        // \"encoded_message\"\
    \ is a sequence of characters in the encoded message\n        var encoded_message\
    \ = new ListBuffer[Char]()\n        // Iterate through each character in the message\n\
    \        for (ch <- message) {\n            // If the character is a letter, swap\
    \ case, and if it is a vowel, replace it\n            // with a letter that appears\
    \ 2 places ahead of that vowel in the english alphabet\n            // Note: All\
    \ non-letters remain unchanged\n            if (ch.isLetter) {\n             \
    \   if (vowels.contains(ch.toLower.toString)) {\n                    if (ch.isUpper)\
    \ {\n                        encoded_message += alphabet(ch.toLower.toString).toUpper\n\
    \                    } else {\n                        encoded_message += alphabet(ch.toLower.toString)\n\
    \                    }\n                } else {\n                    if (ch.isUpper)\
    \ {\n                        encoded_message += ch.toLower\n                 \
    \   } else {\n                        encoded_message +=", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        def nextVowel(x : Char) : Char = {\n\
    \            val code = x - 'a'\n            val isVowel = code % 5 == 0\n   \
    \         val next = if (isVowel) code + 2 else code + 1\n            ('a' + (next\
    \ % 26)).toChar\n        }\n        message.map(nextVowel).map(c => if (vowels.contains(c))\
    \ c.toUpper else c.toLower)", "        return message.map(v => v match {\n   \
    \         case a if \"aeiou\".contains(a) => ('a' + (a - 'a' + 2) % 26).toChar\n\
    \            case b if \"AEIOU\".contains(b) => ('A' + (b - 'A' + 2) % 26).toChar\n\
    \            case c if \"abcdefghijklmnopqrstuvwxyz\".contains(c) => ('a' + (c\
    \ - 'a' + 2) % 26).toChar\n            case d if \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .contains(d) => ('A' + (d - 'A' + 2) % 26).toChar\n            case _ => v\n \
    \       })", "        val lowerCaseLetters = new Range('a', 'z' + 1, 1).toList.mkString\n\
    \        val upperCaseLetters = new Range('A', 'Z' + 1, 1).toList.mkString\n \
    \       val vowels = \"aeiouAEIOU\"\n        var i = 0\n        var encoded =\
    \ \"\"\n        for (i <- 0 until message.length) {\n            if (vowels.contains(message(i)))\
    \ {\n                if (message(i).isUpper) {\n                    val currentIndex\
    \ = upperCaseLetters.indexOf(message(i))\n                    encoded += upperCaseLetters((currentIndex\
    \ + 2) % 26)\n                } else {\n                    val currentIndex =\
    \ lowerCaseLetters.indexOf(message(i))\n                    encoded += lowerCaseLetters((currentIndex\
    \ + 2) % 26)\n                }\n            } else {\n                if (message(i).isUpper)\
    \ {\n                    val currentIndex = upperCaseLetters.indexOf(message(i))\n\
    \                    encoded += lowerCaseLetters(currentIndex)\n             \
    \   } else {\n                    val currentIndex = lowerCaseLetters.indexOf(message(i))\n\
    \                    encoded += upperCaseLetters(currentIndex)\n             \
    \   }\n            }\n        }\n        encoded", "        var result = \"\"\n\
    \        for (c <- message) {\n            if (c.isUpper) result += 'a' + (c -\
    \ 'A' + 2) % 26\n            else if (c.isLower) result += 'A' + (c - 'a' + 2)\
    \ % 26\n            else result += c\n        }\n        result", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        var builder = new StringBuilder(message.length)\n\
    \        for (c <- message) {\n            builder.append(if (vowels contains\
    \ c.toLower) {\n                ((c.toLower - 'a' + 2) % 26 + 'a').toChar\n  \
    \          } else if (c.isUpper) {\n                c.toLower\n            } else\
    \ {\n                c.toUpper\n            })\n        }\n        builder.toString",
  "        val vowels = \"AEIOUaeiou\"\n        var result = \"\"\n        for (i\
    \ <- 0 until message.length) {\n            val x = message(i)\n            if\
    \ (vowels.contains(x)) {\n                val index = (vowels.indexOf(x) + 2)\
    \ % vowels.length\n                result += vowels(index)\n            } else\
    \ if (x.isLower) {\n                result += x.toUpper\n            } else {\n\
    \                result += x.toLower\n            }\n        }\n        result",
  "        if (message.isEmpty) \"\"\n        else {\n            val vowels = \"\
    aeiou\"\n            if (vowels.contains(message.head.toLower)) {\n          \
    \      val index = vowels.indexOf(message.head.toLower)\n                val c\
    \ = if (index < 3) vowels((index + 2) % 5) else vowels(index - 3)\n          \
    \      c.toUpper.toString + encode(message.tail)\n            }\n            else\
    \ {\n                message.head.toString + encode(message.tail)\n          \
    \  }\n        }", "    \tval vowels = List('a', 'e', 'i', 'o', 'u')\n    \tvar\
    \ result = \"\"\n    \tfor (ch <- message) result += (ch match {\n    \t\tcase\
    \ letter if vowels.contains(letter.toLower) => (letter.toLower - 'a' + 2) % 5\
    \ match {\n    \t\t\tcase 0 => 'a'\n    \t\t\tcase 1 => 'e'\n    \t\t\tcase 2\
    \ => 'i'\n    \t\t\tcase 3 => 'o'\n    \t\t\tcase 4 => 'u'\n    \t\t}\n    \t\t\
    case letter if letter.isUpper => letter.toLower\n    \t\tcase letter if letter.isLower\
    \ => letter.toUpper\n    \t\tcase anything => anything\n    \t})\n    \tresult",
  "        val vowels = Array(\"a\", \"e\", \"i\", \"o\", \"u\")\n        val Vowels\
    \ = Array(\"A\", \"E\", \"I\", \"O\", \"U\")\n        var vowelsMap = Map[String,\
    \ String]()\n        for (i <- 0 until vowels.length) {\n            var v = vowels(i)\n\
    \            var V = Vowels(i)\n            var v2 = vowels((i + 2) % vowels.length)\n\
    \            var V2 = Vowels((i + 2) % vowels.length)\n            vowelsMap +=\
    \ (v -> v2)\n            vowelsMap += (V -> V2)\n        }\n        var result\
    \ = \"\"\n        for (c <- message) {\n            if (vowelsMap.contains(c.toString))\
    \ result += vowelsMap(c.toString)\n            else if (vowelsMap.contains(c.toString.toUpperCase))\
    \ result += vowelsMap(c.toString.toUpperCase)\n            else if (c == c.toUpper)\
    \ result += c.toLower\n            else result += c.toUpper\n        }\n     \
    \   result", "    \tvar str = \"\"\n    \tfor (c <- message) {\n    \t\tif (c.isLower)\
    \ str += \n    \t\tif (c.isUpper) str += \n    \t}\n    \tstr", "        var result\
    \ = \"\";\n        for (i <- 0 until message.length) {\n            var char =\
    \ message(i);\n            if (char.isUpper) {\n                result += char.toLower;\n\
    \            } else if (char.isLower) {\n                result += char.toUpper;\n\
    \            } else {\n                result += char;\n            }\n      \
    \  }\n        var vowels = \"aeiou\";\n        for (i <- 0 until result.length)\
    \ {\n            var char = result(i);\n            if (vowels.contains(char))\
    \ {\n                var index = vowels.indexOf(char);\n                index\
    \ = (index + 2) % vowels.length;\n                result = result.substring(0,\
    \ i) + vowels(index) + result.substring(i + 1);\n            }\n        }\n  \
    \      return result;", "        def encodeChar(ch : Char) : Char = {\n      \
    \      if (ch >= 'a' && ch <= 'z') {\n                val v = ch - 'a'\n     \
    \           ((v + 2) % 26 + 'a').toChar\n            } else if (ch >= 'A' && ch\
    \ <= 'Z') {\n                val v = ch - 'A'\n                ((v + 2) % 26 +\
    \ 'A').toChar\n            } else {\n                ch\n            }\n     \
    \   }\n        message.map(encodeChar)", "        val encodeMap = new HashMap[Char,\
    \ Char]\n        for (i <- 'a' to 'z') {\n            val c = ('a' + (i - 'a'\
    \ + 2) % 26).toChar\n            encodeMap += (i -> c)\n            encodeMap\
    \ += (i.toUpper -> c.toUpper)\n        }\n        message.map(c => encodeMap.getOrElse(c,\
    \ c))", '      // YOUR CODE HERE', "        var encoded = \"\"\n        val m\
    \ = message.toLowerCase()\n        val mList = m.toList\n        val vowels =\
    \ List('a', 'e', 'i', 'o', 'u')\n        val shiftedVowels = List('c', 'f', 'j',\
    \ 'n', 'r')\n        for (c <- mList) {\n            if (vowels.contains(c)) {\n\
    \                val i = vowels.indexOf(c)\n                encoded += shiftedVowels(i)\n\
    \            } else {\n                encoded += c\n            }\n        }\n\
    \        return encoded", "    \t\tval vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \    \t\tmessage.map(c => if (vowels.contains(c.toLower)) {\n    \t\t\t\t\t\t\t\
    \t\t\t\t(c.toLower + 2 - 96).toChar\n    \t\t\t\t\t\t\t\t\t\t} else if (c.isLower)\
    \ {\n    \t\t\t\t\t\t\t\t\t\t\tc.toUpper\n    \t\t\t\t\t\t\t\t\t\t} else {\n \
    \   \t\t\t\t\t\t\t\t\t\t\tc.toLower\n    \t\t\t\t\t\t\t\t\t\t})", "        message.map(x\
    \ => x match {\n                case 'A' => 'C'\n                case 'a' => 'c'\n\
    \                case 'E' => 'G'\n                case 'e' => 'g'\n          \
    \      case 'I' => 'K'\n                case 'i' => 'k'\n                case\
    \ 'O' => 'Q'\n                case 'o' => 'q'\n                case 'U' => 'S'\n\
    \                case 'u' => 's'\n                case 'Y' => 'A'\n          \
    \      case 'y' => 'a'\n                case c: Char => c.toUpper\n          \
    \  })", "        var chars = message.toCharArray\n        for (i <- 0 until chars.length)\
    \ {\n            var c = chars(i)\n            if (c.isLetter) {\n           \
    \     if (c.isUpper) chars(i) = c.toLower\n                else chars(i) = c.toUpper\n\
    \                if (c == 'a') chars(i) = 'c'\n                else if (c == 'e')\
    \ chars(i) = 'g'\n                else if (c == 'i') chars(i) = 'k'\n        \
    \        else if (c == 'o') chars(i) = 'q'\n                else if (c == 'u')\
    \ chars(i) = 'y'\n            }\n        }\n        return chars.mkString", " \
    \       val vowels = \"aeiou\"\n        message.map(x => {\n            if (vowels.contains(x.toLower))\
    \ {\n                if (x.isUpper) (x.toLower + 2).toChar.toUpper\n         \
    \       else (x.toLower + 2).toChar\n            }\n            else if (x.isUpper)\
    \ x.toLower\n            else x.toUpper\n        })", "        var output = \"\
    \"\n        val alphabet = 'a' to 'z'\n        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        for (ch <- message) {\n            if (ch.isUpper) output\
    \ += ch.toLower\n            else if (ch.isLower) output += ch.toUpper\n     \
    \       else output += ch\n        }\n        var encoded = \"\"\n        for\
    \ (ch <- output) {\n            if (vowels.contains(ch)) {\n                val\
    \ index = alphabet.indexOf(ch)\n                val next = (index + 2) % alphabet.length\n\
    \                encoded += alphabet(next)\n            }\n            else encoded\
    \ += ch\n        }\n        encoded", "        var encoded = \"\"\n        for\
    \ (c <- message) {\n            if (c.isUpper) {\n                encoded += c.toLower\n\
    \            } else if (c.isLower) {\n                encoded += c.toUpper\n \
    \           } else {\n                encoded += c\n            }\n        }\n\
    \        encoded.replaceAll(\"a\", \"c\").replaceAll(\"e\", \"g\").replaceAll(\"\
    i\", \"k\").replaceAll(\"o\", \"q\").replaceAll(\"u\", \"w\")", "        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        message.map(c => \n            c match\
    \ {\n                case c if c.isUpper => c.toLower\n                case c\
    \ if c.isLower => c.toUpper\n                case c if \"aeiou\".contains(c) =>\n\
    \                    alphabet((alphabet.indexOf(c) + 2) % alphabet.length)\n \
    \               case c => c\n            }\n        )", "        //should be \"\
    tHKS KS C MGSSCGG\"\n        def encodeLetter(c : Char) : Char = {\n         \
    \   if (c.isLower) c.toUpper\n            else c.toLower\n        }\n        def\
    \ encodeVowel(c : Char) : Char = {\n            if (c == 'z') 'b'\n          \
    \  else if (c == 'Z') 'B'\n            else if (c == 'y') 'a'\n            else\
    \ if (c == 'Y') 'A'\n            else (c.toInt + 2).toChar\n        }\n      \
    \  message.map(x => if (Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U').contains(x))\
    \ encodeVowel(x) else encodeLetter(x))", "        var output = \"\"\n        for\
    \ (c <- message) {\n            if (c.isLetter) {\n                output += c.toUpper\n\
    \            } else {\n                output += c\n            }\n        }\n\
    \        var vowels = 'A' to 'E'\n        var map = new HashMap[Char, Char]\n\
    \        for (i <- 0 until vowels.length) {\n            map += (vowels(i) ->\
    \ vowels((i + 2) % vowels.length))\n        }\n        var vowelLetters = 'A'\
    \ to 'Z'\n        for (i <- 0 until vowelLetters.length) {\n            if (!vowels.contains(vowelLetters(i)))\
    \ {\n                map += (vowelLetters(i) -> vowelLetters((i + 2) % vowelLetters.length))\n\
    \            }\n        }\n        for (i <- 0 until output.length) {\n      \
    \      output = output.updated(i, map(output(i)))\n        }\n        output",
  "        val vowels = Seq('a', 'e', 'i', 'o', 'u')\n        message.map {\n    \
    \        ch =>\n                val offset = if (vowels.contains(ch.toLower))\
    \ 2 else 0\n                val newChar = if (ch.isLower) ((ch.toInt + offset\
    \ - 'a') % 26 + 'a').toChar\n                                else ((ch.toInt +\
    \ offset - 'A') % 26 + 'A').toChar\n                if (ch.isUpper) newChar.toUpper\
    \ else newChar\n        }", "        // O(n)\n        message.map((c : Char) =>\
    \ {\n            if (c >= 'a' && c <= 'z') {\n                val x = c - 'a'\n\
    \                (if (x < 24) (x + 2) else (x - 24 + 2)) + 'a'\n            }\
    \ else if (c >= 'A' && c <= 'Z') {\n                val x = c - 'A'\n        \
    \        (if (x < 24) (x + 2) else (x - 24 + 2)) + 'A'\n            } else {\n\
    \                c\n            }\n        })", "        val vowelMap = Map('a'\
    \ -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val vowels\
    \ = vowelMap.keySet\n        message.toLowerCase.map(x => if (vowels.contains(x))\
    \ vowelMap(x) else x).map(x => if (x.isLetter) (x + 2 - 'a') % 26 + 'a' else x).map(x\
    \ => if (x.isLower) x.toUpper else x).mkString", "        return message.map {\
    \ x =>\n            if (x.isLower) \n                (((x - 'a' + 2) % 26) + 'a').toChar\n\
    \            else if (x.isUpper) \n                (((x - 'A' + 2) % 26) + 'A').toChar\n\
    \            else \n                x\n        }", "        var result = \"\"\
    ;\n        val vowels = new ListBuffer[Char]\n        vowels += 'a'\n        vowels\
    \ += 'e'\n        vowels += 'i'\n        vowels += 'o'\n        vowels += 'u'\n\
    \        for (i <- 0 until message.length) {\n            val a = message(i);\n\
    \            if (vowels.contains(a)) result += (((a - 'a' + 2) % 26) + 'a').toChar;\n\
    \            else result += (((a - 'a' + 26) % 26) + 'a').toChar;\n        }\n\
    \        result;", "        var dictionary = mutable.HashMap[Char, Char]()\n \
    \       var index = 0\n        for (i <- 'a' to 'z') {\n            if (index\
    \ > 12) index = 0\n            dictionary += (i -> ('a' + index))\n          \
    \  index += 1\n        }\n        var encoded = \"\"\n        for (i <- message)\
    \ {\n            if (i.isLower) {\n                encoded += dictionary.get(i).get.toUpper\n\
    \            } else {\n                encoded += dictionary.get(i.toLower).get\n\
    \            }\n        }\n        encoded", "        if (message.length == 0)\
    \ \"\"\n        else encode(message.head) + encode(message.tail)", "\t\treturn\
    \ \"\";", "        var s : String = \"\"\n        for (i <- 0 until message.length)\
    \ {\n            if (message(i).isUpper) s += message(i).toLower\n           \
    \ else if (message(i).isLower) s += message(i).toUpper\n            else s +=\
    \ message(i)\n        }\n        var map = HashMap[Char, Char]()\n        map\
    \ += 'a' -> 'c'\n        map += 'e' -> 'g'\n        map += 'i' -> 'k'\n      \
    \  map += 'o' -> 'q'\n        map += 'u' -> 'w'\n        map += 'y' -> 'a'\n \
    \       for (i <- 0 until s.length) {\n            if (map.contains(s(i))) s =\
    \ s.updated(i, map(s(i)))\n        }\n        s", "        val vowels = \"aeiou\"\
    \n        var result = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ vowels((vowels.indexOf(c.toLower) + 2) % 5)\n            else if (c.isUpper)\
    \ c.toLower\n            else c.toUpper\n        })\n        result", "    \t\t\
    var r = message.map(c => c match {\n    \t\t\tcase 'a' => 'c'\n    \t\t\tcase\
    \ 'e' => 'g'\n    \t\t\tcase 'i' => 'k'\n    \t\t\tcase 'o' => 'q'\n    \t\t\t\
    case 'u' => 'y'\n    \t\t\tcase 'A' => 'C'\n    \t\t\tcase 'E' => 'G'\n    \t\t\
    \tcase 'I' => 'K'\n    \t\t\tcase 'O' => 'Q'\n    \t\t\tcase 'U' => 'Y'\n    \t\
    \t\tcase c if c.isUpper => c.toLower\n    \t\t\tcase c if c.isLower => c.toUpper\n\
    \    \t\t\tcase _ => c\n    \t\t})\n    \t\tr.mkString", "        val splitMessage\
    \ = message.split(\"\")\n        val vowels = Array(\"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n        val englishAlphabet = \"abcdefghijklmnopqrstuvwxyz\"\n     \
    \   val result = splitMessage.map(c => {\n            if (c.isLower) {\n     \
    \           if (vowels.contains(c)) {\n                    val index = englishAlphabet.indexOf(c)\n\
    \                    if (index + 2 < englishAlphabet.length)\n               \
    \         englishAlphabet(index + 2).toString\n                    else\n    \
    \                    englishAlphabet(index + 2 - englishAlphabet.length).toString\n\
    \                }\n                else\n                    c.toUpper\n    \
    \        }\n            else if (c.isUpper) {\n                if (vowels.contains(c.toLower))\
    \ {\n                    val index = englishAlphabet.indexOf(c.toLower)\n    \
    \                if (index + 2 < englishAlphabet.length)\n                   \
    \     englishAlphabet(index + 2).toUpper.toString\n                    else\n\
    \                        englishAlphabet(index + 2 - englishAlphabet.length).toUpper.toString\n\
    \                }\n                else\n                    c.toLower\n    \
    \        }\n            else\n                c\n        })\n        result.mkString(\"\
    \")", "        // The alphabet.\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        // The letters that are vowels.\n        val vowels = \"aeiou\"\n  \
    \      // The letters that are consonants.\n        val consonants = \"bcdfghjklmnpqrstvwxyz\"\
    \n        // The two after vowels.\n        val twoAfterVowels = \"cgjkpsvxz\"\
    \n        // The two after consonants.\n        val twoAfterConsonants = \"dhlnrtz\"\
    \n        // The sorted vowels and letters that are two places away from vowels.\n\
    \        val sortedVowels = vowels + twoAfterVowels\n        // The sorted consonants\
    \ and letters that are two places away from consonants.\n        val sortedConsonants\
    \ = consonants + twoAfterConsonants\n        // The vowels and letters that are\
    \ two places away from vowels by index.\n        val indexVowels = collection.mutable.LinkedHashMap[Char,\
    \ Int]()\n        for (i <- 0 until sortedVowels.length) indexVowels(sortedVowels(i))\
    \ = i\n        // The consonants and letters that are two places away from consonants\
    \ by index.\n        val indexConsonants = collection.mutable.LinkedHashMap[Char,\
    \ Int]()\n        for (i <- 0 until sortedConsonants.length) indexConsonants(sortedConsonants(i))\
    \ = i\n        // The message mapped to upper.\n        val upperMessage = message.toUpperCase\n\
    \        // The message mapped to lower.\n        val lowerMessage = message.toLowerCase\n\
    \        // The encoded message.\n        var encodedMessage = \"\"\n        //\
    \ The upper character.\n        var upperChar = ' '\n        // The lower character.\n\
    \        var lowerChar = ' '\n        // Encode message.\n        for (i <- 0\
    \ until message.length) {\n            upperChar = upperMessage(i)\n         \
    \   lowerChar = lowerMessage(i)\n            // Vowel.\n            if (vowels.contains(lowerChar))\
    \ {\n                encodedMessage += sortedVowels(indexVowels(upperChar))\n\
    \           ", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val\
    \ encoding = message.toLowerCase.map(ch => {\n            val pos = vowels.indexOf(ch)\n\
    \            if (pos == -1) ch\n            else {\n                val nextVowel\
    \ = (pos + 2) % vowels.length\n                vowels(nextVowel)\n           \
    \ }\n        })\n        encoding.map(ch => if (ch == ch.toUpper) ch.toLower else\
    \ ch.toUpper).mkString", "        val alphabet = ('a' to 'z').toList\n       \
    \ val vowels = \"aeiou\".toList\n        def findNexVowelIndex(ch : Char) : Int\
    \ = {\n            var i = 0\n            while(i < alphabet.length) {\n     \
    \           if(alphabet(i) == ch) {\n                    if(i + 2 < alphabet.length)\
    \ return i + 2\n                    else return i + 2 - alphabet.length\n    \
    \            }\n                i += 1\n            }\n            return -1\n\
    \        }\n        message.map(ch => if(vowels.contains(ch.toLower)) alphabet(findNexVowelIndex(ch.toLower))\
    \ else ch).map(ch => if(ch.isUpper) ch.toLower else ch.toUpper).mkString", " \
    \       val m = message.toCharArray\n        var r = new StringBuilder\n     \
    \   for (i <- 0 until m.length) {\n            if (m(i).isUpper) {\n         \
    \       r.append(m(i).toLower)\n            } else if (m(i).isLower) {\n     \
    \           r.append(m(i).toUpper)\n            } else {\n                r.append(m(i))\n\
    \            }\n        }\n        r.toString", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ A = 'A'\n        val Z = 'Z'\n        val upperCase = (A to Z).toList\n    \
    \    val a = 'a'\n        val z = 'z'\n        val lowerCase = (a to z).toList\n\
    \        def getMod(letter : Char) : Char = {\n            if (vowels.contains(letter))\
    \ alphabet((alphabet.indexOf(letter) + 2) % 26)\n            else letter\n   \
    \     }\n        def getChar(char : Char) : Char = {\n            if (upperCase.contains(char))\
    \ getMod(char.toLower).toUpper\n            else if (lowerCase.contains(char))\
    \ getMod(char)\n            else char\n        }\n        message.map(getChar(_))",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        message.map(c => if\
    \ (vowels.contains(c.toLower)) vowels(vowels.indexOf(c.toLower) + 2) else c).map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper)", "        //Assume only letters\n\
    \        //This could be improved by using an immutable map\n        val vowels\
    \ = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val\
    \ encoded = for(c <- message) yield {\n            if(c.isUpper)\n           \
    \     c.toLower\n            else\n                c.toUpper\n        }\n    \
    \    val finalEncoded = encoded.map(c => if(vowels.contains(c)) vowels(c) else\
    \ c)\n        return finalEncoded", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        message.map(c => if (vowels.contains(c.toLower)) (c + 2).toChar\
    \ else c).\n        map(c => if (c.isUpper) c.toLower else c.toUpper)", "    \
    \    val vowels = Map(\n            'a' -> 'c',\n            'e' -> 'g',\n   \
    \         'i' -> 'k',\n            'o' -> 'q',\n            'u' -> 'y'\n     \
    \   )\n        var encodedMessage = \"\"\n        for (char <- message) {\n  \
    \          if (vowels.contains(char.toLower)) {\n                encodedMessage\
    \ += vowels(char.toLower)\n            } else if (char.isUpper) {\n          \
    \      encodedMessage += char.toLower\n            } else {\n                encodedMessage\
    \ += char.toUpper\n            }\n        }\n        encodedMessage", "      \
    \  var encodedMessage = \"\"\n        for (c <- message) {\n            encodedMessage\
    \ += encodeCharacter(c)\n        }\n        return encodedMessage", '        message.map
    { c => if (c.isUpper) c.toLower else c.toUpper }', "        var result = \"\"\n\
    \        val vowels = Array('a', 'e', 'i', 'o', 'u')\n        for (i <- 0 until\
    \ message.length) {\n            val c = message(i)\n            if (vowels.contains(c.toLower))\
    \ {\n                result += ('a' + (c.toLower - 'a' + 2) % 5).toChar\n    \
    \        } else {\n                result += c.toLower\n            }\n      \
    \  }\n        result.toUpperCase", "    \tval vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n    \tval a = 'a'\n    \tmessage.map(x => \n    \t\tif (vowels.contains(x.toLower))\n\
    \    \t\t\t((x + 2 - a) % 26 + a).toChar\n    \t\telse\n    \t\t\tif (x.isUpper)\
    \ x.toLower else x.toUpper)", "        if (message.length == 0) return \"\"\n\
    \        else {\n            if (message.head.isUpper) encode(message.tail) +\
    \ (message.head + 2).toChar.toUpper\n            else if (message.head.isLower)\
    \ encode(message.tail) + (message.head + 2).toChar.toLower\n            else encode(message.tail)\
    \ + message.head\n        }", "        message.zipWithIndex.map({\n          \
    \  case (c,i) => {\n                (c match {\n                    case 'A' =>\
    \ 'C'\n                    case 'E' => 'G'\n                    case 'I' => 'K'\n\
    \                    case 'O' => 'Q'\n                    case 'U' => 'W'\n  \
    \                  case 'a' => 'c'\n                    case 'e' => 'g'\n    \
    \                case 'i' => 'k'\n                    case 'o' => 'q'\n      \
    \              case 'u' => 'w'\n                    case ' ' => ' '\n        \
    \            case _ => if (c.isUpper) ((c - 'A' + 13) % 26 + 'A').toChar else\
    \ ((c - 'a' + 13) % 26 + 'a').toChar\n                })\n            }\n    \
    \    }).mkString", "        def encodeChar(c : Char) : Char = {\n            if\
    \ (c >= 'a' && c <= 'z') {\n                if (c == 'z') {\n                \
    \    'b'\n                } else if (c == 'x') {\n                    'a'\n  \
    \              } else {\n                    (c + 2).toChar\n                }\n\
    \            } else if (c >= 'A' && c <= 'Z') {\n                if (c == 'Z')\
    \ {\n                    'B'\n                } else if (c == 'X') {\n       \
    \             'A'\n                } else {\n                    (c + 2).toChar\n\
    \                }\n            } else {\n                c\n            }\n \
    \       }\n        message.map(encodeChar)", "        // >>> encode((\"test\"\
    ))\n        // (\"TGST\")\n        // >>> encode((\"This is a message\"))\n  \
    \      // (\"tHKS KS C MGSSCGG\")\n        val abc = ('a' to 'z').toSet\n    \
    \    val vowel = ('a' to 'z').toSet.diff(('b' to 'd').toSet).diff(('f' to 'h').toSet).diff(('j'\
    \ to 'n').toSet).diff(('p' to 't').toSet).diff(('v' to 'z').toSet)\n        def\
    \ mapVowel(c : Char) : Char = if (vowel.contains(c)) abc.slice(abc.toList.indexOf(c)\
    \ + 2, abc.toList.indexOf(c) + 3).toList(0) else c\n        message.map(x => if\
    \ (abc.contains(x)) mapVowel(x) else x).map(x => if (abc.contains(x)) mapVowel(x)\
    \ else x).map(x => if (abc.contains(x)) x.toUpper else x)", '        return "NOT
    IMPLEMENTED"', "        var result = \"\"\n        for (i <- 0 until message.length)\
    \ {\n            val char = message(i)\n            result += if (char.isUpper)\
    \ char.toLower else char.toUpper\n        }\n        result", "        val m =\
    \ message.split(\"\")\n        val encoded = m.map(c => {\n            if(c.matches(\"\
    [a-zA-Z]\")) {\n                val i = (c.toLowerCase.charAt(0) - 97 + 2) % 26\n\
    \                val c2 = (i + 97).toChar\n                if(c.matches(\"[A-Z]\"\
    ))\n                    c2.toUpper\n                else\n                   \
    \ c2\n            }\n            else {\n                c\n            }\n  \
    \      })\n        encoded.mkString(\"\")", "        var result = \"\"\n     \
    \   val vowels = \"aeiouAEIOU\"\n        for (c <- message) {\n            if\
    \ (vowels.contains(c)) {\n                result += c match {\n              \
    \      case 'z' => 'b'\n                    case 'Z' => 'B'\n                \
    \    case 'x' => 'd'\n                    case 'X' => 'D'\n                  \
    \  case 'c' => 'f'\n                    case 'C' => 'F'\n                    case\
    \ 'v' => 'h'\n                    case 'V' => 'H'\n                    case 'b'\
    \ => 'j'\n                    case 'B' => 'J'\n                    case 'n' =>\
    \ 'l'\n                    case 'N' => 'L'\n                    case 'm' => 'n'\n\
    \                    case 'M' => 'N'\n                    case 'a' => 'c'\n  \
    \                  case 'A' => 'C'\n                    case 'e' => 'g'\n    \
    \                case 'E' => 'G'\n                    case 'i' => 'k'\n      \
    \              case 'I' => 'K'\n                    case 'o' => 'm'\n        \
    \            case 'O' => 'M'\n                    case 'u' => 'o'\n          \
    \          case 'U' => 'O'\n                }\n            } else {\n        \
    \        result += c match {\n                    case 'a' => 'A'\n          \
    \          case 'b' => 'B'\n                    case 'c' => 'C'\n            \
    \        case 'd' => 'D'\n                    case 'e' => 'E'\n              \
    \      case 'f' => 'F'\n                    case 'g' => 'G'\n                \
    \    case 'h' => 'H'\n                    case 'i' => 'I'\n                  \
    \  case 'j' => 'J'\n                    case 'k' => 'K'\n                    case\
    \ 'l' => 'L'\n                    case 'm' => 'M'\n                    case 'n'\
    \ => 'N'\n                    case 'o' => 'O'\n                    case 'p' =>\
    \ 'P'\n                    case 'q' => 'Q'\n                    case 'r' => 'R'\n\
    \                    case 's' => 'S'\n                    case 't' => 'T'\n  \
    \                  case 'u' =>", "        // ###########\n        // Start Here\n\
    \        // ###########\n        val vowels = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val offsets = Map('a' -> 2, 'e' -> 4, 'i' -> 0, 'o' -> 2, 'u' -> 4)\n\
    \        val newAlphabet = \"bcdfghjklmnpqrstvwxyz\".toSet\n        return message.toCharArray.map(\
    \ x => {\n            if (vowels.contains(x)) newAlphabet.dropWhile(_ != x).drop(offsets(x)).head\n\
    \            else if (x.isUpper) x.toLower\n            else x.toUpper\n     \
    \   }).mkString", "        // We will use a buffer to hold the result\n      \
    \  val buffer = new StringBuilder()\n        // Do the case change first\n   \
    \     for (c <- message) buffer.append(if (c.isUpper) c.toLower else c.toUpper)\n\
    \        // Now replace the vowels\n        val vowels = \"aeiou\"\n        val\
    \ replacementVowels = \"eioua\"\n        val result = buffer.toString\n      \
    \  for (i <- 0 until buffer.length) {\n            val c = buffer(i)\n       \
    \     val index = vowels.indexOf(c)\n            if (index != -1) buffer(i) =\
    \ replacementVowels(index)\n        }\n        buffer.toString", "        val\
    \ sb = new StringBuilder(message.length)\n        val vowels = List('a', 'e',\
    \ 'i', 'o', 'u')\n        for (c <- message) {\n            val char = if (c.isUpper)\
    \ c.toLower else c.toUpper\n            sb += (if (vowels.contains(char)) (char\
    \ + 2).toChar else char)\n        }\n        sb.toString", "        //todo\n \
    \       \"\"", "        // Encoder for alphabets\n        def encoder(c : Char)\
    \ : Char = {\n            // Standardize a lowercase or uppercase alphabet\n \
    \           def alphabet(c : Char) : Char = {\n                if (c >= 'a' &&\
    \ c <= 'z') c else c.toLower\n            }\n            // Lowercase vowels\n\
    \            val vowels = \"aeiou\"\n            if (vowels.contains(alphabet(c)))\
    \ {\n                // Change to lowercase first\n                val char =\
    \ alphabet(c)\n                // Get the 2nd letter after that\n            \
    \    val idx = (vowels.indexOf(char) + 2) % vowels.length\n                //\
    \ Return the lowercase\n                vowels(idx)\n            } else {\n  \
    \              // Return the standardize alphabet\n                alphabet(c)\n\
    \            }\n        }\n        // Swap the case of each letter\n        def\
    \ swapCase(c : Char) : Char = {\n            // Swap case\n            if (c >=\
    \ 'a' && c <= 'z') c.toUpper else c.toLower\n        }\n        // Join the characters\n\
    \        val chars = for (c <- message) yield swapCase(encoder(c))\n        chars.mkString",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        message.map(ch => if\
    \ (vowels.contains(ch.toLower)) (ch + 2).toChar else ch)\n          .map(ch =>\
    \ if (ch.isUpper) ch.toLower else ch.toUpper)", "        val alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val vowels = \"AEIOU\"\n        val sb = new StringBuilder\n       \
    \ message.foreach {\n            c => {\n                if (vowels.contains(c.toUpper))\
    \ {\n                    val index = alphabet.indexOf(c.toUpper)\n           \
    \         sb.append(alphabet((index + 2) % alphabet.length))\n               \
    \ } else {\n                    if (c.isUpper) sb.append(c.toLower)\n        \
    \            else sb.append(c.toUpper)\n                }\n            }\n   \
    \     }\n        sb.toString", "        def isLowerCase(c : Char) : Boolean =\
    \ {\n            if (c.toInt >= 97 && c.toInt <= 122) true else false\n      \
    \  }\n        def isUpperCase(c : Char) : Boolean = {\n            if (c.toInt\
    \ >= 65 && c.toInt <= 90) true else false\n        }\n        def isVowel(c :\
    \ Char) : Boolean = {\n            if (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u') true else false\n        }\n        def encodeChar(c : Char)\
    \ : Char = {\n            if (isVowel(c)) {\n                if (c == 'a') {\n\
    \                    'c'\n                } else if (c == 'e') {\n           \
    \         'g'\n                } else if (c == 'i') {\n                    'k'\n\
    \                } else if (c == 'o') {\n                    'q'\n           \
    \     } else if (c == 'u') {\n                    'y'\n                } else\
    \ {\n                    c\n                }\n            } else if (isLowerCase(c))\
    \ {\n                c.toUpper\n            } else if (isUpperCase(c)) {\n   \
    \             c.toLower\n            } else {\n                c\n           \
    \ }\n        }\n        message.map(encodeChar)", "        var vowels = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var shiftedVowels = vowels.tail ++ List(vowels.head)\n\
    \        var encoded = \"\"\n        for (i <- 0 until message.length) {\n   \
    \         if (vowels.contains(message(i).toLower.toString)) {\n              \
    \  encoded += shiftedVowels(vowels.indexOf(message(i).toLower.toString)).toUpper\n\
    \            } else {\n                encoded += message(i).toUpper\n       \
    \     }\n        }\n        encoded", "    \tvar vowels = \"aeiou\"\n    \tvar\
    \ encoding = \"\"\n    \tfor (letter <- message) {\n    \t\tval lowercase = letter.toLower\n\
    \    \t\tif (vowels.contains(lowercase)) {\n    \t\t\tencoding += vowels((vowels.indexOf(lowercase)\
    \ + 2) % vowels.length)\n    \t\t} else {\n    \t\t\tif (letter.isUpper) {\n \
    \   \t\t\t\tencoding += lowercase.toUpper\n    \t\t\t} else {\n    \t\t\t\tencoding\
    \ += lowercase\n    \t\t\t}\n    \t\t}\n    \t}\n    \tencoding", "        if\
    \ (message.length == 0) return message\n        var encodeMessage = message.toLowerCase\n\
    \        if (encodeMessage(0) < 'a' || encodeMessage(0) > 'z') return encodeMessage(0)\
    \ + encode(encodeMessage.substring(1))\n        if (encodeMessage(0) == 'z') encodeMessage\
    \ = 'b' + encodeMessage.substring(1)\n        else if (encodeMessage(0) == 'd')\
    \ encodeMessage = 'f' + encodeMessage.substring(1)\n        else if (encodeMessage(0)\
    \ == 'h') encodeMessage = 'j' + encodeMessage.substring(1)\n        else if (encodeMessage(0)\
    \ == 'n') encodeMessage = 'p' + encodeMessage.substring(1)\n        else if (encodeMessage(0)\
    \ == 't') encodeMessage = 'v' + encodeMessage.substring(1)\n        else encodeMessage\
    \ = (encodeMessage(0) + 2).toChar + encodeMessage.substring(1)\n        encodeMessage(0).toUpper\
    \ + encode(encodeMessage.substring(1))", "        val vowels = \"aeiou\"\n   \
    \     val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val backwards = alphabet.reverse\n\
    \        def swapcase(c : Char) : Char = {\n            if (c.isUpper) c.toLower\n\
    \            else c.toUpper\n        }\n        def replace(c : Char) : Char =\
    \ {\n            val lower = c.toLower\n            if (vowels.contains(lower))\
    \ {\n                alphabet(alphabet.indexOf(lower) + 2)\n            } else\
    \ {\n                backwards(backwards.indexOf(lower) + 2)\n            }\n\
    \        }\n        val ret = message.map(swapcase).map(replace)\n        ret",
  "    \tvar s = \"\"\n    \tfor (ch <- message) {\n    \t\tif (isVowel(ch)) s +=\
    \ shift(ch, 2)\n    \t\telse if (isLowerCase(ch)) s += shift(ch, 32)\n    \t\t\
    else if (isUpperCase(ch)) s += shift(ch, -32)\n    \t\telse s += ch\n    \t}\n\
    \    \ts", "        val vowels = \"aeiou\"\n        val encodeMap = new HashMap[Char,\
    \ Char]\n        for (vowel <- vowels) {\n            encodeMap += (vowel -> vowels((vowels.indexOf(vowel)\
    \ + 2) % vowels.length))\n        }\n        val output = new StringBuilder\n\
    \        for (c <- message) {\n            if (vowels.contains(c)) {\n       \
    \         output += encodeMap(c)\n            } else if (c.isUpper) {\n      \
    \          output += c.toLower\n            } else {\n                output +=\
    \ c.toUpper\n            }\n        }\n        output.toString", '        null',
  "\t\t\"TGST\"", "        // without tail recursion\n        def encodeHelper(message\
    \ : String, acc : String) : String = {\n            if (message.isEmpty) acc\n\
    \            else if (message.head.isUpper) encodeHelper(message.tail, acc + message.head.toLower)\n\
    \            else if (message.head.isLower) encodeHelper(message.tail, acc + message.head.toUpper)\n\
    \            else if (message.head == 'a') encodeHelper(message.tail, acc + 'c')\n\
    \            else if (message.head == 'e') encodeHelper(message.tail, acc + 'g')\n\
    \            else if (message.head == 'i') encodeHelper(message.tail, acc + 'k')\n\
    \            else if (message.head == 'o') encodeHelper(message.tail, acc + 'q')\n\
    \            else if (message.head == 'u') encodeHelper(message.tail, acc + 's')\n\
    \            else encodeHelper(message.tail, acc + message.head)\n        }\n\
    \        encodeHelper(message, \"\")", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        message.map(c => if (vowels.contains(c.toLower)) {\n    \
    \            if (c.isUpper) {\n                    (c + 2 - 26).toChar.toUpper\n\
    \                } else {\n                    (c + 2 - 26).toChar\n         \
    \       }\n            } else if (c.isUpper) {\n                c.toLower\n  \
    \          } else {\n                c.toUpper\n            }\n        )", " \
    \       var res = \"\"\n        for (c <- message) {\n            var n = c\n\
    \            if (c.isUpper) n = n.toLower\n            else if (c.isLower) n =\
    \ n.toUpper\n            if (c == 'a') n = 'c'\n            else if (c == 'e')\
    \ n = 'g'\n            else if (c == 'i') n = 'k'\n            else if (c == 'o')\
    \ n = 'q'\n            else if (c == 'u') n = 'y'\n            res += n\n    \
    \    }\n        res", "        val map = Map(\n            'a' -> 'c', 'e' ->\
    \ 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',\n            'A' -> 'C', 'E' -> 'G',\
    \ 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'\n        )\n        message.map(map.getOrElse(_,\
    \ _)).mkString", "        message.map((c) => 'a' + ((c - 'a' + 2) % 26)).map((c)\
    \ => if (c > 'z') c - 26 else c).map((c) => if (c <= 'z' && c >= 'a') (c + 'A'\
    \ - 'a') else c).mkString", '        return message', "        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        def translateChar(ch : Char) : Char\
    \ = {\n            if (vowels contains ch.toLower) {\n                val alphabet\
    \ = 'a' to 'z'\n                alphabet( (alphabet.indexOf(ch.toLower) + 2) %\
    \ alphabet.length )\n            } else if (ch.isUpper) ch.toLower\n         \
    \   else ch.toUpper\n        }\n        message.map(translateChar)", "       \
    \ // modify the message \n        var modifiedMessage = message\n        //replace\
    \ vowels with char two places after it \n        modifiedMessage = modifiedMessage.replace('a',\
    \ 'c')\n        modifiedMessage = modifiedMessage.replace('e', 'g')\n        modifiedMessage\
    \ = modifiedMessage.replace('i', 'k')\n        modifiedMessage = modifiedMessage.replace('o',\
    \ 'q')\n        modifiedMessage = modifiedMessage.replace('u', 'w')\n        //\
    \ swap case\n        modifiedMessage = modifiedMessage.toUpperCase\n        modifiedMessage",
  "        val vowels = \"aeiouAEIOU\"\n        var result = \"\"\n        for (c\
    \ <- message) {\n            if (vowels.contains(c)) result += vowels((vowels.indexOf(c)\
    \ + 2) % 10)\n            else if (c.isUpper) result += c.toLower\n          \
    \  else if (c.isLower) result += c.toUpper\n            else result += c\n   \
    \     }\n        result", "        return message.toUpperCase().map(c => if (c\
    \ < 'F') (c + 20).toChar else (c - 6).toChar)", '        return null', "     \
    \   var alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\
    \        var result = \"\"\n        for (ch <- message) {\n            if (alphabet.contains(ch))\
    \ {\n                var index = alphabet.indexOf(ch)\n                if (ch.isUpper)\
    \ {\n                    index = (index + 13) % 26\n                    result\
    \ += alphabet(index).toUpper\n                } else {\n                    index\
    \ = (index + 13) % 26\n                    result += alphabet(index).toLower\n\
    \                }\n            } else {\n                result += ch\n     \
    \       }\n        }\n        result", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val replacement = 'a' + 2\n        var result = \"\"\n  \
    \      for (c <- message) {\n            if (vowels.contains(c.toLower)) {\n \
    \               result += (replacement + (c.toLower - 'a') % 5).toChar\n     \
    \       } else {\n                result += c.toLower.toChar\n            }\n\
    \        }\n        result", "        val len = message.length\n        val sb\
    \ = new StringBuilder(len)\n        for (i <- 0 until len) {\n            val\
    \ c = message(i)\n            if (c.isLetter) {\n                val cc = (c.toLowerCase.toInt\
    \ + 2).toChar\n                sb.append(cc.toUpper ^ c.toUpper)\n           \
    \ } else {\n                sb.append(c)\n            }\n        }\n        sb.toString",
  "        val vowels = \"aeiou\".toSet\n        val shifted = message.map(x => if\
    \ (vowels.contains(x.toLower)) (x + 2 - 26).toChar else x)\n        val swapped\
    \ = shifted.map(x => if (x.isLower) x.toUpper else x.toLower)\n        swapped",
  "        var result = new StringBuilder()\n        for (i <- 0 until message.length)\
    \ {\n            val c = message(i)\n            if (c.isLetter) {\n         \
    \       val r = if (c.isUpper) 'A' else 'a'\n                result += (((c -\
    \ r + 13) % 26 + r).toChar)\n            } else {\n                result += c\n\
    \            }\n        }\n        result.toString", "        var alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\".toCharArray\n        var encoded = \"\"\n       \
    \ var chars = message.toCharArray\n        for (i <- 0 until chars.length) {\n\
    \            var char = chars(i)\n            var index = alphabet.indexOf(char.toLower)\n\
    \            if (index == -1) {\n                encoded += char\n           \
    \ } else {\n                if (char.isUpper) {\n                    encoded +=\
    \ alphabet((index + 2) % alphabet.length).toUpper\n                } else {\n\
    \                    encoded += alphabet((index + 2) % alphabet.length)\n    \
    \            }\n            }\n        }\n        encoded", "        val vowels\
    \ = Array(\"a\", \"e\", \"i\", \"o\", \"u\")\n        val letters = 'a' to 'z'\n\
    \        val charToIndex = letters.zipWithIndex.toMap\n        val indexToChar\
    \ = letters.zipWithIndex.map(p => (p._2, p._1)).toMap\n        val messageArray\
    \ = message.toCharArray\n        for (i <- 0 until messageArray.length) {\n  \
    \          val lower = messageArray(i).toLower\n            if (letters.contains(lower))\
    \ {\n                val index = charToIndex(lower)\n                if (vowels.contains(lower.toString))\
    \ {\n                    val newIndex = (index + 2) % 26\n                   \
    \ messageArray(i) = indexToChar(newIndex).toUpper\n                } else {\n\
    \                    messageArray(i) = lower.toUpper\n                }\n    \
    \        }\n        }\n        messageArray.mkString", "    \tmessage.map(c =>\
    \ {\n    \t\tc match {\n    \t\t\tcase 'a' => 'c'\n    \t\t\tcase 'e' => 'g'\n\
    \    \t\t\tcase 'i' => 'k'\n    \t\t\tcase 'o' => 'q'\n    \t\t\tcase 'u' => 'y'\n\
    \    \t\t\tcase 'A' => 'C'\n    \t\t\tcase 'E' => 'G'\n    \t\t\tcase 'I' => 'K'\n\
    \    \t\t\tcase 'O' => 'Q'\n    \t\t\tcase 'U' => 'Y'\n    \t\t\tcase c => if\
    \ (c.isUpper) c.toLower else c.toUpper\n    \t\t}\n    \t})", "        val str\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val s = str.split(\"\")\n        val\
    \ map = scala.collection.mutable.Map[String, String]()\n        for (i <- 0 until\
    \ s.length) {\n            map += (s(i) -> s((i + 2) % 26))\n        }\n     \
    \   val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        val result =\
    \ for (i <- 0 until message.length) yield {\n            if (vowels.contains(message(i).toString.toLowerCase))\
    \ {\n                map(message(i).toString.toLowerCase)\n            } else\
    \ {\n                message(i).toString.toUpperCase\n            }\n        }\n\
    \        result.mkString", "        def swapCase(c : Char) : Char = {\n      \
    \      if (c.isUpper) {\n                c.toLower\n            } else {\n   \
    \             c.toUpper\n            }\n        }\n        def encodeChar(c :\
    \ Char) : Char = {\n            if (c.isLetter) {\n                val shifted\
    \ = (c.toInt + 2) - ('a'.toInt - 'A'.toInt) * (c.isUpper)\n                ('a'.toInt\
    \ + shifted % ('z'.toInt - 'a'.toInt) - 'a'.toInt).toChar\n            } else\
    \ {\n                c\n            }\n        }\n        message.map(encodeChar).map(swapCase)",
  "        val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var upperA\
    \ = \"a\".toCharArray()(0).toInt\n        var upperE = \"e\".toCharArray()(0).toInt\n\
    \        var upperI = \"i\".toCharArray()(0).toInt\n        var upperO = \"o\"\
    .toCharArray()(0).toInt\n        var upperU = \"u\".toCharArray()(0).toInt\n \
    \       var lowerA = \"a\".toLowerCase.toCharArray()(0).toInt\n        var lowerE\
    \ = \"e\".toLowerCase.toCharArray()(0).toInt\n        var lowerI = \"i\".toLowerCase.toCharArray()(0).toInt\n\
    \        var lowerO = \"o\".toLowerCase.toCharArray()(0).toInt\n        var lowerU\
    \ = \"u\".toLowerCase.toCharArray()(0).toInt\n        var encoded = \"\"\n   \
    \     for (c <- message) {\n            if (vowels.contains(c.toLower.toString))\
    \ {\n                if (c.toLower.toString == \"a\") {\n                    encoded\
    \ += if (c.isUpper) ((upperC.toInt + 2).toChar).toString else ((lowerC.toInt +\
    \ 2).toChar).toString\n                } else if (c.toLower.toString == \"e\"\
    ) {\n                    encoded += if (c.isUpper) ((upperG.toInt + 2).toChar).toString\
    \ else ((lowerG.toInt + 2).toChar).toString\n                } else if (c.toLower.toString\
    \ == \"i\") {\n                    encoded += if (c.isUpper) ((upperI.toInt +\
    \ 2).toChar).toString else ((lowerI.toInt + 2).toChar).toString\n            \
    \    } else if (c.toLower.toString == \"o\") {\n                    encoded +=\
    \ if (c.isUpper) ((upperK.toInt + 2).toChar).toString else ((lowerK.toInt + 2).toChar).toString\n\
    \                } else if (c.toLower.toString == \"u\") {\n                 \
    \   encoded", "        // Create the maps\n        val vowels = Map('a' -> 'c',\
    \ 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val others = Map('z'\
    \ -> 'b', 'y' -> 'a', 'x' -> 'z')\n        // Initialize our output string\n \
    \       var output = \"\"\n        // Loop through the message, modifying characters\n\
    \        for (c <- message) {\n            // If it's a letter, encode it\n  \
    \          if (c.isLetter) {\n                if (c.isUpper) {\n             \
    \       // Convert the character to lower case\n                    val lower\
    \ = c.toLower\n                    // See if it's a vowel or not\n           \
    \         if (vowels.contains(lower)) {\n                        // It's a vowel,\
    \ so convert to the value\n                        output += vowels(lower).toUpper\n\
    \                    } else if (others.contains(lower)) {\n                  \
    \      // It's another special character\n                        output += others(lower).toUpper\n\
    \                    } else {\n                        // It's a regular character\n\
    \                        output += lower.toUpper\n                    }\n    \
    \            } else {\n                    // Convert the character to lower case\n\
    \                    val lower = c.toLower\n                    // See if it's\
    \ a vowel or not\n                    if (vowels.contains(lower)) {\n        \
    \                // It's a vowel, so convert to the value\n                  \
    \      output += vowels(lower)\n                    } else if (others.contains(lower))\
    \ {\n                        // It's another special character\n             \
    \           output += others(lower)\n                    } else {\n          \
    \              // It's a regular character\n                        output +=\
    \ lower\n                    }\n                }\n            } else {\n    \
    \            // It's not a letter, so just add it\n                output += c\n\
    \            }\n        }\n        // Return the output\n        output", "  \
    \      var encoded = new StringBuilder()\n        for (c <- message) {\n     \
    \       if (c.isUpper) {\n                encoded += c.toLower\n            }\
    \ else if (c.isLower) {\n                encoded += c.toUpper\n            } else\
    \ {\n                encoded += c\n            }\n        }\n        var vowels\
    \ = List('a', 'e', 'i', 'o', 'u')\n        for (v <- vowels) {\n            encoded\
    \ = new StringBuilder(encoded.toString.replace(v, vowels((vowels.indexOf(v) +\
    \ 2) % vowels.length)))\n            encoded = new StringBuilder(encoded.toString.replace(v.toUpper,\
    \ vowels((vowels.indexOf(v) + 2) % vowels.length).toUpper))\n        }\n     \
    \   encoded.toString", "        val vowels = \"aeiou\"\n        val shifted_vowels\
    \ = \"cfkps\"\n        message.toLowerCase.map(x => if (vowels.contains(x)) shifted_vowels(vowels.indexOf(x))\
    \ else x).map(x => if (x >= 'a' && x <= 'z') (x - 'a' + 13) % 26 + 'a' else x).map(x\
    \ => if (x >= 'a' && x <= 'z') (x - 'a' + 13) % 26 + 'a' else x).map(x => if (x\
    \ >= 'a' && x <= 'z') (x - 'a' + 13) % 26 + 'a' else x).map(x => if (x >= 'a'\
    \ && x <= 'z') (x - 'a' + 13) % 26 + 'a' else x).mkString", "        message.map(x\
    \ => if (x.isUpper) x.toLower else x.toUpper)\n              .map(x => if (\"\
    aeiou\".contains(x)) {\n                            val offset = \"aeiou\".indexOf(x)\n\
    \                            \"aeiou\"(if (offset == 4) 0 else offset + 2)\n \
    \                       } else x)", "        message.flatMap {char =>\n      \
    \      if (char.isLetter) {\n                val encodedChar =\n             \
    \       if (char.isUpper) 'A' + ((char - 'A' + 2) % 26)\n                    else\
    \ 'a' + ((char - 'a' + 2) % 26)\n                encodedChar.toString\n      \
    \      } else {\n                char.toString\n            }\n        }", " \
    \       def swap(c : Char) : Char = {\n            if (c.isUpper) c.toLower\n\
    \            else c.toUpper\n        }\n        def replace(c : Char) : Char =\
    \ {\n            if (\"aeiou\".contains(c)) {\n                val i = c - 'a'\n\
    \                ('a' + (i + 2) % 26).toChar\n            }\n            else\
    \ c\n        }\n        message.map(swap).map(replace)", "        var vowels =\
    \ Array(\"a\", \"e\", \"i\", \"o\", \"u\")\n        def loop(message : String,\
    \ result : String) : String = {\n            if (message.isEmpty) result\n   \
    \         else {\n                if (vowels.contains(message.head.toLower.toString))\
    \ loop(message.tail, result + vowels((vowels.indexOf(message.head.toLower.toString)\
    \ + 2) % 5))\n                else if (message.head.isLower) loop(message.tail,\
    \ result + message.head.toUpper)\n                else if (message.head.isUpper)\
    \ loop(message.tail, result + message.head.toLower)\n                else loop(message.tail,\
    \ result + message.head)\n            }\n        }\n        loop(message, \"\"\
    )", "        val vowels = List(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var\
    \ result = \"\"\n        for (ch <- message) {\n            if (vowels.contains(ch.toLower.toString))\
    \ result += nextVowel(ch)\n            else result += ch\n        }\n        result",
  "        var hm = new HashMap[Char, Char]()\n        hm += 'A' -> 'C', 'a' -> 'c',\
    \ 'E' -> 'G', 'e' -> 'g', 'I' -> 'K', 'i' -> 'k', 'O' -> 'Q', 'o' -> 'q', 'U'\
    \ -> 'W', 'u' -> 'w'\n        var result = \"\"\n        for (ch <- message) {\n\
    \            if (hm.contains(ch)) result += hm(ch)\n            else result +=\
    \ ch\n        }\n        result", "        val vowels = List(\"a\", \"e\", \"\
    i\", \"o\", \"u\")\n        val vowelScramble = Map(\"a\" -> \"c\", \"e\" -> \"\
    g\", \"i\" -> \"k\", \"o\" -> \"q\", \"u\" -> \"s\")\n        message.map { c\
    \ => if (vowels.contains(c.toLower)) vowelScramble(c.toLower) else c }.map { c\
    \ => if (c.isUpper) c.toLower else c.toUpper }", "        var result = \"\"\n\
    \        for (i <- 0 until message.length) {\n            var char = message(i)\n\
    \            if (char.isUpper) {\n                result += char.toLower\n   \
    \         } else if (char.isLower) {\n                result += char.toUpper\n\
    \            } else {\n                result += char\n            }\n       \
    \ }\n        result", "        var ret = \"\";\n        var i = 0;\n        while\
    \ (i < message.length) {\n            ret += swapCase(message(i));\n         \
    \   i += 1;\n        }\n        return ret;", "        // my amazing algorithm\n\
    \        message.map { \n            case 'a' => 'c'\n            case 'e' =>\
    \ 'g'\n            case 'i' => 'k'\n            case 'o' => 'q'\n            case\
    \ 'u' => 'w'\n            case c : Char => c.toUpper\n        }", "        val\
    \ ALPHABET = \"abcdefghijklmnopqrstuvwxyz\"\n        val VOWELS = \"aeiou\"\n\
    \        val ENCODED_VOWELS = \"cdfhjlnprtvxz\"\n        val encrypt = (x : Char)\
    \ => \n            if (x.isLower)\n                if (VOWELS.contains(x))\n \
    \                   ENCODED_VOWELS(VOWELS.indexOf(x))\n                else\n\
    \                    ALPHABET((ALPHABET.indexOf(x) + 13) % 26)\n            else\n\
    \                if (VOWELS.contains(x.toLower))\n                    ENCODED_VOWELS(VOWELS.indexOf(x.toLower)).toUpper\n\
    \                else\n                    ALPHABET((ALPHABET.indexOf(x.toLower)\
    \ + 13) % 26).toUpper\n        message.map(encrypt)", "        var messageArray\
    \ = message.toArray\n        for (i <- 0 until messageArray.length) {\n      \
    \      if (messageArray(i).isUpper) messageArray(i) = messageArray(i).toLower\n\
    \            else if (messageArray(i).isLower) messageArray(i) = messageArray(i).toUpper\n\
    \            if (messageArray(i) == 'a') messageArray(i) = 'c'\n            else\
    \ if (messageArray(i) == 'e') messageArray(i) = 'g'\n            else if (messageArray(i)\
    \ == 'i') messageArray(i) = 'k'\n            else if (messageArray(i) == 'o')\
    \ messageArray(i) = 'q'\n            else if (messageArray(i) == 'u') messageArray(i)\
    \ = 'w'\n        }\n        new String(messageArray)", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        def encodeChar(c : Char) : Char = {\n         \
    \   def encodeVowel(c : Char) : Char = {\n                val alphaIndex = 'z'\
    \ - c\n                val nextVowel = vowels(vowels.indexOf(c) + 2)\n       \
    \         (nextVowel + alphaIndex).toChar\n            }\n            c match\
    \ {\n                case _ if vowels.contains(c) => encodeVowel(c)\n        \
    \        case _ if c >= 'a' && c <= 'z' => ('z' - (c - 'a')).toChar\n        \
    \        case _ if c >= 'A' && c <= 'Z' => ('Z' - (c - 'A')).toChar\n        \
    \        case _ => c\n            }\n        }\n        message.map(encodeChar)",
  "        message.map(c => if (c.isUpper) c.toLower else c.toUpper)\n           \
    \ .map(c => if (\"aeiou\".contains(c)) \"eiuoa\".charAt(\"aeiou\".indexOf(c))\
    \ else c)", "      val vowel = List(\"a\", \"e\", \"i\", \"o\", \"u\")\n     \
    \ val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n      var result = \"\"\n   \
    \   for (c <- message) {\n        val newChar = (c.toLower match {\n         \
    \ case 'z' => 'B'\n          case 'y' => 'A'\n          case c if (vowel contains\
    \ c.toString) => alphabet((alphabet.indexOf(c) + 2) % 26)\n          case c =>\
    \ alphabet((alphabet.indexOf(c) + 1) % 26)\n        })\n        result += newChar.toUpper\n\
    \      }\n      result", '        "TGST"', "        // define alphabet\n     \
    \   var alphabet = new Array[Char](26)\n        for (i <- 0 until 26) alphabet(i)\
    \ = ('a' + i).toChar\n        // loop through each letter\n        var result\
    \ = new StringBuilder\n        for (c <- message) {\n            if ('a' <= c\
    \ && c <= 'z') {\n                val index = (c - 'a' + 2) % 26\n           \
    \     result.append(alphabet(index))\n            } else if ('A' <= c && c <=\
    \ 'Z') {\n                val index = (c - 'A' + 2) % 26\n                result.append(alphabet(index).toUpper)\n\
    \            } else result.append(c)\n        }\n        result.toString", " \
    \       val vowels = \"aeiouAEIOU\"\n        val letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        var encodedMessage = \"\"\n        for (i <- 0 until message.length)\
    \ {\n            val c = message(i)\n            if (letters.contains(c)) {\n\
    \                if (vowels.contains(c)) encodedMessage += (vowels((vowels.indexOf(c)\
    \ + 2) % vowels.length))\n                else encodedMessage += c\n         \
    \   }\n            else encodedMessage += c\n        }\n        encodedMessage",
  "        def nextLetter(c : Char) : Char = {\n            val base = if (c.isUpper)\
    \ 'A' else 'a'\n            val pos = (c - base + 2) % 26\n            (base +\
    \ pos).toChar\n        }\n        def encodeChar(c : Char) : Char = {\n      \
    \      if (c.isUpper) nextLetter(c.toLower) else nextLetter(c.toUpper)\n     \
    \   }\n        (for (c <- message) yield {\n            if (c.isLetter) encodeChar(c)\
    \ else c\n        }).mkString", "        val vowels = Array(\"a\", \"e\", \"i\"\
    , \"o\", \"u\")\n        def getPos(c : Char) : Int = {\n            if (c.isUpper)\n\
    \                c.toLower - 'a'\n            else\n                c - 'a'\n\
    \        }\n        def isVowel(c : Char) : Boolean = {\n            vowels.contains(c.toString)\n\
    \        }\n        def swapCase(c : Char) : Char = {\n            if (c.isUpper)\n\
    \                c.toLower\n            else\n                c.toUpper\n    \
    \    }\n        def encodeLetter(c : Char) : Char = {\n            val pos = getPos(c)\n\
    \            if (isVowel(c))\n                ((pos + 2) % 26 + 'a').toChar\n\
    \            else\n                c\n        }\n        val encoded = for (c\
    \ <- message) yield {\n            encodeLetter(swapCase(c))\n        }\n    \
    \    encoded.mkString", "        val vowels = List(\"a\", \"e\", \"i\", \"o\"\
    , \"u\")\n        val alphabet = ('a' to 'z').toList\n        val encoded = new\
    \ StringBuilder\n        for (ch <- message) {\n            val char = ch.toLower\n\
    \            val encodedChar = if (vowels.contains(char.toString)) {\n       \
    \         if (char == 'u') 'a'\n                else alphabet(alphabet.indexOf(char)\
    \ + 2)\n            } else char\n            encoded += (if (ch.isUpper) encodedChar.toUpper\
    \ else encodedChar)\n        }\n        encoded.toString", "        val vowels\
    \ = \"aeiou\"\n        message.map(c => \n            if (vowels.contains(c.toLower))\n\
    \                vowels( (vowels.indexOf(c.toLower) + 2) % vowels.length ).toUpper\n\
    \            else if (vowels.contains(c.toUpper))\n                vowels( (vowels.indexOf(c.toUpper)\
    \ + 2) % vowels.length ).toLower\n            else\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n        )", "        // Convert the message to a character\
    \ array\n        val messageArray = message.toCharArray\n        // Create an\
    \ array of letters to be swapped\n        val letters = Array('a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z')\n        // Create an array of vowels in order\n\
    \        val vowels = Array('a', 'e', 'i', 'o', 'u')\n        // Create a HashMap\
    \ where we will store encoded characters\n        val encodedMap = HashMap[Char,\
    \ Char]()\n        // Iterate through the entire alphabet array\n        for (i\
    \ <- 0 until letters.length) {\n            // Check to see if the current character\
    \ is uppercase or lowercase\n            if (letters(i).isUpper) {\n         \
    \       // If it is uppercase, encode it and store it in our HashMap\n       \
    \         encodedMap(letters(i)) = (letters(((i + 2) % letters.length)).toUpper)\n\
    \            } else {\n                // If it is lowercase, encode it and store\
    \ it in our HashMap\n                encodedMap(letters(i)) = (letters(((i + 2)\
    \ % letters.length)))\n            }\n        }\n        // Iterate through the\
    \ entire message array\n        for (i <- 0 until messageArray.length) {\n   \
    \         // Check to see if the current character is a vowel\n            if\
    \ (vowels.contains(messageArray(i))) {\n                // If it is a vowel, encode\
    \ it\n                messageArray(i) = encodedMap(messageArray(i))\n        \
    \    } else {\n                // If it is not a vowel, swap case\n          \
    \      messageArray(i) = messageArray(i).toLower.toUpper\n            }\n    \
    \    }\n        // Return the joined array as a string\n        messageArray.mkString",
  "        val vowels = List(\"a\", \"e\", \"i\", \"o\", \"u\")\n        message.map(ch\
    \ => if (vowels.contains(ch.toLower.toString)) ((ch + 2).toChar).toLower else\
    \ ch).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString"]
stop_tokens:
- "\n    }\n"
