language: scala
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val a_list = a.toList\n        val\
    \ b_list = b.toList\n        def xor_list(a_list : List[Char], b_list : List[Char])\
    \ : List[Char] = {\n            if (a_list.length != b_list.length) {throw new\
    \ Exception(\"Input Lists of different length\")}\n            if (a_list.length\
    \ == 0) {List()}\n            else {\n                if (a_list.head == b_list.head)\
    \ {'0' :: xor_list(a_list.tail, b_list.tail)}\n                else {'1' :: xor_list(a_list.tail,\
    \ b_list.tail)}\n            }\n        }\n        val result = xor_list(a_list,\
    \ b_list)\n        result.mkString\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val n = a.length()\n        val\
    \ c = new StringBuilder()\n        for (i <- 0 until n) {\n            val x =\
    \ (a.charAt(i) == '1') ^ (b.charAt(i) == '1')\n            c.append(if (x) \"\
    1\" else \"0\")\n        }\n        c.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) {\n  \
    \          throw new IllegalArgumentException(\"Cannot XOR string of different\
    \ lengths.\")\n        }\n        // a ^ b\n        a.zip(b).map(x => (x._1.toInt\
    \ ^ x._2.toInt).toString).mkString\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val n = max(a.length, b.length)\n\
    \        var result = Array.fill(n)('0')\n        for (i <- 0 until n) {\n   \
    \         result(i) = if (a(i) == b(i)) '0' else '1'\n        }\n        result.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def inner(a: List[Char], b: List[Char],\
    \ ac: List[Char]): List[Char] = {\n            if (a.isEmpty) {\n            \
    \    if (b.isEmpty)\n                    ac\n                else\n          \
    \          inner(a, b.tail, (b.head ^ ac.head) :: ac.tail)\n            }\n  \
    \          else {\n                if (b.isEmpty)\n                    inner(a.tail,\
    \ b, (a.head ^ ac.head) :: ac.tail)\n                else\n                  \
    \  inner(a.tail, b.tail, (a.head ^ b.head ^ ac.head) :: ac.tail)\n           \
    \ }\n        }\n        inner(a.toList, b.toList, List('0')).mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp_swv_3s.scala:14:38\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m                    inner(a,\
    \ b.tail, (b.head ^ ac.head) :: ac.tail)\n\e[31m\e[31m   |\e[0m              \
    \                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                        Found:    Int\n\e[31m   |\e[0m                      \
    \                Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpp_swv_3s.scala:18:38 --------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m                    inner(a.tail, b, (a.head ^ ac.head) :: ac.tail)\n\e\
    [31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                      Found:    Int\n\e[31m   |\e\
    [0m                                      Required: Char\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpp_swv_3s.scala:20:43 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    inner(a.tail, b.tail, (a.head ^ b.head\
    \ ^ ac.head) :: ac.tail)\n\e[31m\e[31m   |\e[0m                              \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                           Found:    Int\n\e[31m   |\e[0m                   \
    \                        Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var res = \"\"\n        var a_index\
    \ = a.length - 1\n        var b_index = b.length - 1\n        while (a_index >=\
    \ 0 || b_index >= 0) {\n            val a_bit = if (a_index >= 0) a(a_index) -\
    \ '0' else 0\n            val b_bit = if (b_index >= 0) b(b_index) - '0' else\
    \ 0\n            res = (a_bit ^ b_bit).toString + res\n            a_index -=\
    \ 1\n            b_index -= 1\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) {\n  \
    \          throw new IllegalArgumentException(\"Arguments should be equal in length\"\
    )\n        }\n        val buf = new StringBuilder\n        for (i <- 0 until a.length)\
    \ {\n            if (a(i) == b(i)) {\n                buf += '0'\n           \
    \ } else {\n                buf += '1'\n            }\n        }\n        buf.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val l = a.length\n        val res\
    \ = new StringBuilder()\n        for (i <- 0 until l) {\n            if (a(i)\
    \ == b(i)) res.append(\"0\")\n            else res.append(\"1\")\n        }\n\
    \        res.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val n = min(a.length, b.length)\n\
    \        var s = \"\"\n        for (i <- 0 until n) {\n            if (a(i) ==\
    \ b(i)) s += \"0\"\n            else s += \"1\"\n        }\n        s\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def xor(x : Char, y : Char) : Char\
    \ = {\n            if (x == y) '0' else '1'\n        }\n        val padded = a.length\
    \ max b.length\n        val a1 = a.reverse.padTo(padded, '0').reverse\n      \
    \  val b1 = b.reverse.padTo(padded, '0').reverse\n        val result = for ((x,\
    \ y) <- a1 zip b1) yield xor(x, y)\n        result.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        assert(a.length == b.length)\n \
    \       val c = new StringBuilder\n        for (i <- 0 until a.length) {\n   \
    \         c.append((a(i) - '0') ^ (b(i) - '0'))\n        }\n        c.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var c = \"\"\n        for (i <-\
    \ 0 until a.length) {\n            if (a(i) == b(i)) {\n                c += \"\
    0\"\n            } else {\n                c += \"1\"\n            }\n       \
    \ }\n        return c\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // NOTE: a and b are the same length\n\
    \        val n = a.length\n        // perform xor on each bit\n        def go(i\
    \ : Int, res : String) : String =\n            if (i == n) res\n            else\
    \ if (a(i) == b(i)) go(i + 1, res + \"0\")\n            else go(i + 1, res + \"\
    1\")\n        go(0, \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val out = new StringBuilder()\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) {\n    \
    \            out.append(\"0\")\n            } else {\n                out.append(\"\
    1\")\n            }\n        }\n        out.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val output = for ((x, y) <- a zip\
    \ b) yield x ^ y\n        output.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBit = BigInt(a, 2)\n      \
    \  val bBit = BigInt(b, 2)\n        val result = (aBit ^ bBit).toString(2)\n \
    \       if (result.length < a.length) \"0\" * (a.length - result.length) + result\n\
    \        else result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        assert(a.length == b.length)\n \
    \       var result = \"\"\n        for (i <- 0 until a.length) {\n           \
    \ if (a(i) == b(i)) result += \"0\"\n            else result += \"1\"\n      \
    \  }\n        return result\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val s = for (i <- 0 until a.length)\
    \ yield {\n            val a1 = a(i)\n            val b1 = b(i)\n            if\
    \ (a1 == b1) {\n                \"0\"\n            } else {\n                \"\
    1\"\n            }\n        }\n        s.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toList.map(c => BigInt(c.toString,\
    \ 16))\n        val bBits = b.toList.map(c => BigInt(c.toString, 16))\n      \
    \  val xor = aBits.zip(bBits).map(p => p._1 ^ p._2)\n        xor.map(i => i.toString(16)).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // We assume that the two input\
    \ strings are the same length\n        require(a.length == b.length)\n       \
    \ def toInt(x : Char) : Int = if (x == '0') 0 else 1\n        def toChar(x : Int)\
    \ : Char = if (x == 0) '0' else '1'\n        val charPairs = a.zip(b)\n      \
    \  val result = for (pair <- charPairs) yield toChar(toInt(pair._1) ^ toInt(pair._2))\n\
    \        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        a.zip(b).map(x => (x._1.toInt ^ x._2.toInt).toString).mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // a.map(c => b.map(d => if (c ==\
    \ d) \"0\" else \"1\").mkString)\n        // a.map(c => b.map(d => if (c == d)\
    \ 0 else 1).mkString)\n        // a.map(c => b.map(d => (c - '0') ^ (d - '0')).mkString)\n\
    \        a.map(c => b.map(d => (c - '0') ^ (d - '0') + '0').mkString)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpls3kxzqh.scala:12:14\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        a.map(\e[36mc\e[0m =>\
    \ b.map(\e[36md\e[0m => (c - \e[31m'0'\e[0m) ^ (d - \e[31m'0'\e[0m) + \e[31m'0'\e\
    [0m).mkString)\n\e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m              Found:    Char => \e[1m\e[31mString\e[0m\n\e\
    [31m   |\e[0m              Required: Char => \e[1m\e[32mChar\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // Java's XOR: XOR is ^ in java.\n\
    \        def boolXor(a : Boolean, b : Boolean) : Boolean = {\n            if (a\
    \ == b) {\n                false\n            } else {\n                true\n\
    \            }\n        }\n        // Convert strings to booleans\n        val\
    \ aa = a.toCharArray.map(x => if (x == '1') true else false)\n        val bb =\
    \ b.toCharArray.map(x => if (x == '1') true else false)\n        // Perform XOR\
    \ on booleans\n        val cc = aa.zip(bb).map(x => boolXor(x._1, x._2))\n   \
    \     // Convert booleans to strings\n        cc.map(x => if (x) \"1\" else \"\
    0\").reduce(_ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) {\n                result\
    \ += \"0\"\n            } else {\n                result += \"1\"\n          \
    \  }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (a, b).zipped.map(_ ^ _).map(_.toString).reduce(_+_)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) throw\
    \ new IllegalArgumentException()\n        var buffer = new StringBuilder\n   \
    \     for (i <- 0 until a.length) {\n            if (a(i) == b(i)) {\n       \
    \         buffer += '0'\n            } else {\n                buffer += '1'\n\
    \            }\n        }\n        buffer.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // Bitwise XOR (^)\n        val\
    \ c = BigInt(a, 2) ^ BigInt(b, 2)\n        c.toString(2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqy2l9991.scala:14)\n\tat Problem.main(tmpqy2l9991.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toList.map(_.toString.toInt)\n\
    \        val bBits = b.toList.map(_.toString.toInt)\n        aBits.zip(bBits).map(bitPair\
    \ => bitPair._1 ^ bitPair._2).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val bits = a.zip(b)\n        val\
    \ xor = bits.map(i => (i._1, i._2)).map(i => i._1.toString.toInt ^ i._2.toString.toInt)\n\
    \        return xor.map(i => i.toString).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var xor = new StringBuilder\n  \
    \      for (i <- 0 until a.length) {\n            xor += a(i) ^ b(i)\n       \
    \ }\n        return xor.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphhpur2m6.scala:11:19\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            xor += a(i) ^ b(i)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \               Found:    Int\n\e[31m   |\e[0m                   Required: Char\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978530
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val len = a.length\n        var\
    \ c = ArrayBuffer[Char]()\n        for (i <- 0 until len) {\n            if (a(i)\
    \ == b(i)) c += '0'\n            else c += '1'\n        }\n        return c.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val c = new StringBuilder\n    \
    \    for (i <- 0 until a.length) {\n            c.append((if (a(i) == '1') 1 else\
    \ 0) ^ (if (b(i) == '1') 1 else 0))\n        }\n        c.toString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var res = \"\"\n        for(i <-\
    \ 0 until a.length) {\n            res += (if(a(i) == b(i)) \"0\" else \"1\")\n\
    \        }\n        return res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) {\n  \
    \          println(\"Unequal strings\")\n            return \"\"\n        }\n\
    \        val n = a.length\n        var buffer = new StringBuilder\n        for\
    \ (i <- 0 until n) {\n            if (a(i) == b(i)) buffer.append(\"0\")\n   \
    \         else buffer.append(\"1\")\n        }\n        buffer.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // Define the result string.\n \
    \       var result = \"\"\n        // Loop over each char in both strings.\n \
    \       for (i <- 0 until a.length) {\n            // Get the chars from string\
    \ a and b at position i.\n            val ai = a.charAt(i)\n            val bi\
    \ = b.charAt(i)\n            // Append to result XOR on ai and bi chars.\n   \
    \         result += (if (ai == bi) '0' else '1')\n        }\n        // Return\
    \ the result string.\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val result = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append(\"\
    0\")\n            else result.append(\"1\")\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def xor(a : Char, b : Char) : Char\
    \ = (a, b) match {\n            case ('0', '0') => '0'\n            case ('0',\
    \ '1') => '1'\n            case ('1', '0') => '1'\n            case ('1', '1')\
    \ => '0'\n        }\n        a.zip(b).map(c => xor(c._1, c._2)).mkString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      var c = \"\"\n      for (i <- 0 until\
    \ a.length) {\n        if (a(i) == b(i)) {\n          c += \"0\"\n        } else\
    \ {\n          c += \"1\"\n        }\n      }\n      return c\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var c = new StringBuilder()\n  \
    \      for (i <- 0 until a.length) {\n            if (a(i) == b(i)) c += \"0\"\
    \n            else c += \"1\"\n        }\n        return c.toString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkz8bhqsj.scala:11:35\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            \e[33mif\e[0m (a(i)\
    \ == b(i)) c += \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m                      \
    \             ^^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    (\e[32m\"0\"\e[0m : String)\n\e[31m   |\e[0m                            \
    \       Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkz8bhqsj.scala:12:22\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m            \e[33melse\e[0m c\
    \ += \e[31m\"1\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e\
    [31m   |\e[0m                      Found:    (\e[32m\"1\"\e[0m : String)\n\e[31m\
    \   |\e[0m                      Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val length = a.length\n        var\
    \ result = \"\"\n        for (i <- 0 until length) {\n            val x = if (a(i)\
    \ == '1') 1 else 0\n            val y = if (b(i) == '1') 1 else 0\n          \
    \  val z = x ^ y\n            result += z.toString\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // Use mutable variable to make\
    \ the code more concise.\n        var c = \"\"\n        for (i <- 0 until a.length)\
    \ {\n            val d = a(i) ^ b(i)\n            c += d.toChar\n        }\n \
    \       c\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk2r85j3w.scala:18)\n\tat Problem.main(tmpk2r85j3w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      var result = \"\"\n      for (i <-\
    \ 0 until a.length) {\n        val bitA = a(i)\n        val bitB = b(i)\n    \
    \    if (bitA == bitB) result += \"0\"\n        else result += \"1\"\n      }\n\
    \      result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      val aBinary : Array[Int] = a.map(_.asDigit).toArray\n\
    \      val bBinary : Array[Int] = b.map(_.asDigit).toArray\n      val cBinary\
    \ : Array[Int] = aBinary.zip(bBinary).map(x => (x._1 ^ x._2))\n      val c : String\
    \ = cBinary.map(_.toString).reduce(_+_)\n      return c\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length)\n    \
    \        throw new IllegalArgumentException(\"inputs are of different length\"\
    )\n        val aa = a.toList\n        val bb = b.toList\n        val cc = aa.zip(bb).map({case\
    \ (x, y) => if (x == y) '0' else '1'})\n        return cc.mkString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var r = \"\";\n        for (i <-\
    \ 0 until min(a.length, b.length)) {\n            r += if (a(i) == b(i)) '0' else\
    \ '1';\n        }\n        if (a.length < b.length) r = b.substring(0, b.length\
    \ - a.length) + r;\n        else if (a.length > b.length) r = a.substring(0, a.length\
    \ - b.length) + r;\n        return r;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7uosq5nc.scala:11:17 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            r += \e[33mif\e[0m (a(i) == b(i)) \e[31m'0'\e\
    [0m \e[33melse\e[0m \e[31m'1'\e[0m;\n\e[31m\e[31m   |\e[0m                 ^^\e\
    [0m\n\e[31m   |\e[0m                 expression expected but \e[31mif\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978528
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        assert(a.length == b.length)\n \
    \       val len = a.length\n        (0 until len).map(i => (a(i) - '0') ^ (b(i)\
    \ - '0')).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            val aInt = a(i).toString.toInt\n       \
    \     val bInt = b(i).toString.toInt\n            result += (aInt ^ bInt).toString\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978538
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var a_array = a.toArray\n      \
    \  var b_array = b.toArray\n        var result_array = Array.fill(a_array.length)(0)\n\
    \        for (i <- 0 until a_array.length) {\n            if (a_array(i) == b_array(i))\
    \ result_array(i) = 0\n            else result_array(i) = 1\n        }\n     \
    \   return result_array.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (for (i <- 0 until a.length) yield\
    \ (a(i) != b(i)).toString).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8_0sqedt.scala:12)\n\tat Problem.main(tmp8_0sqedt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val result = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result +=\
    \ '0'\n            else result += '1'\n        }\n        result.toString\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) throw\
    \ new IllegalArgumentException(\"Input strings should have the same length!\"\
    )\n        def xor(x : Char, y : Char) : Char = if (x == y) '0' else '1'\n   \
    \     val result = for ((x, y) <- a zip b) yield xor(x, y)\n        result.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      val sb = new StringBuilder\n     \
    \ for (i <- 0 until a.length)\n        sb.append((if (a(i) == b(i)) \"0\" else\
    \ \"1\"))\n      sb.toString\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.size != b.size) throw new\
    \ Exception(\"Input strings do not have the same length.\")\n        var ret =\
    \ \"\"\n        for (i <- 0 until a.size) {\n            ret += ((a(i) - '0')\
    \ ^ (b(i) - '0')).toString\n        }\n        ret\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map { case (x, y) => x\
    \ ^ y }.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val n = a.length()\n        var\
    \ res = \"\"\n        for (i <- 0 until n) {\n            val a_i = a(i).toString.toInt\n\
    \            val b_i = b(i).toString.toInt\n            res += (a_i ^ b_i).toString\n\
    \        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(x => (x._1.toInt ^\
    \ x._2.toInt).toString).mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val sb = new StringBuilder\n   \
    \     for (i <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append(\"\
    0\")\n            else sb.append(\"1\")\n        }\n        sb.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def loop(a : List[Char], b : List[Char],\
    \ result : List[Char]) : List[Char] = (a, b) match {\n            case (Nil, Nil)\
    \ => result\n            case (x :: xs, y :: ys) => loop(xs, ys, result :+ (if\
    \ (x == y) '0' else '1'))\n        }\n        loop(a.toList, b.toList, Nil).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val l = a.length\n        var r\
    \ = \"\"\n        for (i <- 0 until l) {\n            if (a(i) == b(i)) r += \"\
    0\"\n            else r += \"1\"\n        }\n        r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBinary = new BigInteger(a,\
    \ 2)\n        val bBinary = new BigInteger(b, 2)\n        val result = aBinary.xor(bBinary)\n\
    \        result.toString(2)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpubk9pdrh.scala:9:26 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBinary\e[0m = \e[33mnew\e\
    [0m \e[35mBigInteger\e[0m(a, \e[31m2\e[0m)\n\e[31m\e[31m  |\e[0m             \
    \             ^^^^^^^^^^\e[0m\n\e[31m  |\e[0m                          Not found:\
    \ type BigInteger\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpubk9pdrh.scala:10:26\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mbBinary\e[0m = \e[33mnew\e[0m \e[35mBigInteger\e[0m(b, \e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                    Not found: type BigInteger\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val buf = new StringBuilder\n  \
    \      val size = a.size\n        for (i <- 0 until size) {\n            val ai\
    \ = a(i).toString.toInt\n            val bi = b(i).toString.toInt\n          \
    \  buf.append((ai + bi) % 2)\n        }\n        buf.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        var a_i\
    \ = 0\n        var b_i = 0\n        while (a_i < a.length || b_i < b.length) {\n\
    \            var r = 0\n            if (a_i < a.length && a(a_i) == '1') {\n \
    \               r = 1\n            }\n            if (b_i < b.length && b(b_i)\
    \ == '1') {\n                r = 1 - r\n            }\n            result += r.toString\n\
    \            a_i += 1\n            b_i += 1\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val result = new StringBuilder\n\
    \        for (i <- 0 until a.length)\n            result.append((a(i) != b(i)).toString)\n\
    \        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1l7b82mm.scala:15)\n\tat Problem.main(tmp1l7b82mm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (for (i <- 0 until a.length) yield\
    \ if (a(i) == b(i)) '0' else '1').mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978542
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // the resulting string must be\
    \ of the same length\n        assert(a.length == b.length)\n        // initialize\
    \ result\n        var res = new StringBuilder(a.length)\n        // to each bit\
    \ of a and b do XOR\n        for (bit <- 0 until a.length) {\n            if (a(bit)\
    \ == b(bit)) res.append(\"0\")\n            else res.append(\"1\")\n        }\n\
    \        // return result as a string\n        res.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        for (i <- 0 until a.length) yield {\n            if (a(i) == b(i)) \"\
    0\" else \"1\"\n        } mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuizqawhy.scala:10:8\
    \ ---------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until a.length) \e[33myield\e[0m {\n\e[31m\e[31m   |\e[0m     \
    \   ^\e[0m\n\e[31m   |\e[0m        Found:    IndexedSeq[String]\n\e[31m   |\e\
    [0m        Required: String\n\e[31m11 |\e[0m            \e[33mif\e[0m (a(i) ==\
    \ b(i)) \e[31m\"0\"\e[0m \e[33melse\e[0m \e[31m\"1\"\e[0m\n\e[31m12 |\e[0m   \
    \     } mkString(\e[31m\"\"\e[0m)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        return a.zip(b).map(t => if (t._1\
    \ == t._2) '0' else '1').mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map((c : (Char, Char))\
    \ => { if (c._1 != c._2) '1' else '0' }).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var ret = \"\"\n        for (i <-\
    \ 0 until a.length) {\n            if (a(i) == b(i)) ret += \"0\"\n          \
    \  else ret += \"1\"\n        }\n        return ret\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978542
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) {\n  \
    \          throw new IllegalArgumentException(\"Strings a and b must be of equal\
    \ length.\")\n        }\n        var xorResult = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) {\n                xorResult += \"\
    0\"\n            } else {\n                xorResult += \"1\"\n            }\n\
    \        }\n        return xorResult\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978548
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(x => (x._1 ^ x._2).toString).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978549
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      if (a.length != b.length) throw new\
    \ IllegalArgumentException(\"Input lengths must be equal\")\n      (for(i <- 0\
    \ until a.length) yield ((a(i) - '0') ^ (b(i) - '0')).toString).mkString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        assert(a.length == b.length)\n \
    \       (for (i <- 0 until a.length) yield (if (a(i) == b(i)) \"0\" else \"1\"\
    )).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(x => (x._1 != x._2).toString).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz0m3sk7l.scala:12)\n\tat Problem.main(tmpz0m3sk7l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      (a zip b).map(x => x._1 ^ x._2).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        val sb = new StringBuilder\n        for (i <- 0 until a.length) {\n \
    \           val aBit = a(i) - '0'\n            val bBit = b(i) - '0'\n       \
    \     sb.append((aBit ^ bBit).toString)\n        }\n        sb.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val length = a.length\n        var\
    \ result = \"\"\n        for (i <- 0 until length) {\n            if (a(i) ==\
    \ b(i)) {\n                result += \"0\"\n            } else {\n           \
    \     result += \"1\"\n            }\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val a = \"010110\"\n        val\
    \ b = \"101110\"\n        val c = \"111001\"\n        val l = a.length\n     \
    \   var xor = \"\"\n        for (i <- 0 until l) {\n            val c1 = a(i).toString.toInt\n\
    \            val c2 = b(i).toString.toInt\n            xor += (c1 ^ c2).toString\n\
    \        }\n        return xor\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgmka0qpu.scala:22)\n\tat Problem.main(tmpgmka0qpu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map { case (x, y) => (x\
    \ ^ y).toString }.mkString\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val len = a.length\n        val\
    \ charArray = new Array[Char](len)\n        for (i <- 0 until len) {\n       \
    \     if (a(i) == b(i)) charArray(i) = '0'\n            else charArray(i) = '1'\n\
    \        }\n        return new String(charArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        assert(a.length == b.length)\n \
    \       val ca = a.toCharArray\n        val cb = b.toCharArray\n        val result\
    \ = new StringBuilder(ca.length)\n        for (i <- 0 until ca.length) {\n   \
    \         if (ca(i) == cb(i)) result.append('0')\n            else result.append('1')\n\
    \        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(x => (x._1 ^ x._2).toString).reduceLeft(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (for ((c, d) <- a zip b) yield if\
    \ (c == d) '0' else '1').mkString\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(x => if (x._1 == x._2)\
    \ '0' else '1').mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // Assert a and b have same length.\n\
    \        require(a.length == b.length)\n        val r = new StringBuilder\n  \
    \      for (i <- 0 until a.length) {\n            r.append((a(i) == b(i)) match\
    \ {\n                case true => \"0\"\n                case false => \"1\"\n\
    \            })\n        }\n        r.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(p => (p._1, p._2)).map(p\
    \ => p._1 ^ p._2).map(_.toString).reduce(_ + _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(x => ((x._1 - '0')\
    \ ^ (x._2 - '0')).toString).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val result = new Array[Int](max(a.length,\
    \ b.length))\n        for (i <- 0 until result.length) {\n            val x =\
    \ if (i < a.length) if (a(i) == '1') 1 else 0 else 0\n            val y = if (i\
    \ < b.length) if (b(i) == '1') 1 else 0 else 0\n            result(i) = (x + y)\
    \ % 2\n        }\n        result.map(x => x.toString).reduceLeft(_ + _)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBitArray = a.split(\"\").map(BitArray(_))\n\
    \        val bBitArray = b.split(\"\").map(BitArray(_))\n        aBitArray.zip(bBitArray).map(x\
    \ => (x._1 ^ x._2).bitString).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0z3sycun.scala:9:40 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBitArray\e[0m = a.split(\e\
    [31m\"\"\e[0m).map(BitArray(_))\n\e[31m\e[31m  |\e[0m                        \
    \                ^^^^^^^^\e[0m\n\e[31m  |\e[0m                               \
    \         Not found: BitArray\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp0z3sycun.scala:9:52\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m9 |\e[0m       \
    \ \e[33mval\e[0m \e[36maBitArray\e[0m = a.split(\e[31m\"\"\e[0m).map(BitArray(_))\n\
    \e[31m\e[31m  |\e[0m                                                    ^\e[0m\n\
    \e[31m  |\e[0m                                            No ClassTag available\
    \ for B\n\e[31m  |\e[0m\n\e[31m  |\e[0m                                      \
    \      where:    B is a type variable\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0z3sycun.scala:10:40 ------------------------\e[0m\e[0m\n\e[31m10 |\e\
    [0m        \e[33mval\e[0m \e[36mbBitArray\e[0m = b.split(\e[31m\"\"\e[0m).map(BitArray(_))\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                        Not found: BitArray\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp0z3sycun.scala:10:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBitArray\e[0m = b.split(\e\
    [31m\"\"\e[0m).map(BitArray(_))\n\e[31m\e[31m   |\e[0m                       \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                  No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m                                          where:    B is a type variable\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659978551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def go(a : List[Char], b : List[Char],\
    \ acc : List[Char]) : List[Char] = {\n            if (a.isEmpty)\n           \
    \     acc.reverse\n            else {\n                val s : Int = if (a.head\
    \ == b.head) 0 else 1\n                go(a.tail, b.tail, s :: acc)\n        \
    \    }\n        }\n        go(a.toList, b.toList, Nil).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8z3c6nju.scala:14:35\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m                go(a.tail, b.tail,\
    \ s :: acc)\n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e\
    [31m   |\e[0m                                   Found:    (s : Int)\n\e[31m  \
    \ |\e[0m                                   Required: Char\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val n = a.length\n        val lst\
    \ = ListBuffer[Char]()\n        for (i <- 0 until n) {\n            if (a(i) ==\
    \ b(i)) lst += '0'\n            else lst += '1'\n        }\n        return lst.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            result += (if (a(i) == b(i)) '0' else '1')\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var res = \"\"\n        for (i <-\
    \ 0 until a.length) {\n            res += if (a(i) == b(i)) '0' else '1'\n   \
    \     }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpf0tk1439.scala:11:19 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            res += \e[33mif\e[0m (a(i) == b(i)) \e[31m'0'\e\
    [0m \e[33melse\e[0m \e[31m'1'\e[0m\n\e[31m\e[31m   |\e[0m                   ^^\e\
    [0m\n\e[31m   |\e[0m                   expression expected but \e[31mif\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (a zip b).map { case (a, b) => (a\
    \ + b).toInt.toString }.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp90xws8o3.scala:12)\n\tat Problem.main(tmp90xws8o3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978560
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // assert that lengths are the same\n\
    \        assert(a.length == b.length)\n        val bXor = a.zip(b).map { case\
    \ (x, y) => if (x == y) '0' else '1' }\n        bXor.mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val tmp = for (i <- 0 until a.length)\
    \ yield a(i) ^ b(i)\n        tmp.map(_.toString).reduce(_ + _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val maxlen = max(a.length, b.length)\n\
    \        val result = new StringBuilder\n        for (i <- 0 until maxlen) {\n\
    \            result += ((if (a.charAt(i) == b.charAt(i)) '0' else '1'))\n    \
    \    }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (for (i <- 0 until min(a.length,\
    \ b.length)) yield ((a(i) - '0') ^ (b(i) - '0')).toString).mkString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length)\n    \
    \        throw new IllegalArgumentException(\"Bit strings a and b must have the\
    \ same length!\")\n        var r = \"\"\n        for (i <- 0 until a.length) {\n\
    \            val c1 = a(i); val c2 = b(i)\n            val xor = (c1, c2) match\
    \ {\n                case ('0', '0') => '0'\n                case ('0', '1') =>\
    \ '1'\n                case ('1', '0') => '1'\n                case ('1', '1')\
    \ => '0'\n            }\n            r += xor\n        }\n        r\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        val sb = new StringBuilder()\n        for (i <- 0 until a.length) {\n\
    \            sb.append((a(i) - '0') ^ (b(i) - '0'))\n        }\n        sb.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        assert(a.length == b.length)\n \
    \       (for (i <- 0 until a.length) yield (if (a(i) == b(i)) \"0\" else \"1\"\
    )).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val a_ = new BigInt(a, 2)\n    \
    \    val b_ = new BigInt(b, 2)\n        val x = a_ ^ b_\n        x.toString(2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0azqbc6z.scala:9:28\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36ma_\e\
    [0m = \e[33mnew\e[0m \e[35mBigInt\e[0m(a, \e[31m2\e[0m)\n\e[31m\e[31m  |\e[0m\
    \                            ^^^^\e[0m\n\e[31m  |\e[0m                       \
    \     Found:    (String, Int)\n\e[31m  |\e[0m                            Required:\
    \ java.math.BigInteger\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0azqbc6z.scala:10:28\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mb_\e\
    [0m = \e[33mnew\e[0m \e[35mBigInt\e[0m(b, \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                            ^^^^\e[0m\n\e[31m   |\e[0m                      \
    \      Found:    (String, Int)\n\e[31m   |\e[0m                            Required:\
    \ java.math.BigInteger\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val r = new StringBuilder()\n  \
    \      (a, b).zipped.foreach{\n            case('0', '0') => r.append('0')\n \
    \           case('0', '1') => r.append('1')\n            case('1', '0') => r.append('1')\n\
    \            case('1', '1') => r.append('0')\n        }\n        r.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val bin_a = BigInt(a, 2)\n     \
    \   val bin_b = BigInt(b, 2)\n        val bin_c = bin_a ^ bin_b\n        bin_c.toString(2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplxa8d7dg.scala:15)\n\tat Problem.main(tmplxa8d7dg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) result += \"0\"\n    \
    \        else result += \"1\"\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var ans = \"\"\n        for (i <-\
    \ 0 until a.length) {\n            if (a(i) == b(i)) {\n                ans +=\
    \ \"0\"\n            } else {\n                ans += \"1\"\n            }\n \
    \       }\n        return ans\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        var res = \"\"\n        for (i <- 0 until a.length) {\n            res\
    \ += if (a(i) == b(i)) '0' else '1'\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6iz42tnm.scala:12:19 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            res += \e[33mif\e[0m (a(i) == b(i)) \e[31m'0'\e\
    [0m \e[33melse\e[0m \e[31m'1'\e[0m\n\e[31m\e[31m   |\e[0m                   ^^\e\
    [0m\n\e[31m   |\e[0m                   expression expected but \e[31mif\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (for (i <- 0 until a.length) yield\
    \ {\n            if (a(i) == b(i)) '0' else '1'\n        }).mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def xor(a : Char, b : Char) : Char\
    \ = {\n            if (a == b) '0' else '1'\n        }\n        a.zip(b).map(x\
    \ => xor(x._1, x._2)).mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val c = new StringBuilder()\n  \
    \      for (i <- 0 until a.length) {\n            if (a(i) == b(i)) {\n      \
    \          c.append(\"0\")\n            } else {\n                c.append(\"\
    1\")\n            }\n        }\n        c.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val totalLength = max(a.length,\
    \ b.length)\n        val paddedA = (\"0\" * (totalLength - a.length)) + a\n  \
    \      val paddedB = (\"0\" * (totalLength - b.length)) + b\n        val result\
    \ = paddedA.zip(paddedB).map(x => ((x._1 == x._2) match {\n                case\
    \ true => 0\n                case false => 1\n            }).toString).mkString\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val sb = new StringBuilder()\n \
    \       for (i <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append(\"\
    0\")\n            else sb.append(\"1\")\n        }\n        sb.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978563
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val xor = Integer.parseInt(a, 2)\
    \ ^ Integer.parseInt(b, 2)\n        return xor.toBinaryString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwqcm_w6g.scala:13)\n\tat Problem.main(tmpwqcm_w6g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) throw\
    \ new IllegalArgumentException\n        val len = a.length\n        var result\
    \ = \"\"\n        for (i <- 0 until len) {\n            result += (if (a(i) ==\
    \ b(i)) \"0\" else \"1\")\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val arr = a.zip(b)\n        val\
    \ res = arr.map(x => ((x._1 == '1') ^ (x._2 == '1')).toString).mkString\n    \
    \    res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcc963dao.scala:14)\n\tat Problem.main(tmpcc963dao.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val result : ArrayBuffer[Char] =\
    \ new ArrayBuffer[Char]\n        for (i <- 0 until min(a.length, b.length)) {\n\
    \            val x = a(i)\n            val y = b(i)\n            if (x == y) result\
    \ += '0'\n            else result += '1'\n        }\n        result.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978563
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val length = max(a.length, b.length)\n\
    \        val a0 = a.padTo(length, '0')\n        val b0 = b.padTo(length, '0')\n\
    \        (a0, b0).zipped.map {\n            case (x, y) => if (x == y) '0' else\
    \ '1'\n        }.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978565
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      var as = a.split(\"\")\n      var\
    \ bs = b.split(\"\")\n      as.zip(bs).map(p => (p._1.toInt ^ p._2.toInt).toString).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        val builder = new StringBuilder()\n        for (i <- 0 until a.length)\
    \ {\n            val x = a(i)\n            val y = b(i)\n            val res =\
    \ if (x == y) '0' else '1'\n            builder.append(res)\n        }\n     \
    \   builder.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val len = a.length\n        val\
    \ bInt = Integer.parseInt(b, 2)\n        val aInt = Integer.parseInt(a, 2)\n \
    \       val cInt = aInt ^ bInt\n        val c = cInt.toBinaryString\n        return\
    \ \"0\" * (len - c.length) + c\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        //assert(a.length == b.length)\n\
    \        (a zip b) map {case (x, y) => if (x == y) '0' else '1'} mkString(\"\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val sb = new StringBuilder\n   \
    \     for (i <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append(\"\
    0\")\n            else sb.append(\"1\")\n        }\n        sb.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        val result = new StringBuilder\n        for (i <- 0 until a.length) {\n\
    \            result.append((a(i) - '0') ^ (b(i) - '0'))\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val sb = new StringBuilder\n   \
    \     for (i <- 0 until a.length) {\n            if (a(i) == b(i)) sb.append(\"\
    0\")\n            else sb.append(\"1\")\n        }\n        sb.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978541
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(e => (e._1.toInt ^\
    \ e._2.toInt).toString).mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (a zip b).map { x => if (x._1 ==\
    \ x._2) \"0\" else \"1\" }.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map((x : (Char, Char))\
    \ => ('0' + ('1' - x._1) + ('1' - x._2) - '0').toChar).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgwrf1050.scala:12)\n\tat Problem.main(tmpgwrf1050.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) throw\
    \ new IllegalArgumentException(\"a and b must be the same length\")\n        else\
    \ {\n            var output : String = \"\"\n            var i : Int = 0\n   \
    \         while (i < a.length) {\n                if (a(i) == b(i)) output +=\
    \ \"0\"\n                else output += \"1\"\n                i += 1\n      \
    \      }\n            return output\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for(i\
    \ <- 0 until a.length) {\n            if(a(i) == b(i)) result += \"0\"\n     \
    \       else result += \"1\"\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      require(a.length == b.length)\n  \
    \    val aB = a.toList.map(_.toString.toInt)\n      val bB = b.toList.map(_.toString.toInt)\n\
    \      aB.zip(bB).map {case (x, y) => if (x == y) 0 else 1}.mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val ret = new StringBuilder\n  \
    \      for (i <- 0 until a.length) {\n            if (a(i) == b(i)) ret += '0'\n\
    \            else ret += '1'\n        }\n        ret.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val zipped = a.zip(b)\n        val\
    \ result = zipped.map(c => c._1 ^ c._2)\n        result.map(_.toString).reduceLeft(_+_)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        (for ((c, d) <- a zip b) yield (c.toInt + d.toInt).toString).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2wusg9rx.scala:13)\n\tat Problem.main(tmp2wusg9rx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val ab = a.zip(b)\n        val xor\
    \ = ab.map(x => x._1 == x._2)\n        val xorS = xor.map(x => if (x) \"0\" else\
    \ \"1\")\n        return xorS.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // Make the strings the same length.\n\
    \        val shorter = min(a.length, b.length)\n        val longer = max(a.length,\
    \ b.length)\n        val a2 = a.reverse.padTo(longer, '0').reverse\n        val\
    \ b2 = b.reverse.padTo(longer, '0').reverse\n        val result = new StringBuilder\n\
    \        for (i <- 0 until shorter) result.append(if (a2(i) == b2(i)) '0' else\
    \ '1')\n        result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def xor(x : Int, y : Int) : Int\
    \ = {\n            if (x == y) 0 else 1\n        }\n        val result = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            result.append(xor(a(i) - '0',\
    \ b(i) - '0'))\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.size != b.size) {\n      \
    \      return (\"String sizes do not match. \")\n        }\n        var s = \"\
    \"\n        for (i <- 0 until a.size) {\n            val a_i = a(i).toString.toInt\n\
    \            val b_i = b(i).toString.toInt\n            s += (a_i ^ b_i).toString\n\
    \        }\n        return s\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (for (i <- 0 until a.length) yield\
    \ (a(i) != b(i)).toString).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8_0sqedt.scala:12)\n\tat Problem.main(tmp8_0sqedt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        assert(a.length == b.length)\n \
    \       val result = new StringBuilder()\n        for (i <- 0 until a.length)\
    \ {\n            if (a(i) == b(i)) result.append(\"0\")\n            else result.append(\"\
    1\")\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) result += \"0\"\n    \
    \        else result += \"1\"\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            val intA = a(i).toString.toInt\n       \
    \     val intB = b(i).toString.toInt\n            val intC = if (intA == intB)\
    \ 0 else 1\n            result += intC.toString\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val ab = a.zip(b)\n        ab.map{case\
    \ (x, y) => (x.toInt ^ y.toInt).toString}.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBytes = a.toCharArray\n   \
    \     val bBytes = b.toCharArray\n        val cBytes = Array.fill(max(aBytes.length,\
    \ bBytes.length)) {\n            if (aBytes.length > bBytes.length) {\n      \
    \          if (aBytes(i) == '1')\n                    if (bBytes(i) == '1')\n\
    \                        '0'\n                    else\n                     \
    \   '1'\n                else\n                    bBytes(i)\n            } else\
    \ {\n                if (bBytes(i) == '1')\n                    if (aBytes(i)\
    \ == '1')\n                        '0'\n                    else\n           \
    \             '1'\n                else\n                    aBytes(i)\n     \
    \       }\n        }\n        val cString = new String(cBytes)\n        return\
    \ cString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjt0vz1hk.scala:13:27 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mif\e[0m (aBytes(i) == \e[31m'1'\e\
    [0m)\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpjt0vz1hk.scala:14:31 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m                    \e[33mif\e[0m (bBytes(i) == \e[31m'1'\e\
    [0m)\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Not found: i\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjt0vz1hk.scala:19:27 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    bBytes(i)\n\e[31m\e[31m   |\e[0m\
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \ Not found: i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjt0vz1hk.scala:21:27\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                \e[33mif\e\
    [0m (bBytes(i) == \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \      ^\e[0m\n\e[31m   |\e[0m                           Not found: i\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjt0vz1hk.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    \e[33mif\e[0m (aBytes(i) == \e[31m'1'\e\
    [0m)\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Not found: i\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjt0vz1hk.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    aBytes(i)\n\e[31m\e[31m   |\e[0m\
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \ Not found: i\n\e[31"
  stdout: ''
  timestamp: 1659978570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val a_n = BigInt(a, 2)\n       \
    \ val b_n = BigInt(b, 2)\n        val c_n = a_n ^ b_n\n        c_n.toString(2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdfe1gv4r.scala:15)\n\tat Problem.main(tmpdfe1gv4r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val zipped = a.zip(b)\n        zipped.map(c\
    \ => ((c._1 - '0') ^ (c._2 - '0')).toString).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) {\n  \
    \          return \"\"\n        }\n        // TODO: Implement method\n       \
    \ return \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptphj3oem.scala:16)\n\tat Problem.main(tmptphj3oem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978579
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        return a.zip(b).map((x : (Char, Char)) => (x._1 ^ x._2).toChar).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz5yd7ieg.scala:13)\n\tat Problem.main(tmpz5yd7ieg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var c = \"\"\n        for (i <-\
    \ 0 until a.length) {\n            if (a(i) == b(i)) {\n                c += \"\
    0\"\n            } else {\n                c += \"1\"\n            }\n       \
    \ }\n        return c\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var c = \"\"\n        for (i <-\
    \ 0 until a.length) {\n            if (a(i) == b(i)) c += \"0\"\n            else\
    \ c += \"1\"\n        }\n        return c\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(f => if (f._1 == f._2)\
    \ '0' else '1').mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length() != b.length()) {\n\
    \            println(\"Error: String lengths not equal. Exit.\")\n           \
    \ return \"\"\n        }\n        var result = ArrayBuffer[Char]()\n        for\
    \ (i <- 0 until a.length()) {\n            if (a(i) == b(i)) result += '0'\n \
    \           else result += '1'\n        }\n        return result.mkString\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length)\n            result += (if (a(i) == b(i)) \"0\" else \"\
    1\")\n        return result\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = Array[String]()\n \
    \       var i = 0\n        while (i < a.length) {\n            if (a(i) == b(i))\
    \ result = result :+ \"0\"\n            else result = result :+ \"1\"\n      \
    \      i += 1\n        }\n        return result.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            result += (if (a(i) == b(i)) '0' else '1')\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        val aBitArray = a.map { _.asDigit }.toArray\n        val bBitArray =\
    \ b.map { _.asDigit }.toArray\n        val resultBitArray = new Array[Int](a.length)\n\
    \        for (i <- 0 until a.length) {\n            resultBitArray(i) = (aBitArray(i)\
    \ + bBitArray(i)) % 2\n        }\n        resultBitArray.mkString\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val result = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result.append(\"\
    0\")\n            else result.append(\"1\")\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // We assume both inputs are the\
    \ same length.\n        assert(a.length == b.length)\n        val n = a.length\n\
    \        val result = new StringBuilder()\n        for (i <- 0 until n) {\n  \
    \          result += (if (a(i) == b(i)) \"0\" else \"1\")\n        }\n       \
    \ result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgteaa2dd.scala:14:41\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            result += (\e[33mif\e\
    [0m (a(i) == b(i)) \e[31m\"0\"\e[0m \e[33melse\e[0m \e[31m\"1\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                         ^^^\e[0m\n\e[31m   |\e[0m\
    \                                         Found:    (\e[32m\"0\"\e[0m : String)\n\
    \e[31m   |\e[0m                                         Required: Char\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgteaa2dd.scala:14:50 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result += (\e[33mif\e[0m (a(i) == b(i)) \e\
    [31m\"0\"\e[0m \e[33melse\e[0m \e[31m\"1\"\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                                            ^^^\e[0m\n\e[31m   |\e[0m       \
    \                                         Found:    (\e[32m\"1\"\e[0m : String)\n\
    \e[31m   |\e[0m                                                Required: Char\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val al = a.toList\n        val bl\
    \ = b.toList\n        val cl = (al zip bl).map((x) => if (x._1 == x._2) '0' else\
    \ '1')\n        cl.mkString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) throw\
    \ new Error(\"a and b must be of equal length.\")\n        val c = new StringBuilder(a.length)\n\
    \        for (i <- 0 until a.length) {\n            c.append(if (a(i) == b(i))\
    \ '0' else '1')\n        }\n        c.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val len : Int = a.length()\n   \
    \     var res : String = \"\"\n        for (i <- 0 until len) {\n            if\
    \ (a(i) == b(i)) res += \"0\"\n            else res += \"1\"\n        }\n    \
    \    return res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val a1 = a.toList\n        val b1\
    \ = b.toList\n        (a1 zip b1).map(p => (p._1, p._2)).map(p => p match {\n\
    \            case ('0', '0') => '0'\n            case ('1', '1') => '0'\n    \
    \        case ('0', '1') => '1'\n            case ('1', '0') => '1'\n        }).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val ai = a.toList.map(_.toString.toInt)\n\
    \        val bi = b.toList.map(_.toString.toInt)\n        val xor = for {\n  \
    \          i <- 0 until ai.length\n        } yield (ai(i) ^ bi(i)).toString\n\
    \        xor.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val l = min(a.length, b.length)\n\
    \        val c = new StringBuilder\n        for (i <- 0 until l) {\n         \
    \   if (a(i) == b(i)) {\n                c.append(\"0\")\n            } else {\n\
    \                c.append(\"1\")\n            }\n        }\n        return c.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def zipped_array = a.zip(b)\n  \
    \      def xor_lst = zipped_array.map(x => if (x._1 == x._2) '0' else '1')\n \
    \       xor_lst.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var c = \"\"\n        for (i <-\
    \ 0 until a.length) {\n            c += (if (a(i) == b(i)) \"0\" else \"1\")\n\
    \        }\n        return c\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = new StringBuilder()\n\
    \        var i = 0\n        while (i < a.length) {\n            if (a(i) == b(i))\
    \ result.append(\"0\")\n            else result.append(\"1\")\n            i +=\
    \ 1\n        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val c = for ((x, y) <- a zip b)\
    \ yield (if (x == y) \"0\" else \"1\")\n        c.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var res = \"\"\n        for (i <-\
    \ 0 until a.length) res += (if (a(i) == b(i)) \"0\" else \"1\")\n        res\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val r = new StringBuilder()\n  \
    \      for(i <- 0 until a.length) {\n            if(a(i) == b(i)) r.append(\"\
    0\")\n            else r.append(\"1\")\n        }\n        r.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        // This is the fastest way.\n  \
    \      //((a.toInt(2) ^ b.toInt(2)).toBinaryString)\n        // This is the longest\
    \ way.\n        (((a zip b) map {case (x, y) => if (x == y) \"0\" else \"1\"}).mkString)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map(p => (p._1 == p._2)\
    \ match {\n            case true => '0'\n            case false => '1'\n     \
    \   }).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978589
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val n = a.length\n        var result\
    \ = new StringBuilder\n        for (i <- 0 until n) {\n            if (a(i) ==\
    \ b(i)) result.append(\"0\")\n            else result.append(\"1\")\n        }\n\
    \        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978591
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val result = new StringBuilder\n\
    \        var i = 0\n        while (i < a.length) {\n            val x = a(i)\n\
    \            val y = b(i)\n            if (x == y) result.append(\"0\")\n    \
    \        else result.append(\"1\")\n            i += 1\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978591
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val zipped = a.zip(b)\n        zipped.map\
    \ { case (x, y) =>\n            val t = x.toInt ^ y.toInt\n            t.toString\n\
    \        }.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      (a, b).zipped.map((x, y) => if (x\
    \ == y) \"0\" else \"1\").mkString\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val xor = BigInt(a, 2) ^ BigInt(b,\
    \ 2)\n        return xor.toString(2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3854498c.scala:13)\n\tat Problem.main(tmp3854498c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978590
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val result = new StringBuilder\n\
    \        for(i <- 0 until a.length) {\n            if(a(i) == b(i)) result.append(\"\
    0\")\n            else result.append(\"1\")\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            result += if (a(i) == b(i)) \"0\" else \"\
    1\"\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpc0ojfs3f.scala:11:22 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            result += \e[33mif\e[0m (a(i) == b(i)) \e\
    [31m\"0\"\e[0m \e[33melse\e[0m \e[31m\"1\"\e[0m\n\e[31m\e[31m   |\e[0m       \
    \               ^^\e[0m\n\e[31m   |\e[0m                      expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (a zip b).map(x => ((x._1 - '0')\
    \ ^ (x._2 - '0')).toString).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        assert(a.length == b.length)\n \
    \       val a_list = a.split(\"\").toList\n        val b_list = b.split(\"\").toList\n\
    \        return (a_list zip b_list).map(t => (t._1.toInt + t._2.toInt) % 2).mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        if (a.length != b.length) throw\
    \ new IllegalArgumentException(\"String lengths differ: \" + a.length + \" !=\
    \ \" + b.length)\n        var result = \"\"\n        for (i <- 0 until a.length)\
    \ {\n            if (a(i) == b(i)) {\n                result += \"0\"\n      \
    \      } else {\n                result += \"1\"\n            }\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map {case (i, j) => if\
    \ ((i == '1') ^ (j == '1')) '1' else '0'}.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        for (i\
    \ <- 0 until a.length) {\n            if (a(i) == b(i)) result += \"0\"\n    \
    \        else result += \"1\"\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aN = a.length\n        val bN\
    \ = b.length\n        var maxN = max(aN, bN)\n        var minN = min(aN, bN)\n\
    \        var str = \"\"\n        var A = a\n        var B = b\n        if (aN\
    \ > bN) {\n            B = b.padTo(aN, '0')\n        } else if (aN < bN) {\n \
    \           A = a.padTo(bN, '0')\n        }\n        for (i <- 0 until maxN) {\n\
    \            if (A(i) == B(i)) {\n                str += \"0\"\n            }\
    \ else {\n                str += \"1\"\n            }\n        }\n        str\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var c = \"\"\n        for (i <-\
    \ 0 until a.length)\n            c += (if (a(i) == b(i)) \"0\" else \"1\")\n \
    \       return c\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        val n = a.length\n        val result = Array.fill(n)('0')\n        for\
    \ (i <- 0 until n) {\n            result(i) = ('0' + ('1' - a(i)) * ('1' - b(i))).toChar\n\
    \        }\n        result.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcsdrqt1d.scala:18)\n\tat Problem.main(tmpcsdrqt1d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        //split string by each character\n\
    \        val a_split = a.split(\"\")\n        val b_split = b.split(\"\")\n  \
    \      //initialize new string to return\n        var ret = \"\"\n        for\
    \ (i <- 0 until a_split.length) {\n            if ((a_split(i) == \"1\" && b_split(i)\
    \ == \"0\") || (a_split(i) == \"0\" && b_split(i) == \"1\")) {\n             \
    \   ret += \"1\"\n            } else {\n                ret += \"0\"\n       \
    \     }\n        }\n        ret\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.zip(b).map((i) => if (i._1 ==\
    \ i._2) '0' else '1').mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        (a zip b) map { case (x, y) => (x.toInt\
    \ ^ y.toInt).toString } mkString \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n      if (a.length != b.length)\n      \
    \  throw new Exception(\"You must pass two strings of the same length\")\n   \
    \   return a.zip(b).map(x => (x._1 ^ x._2).toString).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var output : String = \"\"\n   \
    \     for (i <- 0 until a.length) {\n            val ai = a(i).toString.toInt\n\
    \            val bi = b(i).toString.toInt\n            val oi = ai ^ bi\n    \
    \        output += oi.toString\n        }\n        return output\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        assert(a.length == b.length)\n \
    \       a.zip(b).map(x => (x._1 == x._2) match {\n            case true => \"\
    0\"\n            case false => \"1\"\n        }).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978594
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        a.toList.zip(b.toList).map(x =>\
    \ (x._1.toString.toInt ^ x._2.toString.toInt).toString).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        val result = new StringBuilder()\n        for (i <- 0 until a.length)\
    \ {\n            val x = a(i)\n            val y = b(i)\n            if (x ==\
    \ y) result.append(\"0\")\n            else result.append(\"1\")\n        }\n\
    \        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978594
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def stringXor(a : String, b : String,\
    \ result : String) : String = {\n            if (a.length == 0) result\n     \
    \       else stringXor(a.substring(1), b.substring(1), result + (if (a(0) == b(0))\
    \ '0' else '1'))\n        }\n        stringXor(a, b, \"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val xor = a.toInt(2) ^ b.toInt(2)\n\
    \        xor.toBinaryString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp4jvut1ux.scala:9:20 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = a.toInt(\e[31m2\e\
    [0m) ^ b.toInt(\e[31m2\e[0m)\n\e[31m\e[31m  |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                  \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e\
    [33mclass\e[0m \e[35mStringOps\e[0m does not take parameters\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0m longer explanation available when compiling with `-explain`\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1659978594
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val as = a.split(\"\").map(_.toInt)\n\
    \        val bs = b.split(\"\").map(_.toInt)\n        val l = as.length\n    \
    \    val cs = (for (i <- 0 until l) yield as(i) ^ bs(i)).map(_.toString).reduce(_\
    \ + _)\n        cs\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978595
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        require(a.length == b.length)\n\
    \        val result = for (i <- 0 until a.length) yield {\n            val x =\
    \ a(i)\n            val y = b(i)\n            val intX = if (x == '0') 0 else\
    \ 1\n            val intY = if (y == '0') 0 else 1\n            if (intX == intY)\
    \ '0' else '1'\n        }\n        result.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978596
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        var result = \"\"\n        var i\
    \ = 0\n        while (i < a.length) {\n            result += (((a(i) - '0') ^\
    \ (b(i) - '0')) + '0').toChar\n            i += 1\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978595
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        def xor(i : Int, j : Int) : Int\
    \ = {\n            if (i == j) {\n                0\n            } else {\n  \
    \              1\n            }\n        }\n        require(a.length == b.length)\n\
    \        val c = for (i <- 0 until a.length) yield xor(a(i).asDigit, b(i).asDigit)\n\
    \        c.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978596
