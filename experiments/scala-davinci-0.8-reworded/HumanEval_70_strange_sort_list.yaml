name: HumanEval_70_strange_sort_list
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given list of integers, return list in strange order.\n    // Strange sorting,\
  \ is when you start with the minimum value,\n    // then maximum of the remaining\
  \ integers, then minimum and so on.\n    // Examples:\n    // >>> strangeSortList((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong,\
  \ 3l.toLong))\n    // >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong,\
  \ 5l.toLong)))\n    // (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))\n\
  \    // >>> strangeSortList((List[Long]()))\n    // (List[Long]())\n    def strangeSortList(lst\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(strangeSortList((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong,\
  \ 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong,\
  \ 7l.toLong))));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong,\
  \ 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong,\
  \ 8l.toLong, 6l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong,\
  \ 5l.toLong))));\n    assert(strangeSortList((List[Long]())).equals((List[Long]())));\n\
  \    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong,\
  \ 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long](0l.toLong,\
  \ 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong,\
  \ 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n\
  \    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        // Fill in your code here.\n        var ret : List[Long] =\
    \ List[Long]()\n        if(lst.length == 0){\n            return ret\n       \
    \ }\n        var max = 0\n        var min = 0\n        var lst2 = lst\n      \
    \  while(lst2.length != 0){\n            max = 0\n            min = 0\n      \
    \      for(x <- lst2){\n                if(lst2(max) < x){\n                 \
    \   max = lst2.indexOf(x)\n                }\n                if(lst2(min) > x){\n\
    \                    min = lst2.indexOf(x)\n                }\n            }\n\
    \            lst2 = lst2.take(min) ++ lst2.drop(min + 1)\n            ret = ret\
    \ :+ lst2(min)\n            lst2 = lst2.take(max) ++ lst2.drop(max + 1)\n    \
    \        ret = ret :+ lst2(max)\n        }\n        return ret", '        lst.sorted.sortWith((a,
    b) => if (a < b) true else false)', "        val lstSorted = lst.sorted\n    \
    \    lstSorted.zipWithIndex.map(e => {\n            if (e._2 % 2 == 0) e._1\n\
    \            else lstSorted(lstSorted.length - e._2 / 2 - 1)\n        })", " \
    \       var min = lst.min\n        var max = lst.max\n        var l = List[Long]()\n\
    \        var m = lst.to[Set]\n        var count = 1\n        while (count <= lst.length)\
    \ {\n            if (count % 2 == 1) {\n                l = l :+ min\n       \
    \         m -= min\n                if (m.size == 0)\n                    return\
    \ l\n                min = m.min\n            } else {\n                l = l\
    \ :+ max\n                m -= max\n                if (m.size == 0)\n       \
    \             return l\n                max = m.max\n            }\n         \
    \   count += 1\n        }\n        l", "        if (lst.length == 0) {\n     \
    \       return lst\n        }\n        val maxm = lst.max\n        var lst1 =\
    \ lst.filter((x) => x != maxm)\n        var lst2 = List[Long]()\n        while\
    \ (lst1.length > 0) {\n            lst2 = lst2 :+ lst1.min\n            lst2 =\
    \ lst2 :+ lst1.max\n            lst1 = lst1.filter((x) => x != lst1.min)\n   \
    \         lst1 = lst1.filter((x) => x != lst1.max)\n        }\n        if (lst.length\
    \ % 2 == 1) {\n            lst2 = lst2 :+ maxm\n        }\n        return lst2",
  "        var remaining = lst.sortWith((a, b) => a < b)\n        var result = new\
    \ ListBuffer[Long]()\n        while (remaining.size > 0) {\n            val minimum\
    \ = remaining.min\n            result += minimum\n            remaining = remaining.filter(_\
    \ != minimum)\n            if (remaining.size > 0) {\n                val maximum\
    \ = remaining.max\n                result += maximum\n                remaining\
    \ = remaining.filter(_ != maximum)\n            }\n        }\n        return result.toList",
  "        val odd : List[Long] = lst.zipWithIndex.filter(x => (x._2 % 2) == 0).map(x\
    \ => x._1)\n        val even : List[Long] = lst.zipWithIndex.filter(x => (x._2\
    \ % 2) == 1).map(x => x._1)\n        var oddSorted : List[Long] = List()\n   \
    \     if (odd.size > 0) {\n            oddSorted = odd.sortWith(_ < _)\n     \
    \   }\n        var evenSorted : List[Long] = List()\n        if (even.size > 0)\
    \ {\n            evenSorted = even.sortWith(_ > _)\n        }\n        oddSorted\
    \ ::: evenSorted", "        if (lst.isEmpty) lst\n        else {\n           \
    \ var l = lst.sortWith(_ < _)\n            var c = l.toBuffer\n            var\
    \ m = c.min\n            c.remove(c.indexOf(m))\n            var d = c.toList\n\
    \            strangeSortList((List[Long](m.toLong) ::: d.reverse ::: l))\n   \
    \     }", "        if (lst.length % 2 == 0)\n            lst.sortWith(_ < _).grouped(2).flatMap(x\
    \ => List(x(0), x(1))).toList\n        else {\n            val temp = lst.sortWith(_\
    \ < _).toBuffer\n            temp.insert(lst.length / 2, temp.remove(0))\n   \
    \         temp.toList\n        }", "        // Type your code here\n        var\
    \ result:List[Long] = List()\n        var tmp:List[Long] = lst\n        while(tmp.length\
    \ > 0) {\n            val min = tmp.min\n            val max = tmp.max\n     \
    \       result = result :+ min\n            if(max != min) {\n               \
    \ result = result :+ max\n            }\n            tmp = tmp.filter(_ != min)\n\
    \            tmp = tmp.filter(_ != max)\n        }\n        result", "       \
    \ def strangeSortList(lst : List[Long], acc : List[Long]) : List[Long] = {\n \
    \           lst match {\n                case Nil => acc\n                case\
    \ _ => {\n                    val (max, maxIndex) = lst.zipWithIndex.maxBy(_._1)\n\
    \                    val (min, minIndex) = lst.zipWithIndex.minBy(_._1)\n    \
    \                val lst1 = lst.patch(maxIndex, Nil, 1)\n                    val\
    \ lst2 = lst1.patch(minIndex, Nil, 1)\n                    strangeSortList(lst2,\
    \ acc :+ max :+ min)\n                }\n            }\n        }\n        strangeSortList(lst,\
    \ List())", "    var temp = lst.sorted\n    var ans : List[Long] = Nil\n    var\
    \ i = 0\n    var flag = true\n    while(i < temp.length) {\n        if(flag) {\n\
    \            ans = ans :+ temp(i)\n            flag = false\n        } else {\n\
    \            ans = ans :+ temp(temp.length - 1 - i)\n            flag = true\n\
    \        }\n        i += 1", "        val n = lst.length\n        val lst_sorted\
    \ = lst.sorted\n        val lst_sorted_reversed = lst_sorted.reverse\n       \
    \ val lst_new = lst_sorted.zip(lst_sorted_reversed).flatMap(pair => List(pair._1,\
    \ pair._2))\n        if (n == 0) {\n            lst_new\n        } else if (n\
    \ % 2 == 1) {\n            lst_new.tail\n        } else {\n            lst_new\n\
    \        }", "        val seq = lst.sorted\n        var i = 0\n        val len\
    \ = seq.length\n        var result = List[Long]()\n        while (i < len) {\n\
    \            if (i % 2 == 0) {\n                result = result :+ seq(i)\n  \
    \          } else {\n                result = result :+ seq(len - i - 1)\n   \
    \         }\n            i += 1\n        }\n        result", "        var l =\
    \ new ListBuffer[Long]\n        var lst2 = lst.sortWith(_ < _)\n        if (lst2.size\
    \ % 2 == 0) {\n            for (i <- 0 until lst2.size) {\n                if\
    \ (i % 2 == 0) l += lst2(i)\n                else l += lst2(lst2.size - i - 1)\n\
    \            }\n        } else {\n            for (i <- 0 until lst2.size) {\n\
    \                if (i % 2 == 0) l += lst2(i)\n                else l += lst2(lst2.size\
    \ - i - 1)\n            }\n            l += lst2(lst2.size / 2)\n        }\n \
    \       l.toList", "        // Case base\n        if (lst.length <= 1) return\
    \ lst\n        // Case recursive\n        val min = lst.min\n        val max =\
    \ lst.max\n        val lst1 = lst.filterNot(x => x == min || x == max)\n     \
    \   List(min, max) ::: strangeSortList(lst1)", "        if (lst.length % 2 ==\
    \ 0) {\n            return (lst.zipWithIndex.filter(_._2 % 2 == 0).map(_._1) ++\
    \ lst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1)).toList\n        } else {\n\
    \            return (lst.zipWithIndex.filter(_._2 % 2 == 0).map(_._1) ++ lst.zipWithIndex.filter(_._2\
    \ % 2 == 1).map(_._1) ++ List(lst.last)).toList\n        }", "        // fill\
    \ in code here\n        lst", "        if (lst.isEmpty) lst\n        else {\n\
    \            var temp = lst.sorted\n            var result = ListBuffer[Long]()\n\
    \            var i = 0\n            var reverse = false\n            while (i\
    \ < temp.length) {\n                if (reverse) {\n                    result\
    \ += temp.last\n                    temp = temp.take(temp.length - 1)\n      \
    \          } else {\n                    result += temp.head\n               \
    \     temp = temp.tail\n                }\n                reverse = !reverse\n\
    \                i += 1\n            }\n            result.toList\n        }",
  "        if (lst.isEmpty) return lst\n        var list = lst.sorted\n        val\
    \ result = new ListBuffer[Long]\n        result += list.head\n        list = list.tail\n\
    \        result += list.last\n        list = list.init\n        var reverse =\
    \ false\n        for (i <- 0 until list.length) {\n            if (reverse) {\n\
    \                result += list.last\n                list = list.init\n     \
    \       } else {\n                result += list.head\n                list =\
    \ list.tail\n            }\n            reverse = !reverse\n        }\n      \
    \  result.toList", "        var lstRes = new ListBuffer[Long]\n        var lstTemp\
    \ = lst.sortWith(_ < _)\n        var lstTemp2 = lst.sortWith(_ > _)\n        for\
    \ (i <- 0 until max(lstTemp.length, lstTemp2.length)) {\n            if (i < lstTemp.length)\
    \ lstRes += lstTemp(i)\n            if (i < lstTemp2.length) lstRes += lstTemp2(i)\n\
    \        }\n        lstRes.toList", "        if (lst.isEmpty) return lst\n   \
    \     val (a, b) = lst.partition(_ <= lst.max)\n        (a ::: b.sortWith(_ <\
    \ _)).reverse", "        // Fill up this function body\n        // It must return\
    \ the sorted list in strange order.\n        var result : List[Long] = Nil\n \
    \       var min : Long = lst.min\n        var max : Long = lst.max\n        var\
    \ newlst : List[Long] = lst.filterNot(x => x == min)\n        var size : Int =\
    \ newlst.size\n        var count : Int = 1\n        while(count < size) {\n  \
    \          var newmin : Long = newlst.min\n            var newmax : Long = newlst.max\n\
    \            if(count % 2 == 1) {\n                result = result :+ newmin\n\
    \                newlst = newlst.filterNot(x => x == newmin)\n            }\n\
    \            else {\n                result = result :+ newmax\n             \
    \   newlst = newlst.filterNot(x => x == newmax)\n            }\n            count\
    \ = count + 1\n        }\n        if(newlst.size == 1) {\n            result =\
    \ result :+ newlst.head\n        }\n        else {\n            result = result\
    \ :+ newlst.min\n            result = result :+ newlst.max\n        }\n      \
    \  return result", "        var min : Long = Long.MaxValue\n        var max :\
    \ Long = Long.MinValue\n        var ret : List[Long] = Nil\n        var maxInd\
    \ : Long = 0\n        var minInd : Long = 0\n        for (i <- 0 until lst.length)\
    \ {\n            min = min min lst(i)\n            max = max max lst(i)\n    \
    \    }\n        for (i <- 0 until lst.length) {\n            if (lst(i) == min)\
    \ {\n                minInd = i\n            }\n            if (lst(i) == max)\
    \ {\n                maxInd = i\n            }\n        }\n        var dir : Long\
    \ = 1\n        var curr : Long = minInd\n        while (ret.length < lst.length)\
    \ {\n            ret = ret :+ lst(curr.toInt)\n            if (dir == 1) {\n \
    \               if (curr == maxInd) {\n                    dir = -1\n        \
    \            curr = maxInd - 1\n                } else {\n                   \
    \ curr = curr + 1\n                }\n            } else {\n                if\
    \ (curr == minInd) {\n                    dir = 1\n                    curr =\
    \ minInd + 1\n                } else {\n                    curr = curr - 1\n\
    \                }\n            }\n        }\n        return ret", "        var\
    \ newList = new ListBuffer[Long]()\n        var lstCopy = lst.sorted\n       \
    \ var i = 0\n        while (i < lst.length) {\n            if (i % 2 == 0) newList\
    \ += lstCopy.head\n            else newList += lstCopy.last\n            lstCopy\
    \ = lstCopy.filterNot(x => x == lstCopy.head || x == lstCopy.last)\n         \
    \   i += 1\n        }\n        newList.toList", "        var newList = new ArrayBuffer[Long]()\n\
    \        var l = new ListBuffer[Long]()\n        l.addAll(lst)\n        while\
    \ (l.size > 0) {\n            var min = l.min\n            var max = l.max\n \
    \           newList += min\n            newList += max\n            l -= min\n\
    \            l -= max\n        }\n        newList.toList", '        lst.sortWith(_
    < _)', '        //fill this method', "        if (lst.length == 0) return List[Long]()\n\
    \        val mins = lst.filter(_ == lst.min)\n        val maxs = lst.filter(_\
    \ == lst.max)\n        val rm = lst.filter(a => a != lst.min && a != lst.max)\n\
    \        var remaining = List[Long]()\n        for (x <- 0 to (rm.length / 2 -\
    \ 1)) {\n            remaining = remaining :+ rm(x)\n            remaining = remaining\
    \ :+ rm(rm.length - 1 - x)\n        }\n        if (rm.length % 2 == 1) remaining\
    \ = remaining :+ rm(rm.length / 2)\n        mins ::: remaining ::: maxs", "  \
    \      var l : List[Long] = List.empty[Long]\n        val listBuffer : ListBuffer[Long]\
    \ = ListBuffer.empty[Long]\n        listBuffer ++= lst\n        while(listBuffer.nonEmpty)\
    \ {\n            val min : Long = listBuffer.min\n            val max : Long =\
    \ listBuffer.max\n            listBuffer -= min\n            listBuffer -= max\n\
    \            l = l :+ min\n            l = l :+ max\n        }\n        l", " \
    \       if (lst.length < 2) return lst\n        var f = 0\n        var s = lst.length\
    \ - 1\n        var res = new Array[Long](lst.length)\n        val minMax = minMax(lst)\n\
    \        var min = minMax._1\n        var max = minMax._2\n        var current\
    \ = 0\n        while (f <= s) {\n            if (current % 2 == 0) {\n       \
    \         res(f) = min\n                f += 1\n                min += 1\n   \
    \         } else {\n                res(s) = max\n                s -= 1\n   \
    \             max -= 1\n            }\n            current += 1\n        }\n \
    \       res.toList", "        def sort(remaining : List[Long], sorted : List[Long])\
    \ : List[Long] = {\n            if (remaining.isEmpty) sorted\n            else\
    \ if (remaining.size == 1) remaining ::: sorted\n            else {\n        \
    \        val min = remaining.min\n                val minIndex = remaining.indexOf(min)\n\
    \                val max = remaining.max\n                val maxIndex = remaining.indexOf(max)\n\
    \                if (minIndex < maxIndex) sort(remaining.slice(0, minIndex) :::\
    \ remaining.slice(minIndex + 1, maxIndex) ::: remaining.slice(maxIndex + 1, remaining.size),\
    \ min :: sorted)\n                else sort(remaining.slice(0, maxIndex) ::: remaining.slice(maxIndex\
    \ + 1, minIndex) ::: remaining.slice(minIndex + 1, remaining.size), max :: sorted)\n\
    \            }\n        }\n        sort(lst, List())", "        val min = lst.min\n\
    \        val max = lst.max\n        val m = max - min\n        val n = lst.length\n\
    \        val bf = n % 2 == 0\n        val r = n / 2\n        val mr = m % r\n\
    \        val mp = m / r\n        val hf = (0 until r).map(x => x + min).toList\n\
    \        val h = if (bf) hf else hf ++ hf.reverse\n        val hl = h.length\n\
    \        val t = (0 until (if (bf) hl / 2 else hl)).map(x => h(x) + mp).toList\n\
    \        val result = if (bf) h ++ t else h.dropRight(hl / 2) ++ t\n        result.take(n)",
  '        lst.sorted.foldLeft(List[Long]())((lst, v) => if (lst.length % 2 == 0)
    v :: lst else lst :+ v).reverse', "        // this is the minimum value at the\
    \ beginning\n        // then max, then min, then max, then min, ...\n        //\
    \ sort the list\n        val sorted = lst.sorted\n        // make a new list\n\
    \        val newList = new ListBuffer[Long]\n        // max, min, max, min, ...\n\
    \        var ascending = true\n        // until the list is empty\n        while\
    \ (sorted.nonEmpty) {\n            // add last or first to the new list\n    \
    \        if (ascending) {\n                newList += sorted.last\n          \
    \      sorted.dropRight(1)\n            } else {\n                newList += sorted.head\n\
    \                sorted.drop(1)\n            }\n            // switch ascen/descending\n\
    \            ascending = !ascending\n        }\n        // return new list\n \
    \       newList.toList", '        ???', "        var positive = lst.filter(x =>\
    \ x > 0)\n        var negative = lst.filter(x => x < 0)\n        var ascending\
    \ = positive.sorted\n        var descending = negative.sorted.reverse\n      \
    \  var result = List[Long]()\n        while(!ascending.isEmpty || !descending.isEmpty)\
    \ {\n            if(!ascending.isEmpty) {\n                result = result :+\
    \ ascending.head\n                ascending = ascending.tail\n            }\n\
    \            if(!descending.isEmpty) {\n                result = result :+ descending.head\n\
    \                descending = descending.tail\n            }\n        }\n    \
    \    return result", "        var ls = lst.sortWith(_ < _)\n        var res =\
    \ List[Long]()\n        var counter = 0\n        while (ls.length > 0) {\n   \
    \         if (counter % 2 == 0) res = ls.head :: res\n            else res = ls.last\
    \ :: res\n            ls = if (counter % 2 == 0) ls.tail else ls.init\n      \
    \      counter += 1\n        }\n        res.reverse", "        var result = new\
    \ ListBuffer[Long]\n        var sortedList = lst.sorted\n        for (i <- 0 until\
    \ sortedList.length) {\n            val x = if (i % 2 == 0) {\n              \
    \  sortedList(i / 2)\n            } else {\n                sortedList(sortedList.length\
    \ - 1 - i / 2)\n            }\n            result += x\n        }\n        result.toList",
  "        // Insert your code here\n        if (lst.isEmpty) return lst\n       \
    \ val sorted = lst.sorted\n        val size = sorted.size\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val first = min :: (max :: Nil)\n    \
    \    val other = sorted.tail.init\n        val last = other.reverse\n        last\
    \ ::: first", "        val _sortedList = lst.sortBy(identity)\n        val _maxList\
    \ = _sortedList.reverse\n        var resultList = new ListBuffer[Long]()\n   \
    \     val size = lst.size\n        if (size % 2 == 0) {\n            for (i <-\
    \ 0 until size/2) {\n                resultList += _sortedList(i)\n          \
    \      resultList += _maxList(i)\n            }\n        } else {\n          \
    \  for (i <- 0 until floor(size/2).toInt) {\n                resultList += _sortedList(i)\n\
    \                resultList += _maxList(i)\n            }\n            resultList\
    \ += _sortedList(floor(size/2).toInt)\n        }\n        resultList.toList",
  "        def strangeSortListHelper(lst : List[Long], acc : List[Long]) : List[Long]\
    \ = {\n            if (lst.isEmpty) acc\n            else {\n                strangeSortListHelper(lst.filter(x\
    \ => x != lst.min && x != lst.max), lst.min :: lst.max :: acc)\n            }\n\
    \        }\n        strangeSortListHelper(lst, List[Long]()).reverse", "     \
    \   val sortedList = lst.sorted\n        var list = new ListBuffer[Long]()\n \
    \       var i = 0\n        var j = sortedList.length - 1\n        while (i <=\
    \ j) {\n            list += sortedList(i)\n            if (i != j) {\n       \
    \         list += sortedList(j)\n            }\n            i += 1\n         \
    \   j -= 1\n        }\n        list.toList", "        if (lst.length % 2 == 0)\
    \ (helper(lst.sortWith((a, b) => a < b), \"min\") ::: helper(lst.sortWith((a,\
    \ b) => a > b), \"max\")).toList\n        else (helper(lst.sortWith((a, b) =>\
    \ a < b), \"min\") ::: helper(lst.sortWith((a, b) => a > b), \"max\") :+ helper(lst.sortWith((a,\
    \ b) => a < b), \"min\").last).toList", "        var odd : List[Long] = List[Long]()\n\
    \        var even : List[Long] = List[Long]()\n        var result : List[Long]\
    \ = List[Long]()\n        for(i <- 0 until lst.length) {\n            if(i % 2\
    \ == 0) {\n                odd = odd :+ lst(i)\n            } else {\n       \
    \         even = even :+ lst(i)\n            }\n        }\n        even = even.sortWith(_\
    \ > _)\n        for(i <- 0 until odd.length) {\n            result = result :+\
    \ odd(i)\n            if(i < even.length) {\n                result = result :+\
    \ even(i)\n            }\n        }\n        return result", "        // Implement\
    \ this function\n        return List[Long]()", "        // >>> def strangeSortList(lst\
    \ : List[Long]) : List[Long] = {\n        // ...     if (lst.isEmpty) {\n    \
    \    // ...         lst\n        // ...     } else {\n        // ...         var\
    \ lst1 = lst.min\n        // ...         var lst2 = lst.max\n        // ...  \
    \       var lst3 = lst.filter(x => x != lst1)\n        // ...         var lst4\
    \ = lst3.filter(x => x != lst2)\n        // ...         List[Long](lst1.toLong,\
    \ lst2.toLong) ++ strangeSortList(lst4)\n        // ...     }\n        // ...\
    \ }\n        if (lst.isEmpty) {\n            lst\n        } else {\n         \
    \   var lst1 = lst.min\n            var lst2 = lst.max\n            var lst3 =\
    \ lst.filter(x => x != lst1)\n            var lst4 = lst3.filter(x => x != lst2)\n\
    \            List[Long](lst1.toLong, lst2.toLong) ++ strangeSortList(lst4)\n \
    \       }", "        if (lst.isEmpty) List[Long]()\n        else if (lst.length\
    \ == 1) lst\n        else {\n            var index = 0\n            val res =\
    \ ListBuffer[Long]()\n            val s = lst.sorted\n            val increase\
    \ = true\n            for (i <- 0 until lst.length) {\n                if (increase)\
    \ {\n                    res += s(index)\n                    index += 1\n   \
    \             } else {\n                    res += s(lst.length - index - 1)\n\
    \                }\n                increase = !increase\n            }\n    \
    \        res.toList\n        }", "        var lst1 = lst.sorted\n        var lst2\
    \ = lst1.tail.reverse\n        var lst3 = lst1.head :: lst2\n        var i = 1\n\
    \        var lst4 = List[Long]()\n        while (i < lst.length) {\n         \
    \   if (i % 2 == 0) {\n                lst4 = lst4 :+ lst3(i)\n            } else\
    \ {\n                lst4 = lst4 :+ lst3(lst.length - i)\n            }\n    \
    \        i += 1\n        }\n        return lst4", '        lst.sortWith(_ < _)',
  "        def helper(lst : List[Long], lst2 : List[Long]) : List[Long] = {\n    \
    \        if (lst.length <= 1) lst ::: lst2\n            else {\n             \
    \   val min = lst.min\n                val minIndex = lst.indexOf(min)\n     \
    \           val max = lst.filter(_ != min).max\n                val maxIndex =\
    \ lst.indexOf(max)\n                helper(lst.filter(_ != min).filter(_ != max),\
    \ lst2 ::: List(min, max))\n            }\n        }\n        helper(lst, List())",
  "        val res = new ListBuffer[Long]\n        val pos = new ListBuffer[Int]\n\
    \        var done = false\n        var current = 0\n        while (!done) {\n\
    \            var min = Long.MaxValue\n            var min_i = -1\n           \
    \ var max = Long.MinValue\n            var max_i = -1\n            for (i <- 0\
    \ until lst.length) {\n                if (!pos.contains(i)) {\n             \
    \       if (lst(i) < min) {\n                        min = lst(i)\n          \
    \              min_i = i\n                    }\n                    if (lst(i)\
    \ > max) {\n                        max = lst(i)\n                        max_i\
    \ = i\n                    }\n                }\n            }\n            if\
    \ (min_i == -1 && max_i == -1) done = true\n            else {\n             \
    \   if (current % 2 == 0) {\n                    res += min\n                \
    \    pos += min_i\n                }\n                else {\n               \
    \     res += max\n                    pos += max_i\n                }\n      \
    \          current += 1\n            }\n        }\n        res.toList", "    \
    \    val (small, big) = lst.sortWith((x, y) => x < y).foldLeft((List[Long](),\
    \ List[Long]()))((acc, x) => (acc._2, acc._1))\n        if (small.isEmpty) big\n\
    \        else if (big.isEmpty) small\n        else small.reverse.head :: strangeSortList(small.reverse.tail\
    \ ++ big)", "        // Your code here!\n        lst", "        var result = new\
    \ ListBuffer[Long]\n        var sorter = new ListBuffer[Long]\n        var x =\
    \ 0\n        var z = 0\n        for (x <- 0 to lst.length - 1) sorter += lst(x)\n\
    \        for (x <- 0 to lst.length - 1) {\n            var minimum = sorter.min\n\
    \            var maxindex = sorter.indexOf(minimum)\n            var maximum =\
    \ sorter.max\n            var minindex = sorter.indexOf(maximum)\n           \
    \ if (x % 2 == 0) {\n                result += minimum\n                sorter\
    \ -= minimum\n            } else {\n                result += maximum\n      \
    \          sorter -= maximum\n            }\n        }\n        return result.toList",
  "        val min : Long = lst.min\n        val max : Long = lst.max\n        if\
    \ (min == max) {\n            return lst\n        }\n        var mutLst : ListBuffer[Long]\
    \ = lst.to[ListBuffer]\n        var res : ListBuffer[Long] = ListBuffer()\n  \
    \      res += min\n        mutLst = mutLst.drop(1)\n        res += max\n     \
    \   mutLst = mutLst.dropRight(1)\n        while (mutLst.size > 0) {\n        \
    \    val min : Long = mutLst.min\n            res += min\n            mutLst =\
    \ mutLst.drop(1)\n            if (mutLst.size > 0) {\n                val max\
    \ : Long = mutLst.max\n                res += max\n                mutLst = mutLst.dropRight(1)\n\
    \            }\n        }\n        return res.toList", "        var mn : Long\
    \ = Long.MaxValue\n        var mx : Long = Long.MinValue\n        var lst : List[Long]\
    \ = lst\n        var ans : List[Long] = List[Long]()\n        while (lst.length\
    \ > 0) {\n            mn = lst.min\n            mx = lst.max\n            ans\
    \ = ans :+ mn\n            ans = ans :+ mx\n            lst = lst.filter(p =>\
    \ p != mn && p != mx)\n        }\n        return ans", "        val sortList =\
    \ lst.sortWith(_ < _)\n        val size = sortList.size\n        val result =\
    \ new ArrayBuffer[Long]()\n        var i = 0\n        var j = size - 1\n     \
    \   var k = 0\n        while (i <= j) {\n            if (k % 2 == 0) {\n     \
    \           result += sortList(i)\n                i += 1\n            } else\
    \ {\n                result += sortList(j)\n                j -= 1\n         \
    \   }\n            k += 1\n        }\n        result.toList", "        // Fill\
    \ up this function body\n        // 'lst' is a list of integers\n        // 'lst.sorted'\
    \ is a list of integers, sorted in increasing order\n        // 'lst.sorted.reverse'\
    \ is a list of integers, sorted in decreasing order\n        var ls = List[Long]()\n\
    \        ls = lst.sorted\n        var size = lst.size\n        var i = 1\n   \
    \     var odd = List[Long]()\n        var even = List[Long]()\n        for (x\
    \ <- ls) {\n            if (i % 2 == 0) {\n                even = even :+ x\n\
    \            } else {\n                odd = odd :+ x\n            }\n       \
    \     i = i + 1\n        }\n        var oddl = odd.size\n        var evenl = even.size\n\
    \        var oddi = 0\n        var eveni = 0\n        var oddvar = List[Long]()\n\
    \        var evenvar = List[Long]()\n        for (i <- 1 to size) {\n        \
    \    if (i % 2 == 0) {\n                oddvar = oddvar :+ odd(oddi)\n       \
    \         oddi = oddi + 1\n            } else {\n                evenvar = evenvar\
    \ :+ even(eveni)\n                eveni = eveni + 1\n            }\n        }\n\
    \        var res = oddvar ::: evenvar\n        res", "        def strangeSortListTail(lst\
    \ : List[Long], left : List[Long], right : List[Long]) : List[Long] = {\n    \
    \        if (lst.length == 0) {\n                // Nothing left to sort, return\
    \ the sorted list.\n                return left ::: right\n            } else\
    \ {\n                // Search for the minimum and maximum values.\n         \
    \       val min = (lst.min, lst.indexOf(lst.min))\n                val max = (lst.max,\
    \ lst.indexOf(lst.max))\n                // Append the minimum value to the left.\n\
    \                val minLeft = min._1 :: left\n                // Remove the minimum\
    \ value from the list.\n                val lstMin = lst.slice(0, min._2) :::\
    \ lst.slice(min._2 + 1, lst.length)\n                // Append the maximum value\
    \ to the right.\n                val maxRight = right ::: List(max._1)\n     \
    \           // Remove the maximum value from the list.\n                val lstMax\
    \ = lst.slice(0, max._2) ::: lst.slice(max._2 + 1, lst.length)\n             \
    \   // Recursively sort the remaining list.\n                return strangeSortListTail(lstMin\
    \ ::: lstMax, minLeft, maxRight)\n            }\n        }\n        // Function\
    \ entry point, call with empty left and right lists.\n        return strangeSortListTail(lst,\
    \ List(), List())", '        lst.sortWith((x, y) => (x - y < 0)).foldLeft(List[Long]())((acc,
    x) => if (acc.length % 2 == 0) acc :+ x else acc.init :+ x :+ acc.last)', "  \
    \      val sorted = lst.sorted\n        if (sorted.isEmpty) return sorted\n  \
    \      val result = new ArrayBuffer[Long]\n        val (ls, rs) = sorted.splitAt(sorted.length\
    \ / 2)\n        result ++= ls\n        result ++= rs.reverse\n        result.toList",
  "        // Fill in the function here\n        lst", "        val lstSorted = lst.sorted\n\
    \        val lstSortedMinToMax = lstSorted.scanLeft(lstSorted.head)(_+_).tail\n\
    \        val lstSortedMaxToMin = lstSorted.scanRight(lstSorted.last)(_+_).init\n\
    \        val lst1 = lstSortedMinToMax.zip(lstSortedMaxToMin).flatMap(x => List(x._1,\
    \ x._2))\n        if (lst.size % 2 == 0) lst1 else lst1 :+ lstSortedMinToMax.last",
  "        if (lst.length == 0) return lst\n        var sortedList = lst.sorted\n\
    \        var ans = new ListBuffer[Long]\n        var i = 0\n        while (sortedList.length\
    \ > 0) {\n            if (i % 2 == 0) {\n                ans += sortedList.min\n\
    \                sortedList = sortedList.filter(_ != sortedList.min)\n       \
    \     } else {\n                ans += sortedList.max\n                sortedList\
    \ = sortedList.filter(_ != sortedList.max)\n            }\n            i += 1\n\
    \        }\n        ans.toList", '        return lst', '        return lst.sortWith((a,
    b) => a < b)', "        var lst1 = lst.sorted\n        var lst2 = lst1.reverse\n\
    \        val lst3 = ArrayBuffer.empty[Long]\n        for (i <- 0 until lst1.length)\
    \ {\n            if (i % 2 == 0) lst3 += lst1(i)\n            else lst3 += lst2(i)\n\
    \        }\n        lst3.toList", '        ???', "        val odd_lst = new ListBuffer[Long]()\n\
    \        val even_lst = new ListBuffer[Long]()\n        val lst_sorted = lst.sorted\n\
    \        lst_sorted.zipWithIndex.foreach {\n            case (a, i) => {\n   \
    \             if (i % 2 == 0) odd_lst += a\n                else even_lst += a\n\
    \            }\n        }\n        odd_lst.toList ++ even_lst.toList", "     \
    \   val mutableLst = lst.toBuffer\n        val sortedList = mutableLst.sortWith((a,\
    \ b) => a < b)\n        var odd = true\n        var result = new ListBuffer[Long]\n\
    \        while (!sortedList.isEmpty) {\n            if (odd) {\n             \
    \   result += sortedList.remove(0)\n            } else {\n                result\
    \ += sortedList.remove(sortedList.length - 1)\n            }\n            odd\
    \ = !odd\n        }\n        result.toList", "        val l = ListBuffer[Long]()\n\
    \        if (lst.length == 0) {\n            return l.toList\n        }\n    \
    \    val sorted = lst.sorted\n        val min = sorted.head\n        val max =\
    \ sorted.last\n        var (minI, maxI) = (0, sorted.length - 1)\n        var\
    \ addMin = true\n        while (minI < maxI) {\n            if (addMin) {\n  \
    \              l += sorted(minI)\n                minI += 1\n            } else\
    \ {\n                l += sorted(maxI)\n                maxI -= 1\n          \
    \  }\n            addMin = !addMin\n        }\n        if (l.length == lst.length)\
    \ {\n            l += sorted(minI)\n        }\n        l.toList", "        if\
    \ (lst.length == 0) {\n            List[Long]()\n        } else {\n          \
    \  var newLst = scala.collection.mutable.ArrayBuffer.empty[Long]\n           \
    \ var lstCopy = lst.sortWith(_<_)\n            var lstMax = lstCopy.max\n    \
    \        newLst += lstCopy.min\n            lstCopy -= lstCopy.min\n         \
    \   newLst += lstCopy.max\n            lstCopy -= lstCopy.max\n            while\
    \ (lstCopy.length > 0) {\n                if (newLst.last != lstMax) {\n     \
    \               newLst += lstCopy.min\n                    lstCopy -= lstCopy.min\n\
    \                } else {\n                    newLst += lstCopy.max\n       \
    \             lstCopy -= lstCopy.max\n                }\n            }\n     \
    \       newLst.toList\n        }", "        def helper(lst : List[Long], odd :\
    \ Boolean) : List[Long] = {\n            if (lst.length == 0) Nil\n          \
    \  else if (lst.length == 1) lst\n            else {\n                val head\
    \ = if (odd) lst.min else lst.max\n                val tail = lst.filter(_ !=\
    \ head)\n                head :: helper(tail, !odd)\n            }\n        }\n\
    \        helper(lst, true)", "        if (lst.length <= 1) {\n            return\
    \ lst\n        }\n        var newList = ListBuffer[Long]()\n        var ascending\
    \ : Boolean = true\n        for (i <- 0 until lst.length) {\n            val minElem\
    \ = lst.min\n            val minIndex = lst.indexOf(minElem)\n            newList\
    \ += minElem\n            lst.remove(minIndex)\n        }\n        newList.toList",
  "        // Do nothing if list is empty.\n        if (lst.isEmpty) return lst\n\
    \        // Extract minimum and maximum.\n        var min = lst.min\n        var\
    \ max = lst.max\n        // Remove minimum and maximum from list.\n        var\
    \ lstRevised = lst.filter(x => x != min && x != max)\n        // Get strange sort\
    \ of remaining list.\n        var strangeLst = strangeSortList(lstRevised)\n \
    \       // Result list.\n        var resultLst = List[Long]()\n        // Fill\
    \ result list with minimum and maximum,\n        // and all elements of strange\
    \ sort of remaining list,\n        // alternating.\n        if (lst.size % 2 ==\
    \ 0) {\n            while (strangeLst.size > 0) {\n                resultLst =\
    \ resultLst :+ min\n                resultLst = resultLst :+ strangeLst.head\n\
    \                resultLst = resultLst :+ max\n                resultLst = resultLst\
    \ :+ strangeLst.tail.head\n                strangeLst = strangeLst.tail.tail\n\
    \            }\n        } else {\n            while (strangeLst.size > 0) {\n\
    \                resultLst = resultLst :+ min\n                resultLst = resultLst\
    \ :+ strangeLst.head\n                resultLst = resultLst :+ max\n         \
    \       resultLst = resultLst :+ strangeLst.tail.head\n                strangeLst\
    \ = strangeLst.tail.tail\n            }\n            resultLst = resultLst :+\
    \ min\n        }\n        // Return result list.\n        return resultLst", " \
    \       // Returns (remaining, newLst)\n        def strangeSort(lst : List[Long],\
    \ acc : List[Long]) : (List[Long], List[Long]) = {\n            val min :: rest\
    \ = lst.sorted\n            val max :: rrest = rest.sorted.reverse\n         \
    \   if (rest.isEmpty) (rest, acc :+ min)\n            else strangeSort(rrest,\
    \ acc :+ min :+ max)\n        }\n        strangeSort(lst, List())._2", "     \
    \   if (lst.length == 0) return List[Long]()\n        def strangeSortListIter(lst\
    \ : List[Long], lst_sorted : List[Long]) : List[Long] = {\n            if (lst.length\
    \ == 0) return lst_sorted\n            else {\n                val min = lst.min\n\
    \                val max = lst.max\n                val min_index = lst.indexOf(min)\n\
    \                val max_index = lst.indexOf(max)\n                val lst_new\
    \ = lst.patch(min_index, Nil, 1).patch(max_index - 1, Nil, 1)\n              \
    \  val lst_sorted_new = lst_sorted :+ min :+ max\n                strangeSortListIter(lst_new,\
    \ lst_sorted_new)\n            }\n        }\n        strangeSortListIter(lst,\
    \ List[Long]())", '        lst.sorted.foldLeft(List[Long]())((acc, n) => acc :+
    n)', "        // Fill in the code\n        val m = new HashMap[Int,Long]\n   \
    \     val lstSorted = lst.sorted\n        for (i <- lstSorted.indices) {\n   \
    \         val si = if (i % 2 == 0) i else lstSorted.length - i - 1\n         \
    \   m += (si -> lstSorted(i))\n        }\n        m.toList.sortBy(_._1).map(_._2)",
  '        lst.sorted.foldLeft((List[Long](), true))((res, x) => if (res._2) (res._1
    :+ x, false) else (res._1 :+ x, true))._1', "        var minIndex = 0\n      \
    \  var maxIndex = 0\n        for (i <- 1 until lst.length) {\n            if (lst(i)\
    \ < lst(minIndex)) minIndex = i\n            if (lst(i) > lst(maxIndex)) maxIndex\
    \ = i\n        }\n        if (minIndex == maxIndex) return lst\n        var list\
    \ = scala.collection.mutable.ListBuffer(lst(minIndex))\n        var min = minIndex\n\
    \        var max = maxIndex\n        if (minIndex < maxIndex) {\n            min\
    \ = minIndex + 1\n            max = maxIndex - 1\n        } else {\n         \
    \   min = minIndex - 1\n            max = maxIndex + 1\n        }\n        while\
    \ (min != max) {\n            list += lst(max)\n            if (min > max) {\n\
    \                max -= 1\n            } else {\n                max += 1\n  \
    \          }\n            list += lst(min)\n            if (min > max) {\n   \
    \             min -= 1\n            } else {\n                min += 1\n     \
    \       }\n        }\n        list += lst(max)\n        list.toList", "      \
    \  var lstSorted = lst.sorted\n        var ret = new ListBuffer[Long]\n      \
    \  var left = true\n        while (!lstSorted.isEmpty) {\n            if (left)\
    \ {\n                ret += lstSorted.head\n                lstSorted = lstSorted.tail\n\
    \            } else {\n                ret += lstSorted.last\n               \
    \ lstSorted = lstSorted.init\n            }\n            left = !left\n      \
    \  }\n        ret.toList", '        lst.sortWith((x, y) => (lst.indexOf(x) % 2
    == 0 && lst.indexOf(y) % 2 == 1) || (lst.indexOf(x) % 2 == 1 && lst.indexOf(y)
    % 2 == 0 && x > y) || (lst.indexOf(x) % 2 == 0 && lst.indexOf(y) % 2 == 0 && x
    < y))', "        var result : List[Long] = List[Long]()\n        var sorted =\
    \ lst.sorted\n        while (sorted.length > 0) {\n            result = result\
    \ :+ sorted.head\n            sorted = sorted.tail\n            if (sorted.length\
    \ > 0) {\n                result = result :+ sorted.last\n                sorted\
    \ = sorted.dropRight(1)\n            }\n        }\n        return result", '        lst.sorted',
  "        lst match {\n            case Nil => Nil\n            case x :: xs => {\n\
    \                val (min, rest) = (lst.min, lst.filter(_ != lst.min))\n     \
    \           val y :: ys = strangeSortList(rest)\n                if (y == ys.head)\
    \ (y :: ys) else (min :: y :: ys)\n            }\n        }", "        var list\
    \ = lst.sortWith((x, y) => x < y)\n        var result = List[Long]()\n       \
    \ while (!list.isEmpty) {\n            result = result :+ list.head\n        \
    \    list = list.tail\n            if (!list.isEmpty) {\n                result\
    \ = result :+ list.last\n                list = list.init\n            }\n   \
    \     }\n        result", "        val sortedLst = lst.sorted.reverse\n      \
    \  val result = ListBuffer[Long]()\n        var index = 0\n        while (index\
    \ < sortedLst.length) {\n            if (index % 2 == 0) {\n                result\
    \ += sortedLst(index)\n            } else {\n                result.prepend(sortedLst(index))\n\
    \            }\n            index += 1\n        }\n        result.toList", " \
    \       var xs = lst.sorted\n        var ys = new ListBuffer[Long]\n        while\
    \ (!xs.isEmpty) {\n            ys += xs.head\n            xs = xs.tail\n     \
    \       if (!xs.isEmpty) {\n                ys += xs.last\n                xs\
    \ = xs.init\n            }\n        }\n        ys.toList", "        if (lst.isEmpty)\
    \ List[Long]()\n        else {\n            def sol(lst : List[Long], list : List[Long])\
    \ : List[Long] = {\n                if (lst.isEmpty) list\n                else\
    \ {\n                    val min = lst.min\n                    val max = lst.max\n\
    \                    val lst1 = lst.filter(x => x != min && x != max)\n      \
    \              if (lst1.isEmpty) list :+ min :+ max\n                    else\
    \ sol(lst1, list :+ min :+ max)\n                }\n            }\n          \
    \  sol(lst, List[Long]())\n        }", "        // Your code here.\n        (lst,\
    \ true) match {\n            case (List(), _) => List()\n            case (lst,\
    \ true) =>\n                val min = lst.min\n                val idx = lst.indexOf(min)\n\
    \                val lst2 = lst.take(idx) ++ lst.drop(idx + 1)\n             \
    \   min :: strangeSortList(lst2, false)\n            case (lst, false) =>\n  \
    \              val max = lst.max\n                val idx = lst.indexOf(max)\n\
    \                val lst2 = lst.take(idx) ++ lst.drop(idx + 1)\n             \
    \   max :: strangeSortList(lst2, true)\n        }", "      // Fill up this function\
    \ body\n      // It is recommended to do more than just returning an empty list\n\
    \      List[Long]()", "        if (lst.isEmpty) return lst\n        val sorted\
    \ = lst.sorted\n        val result = new ListBuffer[Long]\n        var i = 0\n\
    \        var j = sorted.length - 1\n        while (i < j) {\n            result\
    \ += sorted(i)\n            result += sorted(j)\n            i += 1\n        \
    \    j -= 1\n        }\n        if (i == j) result += sorted(i)\n        result.toList",
  "        // Your code here.\n        if (lst.length <= 1) lst\n        else {\n\
    \            val head = lst.min\n            val lst_rest = lst.filter(_ != head)\n\
    \            val head_1 = lst_rest.max\n            val lst_rest_1 = lst_rest.filter(_\
    \ != head_1)\n            strangeSortList(head :: head_1 :: lst_rest_1)\n    \
    \    }", "        // Solution 1:\n        // var result = List[Long]()\n     \
    \   // val reverse = lst.sorted.reverse\n        // var current = lst.min\n  \
    \      // for (i <- 0 until lst.length) {\n        //     result = result :+ current\n\
    \        //     if (current == lst.max) current = lst.min\n        //     else\
    \ if (current == lst.min) current = lst.max\n        //     else current = if\
    \ (i % 2 == 0) reverse.dropWhile(_ != current).tail.head else lst.sorted.dropWhile(_\
    \ != current).tail.head\n        // }\n        // result\n        // Solution\
    \ 2:\n        lst.sortWith(_ < _).reverse.grouped(2).toList.transpose.flatten",
  "        def strange(lst : List[Long], lst1 : List[Long]) : List[Long] = lst match\
    \ {\n            case List() => lst1\n            case lst : List[Long] => lst\
    \ match {\n                case List() => lst1\n                case x :: xs =>\
    \ strange(xs, xs.max :: x :: xs.min :: lst1)\n            }\n        }\n     \
    \   strange(lst, List()).reverse", "        val lst2 = lst.toArray.sortWith((x,\
    \ y) => x < y)\n        val lst3 = lst2.toBuffer\n        val lst4 = Buffer[Long]()\n\
    \        for (i <- 0 until lst2.length) {\n            if (i % 2 == 0) lst4 +=\
    \ lst3.remove(0)\n            else lst4 += lst3.remove(lst3.length - 1)\n    \
    \    }\n        return lst4.toList", "        // Fill in the implementation here\n\
    \        // return ???\n        var _list = lst.toArray\n        var tmp = lst.toArray\n\
    \        var l = _list.length\n        while (l > 0) {\n            var minVal\
    \ = lst.min\n            var index = tmp.indexOf(minVal)\n            tmp(index)\
    \ = -1\n            l = l - 1\n            if (l > 0) {\n                var maxVal\
    \ = lst.max\n                index = tmp.indexOf(maxVal)\n                tmp(index)\
    \ = -1\n                l = l - 1\n            }\n        }\n        return _list.toList",
  "        if (lst.length <= 1) return lst\n        var acc: ArrayBuffer[Long] = ArrayBuffer.empty[Long]\n\
    \        var pos = 0\n        if (lst.length % 2 == 0) pos = lst.length / 2 -\
    \ 1\n        else pos = lst.length / 2\n        while (pos >= 0) {\n         \
    \   acc += lst(pos)\n            if (pos + pos + 1 < lst.length) {\n         \
    \       acc += lst(pos + pos + 1)\n            }\n            pos -= 1\n     \
    \   }\n        return acc.toList", "        val list = lst.sortWith((a, b) =>\
    \ a < b)\n        val first = ListBuffer[Long]()\n        val second = ListBuffer[Long]()\n\
    \        while (list.length > 0) {\n            first += list.head\n         \
    \   list.tail.foldLeft(Long.MinValue)((b, a) => {\n                if (a > b)\
    \ {\n                    second += a\n                    a\n                }\
    \ else {\n                    b\n                }\n            })\n         \
    \   list = list.filter(n => n != first.last && n != second.last)\n        }\n\
    \        (first ++ second).toList", "        var lst2 = new Queue[Long]\n    \
    \    var lst1 = scala.collection.mutable.PriorityQueue[Long]()(Ordering.by[Long,\
    \ Long](-_))\n        var lst3 = scala.collection.mutable.PriorityQueue[Long]()(Ordering.by[Long,\
    \ Long](_))\n        var ans = new Queue[Long]\n        for (x <- lst) {\n   \
    \         lst1.enqueue(x)\n            lst3.enqueue(x)\n        }\n        while\
    \ (lst1.nonEmpty) {\n            lst2.enqueue(lst1.dequeue)\n            lst2.enqueue(lst3.dequeue)\n\
    \        }\n        while (lst2.nonEmpty) {\n            ans.enqueue(lst2.dequeue)\n\
    \        }\n        ans.toList", "        if (lst.isEmpty) return List[Long]()\n\
    \        val sorted = lst.sorted\n        val ret = new ListBuffer[Long]\n   \
    \     var start = 0\n        var end = sorted.length - 1\n        while (start\
    \ <= end) {\n            ret += sorted(start)\n            if (start != end) ret\
    \ += sorted(end)\n            start += 1\n            end -= 1\n        }\n  \
    \      ret.toList", "        // Implement here\n        var result = List[Long]()\n\
    \        var temp = lst.sorted\n        while(temp.length > 0) {\n           \
    \ if(temp.length == 1) result = result :+ temp.head\n            else {\n    \
    \            var x = temp.head\n                result = result :+ x\n       \
    \         temp = temp.drop(1)\n                x = temp.last\n               \
    \ result = result :+ x\n                temp = temp.dropRight(1)\n           \
    \ }\n        }\n        result", "        def getMinMax(lst : List[Long]) : (Long,\
    \ Long) = {\n            var min = Long.MaxValue\n            var max = Long.MinValue\n\
    \            for (x <- lst) {\n                if (x < min) min = x\n        \
    \        if (x > max) max = x\n            }\n            (min, max)\n       \
    \ }\n        def helper(lst : List[Long], isMax : Boolean) : List[Long] = {\n\
    \            if (lst.isEmpty) List[Long]()\n            else {\n             \
    \   val (min, max) = getMinMax(lst)\n                if (isMax) {\n          \
    \          max :: helper(lst.filter(_ != max), false)\n                } else\
    \ {\n                    min :: helper(lst.filter(_ != min), true)\n         \
    \       }\n            }\n        }\n        helper(lst, false)", "        val\
    \ len = lst.length\n        if (len <= 0) return lst\n        val result = ListBuffer[Long]()\n\
    \        val min = lst.min\n        val max = lst.max\n        var lst2 = lst.filter(x\
    \ => x != min && x != max)\n        var asc = true\n        while (result.length\
    \ < len) {\n            if (asc) {\n                var min1 = lst2.min\n    \
    \            lst2 = lst2.filter(x => x != min1)\n                result += min1\n\
    \            } else {\n                var max1 = lst2.max\n                lst2\
    \ = lst2.filter(x => x != max1)\n                result += max1\n            }\n\
    \            asc = !asc\n        }\n        result.toList", "        val sorted\
    \ = lst.sorted\n        var result = List[Long]()\n        var temp = sorted\n\
    \        while (temp.length > 0) {\n            result = temp.head :: result\n\
    \            temp = temp.tail\n            if (temp.length > 0) {\n          \
    \      result = temp.last :: result\n                temp = temp.init\n      \
    \      }\n        }\n        result", "        def helper(list : List[Long], res\
    \ : List[Long]) : List[Long] = {\n            if (list.isEmpty) res\n        \
    \    else {\n                val min = list.min\n                val max = list.max\n\
    \                helper(list.filter(_ != min).filter(_ != max), res ++ List(min,\
    \ max))\n            }\n        }\n        helper(lst, List[Long]())", "     \
    \   val lstSorted = lst.sorted\n        val lstSortedLength = lstSorted.length\n\
    \        val lstSortedHalfLength = lstSortedLength / 2\n        val lstSortedOdd\
    \ = lstSortedLength % 2 == 1\n        val lstSortedLeft = lstSorted.take(lstSortedHalfLength)\n\
    \        val lstSortedRight = lstSorted.takeRight(lstSortedHalfLength)\n     \
    \   val lstSortedOddMiddle = if (lstSortedOdd) List(lstSorted(lstSortedHalfLength))\
    \ else List()\n        val lstLeft = lstSortedLeft.zip(lstSortedRight.reverse).flatMap(a\
    \ => List(a._1, a._2))\n        lstLeft ::: lstSortedOddMiddle", "        // Find\
    \ minimum\n        // Find maximum\n        // Remove minimum\n        // Remove\
    \ maximum\n        // Return list\n        def findMin(lst : List[Long]) : Long\
    \ = lst.min\n        def findMax(lst : List[Long]) : Long = lst.max\n        def\
    \ findMinIndex(lst : List[Long]) : Int = lst.indexOf(findMin(lst))\n        def\
    \ findMaxIndex(lst : List[Long]) : Int = lst.indexOf(findMax(lst))\n        def\
    \ removeAt(lst : List[Long], index : Int) : List[Long] = {\n            lst.take(index)\
    \ ++ lst.drop(index + 1)\n        }\n        // Copy list\n        var newLst\
    \ = lst\n        var strangeLst = List[Long]()\n        while (newLst.length >\
    \ 0) {\n            val min = findMin(newLst)\n            val max = findMax(newLst)\n\
    \            val minIndex = findMinIndex(newLst)\n            val maxIndex = findMaxIndex(newLst)\n\
    \            newLst = removeAt(newLst, minIndex)\n            newLst = removeAt(newLst,\
    \ maxIndex - 1)\n            strangeLst = strangeLst :+ min\n            strangeLst\
    \ = strangeLst :+ max\n        }\n        strangeLst", "        var result = List[Long]()\n\
    \        var minIndex = 0\n        var maxIndex = 0\n        var index = 0\n \
    \       if (lst.length == 0) {\n            return result\n        }\n       \
    \ for (i <- 0 until lst.length) {\n            if (lst(i) < lst(minIndex)) {\n\
    \                minIndex = i\n            }\n            if (lst(i) > lst(maxIndex))\
    \ {\n                maxIndex = i\n            }\n        }\n        while (result.length\
    \ < lst.length) {\n            if (index % 2 == 0) {\n                result =\
    \ result :+ lst(minIndex)\n                if (minIndex < maxIndex) {\n      \
    \              minIndex += 1\n                } else {\n                    minIndex\
    \ -= 1\n                }\n            } else {\n                result = result\
    \ :+ lst(maxIndex)\n                if (maxIndex < minIndex) {\n             \
    \       maxIndex += 1\n                } else {\n                    maxIndex\
    \ -= 1\n                }\n            }\n            index += 1\n        }\n\
    \        return result", "        var s = scala.collection.mutable.ListBuffer[Long]()\n\
    \        while (lst.size != 0) {\n            val min = lst.min\n            s\
    \ += min\n            lst = lst.filter(_ != min)\n            if (lst.size !=\
    \ 0) {\n                val max = lst.max\n                s += max\n        \
    \        lst = lst.filter(_ != max)\n            }\n        }\n        s.toList",
  '        lst.sorted.sortWith((a, b) => a > b)', "        // Vars\n        var odd\
    \ : List[Long] = List[Long]()\n        var even : List[Long] = List[Long]()\n\
    \        var i : Int = 0\n        for (i <- 0 to lst.length - 1) {\n         \
    \   if (i % 2 == 0) {\n                odd = odd :+ lst(i)\n            } else\
    \ {\n                even = even :+ lst(i)\n            }\n        }\n       \
    \ // Sort lists\n        odd = odd.sorted\n        even = even.sorted\n      \
    \  // Join lists\n        var res : List[Long] = List[Long]()\n        for (i\
    \ <- 0 to odd.length - 1) {\n            res = res :+ odd(i)\n            if (i\
    \ < even.length) {\n                res = res :+ even(i)\n            }\n    \
    \    }\n        // Return result\n        return res", "        var ans : List[Long]\
    \ = List[Long]()\n        var min_remain : Long = Int.MaxValue\n        var max_remain\
    \ : Long = Int.MinValue\n        var min_val_ind : Int = -1\n        var max_val_ind\
    \ : Int = -1\n        for (i <- 0 until lst.length) {\n            if (lst(i)\
    \ < min_remain) {\n                min_remain = lst(i)\n                min_val_ind\
    \ = i\n            }\n            if (lst(i) > max_remain) {\n               \
    \ max_remain = lst(i)\n                max_val_ind = i\n            }\n      \
    \  }\n        ans = ans :+ min_remain\n        lst.remove(min_val_ind)\n     \
    \   while (lst.length > 0) {\n            min_remain = Int.MaxValue\n        \
    \    max_remain = Int.MinValue\n            min_val_ind = -1\n            max_val_ind\
    \ = -1\n            for (i <- 0 until lst.length) {\n                if (lst(i)\
    \ < min_remain) {\n                    min_remain = lst(i)\n                 \
    \   min_val_ind = i\n                }\n                if (lst(i) > max_remain)\
    \ {\n                    max_remain = lst(i)\n                    max_val_ind\
    \ = i\n                }\n            }\n            ans = ans :+ max_remain\n\
    \            lst.remove(max_val_ind)\n            if (lst.length > 0) {\n    \
    \            ans = ans :+ min_remain\n                lst.remove(min_val_ind)\n\
    \            }\n        }\n        return ans", "        val m = lst.map((x :\
    \ Long) => x).sorted\n        if (m.length == 0) return lst\n        var k = m.head\n\
    \        val n = m.tail\n        var i = n.length - 1\n        var j = 0\n   \
    \     val r = ListBuffer[Long]()\n        r += k\n        while (i > j) {\n  \
    \          r += n(i)\n            i -= 1\n            if (i < j) return r.toList\n\
    \            r += n(j)\n            j += 1\n        }\n        if (i == j) r +=\
    \ n(i)\n        r.toList", "        // Your code here\n        lst", "       \
    \ val min = lst.min\n        var lst1 = lst.filter(_ > min)\n        var lst2\
    \ = lst.filter(_ < min)\n        return strangeSortList(lst1) ::: List(min) :::\
    \ strangeSortList(lst2)", '        lst.sortWith(_ < _)', "        if (lst.length\
    \ % 2 == 0) (lst.sorted ++ lst.sorted.reverse).toList\n        else {\n      \
    \      val temp = (lst.sorted ++ lst.sorted.reverse).toList\n            List(temp.head)\
    \ ++ temp.tail.tail\n        }", '        lst.sortWith(_ < _)', "        var ret\
    \ = List[Long]()\n        var min = -1l\n        var max = -1l\n        while(lst.length\
    \ != 0) {\n            min = lst.min\n            max = lst.max\n            ret\
    \ = min :: ret\n            if(min != max) {\n                ret = max :: ret\n\
    \            }\n            lst = lst.filter(_ != min)\n            lst = lst.filter(_\
    \ != max)\n        }\n        ret.reverse", "        if (lst.length == 0) return\
    \ List[Long]()\n        var max = lst.max\n        var min = lst.min\n       \
    \ var lst2 = lst.toBuffer\n        var result = List[Long]()\n        var addingMin\
    \ = true\n        while (lst2.length > 0) {\n            if (addingMin) {\n  \
    \              result = min :: result\n                lst2 -= min\n         \
    \       min = lst2.min\n            } else {\n                result = max ::\
    \ result\n                lst2 -= max\n                max = lst2.max\n      \
    \      }\n            addingMin = !addingMin\n        }\n        return result",
  "        // Fill in the implementation\n        lst.sortWith(_ < _)", "\t\tlst.sortWith((a,\
    \ b) => a < b)", "        var minlist = List[Long]()\n        var maxlist = List[Long]()\n\
    \        if (lst.length == 0) return List[Long]()\n        var sorted = lst.sorted\n\
    \        for (i <- 0 until lst.length) {\n            if (i % 2 == 0) {\n    \
    \            minlist = minlist :+ sorted(i)\n            } else {\n          \
    \      maxlist = maxlist :+ sorted(i)\n            }\n        }\n        return\
    \ minlist ++ maxlist.reverse", '        lst.sortWith(_ < _)', "        var result\
    \ = new ListBuffer[Long]()\n        val sorted = lst.sorted\n        val n = lst.length\n\
    \        for (i <- 0 until n) {\n            if (i % 2 == 0) result += sorted(i\
    \ / 2)\n            else result += sorted(n - i / 2 - 1)\n        }\n        result.toList",
  "        var sortedList = lst.sorted\n        var flag = false\n        var temp\
    \ = new ListBuffer[Long]()\n        var l = 0\n        var r = lst.length - 1\n\
    \        while (l <= r) {\n            if (flag) {\n                temp += sortedList(l)\n\
    \                l += 1\n            } else {\n                temp += sortedList(r)\n\
    \                r -= 1\n            }\n            flag = !flag\n        }\n\
    \        temp.toList", "        var sortedLst = lst.sorted\n        if (sortedLst.length\
    \ == 0) {\n            return sortedLst\n        }\n        var max = sortedLst.last\n\
    \        var min = sortedLst.head\n        var result = new LinkedList[Long]\n\
    \        while (!sortedLst.isEmpty) {\n            result += min\n           \
    \ sortedLst -= min\n            if (!sortedLst.isEmpty) {\n                result\
    \ += max\n                sortedLst -= max\n            }\n            if (!sortedLst.isEmpty)\
    \ {\n                max = sortedLst.last\n                min = sortedLst.head\n\
    \            }\n        }\n        return result.toList", "        val sorted\
    \ = lst.sorted\n        val res = new ListBuffer[Long]\n        var i = 0\n  \
    \      while (res.size < sorted.size) {\n            if (i % 2 == 0) {\n     \
    \           res += sorted(i / 2)\n            } else {\n                res +=\
    \ sorted(sorted.size - 1 - i / 2)\n            }\n            i += 1\n       \
    \ }\n        res.toList", "    // easy peasy\n        def helper(lst: List[Long],\
    \ result: List[Long]): List[Long] = {\n            if (lst.length == 0) result\n\
    \            else {\n                helper(lst.tail, result ++ List(lst.max,\
    \ lst.min))\n            }\n        }\n        helper(lst, List[Long]())", " \
    \       val list = lst.sorted\n        def strangeSortHelper(list : List[Long],\
    \ odd : Boolean) : List[Long] = {\n            if (list.isEmpty) List()\n    \
    \        else if (odd) {\n                List(list.head) ::: strangeSortHelper(list.tail,\
    \ false)\n            } else {\n                List(list.last) ::: strangeSortHelper(list.init,\
    \ true)\n            }\n        }\n        strangeSortHelper(list, true)", " \
    \   }\n}", "        val lst2 = lst.sortWith(_ < _)\n        val lst1 = lst2.tail\
    \ :+ lst2.head\n        val lst3 = lst1.sortWith(_ > _)\n        val lst4 = lst3.tail\
    \ :+ lst3.head\n        val (lstf, lstb) = lst4.splitAt(lst4.length / 2)\n   \
    \     lstf.zip(lstb).map(x => List(x._1, x._2)).flatten", "        var lst1 =\
    \ lst.sorted\n        var lst2 = lst1.reverse\n        var lst3 = List[Long]()\n\
    \        var b = true\n        for (i <- 0 until lst1.length) {\n            if\
    \ (b) {\n                lst3 = lst3 :+ lst1(i)\n                b = false\n \
    \           } else {\n                lst3 = lst3 :+ lst2(i)\n               \
    \ b = true\n            }\n        }\n        return lst3", "        if (lst.length\
    \ % 2 == 0) {\n            val revlst = lst.reverse\n            val evenlst =\
    \ revlst.grouped(2).map(_.head).toList\n            val oddlst = revlst.grouped(2).map(_.tail.head).toList\n\
    \            evenlst ++ oddlst\n        } else {\n            val revlst = lst.reverse\n\
    \            val oddlst = revlst.grouped(2).map(_.head).toList\n            val\
    \ evenlst = revlst.grouped(2).map(_.tail.head).toList\n            oddlst ++ evenlst\n\
    \        }", "        val srt = lst.sorted\n        for(c <- 0 until lst.length)\
    \ yield if(c % 2 == 0) srt(c / 2) else srt(lst.length - 1 - c / 2)", "       \
    \ val left : List[Long] = lst.sort(((a, b) => a < b))\n        val right : List[Long]\
    \ = lst.sort(((a, b) => a > b))\n        val odd : List[Long] = left.zipWithIndex.filter(((x)\
    \ => x._2 % 2 == 0)).map(((x) => x._1))\n        val even : List[Long] = right.zipWithIndex.filter(((x)\
    \ => x._2 % 2 == 0)).map(((x) => x._1))\n        odd ::: even", '        lst.sortWith((e1,
    e2) => e1 < e2)', "        // Your solution here\n        (List[Long]())", " \
    \       def strangeSortListInner(lst : List[Long], mn : Long, mx : Long, acc :\
    \ List[Long]) : List[Long] = {\n            if (lst.isEmpty) acc\n           \
    \ else {\n                val newList = lst.filter(c => (c != mn) && (c != mx))\n\
    \                val newAcc = acc :+ mn :+ mx\n                strangeSortListInner(newList,\
    \ newList.min, newList.max, newAcc)\n            }\n        }\n        if (lst.isEmpty)\
    \ lst\n        else strangeSortListInner(lst, lst.min, lst.max, List[Long]())",
  "        // Fill in the implementation here.\n        val lst = List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)\n        var ans = List[Long]()\n        var\
    \ size = lst.size\n        var even = true\n        while(size > 0) {\n      \
    \      if(even) {\n                ans = ans :+ lst.min\n                lst.remove(lst.indexOf(lst.min))\n\
    \            } else {\n                ans = ans :+ lst.max\n                lst.remove(lst.indexOf(lst.max))\n\
    \            }\n            even = !even\n            size -= 1\n        }\n \
    \       ans", "        if (lst.isEmpty) List()\n        else {\n            if\
    \ (lst.size == 1) lst\n            else {\n                var min = lst.min\n\
    \                var max = lst.max\n                var lst2 = lst.filter(a =>\
    \ (a != min && a != max))\n                min :: strangeSortList(lst2) ::: max\
    \ :: Nil\n            }\n        }", "        val buf = Buffer[Long]()\n     \
    \   buf ++= lst\n        val size = buf.size\n        for (i <- 0 until size /\
    \ 2) {\n            val s = buf.toSet\n            if (s.size > 1) {\n       \
    \         val min = s.min\n                val max = s.max\n                val\
    \ minidx = buf.indexOf(min)\n                val maxidx = buf.indexOf(max)\n \
    \               buf(minidx) = max\n                buf(maxidx) = min\n       \
    \     }\n        }\n        buf.toList", "        val temp = lst.sorted\n    \
    \    var ans = List[Long]()\n        for (i <- 0 until lst.length) {\n       \
    \     if (i % 2 == 0) ans = ans :+ temp(i / 2)\n            else ans = ans :+\
    \ temp(lst.length - 1 - i / 2)\n        }\n        ans", "        var ans : List[Long]\
    \ = List[Long]()\n        var lst1 : List[Long] = lst.toSet.toList\n        if\
    \ (lst1.size % 2 == 0) {\n            for (i <- 0 until lst1.size / 2) {\n   \
    \             val min : Long = lst1.min\n                val max : Long = lst1.max\n\
    \                ans = ans :+ min\n                ans = ans :+ max\n        \
    \        lst1 = lst1.filter(x => x != min && x != max)\n            }\n      \
    \  } else {\n            for (i <- 0 until lst1.size / 2) {\n                val\
    \ min : Long = lst1.min\n                val max : Long = lst1.max\n         \
    \       ans = ans :+ min\n                ans = ans :+ max\n                lst1\
    \ = lst1.filter(x => x != min && x != max)\n            }\n            ans = ans\
    \ :+ lst1.head\n        }\n        ans", "        val length = lst.length\n  \
    \      if (length == 0) {\n            return List()\n        }\n        val newList\
    \ = new ListBuffer[Long]()\n        var newLength = 0\n        if (length % 2\
    \ == 0) {\n            newLength = length\n        } else {\n            newLength\
    \ = length - 1\n        }\n        var i = 0\n        while (i < newLength) {\n\
    \            val min = lst.min\n            val max = lst.max\n            newList\
    \ += min\n            newList += max\n            i += 2\n        }\n        if\
    \ (length % 2 == 1) {\n            newList += lst.min\n        }\n        return\
    \ newList.toList", '        lst.sortWith((i1, i2) => i1 < i2)', "        def rec(ret\
    \ : List[Long], lst : List[Long]) : List[Long] = {\n            if (lst.length\
    \ == 0) ret\n            else if (lst.length == 1) ret :+ lst(0)\n           \
    \ else {\n                val min = lst.min\n                val max = lst.max\n\
    \                val minPos = lst.indexOf(min)\n                val maxPos = lst.indexOf(max)\n\
    \                if (minPos == maxPos) rec(ret :+ min, lst.slice(0, minPos) :::\
    \ lst.slice(minPos + 1, lst.length))\n                else rec(ret :+ min :+ max,\
    \ lst.slice(0, minPos) ::: lst.slice(minPos + 1, maxPos) ::: lst.slice(maxPos\
    \ + 1, lst.length))\n            }\n        }\n        rec(List[Long](), lst)",
  "        // TODO: add implementation.\n        ???", "        def strangeSortListRec(lst\
    \ : List[Long], acc : List[Long]) : List[Long] = {\n            if (lst.isEmpty)\
    \ {\n                acc\n            } else {\n                val min = lst.min\n\
    \                val max = lst.max\n                strangeSortListRec(lst.filter(x\
    \ => x != min && x != max), acc ++ List(min, max))\n            }\n        }\n\
    \        strangeSortListRec(lst, List[Long]())", "        var lst_ : List[Long]\
    \ = lst.sort((x : Long, y : Long) => if (x < y) true else false)\n        var\
    \ q : Queue[Long] = new Queue[Long]\n        var p : Queue[Long] = new Queue[Long]\n\
    \        var q2 : Queue[Long] = new Queue[Long]\n        var p2 : Queue[Long]\
    \ = new Queue[Long]\n        for (x <- lst_) {\n            if (q.isEmpty) {\n\
    \                q.enqueue(x)\n            } else if (p.isEmpty) {\n         \
    \       p.enqueue(x)\n            } else {\n                q2.enqueue(x)\n  \
    \          }\n        }\n        while (!q2.isEmpty) {\n            var min :\
    \ Long = Long.MaxValue\n            var min_ : Long = Long.MaxValue\n        \
    \    var max : Long = Long.MinValue\n            var max_ : Long = Long.MinValue\n\
    \            while (!q2.isEmpty) {\n                var x : Long = q2.dequeue\n\
    \                if (x < min) {\n                    min_ = min\n            \
    \        min = x\n                } else if (x < min_) {\n                   \
    \ min_ = x\n                }\n                if (x > max) {\n              \
    \      max_ = max\n                    max = x\n                } else if (x >\
    \ max_) {\n                    max_ = x\n                }\n            }\n  \
    \          if (min != Long.MaxValue) {\n                p2.enqueue(min)\n    \
    \        }\n            if (max != Long.MinValue) {\n                p2.enqueue(max)\n\
    \            }\n            if (min_ != Long.MaxValue) {\n                q2.enqueue(min_)\n\
    \            }\n            if (max_ != Long.MinValue) {\n                q2.enqueue(max_)\n\
    \            }\n        }\n        if (q.isEmpty) {\n            p2.dequeueAll.toList\n\
    \        } else if (p.isEmpty) {\n            q.dequeueAll.toList\n        } else\
    \ {\n            val q_ : List[Long] = q.de", '        lst.sortWith(_ < _)', " \
    \       def strangeSortListHelper(lst : List[Long], lst2 : List[Long]) : List[Long]\
    \ = {\n            if (lst.isEmpty) {\n                lst2\n            } else\
    \ {\n                strangeSortListHelper(lst.tail, lst2 :+ lst.min)\n      \
    \      }\n        }\n        def strangeSortListHelper2(lst : List[Long], lst2\
    \ : List[Long]) : List[Long] = {\n            if (lst.isEmpty) {\n           \
    \     lst2\n            } else {\n                strangeSortListHelper2(lst.tail,\
    \ lst2 :+ lst.max)\n            }\n        }\n        def strangeSortListHelper3(lst\
    \ : List[Long], lst2 : List[Long]) : List[Long] = {\n            if (lst.isEmpty)\
    \ {\n                lst2\n            } else {\n                strangeSortListHelper3(lst.tail,\
    \ lst2 :+ lst.min)\n            }\n        }\n        def strangeSortListHelper4(lst\
    \ : List[Long], lst2 : List[Long]) : List[Long] = {\n            if (lst.isEmpty)\
    \ {\n                lst2\n            } else {\n                strangeSortListHelper4(lst.tail,\
    \ lst2 :+ lst.max)\n            }\n        }\n        strangeSortListHelper(lst,\
    \ List[Long]()) ::: strangeSortListHelper2(lst, List[Long]()) ::: strangeSortListHelper3(lst,\
    \ List[Long]()) ::: strangeSortListHelper4(lst, List[Long]())", "        if (lst.length\
    \ == 0) return lst\n        var newList = lst.sorted\n        var list = new ListBuffer[Long]()\n\
    \        var temp = newList(0)\n        newList -= temp\n        list += temp\n\
    \        var sign = true\n        while (newList.length > 0) {\n            if\
    \ (sign) {\n                temp = newList.max\n                newList -= temp\n\
    \                list += temp\n            } else {\n                temp = newList.min\n\
    \                newList -= temp\n                list += temp\n            }\n\
    \            sign = !sign\n        }\n        return list.toList", "        if\
    \ (lst.isEmpty) return lst\n        val sortedList = lst.sorted\n        val seqSize\
    \ = sortedList.size\n        var result = List[Long]()\n        var start = 0\n\
    \        var end = seqSize - 1\n        var count = 0\n        while (count <\
    \ seqSize) {\n            if (count % 2 == 0) {\n                result = result\
    \ :+ sortedList(start)\n                start += 1\n            } else {\n   \
    \             result = result :+ sortedList(end)\n                end -= 1\n \
    \           }\n            count += 1\n        }\n        result", "        var\
    \ result = new ListBuffer[Long]\n        var temp = lst.sortWith(_ < _)\n    \
    \    var flag = true\n        while (temp.size > 0) {\n            val item =\
    \ temp.head\n            if (flag) result += item\n            else result.insert(0,\
    \ item)\n            temp = temp.filter(_ != item)\n            flag = !flag\n\
    \        }\n        result.toList", "        // fill in here\n        lst.sorted.take(lst.length/2).zip(lst.sorted.takeRight(lst.length/2).reverse).flatten",
  "        def helper(lst : List[Long], result : List[Long]) : List[Long] = {\n  \
    \          if (lst.isEmpty) result\n            else {\n                val min\
    \ = lst.min\n                val max = lst.max\n                val lst2 = lst.sorted\n\
    \                val lst3 = lst2.drop(1).dropRight(1)\n                helper(lst3,\
    \ result :+ min :+ max)\n            }\n        }\n        helper(lst, List())",
  "        lst match {\n            case Nil => Nil\n            case _ => {\n   \
    \             var min = minValue(lst)\n                var max = maxValue(lst)\n\
    \                var rem = List[Long]()\n                for (i <- lst) {\n  \
    \                  if (i != min && i != max) {\n                        rem =\
    \ i :: rem\n                    }\n                }\n                List(min,\
    \ max) ::: strangeSortList(rem)\n            }\n        }", "        // Your answer\
    \ here.\n        if (lst.isEmpty) {\n            return lst\n        }\n     \
    \   var lst1 = lst.sorted\n        var lst2 = lst1.sorted.reverse\n        var\
    \ result = ListBuffer[Long]()\n        for (i <- 0 until lst.length) {\n     \
    \       if (i % 2 == 0) {\n                result += lst1.head\n             \
    \   lst1 = lst1.tail\n            } else {\n                result += lst2.head\n\
    \                lst2 = lst2.tail\n            }\n        }\n        return result.toList",
  "        // Fill this function body\n        // Write your code here\n        val\
    \ t = ArrayBuffer[Long]()\n        for (i <- lst.indices) {\n            if (i\
    \ % 2 == 0) {\n                t += lst.min\n                lst.update(lst.indexOf(lst.min),\
    \ lst.max + 1)\n            } else {\n                t += lst.max\n         \
    \       lst.update(lst.indexOf(lst.max), lst.min - 1)\n            }\n       \
    \ }\n        t.toList", "        val dups = lst.groupBy(identity).mapValues(_.size).toArray\n\
    \        dups.sortBy(_._1)\n        dups.sortBy(-_._2)\n        val result = new\
    \ ListBuffer[Long]\n        var i = 0\n        while (i < dups.length) {\n   \
    \         val v = dups(i)._1\n            val c = dups(i)._2\n            var\
    \ j = 0\n            while (j < c) {\n                result += v\n          \
    \      j += 1\n            }\n            i += 1\n        }\n        result.toList",
  '        lst.toBuffer', "        var result : List[Long] = List[Long]()\n      \
    \  var sortedList : List[Long] = lst.sorted\n        var minValue : Long = lst.min\n\
    \        var minValueIndex : Int = lst.indexOf(minValue)\n        var maxValue\
    \ : Long = lst.max\n        var maxValueIndex : Int = lst.indexOf(maxValue)\n\
    \        while (sortedList.length > 0) {\n            if (minValueIndex < maxValueIndex)\
    \ {\n                result = result :+ minValue\n                result = result\
    \ :+ maxValue\n                sortedList = sortedList.filter(x => x != minValue)\n\
    \                sortedList = sortedList.filter(x => x != maxValue)\n        \
    \        minValue = sortedList.min\n                minValueIndex = lst.indexOf(minValue)\n\
    \                maxValue = sortedList.max\n                maxValueIndex = lst.indexOf(maxValue)\n\
    \            } else {\n                result = result :+ maxValue\n         \
    \       result = result :+ minValue\n                sortedList = sortedList.filter(x\
    \ => x != minValue)\n                sortedList = sortedList.filter(x => x !=\
    \ maxValue)\n                minValue = sortedList.min\n                minValueIndex\
    \ = lst.indexOf(minValue)\n                maxValue = sortedList.max\n       \
    \         maxValueIndex = lst.indexOf(maxValue)\n            }\n        }\n  \
    \      return result", "        val lst2 = lst.sorted.toBuffer\n        val lst3\
    \ = ListBuffer[Long]()\n        while (lst2.size > 0) {\n            lst3 += lst2.remove(0)\n\
    \            if (lst2.size > 0) {\n                lst3 += lst2.remove(lst2.size\
    \ - 1)\n            }\n        }\n        lst3.toList", "        val sorted =\
    \ lst.sorted\n        if (sorted.size == 0) sorted\n        else {\n         \
    \   var result = ListBuffer[Long]()\n            val (min, max) = (0, sorted.size\
    \ - 1)\n            var i = min\n            var j = max\n            while (i\
    \ <= j) {\n                result += sorted(i)\n                if (i == j) break\n\
    \                result += sorted(j)\n                i += 1\n               \
    \ j -= 1\n            }\n            result.toList\n        }", "        if (lst.length\
    \ == 0) return lst\n        val sorted = lst.sorted\n        val front = sorted.head\
    \ :: List[Long]()\n        val back = sorted.drop(1)\n        var sorted_back\
    \ = back.reverse\n        var result = front\n        while (sorted_back.length\
    \ > 0) {\n            result = result ::: List(sorted_back.head)\n           \
    \ sorted_back = sorted_back.drop(1)\n            if (sorted_back.length > 0) {\n\
    \                result = result ::: List(sorted_back.last)\n                sorted_back\
    \ = sorted_back.dropRight(1)\n            }\n        }\n        return result",
  '        lst.sorted.sliding(2, 2).flatMap(_.reverse).toList', "        if (lst.isEmpty)\
    \ lst\n        else {\n            val min : Long = lst.min\n            val max\
    \ : Long = lst.max\n            var odd : Boolean = true\n            var nlst\
    \ : List[Long] = List[Long]()\n            while (!lst.isEmpty) {\n          \
    \      val a : Long = if (odd) max else min\n                nlst = a :: nlst\n\
    \                lst = lst.filter(_ != a)\n                odd = !odd\n      \
    \      }\n            nlst.reverse\n        }", "        val sorted = lst.sorted\n\
    \        if (sorted.size == 0) return List()\n        if (sorted.size == 1) return\
    \ sorted\n        val last = sorted.last\n        val rest = sorted.init\n   \
    \     val (min, max) = (rest.head, rest.last)\n        val rest2 = rest.init.tail\n\
    \        (List(min, max) ++ strangeSortList(rest2)) ++ List(last)", "        def\
    \ strangeSortListInner(lst : List[Long], acc : List[Long]) : List[Long] = {\n\
    \            if (lst.length == 0) acc\n            else {\n                val\
    \ min = lst.min\n                val max = lst.max\n                val minIndex\
    \ = lst.indexOf(min)\n                val maxIndex = lst.indexOf(max)\n      \
    \          val minLess = lst.slice(0, minIndex)\n                val maxLess =\
    \ lst.slice(minIndex + 1, maxIndex)\n                val maxMore = lst.slice(maxIndex\
    \ + 1, lst.length)\n                strangeSortListInner(minLess ++ maxLess ++\
    \ maxMore, acc ++ List(min) ++ List(max))\n            }\n        }\n        strangeSortListInner(lst,\
    \ List())", "        var result = List[Long]()\n        var lst_ = lst.sorted\n\
    \        if (lst_.size == 0)\n            return lst_\n        else if (lst_.size\
    \ == 1)\n            return lst_\n        else if (lst_.size == 2)\n         \
    \   return lst_.reverse\n        else {\n            var i = 0\n            var\
    \ lst_len = lst_.size\n            while (lst_.size > 0) {\n                if\
    \ (i % 2 == 0) {\n                    result = lst_.head :: result\n         \
    \           lst_ = lst_.tail\n                }\n                else {\n    \
    \                result = lst_.last :: result\n                    lst_ = lst_.init\n\
    \                }\n                i += 1\n            }\n            return\
    \ result\n        }", "        if (lst.length == 0) return lst\n        var lst2\
    \ = lst.sortWith((x : Long, y : Long) => x < y)\n        var ret = new ListBuffer[Long]\n\
    \        var reverse = false\n        while (lst2.length > 0) {\n            if\
    \ (reverse) {\n                ret += lst2.last\n                lst2 = lst2.dropRight(1)\n\
    \            } else {\n                ret += lst2.head\n                lst2\
    \ = lst2.drop(1)\n            }\n            reverse = !reverse\n        }\n \
    \       return ret.toList", "        if (lst.length == 0) {\n            return\
    \ lst\n        }\n        val sorted = lst.sorted\n        val result = ListBuffer[Long]()\n\
    \        var i = 0\n        var j = sorted.length - 1\n        while (i <= j)\
    \ {\n            result += sorted(i)\n            if (i != j) {\n            \
    \    result += sorted(j)\n            }\n            i += 1\n            j -=\
    \ 1\n        }\n        return result.toList", "        if (lst.length == 0) return\
    \ lst\n        var l : List[Long] = lst.sort(_ < _)\n        var r : List[Long]\
    \ = List[Long]()\n        while (l.length > 0) {\n            r = r :+ l.head\n\
    \            l = l.tail\n            if (l.length > 0) {\n                r =\
    \ r :+ l.last\n                l = l.dropRight(1)\n            }\n        }\n\
    \        return r", "        if (lst.length == 0) return lst\n        val (min,\
    \ max) = (lst.min, lst.max)\n        val (l1, l2) = lst.partition(x => x == min\
    \ || x == max)\n        return strangeSortList(l1.tail) ::: List(min) ::: strangeSortList(l2.tail)\
    \ ::: List(max)", "        var result : List[Long] = List[Long]()\n        var\
    \ min : Long = -1l.toLong\n        var max : Long = -1l.toLong\n        for (i\
    \ <- 0 until lst.length) {\n            val newlst = lst.filter(a => !(a == min\
    \ || a == max))\n            min = newlst.reduceLeft(_ min _)\n            max\
    \ = newlst.reduceLeft(_ max _)\n            result = result ++ List(min, max)\n\
    \        }\n        result.filter(a => !(a == -1l.toLong))", "        // result\
    \ list\n        var result : List[Long] = List[Long]()\n        // copy input\
    \ list\n        var lstCopy : List[Long] = lst\n        // while the copy of the\
    \ input list has at least 2 elements\n        while (lstCopy.length >= 2) {\n\
    \            // find min and max\n            val min : Long = lstCopy.min\n \
    \           val max : Long = lstCopy.max\n            // add these values to the\
    \ result list\n            result = result :+ min :+ max\n            // remove\
    \ these values from the copy of the input list\n            lstCopy = lstCopy.filterNot(x\
    \ => x == min)\n            lstCopy = lstCopy.filterNot(x => x == max)\n     \
    \   }\n        // if the copy of the input list still has elements,\n        //\
    \ these elements must be the same (i.e. there are duplicates)\n        if (lstCopy.length\
    \ == 1) {\n            // so add this element to the result list\n           \
    \ result = result :+ lstCopy.head\n        }\n        // return the result list\n\
    \        result", "        val tempLst = lst.sortWith(_ < _)\n        var flag\
    \ = 0\n        val resultLst = ListBuffer[Long]()\n        while (tempLst.length\
    \ > 0) {\n            if (flag == 0) {\n                resultLst += tempLst.head\n\
    \                tempLst.remove(0)\n                flag = 1\n            } else\
    \ {\n                resultLst += tempLst.last\n                tempLst.remove(tempLst.length\
    \ - 1)\n                flag = 0\n            }\n        }\n        resultLst.toList",
  "        if (lst.isEmpty) return lst\n        var currlist = lst.sorted\n      \
    \  var rst = List[Long]()\n        while (!currlist.isEmpty) {\n            if\
    \ (rst.isEmpty) {\n                rst = List(currlist.head)\n               \
    \ currlist = currlist.tail\n            }\n            if (currlist.isEmpty) {\n\
    \                return rst\n            }\n            rst = rst :+ currlist.last\n\
    \            currlist = currlist.dropRight(1)\n            if (currlist.isEmpty)\
    \ {\n                return rst\n            }\n            rst = rst :+ currlist.head\n\
    \            currlist = currlist.tail\n        }\n        rst", "        var list\
    \ = scala.collection.mutable.ArrayBuffer[Long]()\n        var lst2 = lst.sorted\n\
    \        var lst3 = lst2.reverse\n        val lst4 = lst3 ++ lst2\n        for\
    \ (i <- 0 until lst4.length) {\n            list += lst4(i)\n        }\n     \
    \   return list.toList", "        val sorted = lst.sorted\n        var sortedLst\
    \ = ListBuffer[Long]()\n        val lstLen = lst.length\n        var idx = 0\n\
    \        while (idx < lstLen) {\n            if (idx % 2 == 0) {\n           \
    \     sortedLst += sorted(idx)\n            } else {\n                sortedLst\
    \ += sorted(lstLen - 1 - idx)\n            }\n            idx += 1\n        }\n\
    \        sortedLst.toList", "        // Your code here\n        var retList =\
    \ List[Long]()\n        var min = lst.min\n        var max = lst.max\n       \
    \ val hash = new HashMap[Long, Boolean]()\n        for (element <- lst) {\n  \
    \          hash.put(element, false)\n        }\n        while (hash.size > 0)\
    \ {\n            retList = retList :+ min\n            hash.remove(min)\n    \
    \        retList = retList :+ max\n            hash.remove(max)\n            min\
    \ = hash.keys.min\n            max = hash.keys.max\n        }\n        retList",
  '        lst.sortWith(_ < _)', "        if (lst.length <= 1) return lst\n      \
    \  def getMin(ls : List[Long]) : List[Long] = {\n            var min = ls(0)\n\
    \            var minInd = 0\n            for (i <- 1 until ls.length) {\n    \
    \            if (ls(i) < min) {\n                    min = ls(i)\n           \
    \         minInd = i\n                }\n            }\n            return List(min,\
    \ minInd)\n        }\n        def getMax(ls : List[Long]) : List[Long] = {\n \
    \           var max = ls(0)\n            var maxInd = 0\n            for (i <-\
    \ 1 until ls.length) {\n                if (ls(i) > max) {\n                 \
    \   max = ls(i)\n                    maxInd = i\n                }\n         \
    \   }\n            return List(max, maxInd)\n        }\n        var min = getMin(lst)\n\
    \        var max = getMax(lst)\n        var newLst = List(min(0))\n        var\
    \ i = 0\n        if (min(1) > max(1)) {\n            newLst = newLst :+ max(0)\n\
    \            i = 1\n        }\n        while (i < lst.length) {\n            if\
    \ (i % 2 == 0) {\n                newLst = newLst :+ getMin(lst.patch(0, Nil,\
    \ newLst.length)).head\n            } else {\n                newLst = newLst\
    \ :+ getMax(lst.patch(0, Nil, newLst.length)).head\n            }\n          \
    \  i += 1\n        }\n        return newLst", "        var lst2 = new ListBuffer[Long]\n\
    \        var temp = new ListBuffer[Long]\n        temp = temp ++ lst\n       \
    \ var flip = 0\n        while (temp.length > 0) {\n            if (flip == 0)\
    \ {\n                val min = temp.min\n                temp -= min\n       \
    \         lst2 += min\n                flip = 1\n            } else {\n      \
    \          val max = temp.max\n                temp -= max\n                lst2\
    \ += max\n                flip = 0\n            }\n        }\n        lst2.toList",
  "        var l = lst.sortWith(_ < _)\n        if (l.length <= 1) return l\n    \
    \    var o = ListBuffer[Long]()\n        while (l.length > 0) {\n            o\
    \ += l.head\n            l = l.tail\n            if (l.length > 0) {\n       \
    \         o += l.last\n                l = l.dropRight(1)\n            }\n   \
    \     }\n        return o.toList", "        var temp = lst.sorted\n        var\
    \ finalList = new ListBuffer[Long]\n        var i = 0\n        var last = temp.length\
    \ - 1\n        if (temp.length % 2 == 0) {\n            while (last > 0) {\n \
    \               finalList += temp(last)\n                finalList += temp(i)\n\
    \                last -= 1\n                i += 1\n            }\n        } else\
    \ {\n            while (last > 0) {\n                finalList += temp(last)\n\
    \                finalList += temp(i)\n                last -= 1\n           \
    \     i += 1\n            }\n            finalList += temp(last)\n        }\n\
    \        finalList.toList", "        def sort(lst : List[Long], compare : (Long,\
    \ Long) => Boolean) : List[Long] = {\n            if (lst.isEmpty) return List[Long]()\n\
    \            val m = lst.min\n            val l = lst.filter(_ != m)\n       \
    \     m :: sort(l, !compare(_, _))\n        }\n        sort(lst, _ < _)", "  \
    \      if (lst.length == 0)\n            return lst\n        var ret = ListBuffer[Long]()\n\
    \        var lst2 = lst.toBuffer\n        ret += lst2.min\n        lst2 -= lst2.min\n\
    \        while (lst2.length > 0) {\n            if (lst2.length == 1) {\n    \
    \            ret += lst2(0)\n                lst2 -= lst2(0)\n            } else\
    \ {\n                ret += lst2.max\n                lst2 -= lst2.max\n     \
    \           ret += lst2.min\n                lst2 -= lst2.min\n            }\n\
    \        }\n        return ret.toList", "        var lstNew = lst.sorted\n   \
    \     val lstNew2 = for (i <- 0 until lstNew.length by 2) yield lstNew(i)\n  \
    \      val lstNew3 = for (i <- 1 until lstNew.length by 2) yield lstNew(i)\n \
    \       return lstNew2.toList ++ lstNew3.toList", "        if (lst.isEmpty) return\
    \ lst\n        var ans = new ListBuffer[Long]\n        var list = new ListBuffer[Long]\
    \ ++ lst\n        var min = list.min\n        ans += min\n        list -= min\n\
    \        var max = list.max\n        ans += max\n        list -= max\n       \
    \ while (!list.isEmpty) {\n            min = list.min\n            ans += min\n\
    \            list -= min\n            if (!list.isEmpty) {\n                max\
    \ = list.max\n                ans += max\n                list -= max\n      \
    \      }\n        }\n        ans.toList", "        if (lst.isEmpty) {\n      \
    \      return lst\n        }\n        var lst1 = lst.sorted\n        var lst2\
    \ = lst1.reverse\n        var lst3 = List[Long]()\n        var i = 0\n       \
    \ while (i < lst1.length) {\n            if (i % 2 == 0) {\n                lst3\
    \ = lst3 :+ lst1(i)\n            } else {\n                lst3 = lst3 :+ lst2(i)\n\
    \            }\n            i += 1\n        }\n        return lst3", '        lst.sortWith(_
    < _)', "        val sortedList = lst.sorted\n        val n = lst.length\n    \
    \    val stack = new Stack[Long]\n        stack.push(sortedList(0))\n        var\
    \ i = 1\n        while (i < n) {\n            stack.push(sortedList(i))\n    \
    \        i += 1\n        }\n        if (n % 2 == 0) {\n            i = 0\n   \
    \         while (i < n) {\n                if (i % 2 == 0) {\n               \
    \     sortedList(i) = stack.pop\n                } else {\n                  \
    \  sortedList(i) = stack.pop\n                }\n                i += 1\n    \
    \        }\n        } else {\n            i = 0\n            while (i < n) {\n\
    \                if (i % 2 == 0) {\n                    sortedList(i) = stack.pop\n\
    \                } else {\n                    sortedList(i) = stack.pop\n   \
    \             }\n                i += 1\n            }\n        }\n        sortedList",
  "    // Write your code here\n    // Return the sorted list", "        def strangeSortList(lst\
    \ : List[Long], sortedList : List[Long]) : List[Long] = {\n            if (lst.isEmpty)\
    \ sortedList\n            else {\n                val min = lst.min\n        \
    \        val lstMinIdx = lst.indexOf(min)\n                val lstMinIdxRemainder\
    \ = lstMinIdx % 2\n                val lstMaxIdx = if (lstMinIdxRemainder == 0)\
    \ lst.size - 1 - lstMinIdx else lstMinIdx\n                val max = lst(lstMaxIdx)\n\
    \                strangeSortList(lst.filter(e => e != min && e != max), sortedList\
    \ :+ min :+ max)\n            }\n        }\n        strangeSortList(lst, List[Long]())",
  "        // Fill in the implementation here.\n        lst.sorted"]
stop_tokens:
- "\n    }\n"
