name: HumanEval_20_find_closest_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n    // other and return them in order (smaller\
  \ number, larger number).\n    // >>> findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))\n    //\
  \ ((2.0f, 2.2f))\n    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))\n    // ((2.0f, 2.0f))\n\
  \    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f,\
  \ 4.0f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f,\
  \ 2.2f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));\n\
  \    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat,\
  \ 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));\n    }\n\n}\n"
completions: ["      var bestA : Float = 0\n      var bestB : Float = 0\n      var\
    \ bestDistance : Float = Float.MaxValue\n      var index = 0\n      while (index\
    \ < numbers.length - 1) {\n        val a = numbers(index)\n        val b = numbers(index\
    \ + 1)\n        val distance = abs(a - b)\n        if (distance < bestDistance)\
    \ {\n          bestA = a\n          bestB = b\n          bestDistance = distance\n\
    \        }\n        index += 1\n      }\n      return Tuple2(bestA, bestB)", " \
    \       val selectedNumbers = numbers.sortWith(_ < _)\n        var minimumDifference\
    \ = Float.MaxValue\n        var minimumPair = (selectedNumbers(0), selectedNumbers(1))\n\
    \        var previousNumber = selectedNumbers(0)\n        for (n <- selectedNumbers.tail)\
    \ {\n            val difference = abs(n - previousNumber)\n            if (difference\
    \ < minimumDifference) {\n                minimumDifference = difference\n   \
    \             minimumPair = (previousNumber, n)\n            }\n            previousNumber\
    \ = n\n        }\n        minimumPair", '        (numbers.min, numbers.max)',
  "        // TODO\n        return (0.0f, 0.0f)", "        // a helper function which\
    \ returns the absolute value of its argument\n        def abs(n : Float) : Float\
    \ = if (n < 0) -n else n\n        // get the absolute difference between the first\
    \ two elements of the list\n        var (closest, close1, close2) = (abs(numbers(0)\
    \ - numbers(1)), numbers(0), numbers(1))\n        // go through the list, comparing\
    \ each pair and storing the result if smaller than previous\n        for (i <-\
    \ 1 until numbers.length - 1) {\n            val diff = abs(numbers(i) - numbers(i\
    \ + 1))\n            if (diff < closest) {\n                closest = diff\n \
    \               close1 = numbers(i)\n                close2 = numbers(i + 1)\n\
    \            }\n        }\n        // return the pair\n        (close1, close2)",
  "        var minDiff = Float.MaxValue\n        var closestNumbers = Tuple2(Float.MaxValue,\
    \ Float.MaxValue)\n        for (i <- 0 until numbers.length - 1) {\n         \
    \   val diff = abs(numbers(i) - numbers(i + 1))\n            if (diff < minDiff)\
    \ {\n                minDiff = diff\n                closestNumbers = Tuple2(numbers(i),\
    \ numbers(i + 1))\n            }\n        }\n        closestNumbers", "      \
    \  val sorted = numbers.sorted\n        val pairs = (sorted, sorted.tail).zipped\n\
    \        val distances = pairs.map((x, y) => x - y)\n        val minDistance =\
    \ distances.min\n        val minIndex = distances.indexOf(minDistance)\n     \
    \   (sorted(minIndex), sorted(minIndex + 1))", "        val sortedNumbers = numbers.sorted\n\
    \        var smallestDifference = Float.MaxValue\n        var elements : Tuple2[Float,\
    \ Float] = (0.0f, 0.0f)\n        for (x <- 0 until sortedNumbers.length - 1) {\n\
    \            val firstElement = sortedNumbers(x)\n            val secondElement\
    \ = sortedNumbers(x + 1)\n            val difference = abs(firstElement - secondElement)\n\
    \            if (difference < smallestDifference) {\n                smallestDifference\
    \ = difference\n                elements = (firstElement, secondElement)\n   \
    \         }\n        }\n        elements", "        val array = numbers.toArray\n\
    \        val second = array.tail\n        var minValue = abs(array(0) - second(0))\n\
    \        var minIndex = 0\n        for (i <- 0 until second.length) {\n      \
    \      val currentValue = abs(array(i) - second(i))\n            if (currentValue\
    \ < minValue) {\n                minValue = currentValue\n                minIndex\
    \ = i\n            }\n        }\n        (array(minIndex), second(minIndex))",
  "        var solution = (numbers(0), numbers(1))\n        var distance = abs(numbers(0)\
    \ - numbers(1))\n        for (i <- 0 until numbers.length - 1) {\n           \
    \ for (j <- i + 1 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < distance) {\n                    distance = abs(numbers(i) -\
    \ numbers(j))\n                    solution = (numbers(i), numbers(j))\n     \
    \           }\n            }\n        }\n        solution", "        // Sanity\
    \ check\n        if (numbers.length < 2) {\n            throw new IllegalArgumentException(\"\
    There must be at least two values in the list!\")\n        }\n        // Find\
    \ the smallest difference\n        var closest : (Float, Float) = (numbers(0),\
    \ numbers(1))\n        var minDiff : Float = abs(closest._1 - closest._2)\n  \
    \      var index : Int = 0\n        while (index < numbers.length - 1) {\n   \
    \         val difference : Float = abs(numbers(index) - numbers(index + 1))\n\
    \            if (difference < minDiff) {\n                minDiff = difference\n\
    \                closest = (numbers(index), numbers(index + 1))\n            }\n\
    \            index += 1\n        }\n        closest", "        val sorted = numbers.sorted\n\
    \        val closest = sorted.sliding(2).map(x => x(1) - x(0)).min\n        (sorted.filter(x\
    \ => x + closest == sorted.filter(y => abs(x - y) == closest).max)(0),\n     \
    \   sorted.filter(x => x + closest == sorted.filter(y => abs(x - y) == closest).max)(0)\
    \ + closest)", "        // Approach:\n        // - Iterate from left to right,\
    \ keeping track of the smallest number so far, and the largest number so far.\n\
    \        // - Keep track of the smallest difference so far.\n        // - Compare\
    \ the difference between the current number and the current smallest number, and\
    \ if it is less\n        //   than the difference so far then update the difference\
    \ so far to be this difference and update the\n        //   smallest number so\
    \ far to be the current number and the largest number so far to be the current\
    \ smallest\n        //   number.\n        // - Compare the difference between\
    \ the current number and the current largest number, and if it is less\n     \
    \   //   than the difference so far then update the difference so far to be this\
    \ difference and update the\n        //   smallest number so far to be the current\
    \ largest number and the largest number so far to be the current\n        // \
    \  number.\n        // - Repeat until the end of the list, then return the numbers.\n\
    \        var smallestNumberSoFar : Float = numbers(0)\n        var largestNumberSoFar\
    \ : Float = numbers(0)\n        var smallestDifferenceSoFar : Float = abs(numbers(1)\
    \ - numbers(0))\n        for (i <- 1 until numbers.length) {\n            val\
    \ currentNumber : Float = numbers(i)\n            val differenceWithSmallestNumberSoFar\
    \ : Float = abs(currentNumber - smallestNumberSoFar)\n            if (differenceWithSmallestNumberSoFar\
    \ < smallestDifferenceSoFar) {\n                smallestDifferenceSoFar = differenceWithSmallestNumberSoFar\n\
    \                largestNumberSoFar = smallestNumberSoFar\n                smallestNumberSoFar\
    \ = currentNumber\n            }\n            val differenceWithLargestNumberSoFar\
    \ : Float = abs(currentNumber - largestNumberSoFar)\n            if (differenceWithLargestNumberSoFar\
    \ < smallestDifferenceSoFar) {\n                smallestDifferenceSoFar = differenceWithLargestNumberSoFar\n\
    \                smallestNumberSoFar = largestNumberSoFar\n                largestNumberSoFar\
    \ = currentNumber\n            }\n        }\n        (smallestNumberSoFar, largestNumberSoFar)",
  "        var closest = new Tuple2[Float, Float](numbers(0), numbers(1))\n      \
    \  var diff = abs(closest._1 - closest._2)\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            for (j <- i + 1 until numbers.length) {\n              \
    \  val current = new Tuple2[Float, Float](numbers(i), numbers(j))\n          \
    \      val currentDiff = abs(current._1 - current._2)\n                if (currentDiff\
    \ < diff) {\n                    closest = current\n                    diff =\
    \ currentDiff\n                }\n            }\n        }\n        closest",
  "      var minDiff = numbers(1) - numbers(0)\n      var minEl1 = numbers(0)\n  \
    \    var minEl2 = numbers(1)\n      for (i <- 0 until numbers.length - 1) {\n\
    \        if (numbers(i + 1) - numbers(i) < minDiff) {\n          minDiff = numbers(i\
    \ + 1) - numbers(i)\n          minEl1 = numbers(i)\n          minEl2 = numbers(i\
    \ + 1)\n        }\n      }\n      return (minEl1, minEl2)", "        def rec(list\
    \ : List[Float], close : Float, tuple : Tuple2[Float, Float]) : Tuple2[Float,\
    \ Float] = {\n            if (list.length == 1) {\n                tuple\n   \
    \         } else {\n                val diff = abs(list(0) - list(1))\n      \
    \          if (diff < close) rec(list.tail, diff, (list(0), list(1)))\n      \
    \          else rec(list.tail, close, tuple)\n            }\n        }\n     \
    \   rec(numbers, abs(numbers(0) - numbers(1)), (numbers(0), numbers(1)))", " \
    \       var closest : Float = Float.MaxValue\n        var result = numbers.sorted\n\
    \        for (i <- 0 until result.length - 1) {\n            val dist = abs(result(i)\
    \ - result(i + 1))\n            if (dist < closest) {\n                closest\
    \ = dist\n                result = result.slice(i, i + 2)\n            }\n   \
    \     }\n        (result(0), result(1))", "      // DQ: I am using a list here\
    \ since I think we should be updating it in place instead of copying it each time.\n\
    \      // I'm not sure if I'm allowed to do this.\n      val sorted = numbers.sorted\n\
    \      var result = (sorted(0), sorted(1))\n      var min = abs(sorted(0) - sorted(1))\n\
    \      for (i <- 0 until (sorted.length - 1)) {\n        val pair = (sorted(i),\
    \ sorted(i + 1))\n        val diff = abs(pair._1 - pair._2)\n        if (diff\
    \ < min) {\n          min = diff\n          result = pair\n        }\n      }\n\
    \      result", "        var closestElements : Tuple2[Float, Float] = (numbers(0),\
    \ numbers(1))\n        var minDifference : Float = abs(numbers(0) - numbers(1))\n\
    \        for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1\
    \ until numbers.length) {\n                val diff : Float = abs(numbers(i) -\
    \ numbers(j))\n                if (diff < minDifference) {\n                 \
    \   closestElements = (numbers(i), numbers(j))\n                    minDifference\
    \ = diff\n                }\n            }\n        }\n        closestElements",
  "        var output : Tuple2[Float, Float] = (numbers(0), numbers(1))\n        var\
    \ curr_dist : Float = abs(numbers(0) - numbers(1))\n        var i = 0\n      \
    \  while (i < numbers.length - 1) {\n            if (abs(numbers(i) - numbers(i\
    \ + 1)) < curr_dist) {\n                output = (numbers(i), numbers(i + 1))\n\
    \                curr_dist = abs(numbers(i) - numbers(i + 1))\n            }\n\
    \            i += 1\n        }\n        return output", "        var m = (numbers.length\
    \ - 1, 0, Float.MaxValue)\n        for (i <- 0 until numbers.length) {\n     \
    \       for (j <- i + 1 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < m._3) m = (i, j, abs(numbers(i) - numbers(j)))\n           \
    \ }\n        }\n        var t = if (numbers(m._1) < numbers(m._2)) (numbers(m._1),\
    \ numbers(m._2)) else (numbers(m._2), numbers(m._1))\n        return t", '        findClosestElements(numbers,
    null)', "        var minDiff = Float.MaxValue\n        var minDiffNumbers = (Float.MaxValue,\
    \ Float.MaxValue)\n        for (i <- 0 until numbers.length - 1) {\n         \
    \   val diff = abs(numbers(i) - numbers(i + 1))\n            if (diff < minDiff)\
    \ {\n                minDiff = diff\n                minDiffNumbers = (numbers(i),\
    \ numbers(i + 1))\n            }\n        }\n        return minDiffNumbers", " \
    \       var closestPair : Tuple2[Float, Float] = (numbers(0), numbers(1))\n  \
    \      for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until\
    \ numbers.length) {\n                val newPair : Tuple2[Float, Float] = (numbers(i),\
    \ numbers(j))\n                if (abs(closestPair._1 - closestPair._2) > abs(newPair._1\
    \ - newPair._2)) {\n                    closestPair = newPair\n              \
    \  }\n            }\n        }\n        closestPair", "        // use the abs\
    \ method to compute the absolute value of a number.\n        return (0.0f, 0.0f)",
  "        val sortedNumbers = numbers.sorted\n        // Find minimum difference.\n\
    \        var i = 0\n        var minDiff = abs(sortedNumbers(i) - sortedNumbers(i\
    \ + 1))\n        var result = (sortedNumbers(i), sortedNumbers(i + 1))\n     \
    \   var j = 1\n        while (j < sortedNumbers.length - 1) {\n            val\
    \ diff = abs(sortedNumbers(j) - sortedNumbers(j + 1))\n            if (diff <\
    \ minDiff) {\n                result = (sortedNumbers(j), sortedNumbers(j + 1))\n\
    \                minDiff = diff\n            }\n            j += 1\n        }\n\
    \        result", "        var closest : Tuple2[Float, Float] = (Float.MaxValue,\
    \ Float.MaxValue)\n        for (i <- 0 until numbers.length - 1) {\n         \
    \   for (j <- i + 1 until numbers.length) {\n                val difference =\
    \ abs(numbers(i) - numbers(j))\n                if (difference < abs(closest._1\
    \ - closest._2)) {\n                    closest = if (numbers(i) < numbers(j))\
    \ (numbers(i), numbers(j)) else (numbers(j), numbers(i))\n                }\n\
    \            }\n        }\n        closest", "        var min : Float = Float.MaxValue\n\
    \        var res : Tuple2[Float, Float] = (0.0f, 0.0f)\n        val sortedNumbers\
    \ = numbers.sorted\n        for (x <- 1 until sortedNumbers.length) {\n      \
    \      val diff = sortedNumbers(x) - sortedNumbers(x - 1)\n            if (diff\
    \ < min) {\n                min = diff\n                res = (sortedNumbers(x\
    \ - 1), sortedNumbers(x))\n            }\n        }\n        res", "        def\
    \ findClosestElementsHelper(numbers : List[Float], minDif : Float, smallestNumber\
    \ : Float, largestNumber : Float) : Tuple2[Float, Float] = {\n            if (numbers.length\
    \ == 0) {\n                (smallestNumber, largestNumber)\n            } else\
    \ {\n                val dif = abs(numbers.head - numbers.tail.head)\n       \
    \         if (dif < minDif) {\n                    findClosestElementsHelper(numbers.tail,\
    \ dif, numbers.head, numbers.tail.head)\n                } else {\n          \
    \          findClosestElementsHelper(numbers.tail, minDif, smallestNumber, largestNumber)\n\
    \                }\n            }\n        }\n        if (numbers.length > 1)\
    \ {\n            findClosestElementsHelper(numbers.tail, abs(numbers.head - numbers.tail.head),\
    \ numbers.head, numbers.tail.head)\n        } else {\n            throw new IllegalArgumentException(\"\
    Not enough numbers\")\n        }", "        var prev = numbers(0)\n        var\
    \ prevDiff = abs(numbers(0) - numbers(1))\n        var curr = numbers(1)\n   \
    \     var currDiff = prevDiff\n        numbers.foreach(f => {\n            currDiff\
    \ = abs(f - prev)\n            if (currDiff < prevDiff) {\n                prev\
    \ = f\n                prevDiff = currDiff\n            }\n            else {\n\
    \                prev = curr\n                prevDiff = currDiff\n          \
    \      curr = f\n            }\n        })\n        return (prev, curr)", "\t\
    if (numbers.length < 2) throw new Exception(\"List must have length of at least\
    \ 2\");\n\tvar minDiff = abs(numbers(0) - numbers(1));\n\tvar minPair = (numbers(0),\
    \ numbers(1));\n\tfor (i <- 0 until numbers.length; j <- i + 1 until numbers.length)\
    \ {\n\t    var diff = abs(numbers(i) - numbers(j));\n\t    if (diff < minDiff)\
    \ {\n\t\tminDiff = diff;\n\t\tminPair = (numbers(i), numbers(j));\n\t    }\n\t\
    }\n\tminPair;", "        var closestElements : Tuple2[Float, Float] = (0.0f, 0.0f)\n\
    \        var closestDistance : Float = Float.MaxValue\n        for (i <- 0 until\
    \ numbers.length) {\n            for (j <- 0 until numbers.length) {\n       \
    \         if (i == j) continue\n                if (abs(numbers(i) - numbers(j))\
    \ < closestDistance) {\n                    closestElements = (min(numbers(i),\
    \ numbers(j)), max(numbers(i), numbers(j)))\n                    closestDistance\
    \ = abs(numbers(i) - numbers(j))\n                }\n            }\n        }\n\
    \        closestElements", "        var closestDistance : Float = Float.MaxValue\n\
    \        var closestPair : Tuple2[Float, Float] = null\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            val currentDistance = abs(numbers(i) - numbers(i\
    \ + 1))\n            if (currentDistance < closestDistance) {\n              \
    \  closestDistance = currentDistance\n                closestPair = Tuple2(numbers(i),\
    \ numbers(i + 1))\n            }\n        }\n        closestPair", "        //\
    \ For each element in list, do the following:\n        //  - Calculate the difference\
    \ with all other elements (take the absolute value)\n        //  - Keep the two\
    \ smallest differences and their associated numbers\n        var smallestDifference\
    \ = 1000000.0f.toFloat\n        var smallestDifferenceNumbers = (0.0f.toFloat,\
    \ 0.0f.toFloat)\n        var secondSmallestDifference = 1000000.0f.toFloat\n \
    \       var secondSmallestDifferenceNumbers = (0.0f.toFloat, 0.0f.toFloat)\n \
    \       for (i <- numbers) {\n            for (j <- numbers) {\n             \
    \   if (i != j) {\n                    if (abs(i - j) < smallestDifference) {\n\
    \                        smallestDifference = abs(i - j)\n                   \
    \     smallestDifferenceNumbers = (i, j)\n                    }\n            \
    \        else if (abs(i - j) < secondSmallestDifference) {\n                 \
    \       secondSmallestDifference = abs(i - j)\n                        secondSmallestDifferenceNumbers\
    \ = (i, j)\n                    }\n                }\n            }\n        }\n\
    \        // If the two smallest differences are the same, then choose the two\
    \ numbers that are in order.\n        if (smallestDifference == secondSmallestDifference)\
    \ {\n            return if (smallestDifferenceNumbers._1 < smallestDifferenceNumbers._2)\
    \ smallestDifferenceNumbers else (smallestDifferenceNumbers._2, smallestDifferenceNumbers._1)\n\
    \        }\n        else {\n            return smallestDifferenceNumbers\n   \
    \     }", "        var closest : Tuple2[Float, Float] = (numbers(0), numbers(1))\n\
    \        for (i <- numbers.indices) {\n            for (j <- numbers.indices)\
    \ {\n                if (abs(numbers(i) - numbers(j)) < abs(closest._1 - closest._2))\
    \ {\n                    closest = (numbers(i), numbers(j))\n                }\n\
    \            }\n        }\n        closest", "        def closer(tuple1 : Tuple2[Float,\
    \ Float], tuple2 : Tuple2[Float, Float]) : Tuple2[Float, Float] = if (abs(tuple1._1\
    \ - tuple1._2) <= abs(tuple2._1 - tuple2._2)) tuple1 else tuple2\n        val\
    \ newList = numbers.sortWith((x, y) => x < y)\n        if (newList.length < 2)\
    \ throw new Exception(\"invalid input\")\n        else (newList zip newList.tail).reduceLeft(closer)",
  "        if (numbers.length < 2) throw new Exception(\"Not enough numbers in list.\"\
    )\n        var closest = abs(numbers(0) - numbers(1))\n        var c1 = numbers(0)\n\
    \        var c2 = numbers(1)\n        for (i <- 0 until numbers.length - 1) {\n\
    \            if (abs(numbers(i) - numbers(i + 1)) < closest) {\n             \
    \   closest = abs(numbers(i) - numbers(i + 1))\n                c1 = numbers(i)\n\
    \                c2 = numbers(i + 1)\n            }\n        }\n        if (c1\
    \ < c2) (c1, c2) else (c2, c1)", "        //TODO\n        var min: Float = numbers(0)\
    \ - numbers(1)\n        var minI = 0\n        var minJ = 1\n        var i = 0\n\
    \        var j = 1\n        for (i <- 0 to numbers.length - 2) {\n           \
    \ for (j <- i + 1 to numbers.length - 1) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < min) {\n                    min = abs(numbers(i) - numbers(j))\n\
    \                    minI = i\n                    minJ = j\n                }\n\
    \            }\n        }\n        if (numbers(minI) > numbers(minJ)) {\n    \
    \        return (numbers(minJ), numbers(minI))\n        } else {\n           \
    \ return (numbers(minI), numbers(minJ))\n        }", "        val n = numbers.length\n\
    \        var minPair = numbers(0)\n        var minDiff = abs(numbers(0) - numbers(1))\n\
    \        for (i <- 0 until n-1) {\n            for (j <- i+1 until n) {\n    \
    \            val diff = abs(numbers(i) - numbers(j))\n                if (diff\
    \ < minDiff) {\n                    minDiff = diff\n                    minPair\
    \ = numbers(i)\n                }\n            }\n        }\n        (minPair,\
    \ minPair + minDiff)", "      val f = numbers.sortWith(_<_)\n      var min = f(0)\n\
    \      var minList = List[Float]()\n      for (i <- 1 until f.length) {\n    \
    \    if (f(i) - min < minList.length) minList = List(min, f(i))\n        else\
    \ if (f(i) - min == minList.length) minList = minList :+ f(i)\n        min = f(i)\n\
    \      }\n      (minList(0), minList(1))", "        if (numbers.length < 2) throw\
    \ new IllegalArgumentException(\"List must have at least two elements.\")\n  \
    \      var closest = (numbers(0), numbers(1))\n        var gap = abs(closest._1\
    \ - closest._2)\n        numbers.combinations(2).foreach(t => {\n            if\
    \ (abs(t(0) - t(1)) < gap) {\n                gap = abs(t(0) - t(1))\n       \
    \         closest = (t(0), t(1))\n            }\n        })\n        return closest",
  "        var currentClosest = abs(numbers(0) - numbers(1))\n        var currentClosestPair\
    \ = (numbers(0), numbers(1))\n        for (x <- numbers; y <- numbers) {\n   \
    \         if (abs(x - y) < currentClosest && x != y) {\n                currentClosest\
    \ = abs(x - y)\n                currentClosestPair = (x, y)\n            }\n \
    \       }\n        return currentClosestPair", "        val sorted = numbers.sorted\n\
    \        val distances = sorted.sliding(2).map(p => (p(0), p(1), abs(p(0) - p(1)))).toList\n\
    \        val minDistance = distances.minBy(e => e._3)\n        (minDistance._1,\
    \ minDistance._2)", "        require(numbers.length >= 2)\n        // Compute\
    \ the difference between every pair of numbers, then select the minimum-value\
    \ one.\n        val diffs = for (x <- numbers; y <- numbers) yield abs(x - y)\n\
    \        val diffs2 = diffs.sorted\n        // Create a list of numbers (of length\
    \ at least two) with duplicates, then take the first two.\n        val firstTwo\
    \ = diffs2.take(2)\n        // Find the first two elements in the numbers list\
    \ that correspond to the first two elements in the diffs2 list.\n        val closest\
    \ = (for (x <- numbers; y <- numbers; if (abs(x - y) == firstTwo(0) || abs(x -\
    \ y) == firstTwo(1))) yield (x, y)).sorted.head\n        // Return the first two\
    \ elements (of length two) of the closest list.\n        (closest._1, closest._2)",
  "        var smallestDif = Float.MaxValue\n        var result : Tuple2[Float, Float]\
    \ = null\n        for (i <- 0 until numbers.length - 1) {\n            val dif\
    \ = abs(numbers(i) - numbers(i + 1))\n            if (dif < smallestDif) {\n \
    \               smallestDif = dif\n                result = if (numbers(i) > numbers(i\
    \ + 1)) (numbers(i + 1), numbers(i)) else (numbers(i), numbers(i + 1))\n     \
    \       }\n        }\n        result", "        if (numbers.length < 2) {\n  \
    \          throw new IllegalArgumentException(\"numbers list must be of length\
    \ at least 2\")\n        }\n        var closestNumbers : Tuple2[Float, Float]\
    \ = null\n        var currentClosestDistance : Float = Float.MaxValue\n      \
    \  for (numberIndex <- 0 until numbers.length) {\n            for (numberIndex2\
    \ <- numberIndex + 1 until numbers.length) {\n                val number1 = numbers(numberIndex)\n\
    \                val number2 = numbers(numberIndex2)\n                val distance\
    \ = abs(number1 - number2)\n                if (distance < currentClosestDistance)\
    \ {\n                    currentClosestDistance = distance\n                 \
    \   closestNumbers = if (number1 < number2) (number1, number2) else (number2,\
    \ number1)\n                }\n            }\n        }\n        closestNumbers",
  "        def findClosestElements(numbers : List[Float], (minDiff, pair) : Tuple2[Float,\
    \ Tuple2[Float, Float]]) : Tuple2[Float, Tuple2[Float, Float]] = {\n         \
    \   if (numbers.length == 0) (minDiff, pair)\n            else if (numbers.length\
    \ == 1) (minDiff, pair)\n            else {\n                val diff = abs(numbers(0)\
    \ - numbers(1))\n                if (diff < minDiff) findClosestElements(numbers.tail,\
    \ (diff, (numbers(0), numbers(1))))\n                else findClosestElements(numbers.tail,\
    \ (minDiff, pair))\n            }\n        }\n        findClosestElements(numbers,\
    \ (abs(numbers(0) - numbers(1)), (numbers(0), numbers(1))))._2", "        if (numbers.length\
    \ < 2) throw new IllegalArgumentException(\"length of numbers must be greater\
    \ than 1\")\n        val numbersSorted = numbers.sorted\n        var minDiff =\
    \ numbersSorted(1) - numbersSorted(0)\n        var min = numbersSorted(0)\n  \
    \      var max = numbersSorted(1)\n        for (i <- 1 until numbersSorted.length\
    \ - 1) {\n            val currentDiff = numbersSorted(i + 1) - numbersSorted(i)\n\
    \            if (currentDiff < minDiff) {\n                minDiff = currentDiff\n\
    \                min = numbersSorted(i)\n                max = numbersSorted(i\
    \ + 1)\n            }\n        }\n        (min, max)", "        if (numbers.size\
    \ < 2) throw new IllegalArgumentException(\"numbers should have at least two elements\"\
    )\n        var closestDifference = Float.MaxValue\n        var closestPair : Tuple2[Float,\
    \ Float] = (0, 0)\n        for (i <- 0 until numbers.size - 1) {\n           \
    \ val first = numbers(i)\n            val second = numbers(i + 1)\n          \
    \  val difference = abs(first - second)\n            if (difference < closestDifference)\
    \ {\n                closestDifference = difference\n                closestPair\
    \ = if (first > second) (second, first) else (first, second)\n            }\n\
    \        }\n        closestPair", "        if (numbers.length < 2) throw new Exception(\"\
    too few numbers\")\n        var min_difference = -1.0f.toFloat\n        var result\
    \ : Tuple2[Float, Float] = null\n        var current_number = numbers(0)\n   \
    \     for (number <- numbers.tail) {\n            if (min_difference == -1.0f.toFloat\
    \ || (number - current_number) < min_difference) {\n                min_difference\
    \ = number - current_number\n                result = (current_number, number)\n\
    \            }\n            current_number = number\n        }\n        result",
  "        var mn = numbers.sortWith(_ < _).toArray\n        var min = mn(1) - mn(0)\n\
    \        var tup = Tuple2(mn(0), mn(1))\n        for (i <- 0 until mn.length -\
    \ 1) {\n            var n = mn(i + 1) - mn(i)\n            if (n < min) {\n  \
    \              min = n\n                tup = Tuple2(mn(i), mn(i + 1))\n     \
    \       }\n        }\n        tup", "        var first = numbers(0)\n        var\
    \ second = numbers(1)\n        var minDiff = abs(first - second)\n        for\
    \ (i <- 0 until numbers.length) {\n            for (j <- 0 until numbers.length)\
    \ {\n                if (i != j) {\n                    val diff = abs(numbers(i)\
    \ - numbers(j))\n                    if (diff < minDiff) {\n                 \
    \       minDiff = diff\n                        first = numbers(i)\n         \
    \               second = numbers(j)\n                    }\n                }\n\
    \            }\n        }\n        (first, second)", "        var closest = numbers(0)\n\
    \        var prev = numbers(0)\n        var ret = new Tuple2(numbers(0), numbers(1))\n\
    \        for (number <- numbers) {\n            if (abs(number - prev) < abs(ret._1\
    \ - ret._2)) {\n                ret = new Tuple2(prev, number)\n            }\n\
    \            prev = number\n        }\n        return ret", "        val numbersSorted\
    \ = numbers.sorted\n        var closest = abs(numbersSorted(0) - numbersSorted(1))\n\
    \        var closestPair = (numbersSorted(0), numbersSorted(1))\n        for (i\
    \ <- 0 until numbersSorted.length - 1) {\n            if (abs(numbersSorted(i)\
    \ - numbersSorted(i + 1)) < closest) {\n                closest = abs(numbersSorted(i)\
    \ - numbersSorted(i + 1))\n                closestPair = (numbersSorted(i), numbersSorted(i\
    \ + 1))\n            }\n        }\n        closestPair", "        val sortedNumbers\
    \ = numbers.sorted\n        var closest = (sortedNumbers(0), sortedNumbers(1))\n\
    \        for (i <- 1 until sortedNumbers.length - 1) {\n            val candidate\
    \ = (sortedNumbers(i), sortedNumbers(i + 1))\n            if (abs(candidate._1\
    \ - candidate._2) < abs(closest._1 - closest._2)) closest = candidate\n      \
    \  }\n        closest", "        var smallestDifference : Float = abs(numbers(0)\
    \ - numbers(1))\n        var closestElements : Tuple2[Float, Float] = (numbers(0),\
    \ numbers(1))\n        for (i <- 0 until numbers.length) {\n            for (j\
    \ <- 0 until numbers.length) {\n                if (i != j) {\n              \
    \      val difference : Float = abs(numbers(i) - numbers(j))\n               \
    \     if (difference < smallestDifference) {\n                        smallestDifference\
    \ = difference\n                        if (numbers(i) < numbers(j)) closestElements\
    \ = (numbers(i), numbers(j))\n                        else closestElements = (numbers(j),\
    \ numbers(i))\n                    }\n                }\n            }\n     \
    \   }\n        closestElements", "        // Note that scala.List objects are\
    \ immutable and so the original parameter list will not be changed by this\n \
    \       // function.\n        var result : Tuple2[Float, Float] = (0.0f, 0.0f)\n\
    \        // Trivial case where there are only two entries in the list.\n     \
    \   if (numbers.length == 2) {\n            result = (numbers(0), numbers(1))\n\
    \        } else {\n            // Iterate over the list of numbers (which has\
    \ at least three entries) checking the difference between\n            // each\
    \ number and the next to see if it is closer than the current closest two numbers.\
    \ We can assume we\n            // will find a smaller difference than the first\
    \ two because the list is sorted.\n            var closestDifference : Float =\
    \ numbers(1) - numbers(0)\n            for (x <- 1 to numbers.length - 2) {\n\
    \                if (numbers(x + 1) - numbers(x) < closestDifference) {\n    \
    \                closestDifference = numbers(x + 1) - numbers(x)\n           \
    \         result = (numbers(x), numbers(x + 1))\n                }\n         \
    \   }\n        }\n        result", "        assert(numbers.length >= 2)\n    \
    \    var (a, b) = (numbers(0), numbers(1))\n        var (minDistance, index) =\
    \ (abs(a - b), 0)\n        for (i <- 0 until numbers.length - 1) {\n         \
    \   val distance = abs(numbers(i) - numbers(i + 1))\n            if (distance\
    \ < minDistance) {\n                minDistance = distance\n                index\
    \ = i\n            }\n        }\n        (numbers(index), numbers(index + 1))",
  "        var closestPair : Tuple2[Float, Float] = (numbers(0), numbers(1))\n   \
    \     var closestDifference : Float = abs(numbers(0) - numbers(1))\n        for\
    \ (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val distance : Float = abs(numbers(i) - numbers(j))\n   \
    \             if (distance < closestDifference) {\n                    closestDifference\
    \ = distance\n                    closestPair = (numbers(i), numbers(j))\n   \
    \             }\n            }\n        }\n        return closestPair", "    \
    \    if (numbers.length < 2) {\n            throw new IllegalArgumentException(\"\
    numbers is of length \" + numbers.length + \"; must be at least 2\")\n       \
    \ }\n        var pair : Tuple2[Float, Float] = (numbers(0), numbers(1))\n    \
    \    for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until\
    \ numbers.length) {\n                val diff = abs(numbers(i) - numbers(j))\n\
    \                if (diff < abs(pair._1 - pair._2)) {\n                    pair\
    \ = (min(numbers(i), numbers(j)), max(numbers(i), numbers(j)))\n             \
    \   }\n            }\n        }\n        pair", "        require(numbers.length\
    \ >= 2)\n        // sort the list\n        val sortedNumbers = numbers.sorted\n\
    \        // get the current pair\n        var minDifference = abs(sortedNumbers(0)\
    \ - sortedNumbers(1))\n        var currentPair = (sortedNumbers(0), sortedNumbers(1))\n\
    \        // loop through the list and check the difference between adjacent numbers\n\
    \        for (i <- 1 until sortedNumbers.length - 1) {\n            if (abs(sortedNumbers(i)\
    \ - sortedNumbers(i + 1)) < minDifference) {\n                minDifference =\
    \ abs(sortedNumbers(i) - sortedNumbers(i + 1))\n                currentPair =\
    \ (sortedNumbers(i), sortedNumbers(i + 1))\n            }\n        }\n       \
    \ // return\n        currentPair", "      var min : Float = Float.MaxValue\n \
    \     var result : Tuple2[Float, Float] = (0.0f, 0.0f)\n      for (i <- 0 until\
    \ numbers.length - 1) {\n        var diff : Float = abs(numbers(i) - numbers(i\
    \ + 1))\n        if (diff < min) {\n          min = diff\n          result = (numbers(i),\
    \ numbers(i + 1))\n        }\n      }\n      result", "\tvar closestPair : Tuple2[Float,\
    \ Float] = null\n\tfor (i <- 1 until numbers.length) {\n\t    val n1 = numbers(i\
    \ - 1)\n\t    val n2 = numbers(i)\n\t    if (closestPair == null || n2 - n1 <\
    \ closestPair._2 - closestPair._1) {\n\t\tclosestPair = (n1, n2)\n\t    }\n\t\
    }\n\tclosestPair", "        var minimumDistance = Float.MaxValue\n        var\
    \ distance : Float = 0\n        var min1 : Float = 0\n        var min2 : Float\
    \ = 0\n        for (i <- 0 until numbers.length - 1) {\n            for (j <-\
    \ i + 1 until numbers.length) {\n                distance = abs(numbers(i) - numbers(j))\n\
    \                if (distance < minimumDistance) {\n                    minimumDistance\
    \ = distance\n                    min1 = numbers(i)\n                    min2\
    \ = numbers(j)\n                }\n            }\n        }\n        (min1, min2)",
  "        if (numbers.size >= 2) {\n            var minDistance = Float.MaxValue\n\
    \            var closestPair = (numbers(0), numbers(1))\n            numbers.sorted.map(a\
    \ => numbers.filter(_ > a).sorted.min).map(a => if (abs(a - numbers.filter(_ <\
    \ a).sorted.max) < minDistance) {\n                minDistance = abs(a - numbers.filter(_\
    \ < a).sorted.max)\n                closestPair = (numbers.filter(_ < a).sorted.max,\
    \ a)\n            })\n            closestPair\n        } else {\n            throw\
    \ new IllegalArgumentException(\"numbers list needs to have at least two elements\"\
    )\n        }", "        val numbersSorted = numbers.sorted\n        var closestSoFar\
    \ : Tuple2[Float, Float] = Tuple2(numbersSorted(0), numbersSorted(1))\n      \
    \  for (i <- 0 until numbersSorted.length - 1) {\n            if (abs(numbersSorted(i)\
    \ - numbersSorted(i + 1)) < abs(closestSoFar._1 - closestSoFar._2))\n        \
    \        closestSoFar = Tuple2(numbersSorted(i), numbersSorted(i + 1))\n     \
    \   }\n        closestSoFar", "        require(numbers.length >= 2)\n        var\
    \ lastNum = numbers(0)\n        var closestElements = (lastNum, lastNum)\n   \
    \     var minDiff = abs(lastNum - numbers(1))\n        for (num <- numbers.tail)\
    \ {\n            val diff = abs(lastNum - num)\n            if (diff < minDiff)\
    \ {\n                minDiff = diff\n                closestElements = (lastNum,\
    \ num)\n            }\n            lastNum = num\n        }\n        closestElements",
  "        // For empty or too short lists, return a meaningful value.\n        if\
    \ (numbers.isEmpty || numbers.length < 2) return (0.0f, 0.0f)\n        // Now\
    \ start with the first pair, assuming that's the closest.\n        var closestPair\
    \ = (numbers(0), numbers(1))\n        // And start with an arbitrarily large gap.\n\
    \        var bestDifference = Float.MaxValue\n        // Now do the classic loop\
    \ to find the closest pair.\n        for (i <- 0 until numbers.length - 1) {\n\
    \            for (j <- i + 1 until numbers.length) {\n                val diff\
    \ = abs(numbers(i) - numbers(j))\n                if (diff < bestDifference) {\n\
    \                    bestDifference = diff\n                    closestPair =\
    \ (numbers(i), numbers(j))\n                }\n            }\n        }\n    \
    \    // Lastly, order the pair.\n        val first = min(closestPair._1, closestPair._2)\n\
    \        val second = max(closestPair._1, closestPair._2)\n        (first, second)",
  "        var closest : Tuple2[Float, Float] = Tuple2(Float.MaxValue, Float.MaxValue)\n\
    \        for (i <- numbers) {\n            for (j <- numbers) {\n            \
    \    if (abs(i - j) < abs(closest._1 - closest._2)) {\n                    if\
    \ (i < j) closest = Tuple2(i, j)\n                    else closest = Tuple2(j,\
    \ i)\n                }\n            }\n        }\n        closest", "       \
    \ var minimumDistance = Float.MaxValue\n        var result = (0.0f, 0.0f)\n  \
    \      val sortedNumbers = numbers.sorted\n        for (i <- 0 until sortedNumbers.length\
    \ - 1) {\n            val currentDistance = abs(sortedNumbers(i) - sortedNumbers(i\
    \ + 1))\n            if (currentDistance < minimumDistance) {\n              \
    \  minimumDistance = currentDistance\n                result = (sortedNumbers(i),\
    \ sortedNumbers(i + 1))\n            }\n        }\n        result", "        //\
    \ If the list is length 2 or less, simply return the list of elements.\n     \
    \   if (numbers.length <= 2) {\n            return (numbers(0), numbers(1))\n\
    \        }\n        // Sort the list.\n        var numbersSorted = numbers.sorted\n\
    \        // The first element and the second element are the closest elements\
    \ to each other.\n        var minDifference = abs(numbersSorted(0) - numbersSorted(1))\n\
    \        var minElements = (numbersSorted(0), numbersSorted(1))\n        // Loop\
    \ through the rest of the list and compare the distance between elements.\n  \
    \      for (i <- 2 until numbersSorted.length) {\n            var difference =\
    \ abs(numbersSorted(i) - numbersSorted(i - 1))\n            if (difference < minDifference)\
    \ {\n                minDifference = difference\n                minElements =\
    \ (numbersSorted(i - 1), numbersSorted(i))\n            }\n        }\n       \
    \ // Return the minimum elements.\n        return minElements", "        var closestValue\
    \ : Float = numbers(0)\n        var closetValueIndex : Int = 0\n        var currentValue\
    \ : Float = numbers(0)\n        var currentValueIndex : Int = 0\n        var smallestDifference\
    \ : Float = abs(currentValue - closestValue)\n        for (i <- 1 until numbers.length)\
    \ {\n            if (i % 2 == 0) {\n                currentValue = numbers(i)\n\
    \                currentValueIndex = i\n            } else {\n               \
    \ closestValue = numbers(i)\n                closetValueIndex = i\n          \
    \  }\n            if (abs(currentValue - closestValue) < smallestDifference) {\n\
    \                smallestDifference = abs(currentValue - closestValue)\n     \
    \       }\n        }\n        (numbers(min(currentValueIndex, closetValueIndex)),\
    \ numbers(max(currentValueIndex, closetValueIndex)))", "        def loop(numbers\
    \ : List[Float], closestSoFar : (Float, Float)) : Tuple2[Float, Float] = {\n \
    \           numbers match {\n                case Nil => throw new RuntimeException(\"\
    Number list was empty.  Please ensure that the list has at least two elements.\"\
    )\n                case x :: Nil => closestSoFar\n                case x :: xs\
    \ => {\n                    val newClosest = if (abs(x - xs.head) < abs(closestSoFar._1\
    \ - closestSoFar._2)) (x, xs.head) else closestSoFar\n                    loop(xs,\
    \ newClosest)\n                }\n            }\n        }\n        loop(numbers,\
    \ (numbers.head, numbers.head))", "        var minDiff = Float.MaxValue\n    \
    \    var minPair = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length) {\n\
    \            for (j <- i + 1 until numbers.length) {\n                val diff\
    \ = abs(numbers(i) - numbers(j))\n                if (diff < minDiff) {\n    \
    \                minDiff = diff\n                    minPair = if (numbers(i)\
    \ < numbers(j)) (numbers(i), numbers(j)) else (numbers(j), numbers(i))\n     \
    \           }\n            }\n        }\n        minPair", "        val sortedNumbers\
    \ = numbers.sorted\n        var minimumDifference : Float = abs(sortedNumbers(0)\
    \ - sortedNumbers(1))\n        var closestElements : Tuple2[Float, Float] = (sortedNumbers(0),\
    \ sortedNumbers(1))\n        for (i <- 0 until sortedNumbers.length - 1) {\n \
    \           val absoluteDifference = abs(sortedNumbers(i) - sortedNumbers(i +\
    \ 1))\n            if (absoluteDifference < minimumDifference) {\n           \
    \     minimumDifference = absoluteDifference\n                closestElements\
    \ = (sortedNumbers(i), sortedNumbers(i + 1))\n            }\n        }\n     \
    \   closestElements", "        require(numbers.length >= 2)\n        var minDist\
    \ : Float = abs(numbers(0) - numbers(1))\n        var result : Tuple2[Float, Float]\
    \ = (numbers(0), numbers(1))\n        for (i <- 0 until numbers.length) {\n  \
    \          for (j <- i + 1 until numbers.length) {\n                val dist =\
    \ abs(numbers(i) - numbers(j))\n                if (dist < minDist) {\n      \
    \              minDist = dist\n                    result = (min(numbers(i), numbers(j)),\
    \ max(numbers(i), numbers(j)))\n                }\n            }\n        }\n\
    \        result", "        if (numbers.length < 2) throw new IllegalArgumentException(\"\
    List must have at least two numbers.\")\n        var result = Tuple2(numbers(0),\
    \ numbers(1))\n        for (i <- 0 until numbers.length; j <- i+1 until numbers.length)\
    \ {\n            val newResult = Tuple2(numbers(i), numbers(j))\n            if\
    \ (abs(newResult._1 - newResult._2) < abs(result._1 - result._2)) result = newResult\n\
    \        }\n        result", "        // >>> findClosestElements((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))\n  \
    \      // ((2.0f, 2.2f))\n        var closest : Tuple2[Float, Float] = null\n\
    \        var distance : Float = Float.MaxValue\n        // >>> findClosestElements((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))\n  \
    \      // ((2.0f, 2.0f))\n        for (i <- 0 until numbers.length; j <- i + 1\
    \ until numbers.length) {\n            val diff = abs(numbers(i) - numbers(j))\n\
    \            if (diff < distance) {\n                closest = (numbers(i), numbers(j))\n\
    \                distance = diff\n            }\n        }\n        // >>> findClosestElements((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))\n  \
    \      // ((2.0f, 2.2f))\n        closest", "        val first : Float = numbers.head\n\
    \        val (second : Float, _) = numbers.tail.foldLeft((first, abs(first - numbers.tail.head)))\
    \ {\n            case ((prevClosest : Float, prevClosestDistance : Float), current\
    \ : Float) => {\n                val currentDistance : Float = abs(current - prevClosest)\n\
    \                if (currentDistance < prevClosestDistance) (current, currentDistance)\n\
    \                else (prevClosest, prevClosestDistance)\n            }\n    \
    \    }\n        (min(first, second), max(first, second))", "        var closest\
    \ : Tuple2[Float, Float] = (Float.MaxValue, Float.MaxValue)\n        for (i <-\
    \ 0 until numbers.length - 1) {\n            val x = numbers(i)\n            val\
    \ y = numbers(i + 1)\n            val diff = abs(x - y)\n            if (diff\
    \ < abs(closest._1 - closest._2)) closest = (x, y)\n        }\n        closest",
  "        var firstNumber : Float = 0.0f\n        var secondNumber : Float = 0.0f\n\
    \        var firstFound : Boolean = false\n        for (i <- 0 until numbers.length)\
    \ {\n            for (j <- 0 until numbers.length) {\n                if (i !=\
    \ j) {\n                    if (!firstFound) {\n                        firstNumber\
    \ = numbers(i)\n                        secondNumber = numbers(j)\n          \
    \              firstFound = true\n                    }\n                    if\
    \ (abs(numbers(i) - numbers(j)) < abs(firstNumber - secondNumber)) {\n       \
    \                 firstNumber = numbers(i)\n                        secondNumber\
    \ = numbers(j)\n                    }\n                }\n            }\n    \
    \    }\n        if (firstNumber > secondNumber) {\n            return (secondNumber,\
    \ firstNumber)\n        }\n        else {\n            return (firstNumber, secondNumber)\n\
    \        }", '        findClosestElementsHelper(numbers.toArray, 0)', '        ???',
  "        require(numbers.length >= 2)\n        var result : Tuple2[Float, Float]\
    \ = null\n        var currentDifference : Float = Float.MaxValue\n        for\
    \ (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val diff = abs(numbers(i) - numbers(j))\n               \
    \ if (diff < currentDifference) {\n                    result = (min(numbers(i),\
    \ numbers(j)), max(numbers(i), numbers(j)))\n                    currentDifference\
    \ = diff\n                }\n            }\n        }\n        result", '        return
    (1.0f, 2.0f)', "        // Loop through the supplied list of numbers to find the\
    \ two nearest each other and return them\n        // as a tuple.\n        var\
    \ smallest : Float = abs(numbers(0) - numbers(1))\n        var first : Float =\
    \ numbers(0)\n        var second : Float = numbers(1)\n        for (i <- 0 until\
    \ numbers.length) {\n            for (j <- 0 until numbers.length) {\n       \
    \         if (j != i) {\n                    val thisDifference : Float = abs(numbers(i)\
    \ - numbers(j))\n                    if (thisDifference < smallest) {\n      \
    \                  smallest = thisDifference\n                        first =\
    \ numbers(i)\n                        second = numbers(j)\n                  \
    \  }\n                }\n            }\n        }\n        (first, second)", " \
    \       def closest(numbers : List[Float], best : Tuple2[Float, Float]) : Tuple2[Float,\
    \ Float] = numbers match {\n            case Nil => best\n            case x ::\
    \ Nil => best\n            case x :: xs => {\n                val bestDelta =\
    \ (best._2 - best._1).abs\n                val currentDelta = (x - xs.head).abs\n\
    \                if (currentDelta < bestDelta) closest(xs, (x, xs.head))\n   \
    \             else closest(xs, best)\n            }\n        }\n        closest(numbers.sorted,\
    \ (numbers.head, numbers.tail.head))", "      var closest : (Float, Float) = null\n\
    \      var closestDist : Float = Float.MaxValue\n      for (i <- 0 until numbers.length\
    \ - 1) {\n        val thisDist = abs(numbers(i) - numbers(i + 1))\n        if\
    \ (thisDist < closestDist) {\n          closestDist = thisDist\n          closest\
    \ = (numbers(i), numbers(i + 1))\n        }\n      }\n      closest", "\tif (numbers.length\
    \ < 2) throw new Exception(\"not enough numbers\")\n\tval sorted = numbers.sortWith(_\
    \ < _)\n\tval min = (sorted(0), sorted(1))\n\tval max = (sorted(sorted.length\
    \ - 2), sorted(sorted.length - 1))\n\tvar closest = min\n\tvar distance = max._1\
    \ - max._2\n\tvar temp = 0.0f\n\tfor (i <- 0 until sorted.length - 1) {\n\t  \
    \  temp = sorted(i + 1) - sorted(i)\n\t    if (temp < distance) {\n\t\tclosest\
    \ = (sorted(i), sorted(i + 1))\n\t\tdistance = temp\n\t    }\n\t}\n\tclosest",
  "        // Put all the numbers into a sorted array\n        val numbersSorted =\
    \ numbers.sorted\n        // The difference between the two closest numbers\n\
    \        var minDiff = Float.MaxValue\n        // The first closest number\n \
    \       var first = Float.MaxValue\n        // The second closest number\n   \
    \     var second = Float.MaxValue\n        // For each number in the sorted list\n\
    \        for (i <- 0 until numbersSorted.length - 1) {\n            // If the\
    \ difference between the two numbers is less than the minimum difference\n   \
    \         if (numbersSorted(i + 1) - numbersSorted(i) < minDiff) {\n         \
    \       // This is the new closest pair of numbers\n                minDiff =\
    \ numbersSorted(i + 1) - numbersSorted(i)\n                first = numbersSorted(i)\n\
    \                second = numbersSorted(i + 1)\n            }\n        }\n   \
    \     // Return the closest pair of numbers\n        (first, second)", "     \
    \   numbers.sortWith(_ < _) match {\n            case a :: b :: rest => (a, b)\n\
    \            case _ => throw new IllegalArgumentException(\"There should be at\
    \ least two elements in list\")\n        }", "        var closest = (numbers(0),\
    \ numbers(1))\n        var diff = abs(closest._1 - closest._2)\n        for (i\
    \ <- 1 until numbers.length) {\n            for (j <- 1 until numbers.length)\
    \ {\n                if (j > i) {\n                    if (abs(numbers(i) - numbers(j))\
    \ < diff) {\n                        closest = (numbers(i), numbers(j))\n    \
    \                    diff = abs(closest._1 - closest._2)\n                   \
    \ }\n                }\n            }\n        }\n        return closest", " \
    \     var tup = numbers.tail.foldLeft((numbers.head, numbers.tail.head, abs(numbers.head\
    \ - numbers.tail.head))) {(tup, number) =>\n          var diff = abs(tup._1 -\
    \ number)\n          if (diff < tup._3) (tup._1, number, diff)\n          else\
    \ tup\n      }\n      if (tup._1 < tup._2) (tup._1, tup._2)\n      else (tup._2,\
    \ tup._1)", "        var number1 : Float = 0.0f\n        var number2 : Float =\
    \ 0.0f\n        var distance : Float = Float.MaxValue\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            for (j <- i + 1 until numbers.length) {\n\
    \                val tempDistance = abs(numbers(i) - numbers(j))\n           \
    \     if (tempDistance < distance) {\n                    number1 = numbers(i)\n\
    \                    number2 = numbers(j)\n                    distance = tempDistance\n\
    \                }\n            }\n        }\n        (number1, number2)", " \
    \       // TODO Implement this.\n        // Hint: use the Scala function \"sortWith\"\
    \ to sort the list to make sure the numbers are in order.\n        // This can\
    \ be easily done by writing a function that compares the two arguments of the\
    \ sortWith function to\n        // determine which one should come first.\n  \
    \      // This function is of type : (A, A) => Boolean, where A is the type of\
    \ the list argument.\n        // Think about what this means, and how you could\
    \ write a function to satisfy this type.\n        // To sort a list in ascending\
    \ order, you can call this function like this:\n        // (1) List.sortWith(myFunction);\
    \ // where List is of type List[Float]\n        // (2) List.sortWith(myFunction);\
    \ // where List is of type List[Int]\n        // The function myFunction is the\
    \ function you write to determine what order the numbers should be sorted in.\n\
    \        // When the list is sorted, you should be able to iterate through the\
    \ list to find the two elements that are\n        // closest together.\n     \
    \   (0.0f, 0.0f)", "        // >>> findClosestElements((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))\n  \
    \      // ((2.0f, 2.2f))\n        // >>> findClosestElements((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))\n  \
    \      // ((2.0f, 2.0f))\n        // >>> findClosestElements((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 6.0f.toFloat)))\n  \
    \      // ((5.0f, 6.0f))\n        // >>> findClosestElements((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 6.0f.toFloat, 7.0f.toFloat)))\n\
    \        // ((6.0f, 7.0f))\n        // >>> findClosestElements((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 6.0f.toFloat, 7.0f.toFloat,\
    \ 8.0f.toFloat)))\n        // ((7.0f, 8.0f))\n        val numbersSorted = numbers.sorted\n\
    \        var first = 0\n        var second = 0\n        var first_second = numbersSorted(1)\
    \ - numbersSorted(0)\n        for (i <- 1 to numbersSorted.length - 1) {\n   \
    \         val temp = numbersSorted(i) - numbersSorted(i - 1)\n            if (temp\
    \ < first_second) {\n                first_second = temp\n                first\
    \ = i", "        var prev = numbers(0)\n        var minDiff = abs(numbers(0) -\
    \ numbers(1))\n        var result : Tuple2[Float, Float] = (prev, numbers(1))\n\
    \        for (current <- numbers.slice(1, numbers.length)) {\n            val\
    \ diff = abs(current - prev)\n            if (diff < minDiff) {\n            \
    \    minDiff = diff\n                result = (prev, current)\n            }\n\
    \            prev = current\n        }\n        result", "        // Fill in your\
    \ answer here\n        return (0.0f, 0.0f)", '        (numbers.min, numbers.max)',
  "        if (numbers.length < 2) {\n            throw new IllegalArgumentException\n\
    \        }\n        else {\n            var closest : Tuple2[Float, Float] = (numbers(0),\
    \ numbers(1))\n            var minDiff : Float = abs(numbers(0) - numbers(1))\n\
    \            var a = numbers(0)\n            var b = numbers(1)\n            var\
    \ i = 0\n            while (i < numbers.length - 1) {\n                a = numbers(i)\n\
    \                b = numbers(i + 1)\n                if (minDiff > abs(a - b))\
    \ {\n                    minDiff = abs(a - b)\n                    closest = (a,\
    \ b)\n                }\n                i += 1\n            }\n            closest\n\
    \        }", "        var previous = numbers(0)\n        var current = numbers(1)\n\
    \        var record = abs(current - previous)\n        var result = (previous,\
    \ current)\n        for (i <- 2 until numbers.length) {\n            previous\
    \ = current\n            current = numbers(i)\n            val diff = abs(current\
    \ - previous)\n            if (diff < record) {\n                record = diff\n\
    \                result = (previous, current)\n            }\n        }\n    \
    \    result", "        var smallest : Float = 0.0f.toFloat\n        var largest\
    \ : Float = 0.0f.toFloat\n        var minDiff : Float = 999999999.9f.toFloat\n\
    \        for (i <- 0 until numbers.length - 1) {\n            val diff : Float\
    \ = abs(numbers(i + 1) - numbers(i))\n            if (diff < minDiff) {\n    \
    \            minDiff = diff\n                smallest = numbers(i)\n         \
    \       largest = numbers(i + 1)\n            }\n        }\n        return (smallest,\
    \ largest)", "        var closestPair : Tuple2[Float, Float] = (numbers(0), numbers(1))\n\
    \        var closestPairDistance : Float = abs(numbers(0) - numbers(1))\n    \
    \    for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until\
    \ numbers.length) {\n                val candidateDistance : Float = abs(numbers(i)\
    \ - numbers(j))\n                if (candidateDistance < closestPairDistance)\
    \ {\n                    closestPair = (numbers(i), numbers(j))\n            \
    \        closestPairDistance = candidateDistance\n                }\n        \
    \    }\n        }\n        closestPair", "        var smallestDistance = scala.Float.MaxValue\n\
    \        var bestPair = Tuple2(scala.Float.MinValue, scala.Float.MinValue)\n \
    \       for (x <- numbers) {\n            for (y <- numbers if y > x) {\n    \
    \            if (abs(x - y) < smallestDistance) {\n                    smallestDistance\
    \ = abs(x - y)\n                    bestPair = Tuple2(x, y)\n                }\n\
    \            }\n        }\n        return bestPair", "        require(numbers.length\
    \ >= 2)\n        var minDifference = Float.MaxValue\n        var minDifferencePair\
    \ : Tuple2[Float, Float] = (numbers(0), numbers(1))\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            for (j <- i + 1 until numbers.length) {\n\
    \                val difference = abs(numbers(i) - numbers(j))\n             \
    \   if (difference < minDifference) {\n                    minDifference = difference\n\
    \                    minDifferencePair = if (numbers(i) < numbers(j)) (numbers(i),\
    \ numbers(j)) else (numbers(j), numbers(i))\n                }\n            }\n\
    \        }\n        minDifferencePair", "        // First sort the list\n    \
    \    val sortedList = numbers.sorted\n        var minDiff = abs(sortedList(0)\
    \ - sortedList(1))\n        var minElems = (sortedList(0), sortedList(1))\n  \
    \      // Then go through them one by one, keeping track of the closest elements\
    \ seen so far\n        for (i <- 1 until sortedList.length - 1) {\n          \
    \  val diff = abs(sortedList(i) - sortedList(i + 1))\n            if (diff < minDiff)\
    \ {\n                minDiff = diff\n                minElems = (sortedList(i),\
    \ sortedList(i + 1))\n            }\n        }\n        minElems", "\t    // Complete\
    \ the method so that it returns a tuple (Tuple2) of the two closest numbers\n\t\
    \    // e.g. (2.0f, 2.2f) or (2.0f, 2.0f) or (5.0f, 6.0f) or (1.0f, 2.0f) or (-2.0f,\
    \ -1.0f) or (0.0f, 2.0f) or (0.0f, 1.0f) or (-2.0f, 2.0f) or (-2.0f, 2.1f) or\
    \ (-2.0f, 2.0f) or (1.0f, 2.0f) or (2.0f, 2.1f) or (2.0f, 2.0f) or (2.0f, 2.1f)\
    \ or (2.0f, 2.0f) or (2.0f, 2.1f) or (2.0f, 2.0f) or (2.0f, 2.1f) or (2.0f, 2.0f)\
    \ or (2.0f, 2.1f) or (2.0f, 2.0f) or (2.0f, 2.1f) or (2.0f, 2.0f) or (2.0f, 2.1f)\
    \ or (2.0f, 2.0f) or (2.0f, 2.1f) or (2.0f, 2.0f) or (2.0f, 2.1f) or (2.0f, 2.0f)\
    \ or (2.0f, 2.1f) or (2.0f, 2.0f) or (2.0f, 2.1f) or (2.0f, 2.0f) or (2.0f, 2.1f)\
    \ or (2.0f, 2.0f) or (2.0f, 2.1f) or (2.0f, 2.0f) or (2.0f, 2.1f) or (2.0f, 2.0f)\
    \ or (2.0f, 2.1f) or", '        return findClosestElements(numbers, Float.MaxValue,
    0, numbers.size - 1)', "        var (first, second) = numbers match {\n      \
    \      case x1 :: x2 :: xs => (x1, x2)\n            case _ => (0, 0)\n       \
    \ }\n        var (maxDiff, diff) = (0.0f, 0.0f)\n        for (i <- 1 until numbers.length)\
    \ {\n            diff = abs(numbers(i) - numbers(i - 1))\n            if (diff\
    \ > maxDiff) {\n                first = numbers(i - 1)\n                second\
    \ = numbers(i)\n                maxDiff = diff\n            }\n        }\n   \
    \     (first, second)", "        var closest : Tuple2[Float, Float] = (numbers(0),\
    \ numbers(1))\n        var distance : Float = abs(numbers(0) - numbers(1))\n \
    \       for (i <- numbers) {\n            for (j <- numbers) {\n             \
    \   if (i != j) {\n                    if (abs(i - j) < distance) {\n        \
    \                closest = (i, j)\n                        distance = abs(i -\
    \ j)\n                    }\n                }\n            }\n        }\n   \
    \     closest", '        return numbers.sortWith(_ < _).sliding(2).map(x => (x(0),
    x(1))).minBy(x => abs(x._1 - x._2))', "        // Your code here!\n        (0f,\
    \ 0f)", "        // Create a new list, adding a 0.0 at the start and end\n   \
    \     val s = 0.0f +: numbers :+ 0.0f\n        // Create a zip of the new list,\
    \ mapping the diff between the two elements\n        val p = s.zip(s.tail).map(x\
    \ => x._2 - x._1)\n        // Find the lowest value in the list\n        val m\
    \ = p.min\n        // Find the index of the first occurance of that value\n  \
    \      val i = p.indexOf(m)\n        // Return the two adjacent numbers in the\
    \ original list\n        (s(i), s(i + 1))", "      var closest : Float = numbers(0)\
    \ - numbers(1)\n      var elements : Tuple2[Float, Float] = null\n      for (i\
    \ <- 0 until numbers.length - 1) {\n        val a = numbers(i)\n        val b\
    \ = numbers(i + 1)\n        val diff = abs(a - b)\n        if (diff < closest)\
    \ {\n          closest = diff\n          elements = (a, b)\n        }\n      }\n\
    \      return elements", "      var temp = numbers.sorted\n      var first = temp.head\n\
    \      var second = temp.tail.head\n      for (i <- 0 to temp.length - 2) {\n\
    \        if (abs(temp(i) - temp(i + 1)) < abs(first - second)) {\n          first\
    \ = temp(i)\n          second = temp(i + 1)\n        }\n      }\n      return\
    \ (first, second)", "      // Fill in the body of this function\n      var tup\
    \ : Tuple2[Float, Float] = (0.0f, 0.0f)\n      var smallest : Float = 99999999.0f\n\
    \      for (i <- 0 to numbers.length - 2) {\n        for (j <- i + 1 to numbers.length\
    \ - 1) {\n          if (abs(numbers(i) - numbers(j)) < smallest) {\n         \
    \   smallest = abs(numbers(i) - numbers(j))\n            tup = (min(numbers(i),\
    \ numbers(j)), max(numbers(i), numbers(j)))\n          }\n        }\n      }\n\
    \      tup", "        val absDiff = numbers.indices.map(i => abs(numbers(i) -\
    \ numbers(i + 1))).toList\n        (numbers(absDiff.indexOf(absDiff.min)), numbers(absDiff.indexOf(absDiff.min)\
    \ + 1))", "        val sortedList = numbers.sorted\n        var idx = 0\n    \
    \    var minDiff = Float.MaxValue\n        var minDiffElements = (0.0f, 0.0f)\n\
    \        for (idx <- 0 until sortedList.length - 1) {\n            val currentDiff\
    \ = abs(sortedList(idx) - sortedList(idx + 1))\n            if (currentDiff <\
    \ minDiff) {\n                minDiff = currentDiff\n                minDiffElements\
    \ = (sortedList(idx), sortedList(idx + 1))\n            }\n        }\n       \
    \ minDiffElements", "        var minDistance = Float.MaxValue\n        var minTuple\
    \ = new Tuple2[Float, Float](0.0f, 0.0f)\n        for (i <- 0 until numbers.length)\
    \ {\n            for (j <- i + 1 until numbers.length) {\n                if (Math.abs(numbers(i)\
    \ - numbers(j)) < minDistance) {\n                    minDistance = Math.abs(numbers(i)\
    \ - numbers(j))\n                    minTuple = new Tuple2[Float, Float](numbers(i),\
    \ numbers(j))\n                }\n            }\n        }\n        minTuple",
  "        var minDiff = 100000f\n        var minTuple = (0f, 0f)\n        for (i\
    \ <- 0 until numbers.length) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val diff = abs(numbers(i) - numbers(j))\n               \
    \ if (diff < minDiff) {\n                    minDiff = diff\n                \
    \    minTuple = if (numbers(i) < numbers(j)) (numbers(i), numbers(j)) else (numbers(j),\
    \ numbers(i))\n                }\n            }\n        }\n        minTuple",
  "        var closest_elements : Tuple2[Float, Float] = null\n        var best_distance\
    \ : Float = Float.MaxValue\n        var distance : Float = 0.0f\n        for (x\
    \ <- numbers) {\n            for (y <- numbers) {\n                if (x <= y)\
    \ {\n                    distance = abs(x - y)\n                    if (distance\
    \ < best_distance) {\n                        best_distance = distance\n     \
    \                   closest_elements = Tuple2(x, y)\n                    }\n \
    \               }\n            }\n        }\n        closest_elements", "    \
    \    def findClosestElements0(numbers : List[Float], minDifference : Float, minNumbers\
    \ : Tuple2[Float, Float]) : Tuple2[Float, Float] = numbers match {\n         \
    \   case first :: second :: rest => {\n                val diff = abs(first -\
    \ second)\n                if (diff < minDifference) findClosestElements0(numbers.tail,\
    \ diff, (first, second))\n                else findClosestElements0(numbers.tail,\
    \ minDifference, minNumbers)\n            }\n            case _ => minNumbers\n\
    \        }\n        numbers match {\n            case first :: second :: rest\
    \ => findClosestElements0(numbers.tail, abs(first - second), (first, second))\n\
    \            case _ => throw new IllegalArgumentException(\"Array of numbers must\
    \ contain at least two elements\")\n        }", "        var closestNumbers :\
    \ Tuple2[Float, Float] = (numbers(0), numbers(1))\n        var closestDistance\
    \ : Float = abs(numbers(0) - numbers(1))\n        var currentDistance : Float\
    \ = 0.0f\n        for (i <- 0 until numbers.length - 1) {\n            for (j\
    \ <- i + 1 until numbers.length) {\n                currentDistance = abs(numbers(i)\
    \ - numbers(j))\n                if (currentDistance < closestDistance) {\n  \
    \                  closestDistance = currentDistance\n                    closestNumbers\
    \ = (numbers(i), numbers(j))\n                }\n            }\n        }\n  \
    \      closestNumbers", "        val sorted = numbers.sorted\n        var closest\
    \ = Tuple2(sorted(0), sorted(1))\n        for (i <- 0 until sorted.length - 1)\
    \ {\n            val diff = abs(sorted(i) - sorted(i + 1))\n            if (diff\
    \ < abs(closest._1 - closest._2)) closest = Tuple2(sorted(i), sorted(i + 1))\n\
    \        }\n        closest", "      require(numbers.length >= 2)\n      var minimumDiff\
    \ = Float.MaxValue\n      var closestNumbers = (Float.MaxValue, Float.MaxValue)\n\
    \      for (i <- 0 until numbers.length) {\n        for (j <- 0 until numbers.length)\
    \ {\n          if (i != j) {\n            val difference = abs(numbers(i) - numbers(j))\n\
    \            if (difference < minimumDiff) {\n              minimumDiff = difference\n\
    \              closestNumbers = (min(numbers(i), numbers(j)), max(numbers(i),\
    \ numbers(j)))\n            }\n          }\n        }\n      }\n      closestNumbers",
  '        return ((2.0f, 2.0f))', "\tvar closestPair : Tuple2[Float, Float] = (0.0f,\
    \ 0.0f)\n\tvar closestDistance : Float = 100000.0f\n\tfor (i <- 0 until numbers.length\
    \ - 1) {\n\t    for (j <- i + 1 until numbers.length) {\n\t\tif (abs(numbers(i)\
    \ - numbers(j)) < closestDistance) {\n\t\t    closestDistance = abs(numbers(i)\
    \ - numbers(j))\n\t\t    closestPair = (min(numbers(i), numbers(j)), max(numbers(i),\
    \ numbers(j)))\n\t\t}\n\t    }\n\t}\n\tclosestPair", "        def findClosestElementsRec(numbers\
    \ : List[Float], x : Float, y : Float, closestDistance : Float) : Tuple2[Float,\
    \ Float] = {\n            if (numbers.length == 0) {\n                (x, y)\n\
    \            } else {\n                val f0 = numbers(0)\n                val\
    \ numbersRest = numbers.drop(1)\n                findClosestElementsRec(numbersRest,\n\
    \                    if (abs(f0 - x) < closestDistance) {\n                  \
    \      if (x < f0) (x, f0) else (f0, x)\n                    } else if (abs(f0\
    \ - y) < closestDistance) {\n                        if (y < f0) (y, f0) else\
    \ (f0, y)\n                    } else {\n                        (x, y)\n    \
    \                },\n                    closestDistance)\n            }\n   \
    \     }\n        if (numbers.length == 0) {\n            return (0, 0)\n     \
    \   }\n        val f0 = numbers(0)\n        val numbersRest = numbers.drop(1)\n\
    \        val result = findClosestElementsRec(numbersRest, (f0, f0), abs(f0 - f0))\n\
    \        if (result._1 > result._2) {\n            (result._2, result._1)\n  \
    \      } else {\n            result\n        }", "        // >>> findClosestElements(List(1.0f,\
    \ 2.0f, 3.0f, 4.0f, 5.0f, 2.2f))\n        // ((2.0f, 2.2f))\n        // >>> findClosestElements(List(1.0f,\
    \ 2.0f, 3.0f, 4.0f, 5.0f, 2.0f))\n        // ((2.0f, 2.0f))\n        // >>> findClosestElements(List(0.0f,\
    \ 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.2f))\n        // ((1.0f, 2.0f))\n        //\
    \ >>> findClosestElements(List(0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.0f))\n  \
    \      // ((1.0f, 2.0f))\n        // >>> findClosestElements(List(0.0f, 1.0f,\
    \ 2.0f, 3.0f, 4.0f, 5.0f, 2.3f))\n        // ((2.0f, 2.3f))\n        // >>> findClosestElements(List(1.0f,\
    \ 2.0f, 3.0f, 4.0f, 5.0f, 1.0f))\n        // ((1.0f, 1.0f))\n        // >>> findClosestElements(List(1.0f,\
    \ 2.0f, 3.0f, 4.0f, 5.0f, 6.0f))\n        // ((5.0f, 6.0f))\n        // >>> findClosestElements(List(1.0f,\
    \ 2.0f, 3.0f, 4.0f, 5.0f, 0.0f))\n        // ((4.0f, 5.0f))\n        // >>> findClosestElements(List(1.0f,\
    \ 2.0f, 3.0f, 4.0f, 5.0f, 1.2", "        var c = 0\n        var diff = 0.0f\n\
    \        var min = Float.MaxValue\n        var min1 = 0.0f\n        var min2 =\
    \ 0.0f\n        for (i <- 0 until numbers.length-1) {\n            diff = abs(numbers(i)\
    \ - numbers(i+1))\n            if (diff < min) {\n                min = diff\n\
    \                min1 = numbers(i)\n                min2 = numbers(i+1)\n    \
    \        }\n        }\n        if (min1 > min2) {\n            var temp = min1\n\
    \            min1 = min2\n            min2 = temp\n        }\n        return (min1,\
    \ min2)", "        val sorted = numbers.sorted\n        var prev = sorted.head\n\
    \        var curr = sorted.head\n        var closest = Tuple2(prev, curr)\n  \
    \      var smallest = curr - prev\n        sorted.tail.foreach(next => {\n   \
    \         prev = curr\n            curr = next\n            val d = curr - prev\n\
    \            if (d < smallest) {\n                smallest = d\n             \
    \   closest = Tuple2(prev, curr)\n            }\n        })\n        closest",
  "        if (numbers.length <= 1) {\n            throw new IllegalArgumentException(\"\
    length of list must be at least two.\")\n        }\n        val numbers_l = (numbers.toBuffer).sortWith(_\
    \ < _)\n        var closest_diff = (numbers_l(1) - numbers_l(0)).abs\n       \
    \ var closest_pair = (numbers_l(0), numbers_l(1))\n        for (i <- 1 until numbers_l.length\
    \ - 1) {\n            val diff = (numbers_l(i + 1) - numbers_l(i)).abs\n     \
    \       if (diff < closest_diff) {\n                closest_diff = diff\n    \
    \            closest_pair = (numbers_l(i), numbers_l(i + 1))\n            }\n\
    \        }\n        closest_pair", "        val absDiff = numbers.map(x => numbers.map(y\
    \ => (x, y, abs(x - y))).filter(x => x._1 != x._2).sortBy(x => x._3)).flatten.sortBy(x\
    \ => x._3)\n        (absDiff.head._1, absDiff.head._2)", "        var minDistance\
    \ = Float.MaxValue\n        var minValue1 = Float.MinValue\n        var minValue2\
    \ = Float.MinValue\n        for (i <- 1 until numbers.length) {\n            if\
    \ (abs(numbers(i) - numbers(i - 1)) < minDistance) {\n                minDistance\
    \ = abs(numbers(i) - numbers(i - 1))\n                minValue1 = numbers(i -\
    \ 1)\n                minValue2 = numbers(i)\n            }\n        }\n     \
    \   if (minValue1 > minValue2) {\n            (minValue2, minValue1)\n       \
    \ } else {\n            (minValue1, minValue2)\n        }", "        // Seperate\
    \ into two lists\n        // Sort ascending\n        // Search for the two closest,\
    \ start in the middle and expand to the edges\n        // Search from the middle\
    \ to the front, then from the middle to the end\n        // Return the result\n\
    \        def search(list : List[Float], (currentClosestIndex1 : Int, currentClosestIndex2\
    \ : Int), (currentClosestDistance : Float)) : Tuple2[Int, Int] = {\n         \
    \   // Contains a list of index ranges to search\n            // The tuples are\
    \ min, max inclusive\n            val indexRanges = List[Tuple2[Int, Int]]((0,\
    \ currentClosestIndex1 - 1), (currentClosestIndex1 + 1, currentClosestIndex2 -\
    \ 1), (currentClosestIndex2 + 1, list.length - 1))\n            // Function to\
    \ search a range, returns the closest for that range\n            def searchRange(range\
    \ : Tuple2[Int, Int]) : Tuple2[Int, Int] = {\n                // If the range\
    \ has a length of one, there is only one element and that must be the closest\
    \ to the other\n                if (range._1 == range._2) {\n                \
    \    (range._1, currentClosestIndex2)\n                }\n                // If\
    \ the range has a length of two, there are only two elements and both must be\
    \ compared\n                else if (range._1 + 1 == range._2) {\n           \
    \         val difference1 = abs(list(range._1) - list(currentClosestIndex2))\n\
    \                    val difference2 = abs(list(range._2) - list(currentClosestIndex2))\n\
    \                    if (difference1 < difference2) {\n                      \
    \  (range._1, currentClosestIndex2)\n                    }\n                 \
    \   else {\n                        (range._2, currentClosestIndex2)\n       \
    \             }\n                }\n                // Otherwise, a binary search\
    \ can be applied\n                else {\n                    // Perform a binary\
    \ search on the current range\n                    // Uses a queue to perform\
    \ the search\n                    def binarySearch(currentRange : Tuple2[Int,\
    \ Int], queue : Queue[Tuple2[Int, Int]]) : Tuple2[Int, Int] = {\n            \
    \            // Queue is", "      var closestTuple : Tuple2[Float, Float] = numbers(0)\
    \ -> numbers(1)\n      var closestDistance : Float = numbers(1) - numbers(0)\n\
    \      for (i <- 0 until numbers.length) {\n        for (j <- i + 1 until numbers.length)\
    \ {\n          if (abs(numbers(j) - numbers(i)) < closestDistance) {\n       \
    \     closestTuple = numbers(i) -> numbers(j)\n            closestDistance = abs(numbers(j)\
    \ - numbers(i))\n          }\n        }\n      }\n      closestTuple", "     \
    \   // Scala's List is immutable, so don't modify it.\n        // instead, create\
    \ new Lists as needed for calculations.\n        // Sort the array of numbers.\n\
    \        val sortedNumbers = numbers.sortWith(_ < _)\n        // Find the distances\
    \ between each of the sorted numbers.\n        // this is all but the last number\n\
    \        // This gives a list of distances.\n        val distances = sortedNumbers.init.zip(sortedNumbers.tail).map(pair\
    \ => abs(pair._1 - pair._2))\n        // find the minimum distance in the list\
    \ of distances.\n        val minDistance = distances.min\n        // find the\
    \ index of that minimum distance.\n        val index = distances.indexOf(minDistance)\n\
    \        // return a pair of numbers: the first the number before the minimum\
    \ distance, the second the number after.\n        (sortedNumbers(index), sortedNumbers(index\
    \ + 1))", "        // >>> math.abs(-5)\n        // 5\n        // >>> math.abs(5)\n\
    \        // 5\n        // >>> math.abs(5 - 10)\n        // 5\n        // >>> math.abs(5\
    \ - 5)\n        // 0\n        // >>> math.abs(5 - 4)\n        // 1\n        //\
    \ >>> math.abs(5 - 1)\n        // 4\n        // >>> math.abs(5 - 0)\n        //\
    \ 5\n        val distance = (a : Float, b : Float) => abs(a - b)\n        val\
    \ smallestDistance = (a : Float, b : Float) => a < b\n        val isDistanceTheSmallest\
    \ = (distanceBeingCompared : Float, currentSmallestDistance : Float) => smallestDistance(distanceBeingCompared,\
    \ currentSmallestDistance)\n        val previousSmallestDistance = (distanceBeingCompared\
    \ : Float, currentSmallestDistance : Float) => distanceBeingCompared\n       \
    \ val valuesThatAreAtTheSmallestDistance = (smallestDistance : Float, numbersBeingCompared\
    \ : List[Float]) => {\n            // >>> List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat).filter(a => abs(a -\
    \ 5) == abs(2.2f.toFloat - 5))\n            // List(5.0, 2.2)\n            //\
    \ >>> List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat,\
    \ 2.2f.toFloat).filter(a => abs(a - 2.2f.toFloat) == abs(2.2f.toFloat - 5))\n\
    \            // List(2.2)\n            // >>> List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat).filter(a => abs(a -\
    \ 2.2f.toFloat) == abs(2.2f.toFloat - 5)).sorted", "        var minDiff = 2.0f\n\
    \        var minPair : Tuple2[Float, Float] = null\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            for (j <- i + 1 until numbers.length) {\n\
    \                val diff = abs(numbers(i) - numbers(j))\n                if (diff\
    \ < minDiff) {\n                    minDiff = diff\n                    minPair\
    \ = if (numbers(i) < numbers(j)) (numbers(i), numbers(j)) else (numbers(j), numbers(i))\n\
    \                }\n            }\n        }\n        minPair", "        val delta\
    \ = abs(numbers(0) - numbers(1))\n        var closest : Tuple2[Float, Float] =\
    \ (numbers(0), numbers(1))\n        for (i <- 0 until numbers.length - 1) {\n\
    \            val next = abs(numbers(i) - numbers(i + 1))\n            if (next\
    \ < delta) {\n                closest = (numbers(i), numbers(i + 1))\n       \
    \     }\n        }\n        closest", "        var result : Tuple2[Float, Float]\
    \ = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length) {\n            for\
    \ (j <- i+1 until numbers.length) {\n                if (abs(numbers(i) - numbers(j))\
    \ < abs(result._1 - result._2)) {\n                    result = (numbers(i), numbers(j))\n\
    \                }\n            }\n        }\n        result", "        var distances\
    \ : List[Tuple2[Float, Float]] = List[Tuple2[Float, Float]]()\n        var closest\
    \ : Tuple2[Float, Float] = (numbers(0), numbers(1))\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            for (j <- i + 1 until numbers.length) {\n\
    \                val distance : Float = abs(numbers(i) - numbers(j))\n       \
    \         if (distance < abs(closest._1 - closest._2)) {\n                   \
    \ closest = (numbers(i), numbers(j))\n                }\n            }\n     \
    \   }\n        closest", "        var tuple = (numbers(0), numbers(1))\n     \
    \   for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until\
    \ numbers.length) {\n                if (abs(numbers(i) - numbers(j)) < abs(tuple._1\
    \ - tuple._2)) {\n                    tuple = (numbers(i), numbers(j))\n     \
    \           }\n            }\n        }\n        tuple", "        var elements\
    \ : Tuple2[Float, Float] = (0.0f, 0.0f)\n        var minDifference : Float = Float.MaxValue\n\
    \        for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1\
    \ until numbers.length) {\n                val diff : Float = abs(numbers(i) -\
    \ numbers(j))\n                if (diff < minDifference) {\n                 \
    \   minDifference = diff\n                    elements = if (numbers(i) < numbers(j))\
    \ (numbers(i), numbers(j)) else (numbers(j), numbers(i))\n                }\n\
    \            }\n        }\n        elements", "        // TODO: Solve the problem\n\
    \        return (0f, 0f)", "\t\tval length = numbers.length\n\t\tval closestNumbers\
    \ = ListBuffer[Tuple2[Float, Float]]()\n\t\tfor (i <- 0 until length) {\n\t\t\t\
    for (j <- i + 1 until length) {\n\t\t\t\tclosestNumbers += Tuple2(numbers(i),\
    \ numbers(j))\n\t\t\t}\n\t\t}\n\t\tclosestNumbers.sortWith((a, b) => abs(a._1\
    \ - a._2) < abs(b._1 - b._2)).head", "        var minDistance = Float.MaxValue\n\
    \        var minElements = (Float.MaxValue, Float.MaxValue)\n        var i = 0\n\
    \        while (i < numbers.length - 1) {\n            var j = i + 1\n       \
    \     while (j < numbers.length) {\n                val distance = abs(numbers(i)\
    \ - numbers(j))\n                if (distance < minDistance) {\n             \
    \       minDistance = distance\n                    minElements = (numbers(i),\
    \ numbers(j))\n                }\n                j += 1\n            }\n    \
    \        i += 1\n        }\n        minElements", "        val numbersSorted =\
    \ numbers.sorted\n        var minDistance = abs(numbersSorted(0) - numbersSorted(1))\n\
    \        var minElements = numbersSorted(0) -> numbersSorted(1)\n        for (i\
    \ <- 0 until numbersSorted.length - 1) {\n            val distance = abs(numbersSorted(i)\
    \ - numbersSorted(i + 1))\n            if (distance < minDistance) {\n       \
    \         minDistance = distance\n                minElements = numbersSorted(i)\
    \ -> numbersSorted(i + 1)\n            }\n        }\n        minElements", " \
    \       var result = (numbers(0), numbers(1))\n        var minDiff = abs(numbers(0)\
    \ - numbers(1))\n        for (i <- 1 until numbers.length - 1) {\n           \
    \ if (abs(numbers(i) - numbers(i + 1)) < minDiff) {\n                result =\
    \ (numbers(i), numbers(i + 1))\n                minDiff = abs(numbers(i) - numbers(i\
    \ + 1))\n            }\n        }\n        result", "        // Input validation\n\
    \        if (numbers.length < 2) throw new IllegalArgumentException(\"Input list\
    \ must have at least two values\")\n        // Loop variables\n        var closestElements\
    \ : Tuple2[Float, Float] = (numbers(0), numbers(1))\n        var minDistance :\
    \ Float = abs(numbers(0) - numbers(1))\n        // If the input list has more\
    \ than two values, scan it for more closely related pairs\n        if (numbers.length\
    \ > 2) {\n            for (i <- 0 until numbers.length) {\n                for\
    \ (j <- i + 1 until numbers.length) {\n                    val distance : Float\
    \ = abs(numbers(i) - numbers(j))\n                    if (distance < minDistance)\
    \ {\n                        closestElements = (numbers(i), numbers(j))\n    \
    \                    minDistance = distance\n                    }\n         \
    \       }\n            }\n        }\n        closestElements", '        return
    (numbers(0), numbers(1))', "        val zipped = numbers.zip(numbers.tail)\n \
    \       val diffs = zipped.map { case (x, y) => abs(x - y) }\n        val min_diff\
    \ = diffs.min\n        val min_diff_index = diffs.indexOf(min_diff)\n        zipped(min_diff_index)",
  "        if (numbers.size >= 2) {\n            var (closest1, closest2) = (numbers(0),\
    \ numbers(1))\n            var (min1, min2) = (abs(closest1 - closest2), numbers.size\
    \ - 1)\n            var (i, j) = (0, 1)\n            while (j < numbers.size)\
    \ {\n                var (diff, i2, j2) = (abs(numbers(i) - numbers(j)), i, j)\n\
    \                if (diff < min1) {\n                    (closest1, closest2)\
    \ = (numbers(i), numbers(j))\n                    (min1, min2) = (diff, numbers.size\
    \ - 1)\n                }\n                else if (diff == min1) {\n        \
    \            min2 = diff\n                }\n                if (min2 < min1)\
    \ {\n                    (closest1, closest2) = (numbers(i), numbers(j))\n   \
    \                 (min1, min2) = (min2, min1)\n                }\n           \
    \     (i, j) = if (i < numbers.size - 1) (i + 1, j) else (0, j + 1)\n        \
    \    }\n            if (closest1 < closest2) (closest1, closest2) else (closest2,\
    \ closest1)\n        }\n        else null", "        require(numbers.length >=\
    \ 2)\n        val initial : Tuple2[Float, Float] = (numbers(0), numbers(1))\n\
    \        val closer : (Tuple2[Float, Float], Float) => Tuple2[Float, Float] =\
    \ (candidate, element) => {\n            if (abs(candidate._1 - candidate._2)\
    \ < abs(element - candidate._2)) {\n                candidate\n            } else\
    \ {\n                (candidate._2, element)\n            }\n        }\n     \
    \   val reduced : Tuple2[Float, Float] = numbers.tail.foldLeft(initial)(closer)\n\
    \        val first : Tuple2[Float, Float] = (reduced._1, reduced._2)\n       \
    \ val reverse : Tuple2[Float, Float] = (reduced._2, reduced._1)\n        if (abs(first._1\
    \ - first._2) < abs(reverse._1 - reverse._2)) {\n            first\n        }\
    \ else {\n            reverse\n        }", "        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var diff = 0.0f\n        var closestElement =\
    \ (0.0f, 0.0f)\n        // var diff = 0.0f\n        for (i <- 0 to numbers.length\
    \ - 1) {\n            for (j <- 0 to numbers.length - 1) {\n                diff\
    \ = (abs(numbers(i) - numbers(j)))\n                // println(diff)\n       \
    \         if (diff < closestElement._2) {\n                    closestElement\
    \ = (numbers(i), numbers(j))\n                }\n            }\n        }\n  \
    \      return closestElement", "        var closestElements = (numbers(0), numbers(1))\n\
    \        for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1\
    \ until numbers.length) {\n                val distance = abs(numbers(i) - numbers(j))\n\
    \                if (distance < abs(closestElements._1 - closestElements._2))\
    \ closestElements = (numbers(i), numbers(j))\n            }\n        }\n     \
    \   closestElements", "        var c = numbers(0)\n        var m = numbers(1)\n\
    \        var d = abs(numbers(0) - numbers(1))\n        for (i <- numbers) {\n\
    \            for (j <- numbers) {\n                if (abs(i - j) < d && i !=\
    \ j) {\n                    c = i\n                    m = j\n               \
    \     d = abs(i - j)\n                }\n            }\n        }\n        (c,\
    \ m)", "        val sorted = numbers.sorted\n        var min : Float = Float.MaxValue\n\
    \        var min_nums : Tuple2[Float, Float] = (0.0f, 0.0f)\n        for (i <-\
    \ 1 until sorted.length) {\n            if (sorted(i) - sorted(i - 1) < min) {\n\
    \                min = sorted(i) - sorted(i - 1)\n                min_nums = (sorted(i\
    \ - 1), sorted(i))\n            }\n        }\n        min_nums", "        // ToDo:\
    \ Implement code\n        return (numbers(0), numbers(1))", "      var closest\
    \ = List[Float]()\n      var temp = List[Float]()\n      if (numbers.length <\
    \ 2) {\n        return (0.0f, 0.0f)\n      }\n      for (i <- 0 until numbers.length)\
    \ {\n        for (j <- 0 until numbers.length) {\n          if (i != j) {\n  \
    \          if (abs(numbers(i) - numbers(j)) < abs(numbers(0) - numbers(1))) {\n\
    \              closest = numbers(i) :: numbers(j) :: Nil\n            }\n    \
    \      }\n        }\n      }\n      if (closest.isEmpty) {\n        closest =\
    \ numbers(0) :: numbers(1) :: Nil\n      }\n      if (closest(0) < closest(1))\
    \ {\n        return (closest(0), closest(1))\n      }\n      else {\n        return\
    \ (closest(1), closest(0))\n      }", "        var closest : (Float, Float) =\
    \ (Float.NaN, Float.NaN)\n        var closestDistance : Float = Float.PositiveInfinity\n\
    \        for (numberA <- numbers) {\n            for (numberB <- numbers) {\n\
    \                val distance = abs(numberA - numberB)\n                if (distance\
    \ < closestDistance) {\n                    closest = (numberA, numberB)\n   \
    \                 closestDistance = distance\n                }\n            }\n\
    \        }\n        closest", "        var closestPair: Tuple2[Float, Float] =\
    \ (numbers(0), numbers(1))\n        var minimumDistance = abs(numbers(0) - numbers(1))\n\
    \        for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1\
    \ until numbers.length) {\n                if (abs(numbers(i) - numbers(j)) <\
    \ minimumDistance) {\n                    minimumDistance = abs(numbers(i) - numbers(j))\n\
    \                    closestPair = (numbers(i), numbers(j))\n                }\n\
    \            }\n        }\n        closestPair", "        var closest : Tuple2[Float,\
    \ Float] = (numbers(0), numbers(1))\n        val size = numbers.size\n       \
    \ for (i <- 0 until size - 1) {\n            val k = i + 1\n            for (j\
    \ <- k until size) {\n                val (previous_first, previous_second) =\
    \ closest\n                val (first, second) = (numbers(i), numbers(j))\n  \
    \              if (abs(first - second) < abs(previous_first - previous_second))\
    \ {\n                    if (first < second) {\n                        closest\
    \ = (first, second)\n                    } else {\n                        closest\
    \ = (second, first)\n                    }\n                }\n            }\n\
    \        }\n        closest", "        require(numbers.length >= 2)\n        val\
    \ groups : Map[Float, List[Float]] = numbers.groupBy((num : Float) => num)\n \
    \       // Assume the first two numbers are the closest to each other\n      \
    \  var closest : Tuple2[Float, Float] = (numbers(0), numbers(1))\n        for\
    \ (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                if (abs(numbers(i) - numbers(j)) < abs(closest._1 - closest._2))\
    \ {\n                    closest = (numbers(i), numbers(j))\n                }\n\
    \            }\n        }\n        return closest", "        // Start with a big\
    \ difference, then iterate through the list and see if we can find something that's\
    \ smaller.\n        var minDiff = 99999999999.0f.toFloat\n        var minDiffTuple\
    \ = (numbers(0), numbers(1))\n        var currentIndex = 0\n        while (currentIndex\
    \ < numbers.length - 1) {\n            var diff = abs(numbers(currentIndex) -\
    \ numbers(currentIndex + 1))\n            if (diff < minDiff) {\n            \
    \    minDiff = diff\n                minDiffTuple = (numbers(currentIndex), numbers(currentIndex\
    \ + 1))\n            }\n            currentIndex += 1\n        }\n        return\
    \ minDiffTuple", "        val len = numbers.length\n        val maxindex = len\
    \ - 1\n        if (maxindex > 0) {\n            var min_index = 0\n          \
    \  var max_index = 1\n            var min_value = numbers(max_index) - numbers(min_index)\n\
    \            for (i <- 0 to maxindex - 1) {\n                for (j <- i + 1 to\
    \ maxindex) {\n                    val value = numbers(j) - numbers(i)\n     \
    \               if (value < min_value) {\n                        min_value =\
    \ value\n                        min_index = i\n                        max_index\
    \ = j\n                    }\n                }\n            }\n            (numbers(min_index),\
    \ numbers(max_index))\n        } else {\n            (numbers(0), numbers(1))\n\
    \        }", "        if (numbers.length < 2) return null\n        var c1 = numbers(0)\n\
    \        var c2 = numbers(1)\n        var c = abs(c1 - c2)\n        for (i <-\
    \ 0 until numbers.length - 1) {\n            val x = numbers(i)\n            val\
    \ y = numbers(i + 1)\n            val d = abs(x - y)\n            if (d < c) {\n\
    \                c = d\n                c1 = x\n                c2 = y\n     \
    \       }\n        }\n        if (c1 < c2) (c1, c2) else (c2, c1)", "        val\
    \ sortedNumbers = numbers.sorted\n        var closestTuple = (0.0f, 0.0f)\n  \
    \      var closestDifference = Math.abs(sortedNumbers(0) - sortedNumbers(1))\n\
    \        for (i <- 0 until sortedNumbers.length - 1) {\n            val difference\
    \ = Math.abs(sortedNumbers(i) - sortedNumbers(i + 1))\n            if (difference\
    \ <= closestDifference) {\n                closestDifference = difference\n  \
    \              closestTuple = (sortedNumbers(i), sortedNumbers(i + 1))\n     \
    \       }\n        }\n        closestTuple", "        // Iterate through the list\
    \ and check for the adjacent pair that is closest in value to each other.\n  \
    \      var min = Float.MaxValue\n        var result : Tuple2[Float, Float] = null\n\
    \        for (i <- 0 until numbers.length - 1) {\n            val first = numbers(i)\n\
    \            val second = numbers(i + 1)\n            val delta = abs(first -\
    \ second)\n            if (delta < min) {\n                min = delta\n     \
    \           result = (first, second)\n            }\n        }\n        result",
  "        var closest : Tuple2[Float, Float] = Tuple2(numbers(0), numbers(1))\n \
    \       var smallestDiff : Float = Math.abs(numbers(0) - numbers(1))\n       \
    \ for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                if (Math.abs(numbers(i) - numbers(j)) < smallestDiff) {\n\
    \                    smallestDiff = Math.abs(numbers(i) - numbers(j))\n      \
    \              closest = Tuple2(numbers(i), numbers(j))\n                }\n \
    \           }\n        }\n        closest", "        val sortedNumbers = numbers.sorted\n\
    \        var minDistance = abs(sortedNumbers(0) - sortedNumbers(1))\n        var\
    \ minPair = Tuple2(sortedNumbers(0), sortedNumbers(1))\n        for (i <- (1 to\
    \ sortedNumbers.length - 1)) {\n            if (abs(sortedNumbers(i) - sortedNumbers(i\
    \ - 1)) < minDistance) {\n                minDistance = abs(sortedNumbers(i) -\
    \ sortedNumbers(i - 1))\n                minPair = Tuple2(sortedNumbers(i - 1),\
    \ sortedNumbers(i))\n            }\n        }\n        minPair", "        // TODO:\
    \ Complete this function to return the two elements in numbers that are closest\
    \ to each other\n        // Hint: numbers should be sorted first\n        (0.0f,\
    \ 1.0f)", "        if (numbers.length < 2) throw new Error(\"Must supply two or\
    \ more numbers\")\n        else {\n            var closest1 = numbers(0)\n   \
    \         var closest2 = numbers(1)\n            var closestDiff = abs(closest1\
    \ - closest2)\n            var i = 0\n            while (i < numbers.length -\
    \ 1) {\n                val diff = abs(numbers(i) - numbers(i + 1))\n        \
    \        if (diff < closestDiff) {\n                    closest1 = numbers(i)\n\
    \                    closest2 = numbers(i + 1)\n                    closestDiff\
    \ = diff\n                }\n                i += 1\n            }\n         \
    \   if (closest1 > closest2) return (closest2, closest1)\n            else return\
    \ (closest1, closest2)\n        }", "        val sorted = numbers.sorted\n   \
    \     val min = sorted.tail.zip(sorted).map(l => abs(l._1 - l._2)).min\n     \
    \   val found = sorted.tail.zip(sorted).filter(l => abs(l._1 - l._2) == min)\n\
    \        (found.head._1, found.head._2)", "        var minDiff : Float = Float.MaxValue\n\
    \        var minPair : Tuple2[Float, Float] = null\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            for (j <- i + 1 until numbers.length) {\n\
    \                val diff = abs(numbers(i) - numbers(j))\n                if (diff\
    \ < minDiff) {\n                    minDiff = diff\n                    minPair\
    \ = (numbers(i), numbers(j))\n                }\n            }\n        }\n  \
    \      minPair", "      var minDiff = Float.MaxValue\n      var minDiffTuple :\
    \ Tuple2[Float, Float] = (0.0f, 0.0f)\n      for (i <- 0 until numbers.length)\
    \ {\n        for (j <- i + 1 until numbers.length) {\n          if (abs(numbers(i)\
    \ - numbers(j)) < minDiff) {\n            minDiff = abs(numbers(i) - numbers(j))\n\
    \            minDiffTuple = if (numbers(i) < numbers(j)) (numbers(i), numbers(j))\
    \ else (numbers(j), numbers(i))\n          }\n        }\n      }\n      minDiffTuple",
  "        var smallestDifference = Float.MaxValue\n        var closestElement = (0.0f,\
    \ 0.0f)\n        for (i <- 0 until numbers.length - 1) {\n            for (j <-\
    \ i + 1 until numbers.length) {\n                val difference = abs(numbers(i)\
    \ - numbers(j))\n                if (difference < smallestDifference) {\n    \
    \                closestElement = (min(numbers(i), numbers(j)), max(numbers(i),\
    \ numbers(j)))\n                    smallestDifference = difference\n        \
    \        }\n            }\n        }\n        closestElement", "        var closest1\
    \ : Float = numbers(0)\n        var closest2 : Float = numbers(1)\n        var\
    \ closestDist : Float = abs(closest1 - closest2)\n        for (i <- numbers.indices)\
    \ {\n            for (j <- (i + 1) until numbers.length) {\n                if\
    \ (abs(numbers(i) - numbers(j)) < closestDist) {\n                    closest1\
    \ = numbers(i)\n                    closest2 = numbers(j)\n                  \
    \  closestDist = abs(closest1 - closest2)\n                }\n            }\n\
    \        }\n        (closest1, closest2)", "        val minDelta = numbers.reduce((a,\
    \ b) => if(abs(a - b) < abs(minDelta)) abs(a - b) else minDelta)\n        val\
    \ minPair = numbers.combinations(2).toList.find(p => abs(p(0) - p(1)) == minDelta)\n\
    \        if(minPair.get(0) > minPair.get(1)) (minPair.get(1), minPair.get(0))\
    \ else (minPair.get(0), minPair.get(1))", "        val length = numbers.length\n\
    \        val sortedNumbers = numbers.sorted\n        var closestElements : Tuple2[Float,\
    \ Float] = null\n        for (i <- 1 until length) {\n            val a = sortedNumbers(i\
    \ - 1)\n            val b = sortedNumbers(i)\n            if (closestElements\
    \ == null) closestElements = (a, b)\n            else if (b - a < closestElements._2\
    \ - closestElements._1) closestElements = (a, b)\n        }\n        closestElements",
  "        var ret : Tuple2[Float, Float] = (numbers(0), numbers(1))\n        var\
    \ min : Float = abs(numbers(0) - numbers(1))\n        for (i <- 0 until numbers.length)\
    \ {\n            for (j <- 0 until numbers.length) {\n                if (i !=\
    \ j) {\n                    if (abs(numbers(i) - numbers(j)) < min) {\n      \
    \                  min = abs(numbers(i) - numbers(j))\n                      \
    \  ret = if (numbers(i) < numbers(j)) (numbers(i), numbers(j)) else (numbers(j),\
    \ numbers(i))\n                    }\n                }\n            }\n     \
    \   }\n        ret", "        var minPair = (numbers(0), numbers(1))\n       \
    \ var minDist = abs(numbers(0) - numbers(1))\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            val x = numbers(i)\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val y = numbers(j)\n                val dist = abs(x - y)\n\
    \                if (dist < minDist) {\n                    minDist = dist\n \
    \                   minPair = (x, y)\n                }\n            }\n     \
    \   }\n        if (minPair._1 > minPair._2) minPair = (minPair._2, minPair._1)\n\
    \        minPair", "        // Must have at least two numbers to compare\n   \
    \     if (numbers.length < 2) {\n            throw new RuntimeException(\"Supplied\
    \ list must have at least two numbers\")\n        }\n        // Put numbers in\
    \ order\n        val n = numbers.sorted\n        // Initialize tuple\n       \
    \ var t = Tuple2(n(0), n(1))\n        var distance = abs(n(0) - n(1))\n      \
    \  // Iterate over the list of numbers, starting at the second number\n      \
    \  for (i <- 1 until n.length) {\n            val d = abs(n(i) - n(i - 1))\n \
    \           if (d < distance) {\n                distance = d\n              \
    \  t = Tuple2(n(i - 1), n(i))\n            }\n        }\n        t", "       \
    \ var left : Float = numbers(0)\n        var right : Float = numbers(1)\n    \
    \    var minDiff : Float = abs(left - right)\n        for (i <- 0 until numbers.length)\
    \ {\n            for (j <- i + 1 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < minDiff) {\n                    minDiff = abs(numbers(i) - numbers(j))\n\
    \                    left = min(numbers(i), numbers(j))\n                    right\
    \ = max(numbers(i), numbers(j))\n                }\n            }\n        }\n\
    \        return (left, right)", "        var minDiff = Float.MaxValue\n      \
    \  var minPair = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length - 1) {\n\
    \            for (j <- i + 1 until numbers.length) {\n                val diff\
    \ = abs(numbers(i) - numbers(j))\n                if (diff < minDiff) {\n    \
    \                minDiff = diff\n                    minPair = (min(numbers(i),\
    \ numbers(j)), max(numbers(i), numbers(j)))\n                }\n            }\n\
    \        }\n        minPair", "      require(numbers.length >= 2)\n      var currentMin\
    \ = Float.MaxValue\n      var closestPair : Tuple2[Float, Float] = null\n    \
    \  for (i <- 0 until numbers.length - 1) {\n        val first = numbers(i)\n \
    \       for (j <- i + 1 until numbers.length) {\n          val second = numbers(j)\n\
    \          val min = abs(first - second)\n          if (min < currentMin) {\n\
    \            closestPair = (min(first, second), max(first, second))\n        \
    \    currentMin = min\n          }\n        }\n      }\n      closestPair", " \
    \       val numbersSorted = numbers.sorted\n        var closestElements : Tuple2[Float,\
    \ Float] = (numbersSorted(0), numbersSorted(1))\n        for (number <- numbersSorted)\
    \ {\n            if (numbersSorted.indexOf(number) != numbersSorted.length - 1)\
    \ {\n                if (abs(numbersSorted(numbersSorted.indexOf(number) + 1)\
    \ - number) < abs(closestElements._2 - closestElements._1)) {\n              \
    \      closestElements = (number, numbersSorted(numbersSorted.indexOf(number)\
    \ + 1))\n                }\n            }\n        }\n        closestElements",
  "        var closest = (numbers(0), numbers(1))\n        for (x <- numbers; y <-\
    \ numbers) {\n            if (abs(x - y) < abs(closest._1 - closest._2)) {\n \
    \               closest = (x, y)\n            }\n        }\n        closest",
  "        var closest = (numbers(0), numbers(1))\n        var distance = abs(numbers(0)\
    \ - numbers(1))\n        for (i <- 0 until numbers.length; j <- i + 1 until numbers.length)\
    \ {\n            val d = abs(numbers(i) - numbers(j))\n            if (d < distance)\
    \ {\n                closest = (numbers(i), numbers(j))\n                distance\
    \ = d\n            }\n        }\n        return closest", "        val minDiff\
    \ = (Float.MaxValue, -1, -1)\n        val len = numbers.length\n        for (i\
    \ <- 0 until len - 1) {\n            for (j <- i + 1 until len) {\n          \
    \      val diff = abs(numbers(i) - numbers(j))\n                if (diff < minDiff._1)\
    \ {\n                    val tup = if (numbers(i) < numbers(j)) (numbers(i), numbers(j))\
    \ else (numbers(j), numbers(i))\n                    minDiff.copy(diff, i, j)\n\
    \                }\n            }\n        }\n        Tuple2(numbers(minDiff._2),\
    \ numbers(minDiff._3))", "        val sorted = numbers.sorted\n        var closest\
    \ = sorted(0) -> sorted(1)\n        var closestDiff = abs(sorted(0) - sorted(1))\n\
    \        for (i <- 1 until sorted.length) {\n            val diff = abs(sorted(i)\
    \ - sorted(i - 1))\n            if (diff < closestDiff) {\n                closest\
    \ = sorted(i - 1) -> sorted(i)\n                closestDiff = diff\n         \
    \   }\n        }\n        closest", "        var min_difference : Float = Float.MaxValue\n\
    \        var min_pair : Tuple2[Float, Float] = null\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            for (j <- i + 1 until numbers.length) {\n\
    \                val difference = abs(numbers(i) - numbers(j))\n             \
    \   if (difference < min_difference) {\n                    min_difference = difference\n\
    \                    min_pair = (numbers(i), numbers(j))\n                }\n\
    \            }\n        }\n        return min_pair", "        var closest = (numbers(0),\
    \ numbers(1))\n        var distance = abs(numbers(0) - numbers(1))\n        for\
    \ (i <- 1 until numbers.length - 1) {\n            if (abs(numbers(i) - numbers(i\
    \ + 1)) < distance) {\n                closest = (numbers(i), numbers(i + 1))\n\
    \                distance = abs(numbers(i) - numbers(i + 1))\n            }\n\
    \        }\n        return closest", "        var closestPair : Tuple2[Float,\
    \ Float] = (numbers(0), numbers(1))\n        var closestPairDistance : Float =\
    \ abs(numbers(0) - numbers(1))\n        for (i <- numbers.indices) {\n       \
    \     for (j <- i + 1 until numbers.length) {\n                val currentDistance\
    \ : Float = abs(numbers(i) - numbers(j))\n                if (currentDistance\
    \ < closestPairDistance) {\n                    closestPair = (numbers(i), numbers(j))\n\
    \                    closestPairDistance = currentDistance\n                }\n\
    \            }\n        }\n        closestPair", "        def findClosestElementsRec(numbers\
    \ : List[Float], min : Float, result : Tuple2[Float, Float]) : Tuple2[Float, Float]\
    \ = {\n            if (numbers.length == 0) result\n            else {\n     \
    \           val diff = abs(numbers.head - numbers.tail.head)\n               \
    \ if (diff < min) findClosestElementsRec(numbers.tail, diff, (numbers.head, numbers.tail.head))\n\
    \                else findClosestElementsRec(numbers.tail, min, result)\n    \
    \        }\n        }\n        findClosestElementsRec(numbers, abs(numbers.head\
    \ - numbers.tail.head), (numbers.head, numbers.tail.head))", "        // Edge\
    \ case check for the supplied list\n        if (numbers.length < 2) {\n      \
    \      throw new Exception(\"Input list length must be at least two.\")\n    \
    \    }\n        // Transform the supplied list into a sorted list, then iterate\
    \ through the sorted list, saving the difference\n        // in each pair as a\
    \ new entry in a list, taking the absolute value of each new entry. Finally, take\
    \ the\n        // minimum value from the new list of differences and return it\
    \ along with the two corresponding entries in\n        // the original list.\n\
    \        val sortedList = numbers.sorted\n        val differences = Buffer[Float]()\n\
    \        var element1 = sortedList(0)\n        var element2 = sortedList(1)\n\
    \        var minDifference = 0.0f\n        for (i <- 0 until sortedList.length\
    \ - 1) {\n            differences += abs(sortedList(i) - sortedList(i + 1))\n\
    \            if (differences(i) < minDifference || i == 0) {\n               \
    \ minDifference = differences(i)\n                element1 = sortedList(i)\n \
    \               element2 = sortedList(i + 1)\n            }\n        }\n     \
    \   (element1, element2)", "        // The given list is of length at least two,\
    \ therefore this line will not cause an error.\n        val sortedNumbers = numbers.sorted\n\
    \        // Initialize the smallest difference and the two elements that cause\
    \ it to 0.\n        var smallestDifference = 0.0f\n        var firstElement =\
    \ 0.0f\n        var secondElement = 0.0f\n        for (i <- 0 until (sortedNumbers.length\
    \ - 1)) {\n            // The difference between the current elements.\n     \
    \       val difference = abs(sortedNumbers(i) - sortedNumbers(i + 1))\n      \
    \      // If the difference is smaller than the smallest difference.\n       \
    \     if (difference < smallestDifference || i == 0) {\n                // Save\
    \ the current difference as the smallest difference.\n                smallestDifference\
    \ = difference\n                // Save the current element as the first element.\n\
    \                firstElement = sortedNumbers(i)\n                // Save the\
    \ next element as the second element.\n                secondElement = sortedNumbers(i\
    \ + 1)\n            }\n        }\n        // Return the two closest elements in\
    \ order.\n        (firstElement, secondElement)", "      var minDiff = abs(numbers(0)\
    \ - numbers(1))\n      var closestNumbers = Tuple2(numbers(0), numbers(1))\n \
    \     for (i <- 0 until numbers.length - 1) {\n        for (j <- i + 1 until numbers.length)\
    \ {\n          val diff = abs(numbers(i) - numbers(j))\n          if (diff < minDiff)\
    \ {\n            minDiff = diff\n            closestNumbers = Tuple2(numbers(i),\
    \ numbers(j))\n          }\n        }\n      }\n      closestNumbers", "     \
    \   var closestDiff = Float.MaxValue\n        var closestPair = (Float.MaxValue,\
    \ Float.MaxValue)\n        for (i <- 0 until numbers.length) {\n            for\
    \ (j <- i + 1 until numbers.length) {\n                val diff = abs(numbers(i)\
    \ - numbers(j))\n                if (diff < closestDiff) {\n                 \
    \   closestDiff = diff\n                    closestPair = (min(numbers(i), numbers(j)),\
    \ max(numbers(i), numbers(j)))\n                }\n            }\n        }\n\
    \        closestPair", "        def _findClosestElements(numbers : List[Float],\
    \ minDiff : Float, minElements : Tuple2[Float, Float]) : Tuple2[Float, Float]\
    \ = {\n            if (numbers.isEmpty) minElements\n            else {\n    \
    \            val diff = abs(numbers.head - numbers.tail.head)\n              \
    \  if (diff == 0.0f) (numbers.head, numbers.tail.head)\n                else if\
    \ (diff < minDiff) _findClosestElements(numbers.tail, diff, (numbers.head, numbers.tail.head))\n\
    \                else _findClosestElements(numbers.tail, minDiff, minElements)\n\
    \            }\n        }\n        _findClosestElements(numbers, Float.MaxValue,\
    \ (numbers.head, numbers.tail.head))"]
stop_tokens:
- "\n    }\n"
