name: HumanEval_119_match_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of two strings, both strings consist of open\n    //\
  \ parentheses '(' or close parentheses ')' only.\n    // Your job is to check if\
  \ it is possible to concatenate the two strings in\n    // some order, that the\
  \ resulting string will be good.\n    // A string S is considered to be good if\
  \ and only if all parentheses in S\n    // are balanced. For example: the string\
  \ '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes'\
  \ if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n\
  \    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    //\
  \ >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst\
  \ : List[String]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
  ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
  , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
  , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
  , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
  , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\"\
  , \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\",\
  \ \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
  , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
  , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \"\
  )(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"\
  Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\"\
  )));\n    }\n\n}\n"
completions: ["        if (lst.map(isEvenNumParens).contains(false)) {\n         \
    \   \"No\"\n        } else {\n            if (isOdd(lst.map(countParens).sum))\
    \ {\n                \"No\"\n            } else {\n                \"Yes\"\n \
    \           }\n        }", "        val str = lst.reduceLeft(_ + _)\n        var\
    \ cnt = 0\n        for (i <- 0 until str.length) {\n            if (str(i) ==\
    \ '(') cnt += 1\n            else cnt -= 1\n            if (cnt < 0) return \"\
    No\"\n        }\n        return if (cnt == 0) \"Yes\" else \"No\"", "        val\
    \ l = lst(0)\n        val r = lst(1)\n        var count = 0\n        for (i <-\
    \ l) {\n            if (i == '(') {\n                count += 1\n            }\
    \ else {\n                count -= 1\n            }\n            if (count < 0)\
    \ {\n                return \"No\"\n            }\n        }\n        for (i <-\
    \ r) {\n            if (i == '(') {\n                count += 1\n            }\
    \ else {\n                count -= 1\n            }\n            if (count < 0)\
    \ {\n                return \"No\"\n            }\n        }\n        if (count\
    \ == 0) {\n            \"Yes\"\n        } else {\n            \"No\"\n       \
    \ }", "        val l1 = lst(0)\n        val l2 = lst(1)\n        def isGood(str\
    \ : String) : Boolean = {\n            if (str.isEmpty) true\n            else\
    \ if (str.head == '(') isGood(str.tail)\n            else if (str.head == ')')\
    \ {\n                if (str.tail.isEmpty) false\n                else isGood(str.tail)\n\
    \            }\n            else false\n        }\n        if (isGood(l1 + l2))\
    \ \"Yes\"\n        else if (isGood(l2 + l1)) \"Yes\"\n        else \"No\"", " \
    \       def isGood(str : String) : Boolean = {\n            var count = 0\n  \
    \          for (i <- 0 until str.length) {\n                val c = str(i)\n \
    \               if (c == '(') count += 1\n                else if (c == ')') count\
    \ -= 1\n                if (count < 0) return false\n            }\n         \
    \   return count == 0\n        }\n        if (isGood(lst(0)) && isGood(lst(1)))\
    \ return \"Yes\"\n        for (p <- 0 until lst(0).length) {\n            for\
    \ (q <- 0 until lst(1).length) {\n                if (isGood(lst(0).substring(0,\
    \ p) + lst(1).substring(0, q)) &&\n                    isGood(lst(0).substring(p,\
    \ lst(0).length) + lst(1).substring(q, lst(1).length))) return \"Yes\"\n     \
    \       }\n        }\n        return \"No\"", "        val lhs = lst(0)\n    \
    \    val rhs = lst(1)\n        val lhsLen = lhs.length\n        val rhsLen = rhs.length\n\
    \        if (lhsLen == 0 && rhsLen == 0) {\n            \"Yes\"\n        } else\
    \ if (lhsLen == 0) {\n            if (rhs.count('(' == _) == rhs.count(')' ==\
    \ _)) {\n                \"Yes\"\n            } else {\n                \"No\"\
    \n            }\n        } else if (rhsLen == 0) {\n            if (lhs.count('('\
    \ == _) == lhs.count(')' == _)) {\n                \"Yes\"\n            } else\
    \ {\n                \"No\"\n            }\n        } else {\n            val\
    \ lhsOpens = lhs.count('(' == _)\n            val lhsCloses = lhs.count(')' ==\
    \ _)\n            val rhsOpens = rhs.count('(' == _)\n            val rhsCloses\
    \ = rhs.count(')' == _)\n            if (lhsOpens > lhsCloses) {\n           \
    \     if (rhsOpens > rhsCloses) {\n                    \"No\"\n              \
    \  } else {\n                    if (lhsOpens > rhsCloses) {\n               \
    \         \"No\"\n                    } else {\n                        \"Yes\"\
    \n                    }\n                }\n            } else {\n           \
    \     if (rhsOpens > rhsCloses) {\n                    if (rhsOpens > lhsCloses)\
    \ {\n                        \"No\"\n                    } else {\n          \
    \              \"Yes\"\n                    }\n                } else {\n    \
    \                \"Yes\"\n                }\n            }\n        }", "    \
    \  def aux(str : String) : Int = {\n        if (str.length == 0) return 0\n  \
    \      else if (str.head == '(') 1 + aux(str.tail)\n        else if (str.head\
    \ == ')') -1 + aux(str.tail)\n        else throw new Exception(\"Invalid character\"\
    )\n      }\n      if (aux(lst(0)) == aux(lst(1))) \"Yes\" else \"No\"", "    \
    \    var c = 0\n        for (i <- 0 until lst(0).length) {\n            if (lst(0)(i)\
    \ == '(') c += 1\n            else c -= 1\n        }\n        for (i <- 0 until\
    \ lst(1).length) {\n            if (lst(1)(i) == '(') c += 1\n            else\
    \ c -= 1\n        }\n        if (c == 0) \"Yes\" else \"No\"", "        val (s1,\
    \ s2) = (lst(0), lst(1))\n        val balanced : Boolean = s1.foldLeft(0)((t,\
    \ b) => if (b == '(') t + 1 else t - 1) + s2.foldLeft(0)((t, b) => if (b == '(')\
    \ t + 1 else t - 1) == 0\n        if (balanced) \"Yes\" else \"No\"", "      \
    \  val s = lst.mkString\n        if (s.count(_ == '(') != s.count(_ == ')')) \"\
    No\"\n        else if (s == \"\") \"Yes\"\n        else {\n            if (s.take(1)\
    \ == \"(\") matchParens(lst.map(x => x.takeRight(x.length - 1)))\n           \
    \ else \"No\"\n        }", "        var stack : List[Char] = List()\n        for\
    \ (s <- lst) {\n            for (c <- s) {\n                if (c == '(') stack\
    \ = c :: stack\n                else if (c == ')') {\n                    if (stack.isEmpty)\
    \ return \"No\"\n                    else stack = stack.tail\n               \
    \ }\n            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"",
  "        val s = lst.foldLeft(\"\")(_ + _)\n        var count = 0\n        for (ch\
    \ <- s) {\n            if (ch == '(') count += 1\n            else if (ch == ')')\
    \ count -= 1\n            if (count < 0) return \"No\"\n        }\n        if\
    \ (count == 0) \"Yes\" else \"No\"", "        def matchParens_help(s : String)\
    \ : Boolean = {\n            var left = 0\n            for (ch <- s) if (ch ==\
    \ '(') left += 1 else left -= 1\n            if (left != 0) return false\n   \
    \         var depth = 0\n            for (ch <- s) {\n                if (ch ==\
    \ '(') depth += 1 else depth -= 1\n                if (depth < 0) return false\n\
    \            }\n            return true\n        }\n        if (matchParens_help(lst(0)\
    \ + lst(1))) return \"Yes\"\n        else if (matchParens_help(lst(1) + lst(0)))\
    \ return \"Yes\"\n        else return \"No\"", "        var left = 0\n       \
    \ var right = 0\n        for (i <- 0 until lst(0).length) if (lst(0)(i) == '(')\
    \ left += 1 else right += 1\n        for (i <- 0 until lst(1).length) if (lst(1)(i)\
    \ == '(') left += 1 else right += 1\n        if (left != right) return \"No\"\n\
    \        else return \"Yes\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n\
    \        val dict = new HashMap[Char, Char]\n        dict('(') = ')'\n       \
    \ dict(')') = '('\n        def process(s : String) : Boolean = {\n           \
    \ val open = \"(\"\n            val close = \")\"\n            val len = s.length\n\
    \            var cnt = 0\n            for (i <- 0 until len) {\n             \
    \   if (s(i) == open(0)) cnt += 1\n                else cnt -= 1\n           \
    \     if (cnt < 0) return false\n            }\n            if (cnt != 0) return\
    \ false\n            return true\n        }\n        if (process(s1 + s2)) return\
    \ \"Yes\"\n        if (process(s1 + s2.reverse)) return \"Yes\"\n        if (process(s2\
    \ + s1)) return \"Yes\"\n        if (process(s2 + s1.reverse)) return \"Yes\"\n\
    \        return \"No\"", "        val arr = lst.foldLeft(new ArrayBuffer[Char])((a,b)\
    \ => a ++= b.toCharArray).toArray\n        val stack = new ArrayStack[Char]\n\
    \        for (char <- arr) {\n            if (char == '(') stack.push(char)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          stack.pop\n            }\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"", "        val open = List('(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(')\n        val close = List(')', ')', ')', ')', ')', ')', ')',\
    \ ')', ')', ')')\n        def aux(lst : List[String], open : List[Char], close\
    \ : List[Char]) : String = {\n            lst match {\n                case List()\
    \ => if (open.length == close.length) \"Yes\" else \"No\"\n                case\
    \ p :: List() => aux(List(), open, close ::: p.toList)\n                case p\
    \ :: ps => aux(ps, open, close ::: p.toList)\n            }\n        }\n     \
    \   aux(lst, open, List())", "        val g = lst(0) + lst(1)\n        var count\
    \ = 0\n        for (i <- 0 until g.length) {\n            if (g(i) == '(') {\n\
    \                count += 1\n            } else {\n                count -= 1\n\
    \            }\n            if (count < 0) return \"No\"\n        }\n        if\
    \ (count == 0) \"Yes\" else \"No\"", "        val s = lst.foldLeft(\"\")(_ + _)\n\
    \        if (s == \"\") return \"Yes\"\n        // Handle by parity. For example,\
    \ if the number of '(' is even, then we\n        // should cut the even number\
    \ '(' into the first string and the remaining\n        // should be ')'.\n   \
    \     var map = Map[Char, Int]()\n        s.foreach(c => map(c) = map.getOrElse(c,\
    \ 0) + 1)\n        val parity = map('(') % 2\n        for (i <- parity to s.length\
    \ by 2) {\n            val x = s.substring(0, i)\n            val y = s.substring(i)\n\
    \            if (isGood(x) && isGood(y)) return \"Yes\"\n        }\n        \"\
    No\"", "        var s = lst(0) + lst(1)\n        val n = s.length\n        var\
    \ flag = false\n        for (i <- 0 until n) {\n            if (s(i) == '(') flag\
    \ = true\n            else if (s(i) == ')') flag = false\n            if (flag\
    \ == false) {\n                s = s.substring(0, i) + s.substring(i + 1)\n  \
    \              i -= 1\n            }\n        }\n        flag = false\n      \
    \  for (i <- n - 1 to 0 by -1) {\n            if (s(i) == ')') flag = true\n \
    \           else if (s(i) == '(') flag = false\n            if (flag == false)\
    \ {\n                s = s.substring(0, i) + s.substring(i + 1)\n            }\n\
    \        }\n        if (isGood(s)) \"Yes\" else \"No\"", "        val str1 = lst(0)\n\
    \        val str2 = lst(1)\n        def append(str1 : String, str2 : String) :\
    \ String = str1 + str2\n        def checkParens(str : String) : Boolean = {\n\
    \            val stack = Stack[Char]()\n            for (c <- str) {\n       \
    \         if (c == '(') stack.push(c)\n                else if (c == ')') {\n\
    \                    if (stack.isEmpty) return false\n                    stack.pop\n\
    \                }\n            }\n            return stack.isEmpty\n        }\n\
    \        if (checkParens(append(str1, str2))) \"Yes\"\n        else if (checkParens(append(str2,\
    \ str1))) \"Yes\"\n        else \"No\"", "        val l = lst(0).split(\"\");\n\
    \        val r = lst(1).split(\"\");\n        var open = 0;\n        for (ch <-\
    \ l) {\n            if (ch == \"(\") open += 1\n            else open -= 1\n \
    \       }\n        for (ch <- r) {\n            if (ch == \"(\") open += 1\n \
    \           else open -= 1\n        }\n        if (open < 0) return \"No\"\n \
    \       val openL = open;\n        open = 0;\n        var openR = 0;\n       \
    \ for (ch <- l) {\n            if (ch == \"(\") open += 1\n            else open\
    \ -= 1\n        }\n        openR = open;\n        open = 0;\n        for (ch <-\
    \ r) {\n            if (ch == \"(\") open += 1\n            else open -= 1\n \
    \       }\n        if (openR + open < 0) return \"No\"\n        if (openL + open\
    \ > 0) return \"No\"\n        \"Yes\"", "        val s1 = lst(0)\n        val\
    \ s2 = lst(1)\n        if (s1.length < s2.length) {\n            if (checkParens(s1\
    \ + s2)) \"Yes\" else \"No\"\n        } else {\n            if (checkParens(s2\
    \ + s1)) \"Yes\" else \"No\"\n        }", "        var s = \"\"\n        for (str\
    \ <- lst) s += str\n        var sum = 0\n        for (i <- 0 until s.length) {\n\
    \            if (s(i) == '(') sum += 1\n            else sum -= 1\n          \
    \  if (sum < 0) return \"No\"\n        }\n        if (sum == 0) \"Yes\" else \"\
    No\"", "        val s = lst.foldLeft(\"\")(_ + _)\n        val (a, b) = s.span(_\
    \ == '(')\n        val len = b.length\n        if (len > a.length) \"No\"\n  \
    \      else if (len == a.length) {\n            val c = b.span(_ == ')')\n   \
    \         if (c._1.length == c._2.length) \"Yes\"\n            else \"No\"\n \
    \       }\n        else \"Yes\"", "      var result = true\n      var lst2 = lst(0)\
    \ + lst(1)\n      for (i <- 1 to lst2.length()) {\n        var left = 0\n    \
    \    var right = 0\n        for (j <- 0 to i - 1) {\n          if (lst2(j) ==\
    \ '(') left += 1\n          else if (lst2(j) == ')') right += 1\n        }\n \
    \       for (j <- i to lst2.length() - 1) {\n          if (lst2(j) == '(') left\
    \ -= 1\n          else if (lst2(j) == ')') right -= 1\n        }\n        if (left\
    \ < 0 || right < 0) result = false\n      }\n      if (result) \"Yes\" else \"\
    No\"", "        val input : String = lst.mkString(\"\")\n        if (isGood(input))\
    \ \"Yes\" else \"No\"", "        // Solution 1:\n        // This problem can be\
    \ solved by examining a property of balanced\n        // parentheses: each pair\
    \ of parentheses has to be around a non-zero\n        // length string. So if\
    \ we concatenate all the strings into one big\n        // string, we can determine\
    \ if it is possible to make a good string by\n        // checking if the number\
    \ of open parentheses is equal to the number of\n        // close parentheses.\n\
    \        // This solution is O(n) where n is the total number of parentheses in\n\
    \        // the two strings.\n        // val s = lst.mkString\n        // val\
    \ openCount = s.count(_ == '(')\n        // val closeCount = s.count(_ == ')')\n\
    \        // if (openCount == closeCount) {\n        //     \"Yes\"\n        //\
    \ } else {\n        //     \"No\"\n        // }\n        // Solution 2:\n    \
    \    // A closed parentheses must be closed by an open parentheses before it.\n\
    \        // So if we examine the two strings left to right, we can check if it\
    \ is\n        // possible to make a good string by checking if the number of open\n\
    \        // parentheses minus the number of close parentheses is non-negative\
    \ at\n        // each step.\n        // This solution is O(m + n) where m and\
    \ n are the number of parentheses\n        // in the two strings respectively.\n\
    \        // val s1 = lst(0)\n        // val s2 = lst(1)\n        // val leftOpen\
    \ = s1.count(_ == '(')\n        // val leftClose = s1.count(_ == ')')\n      \
    \  // val rightOpen = s2.count(_ == '(')\n        // val rightClose = s2.count(_\
    \ == ')')\n        // if (leftOpen - leftClose + rightOpen >= rightClose) {\n\
    \        //     \"Yes\"\n        // } else {\n        //     \"No\"\n        //\
    \ }\n        // Solution 3:\n        // Alternative solution to solution 2.\n\
    \        // This solution is O(m + n) where m and n are the number of parentheses\n\
    \        // in the two strings respectively.\n        // val s1 = lst(0)\n   \
    \     // val s2 = lst(1)\n        // val leftOpen", "        // We want to check\
    \ if it is possible to concatenate two strings, both\n        // consisting of\
    \ open and close parentheses, in some order, so that the\n        // resulting\
    \ string will be good. We can think of this as a graph\n        // problem: if\
    \ we have some two strings, we can think of their concatenation\n        // as\
    \ a concatenation of two nodes in a graph, where the first node is\n        //\
    \ the first string and the second node is the second string. Each node is\n  \
    \      // connected to its neighbors. Then, we want to traverse the graph from\n\
    \        // left to right and check that each node is a good substring (that is,\n\
    \        // all parentheses are balanced).\n        // Once we have constructed\
    \ the graph, we can simply traverse it from\n        // left to right, where each\
    \ node is a string, and check that all nodes\n        // are good strings.\n \
    \       // Notice that there are only 4 possible strings:\n        // ()) or )(\
    \ or (() or ()(\n        // There are only two possible types of nodes: either\
    \ a concatenation of\n        // two strings or the concatenation of a string\
    \ and a single parenthesis.\n        // Thus, we don't need to store the nodes;\
    \ we can directly check that\n        // their concatenation is a good string.\n\
    \        // The possible strings are:\n        // Empty string: \"\";\n      \
    \  // Strings with one parenthesis: \"(\" and \")\";\n        // Strings with\
    \ two parentheses: \"()\", \")(\", \"((\", \"))\", \"(()\", \"())\",\n       \
    \ // \"(())\", \"()()\", \")((\", \")()\", \")(()\", \"())(\".\n        // Strings\
    \ with three parentheses: \")((\", \"))(\", \")(((\", \"))((\", \")(()\",\n  \
    \      // \"))()\", \")(())\", \"))(()\", \")(()(\", \"))()(\", \")(()()\", \"\
    ))()()\", \"(()(\",\n        // \"()((\", \"(()((\", \"()(((\", \"(()()\", \"\
    ()()(\", \"(()())\", \"()()()\", \"((()\",\n        // \"((()(\", \"((())\", \"\
    ((()()\", \"()(()\", \"()(()(\", \"", "        (lst(0).replace(\"(\", \"\").length,\
    \ lst(1).replace(\")\", \"\").length) match {\n            case (0, 0) => \"Yes\"\
    \n            case (0, _) => \"No\"\n            case (_, 0) => \"No\"\n     \
    \       case _ => \"Yes\"\n        }", "        if (lst.head.length == 0) return\
    \ \"Yes\"\n        if (lst.last.length == 0) return \"Yes\"\n        if (lst.head.length\
    \ == 1 && lst.last.length == 1) return \"No\"\n        if (lst.head.length ==\
    \ 1) return matchParens(List(lst.last.tail, lst.last.head + lst.last.tail))\n\
    \        if (lst.last.length == 1) return matchParens(List(lst.head.head + lst.head.tail,\
    \ lst.head.tail))\n        if (lst.head.head == '(' && lst.last.last == ')') return\
    \ matchParens(List(lst.head.tail, lst.last.init))\n        matchParens(List(lst.head.head\
    \ + lst.head.tail, lst.last))", "        val parenthesis = lst.mkString\n    \
    \    var stack = new Stack[Char]\n        for (ch <- parenthesis) {\n        \
    \    if (ch == '(') stack.push(ch)\n            else if (stack.isEmpty) return\
    \ \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"", "        val open = '('\n        val close = ')'\n       \
    \ val s = lst.head\n        val t = lst.tail.head\n        val sRev = s.reverse\n\
    \        val tRev = t.reverse\n        val len = s.length + t.length\n       \
    \ val mod = pow(10, 9).toInt + 7\n        val K = 33;\n        val base = Vector(0,\
    \ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181,\
    \ 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040,\
    \ 1346269, 2178309, 3524578)\n        val pw = Array.fill(len + 1)(0L)\n     \
    \   val c = Array.fill(len + 1)(0L)\n        def power(a : Long, b : Long) : Long\
    \ = {\n            if (b == 0) 1\n            else if (b == 1) a\n           \
    \ else {\n                var x = power(a, b / 2)\n                x = (x * x)\
    \ % mod\n                if (b % 2 == 1) x = (x * a) % mod\n                x\n\
    \            }\n        }\n        def precompute() {\n            pw(0) = 1\n\
    \            for (i <- 1 to len) pw(i) = (pw(i - 1) * K) % mod\n            var\
    \ sum = 0L\n            for (i <- 0 to len - 1) {\n                if (tRev(i)\
    \ == open) sum += 1\n                else if (tRev(i) == close) sum -= 1\n   \
    \             if (sum < 0) c(i + 1) = 1\n            }\n            c(0) = if\
    \ (sum != 0) 1 else 0\n            var j = len - 1\n            while (j >= 0)\
    \ {\n                if (c(j + 1) == 1) c(j) = 1\n                else if (tRev(j)\
    \ == close) c(j) = c(j + 1)\n                else if (tRev(j", "        val str\
    \ = lst.mkString(\"\").toList\n        if (str.size % 2 == 1) return \"No\"\n\
    \        val stack = new Stack[Char]\n        for (c <- str) {\n            if\
    \ (c == '(') stack.push(c)\n            else if (stack.isEmpty) return \"No\"\n\
    \            else stack.pop\n        }\n        if (stack.isEmpty) \"Yes\" else\
    \ \"No\"", "        val s = lst.mkString(\"\")\n        val stk = new Stack[Char]\n\
    \        for (c <- s) {\n            if (c == '(') {\n                stk.push(c)\n\
    \            } else {\n                if (stk.isEmpty) return \"No\"\n      \
    \          stk.pop\n            }\n        }\n        if (stk.isEmpty) \"Yes\"\
    \ else \"No\"", "        (lst(0).count(_ == '(') + lst(1).count(_ == '(')) ==\
    \ (lst(0).count(_ == ')') + lst(1).count(_ == ')')) match {\n            case\
    \ true => \"Yes\"\n            case false => \"No\"\n        }", "        val\
    \ lst1 = lst(0)\n        val lst2 = lst(1)\n        val lstp = lst1.toList ++\
    \ lst2.toList\n        val lst_stack = new Stack[Char]\n        lstp.foreach(ch\
    \ => {\n            if (ch == '(') lst_stack.push(ch)\n            else if (ch\
    \ == ')') {\n                if (lst_stack.isEmpty) return \"No\"\n          \
    \      lst_stack.pop\n            }\n        })\n        if (lst_stack.isEmpty)\
    \ \"Yes\"\n        else \"No\"", "      val s = lst.mkString\n      val num =\
    \ s.foldLeft(0) { (acc, c) =>\n        if (c == '(') acc + 1\n        else if\
    \ (c == ')') acc - 1\n        else acc\n      }\n      if (num == 0) \"Yes\" else\
    \ \"No\"", "        val lst1 = lst(0)\n        val lst2 = lst(1)\n        var\
    \ lst1Count = 0\n        var lst2Count = 0\n        var notGood = false\n    \
    \    lst1.foreach(c => {\n            if (c == '(') {\n                lst1Count\
    \ += 1\n            } else {\n                lst1Count -= 1\n            }\n\
    \            if (lst1Count < 0) {\n                notGood = true\n          \
    \  }\n        })\n        lst2.foreach(c => {\n            if (c == '(') {\n \
    \               lst2Count += 1\n            } else {\n                lst2Count\
    \ -= 1\n            }\n            if (lst2Count < 0) {\n                notGood\
    \ = true\n            }\n        })\n        if (notGood || lst1Count != lst2Count)\
    \ {\n            \"No\"\n        } else {\n            \"Yes\"\n        }", " \
    \       val open  = lst(0).filter(x => x == '(').length\n        val close = lst(1).filter(x\
    \ => x == ')').length\n        if (open == close) \"Yes\" else \"No\"", "    \
    \    val s1 = lst(0)\n        val s2 = lst(1)\n        val s3 = s1 + s2\n    \
    \    val p = new Stack[Char]\n        for (i <- 0 until s3.length) {\n       \
    \     if (s3(i) == '(') p.push('(')\n            else if (s3(i) == ')') {\n  \
    \              if (p.isEmpty) return \"No\"\n                else p.pop\n    \
    \        }\n        }\n        if (p.isEmpty) \"Yes\" else \"No\"", "        val\
    \ t = lst.map(_.count(_ == '(') - _.count(_ == ')')).sum\n        if (t == 0)\
    \ \"Yes\" else \"No\"", "        val result = lst.foldLeft(List[Char]())((acc,\
    \ x) => {\n            acc ::: x.toList\n        })\n        if (result.count(_\
    \ == '(') == result.count(_ == ')')) \"Yes\" else \"No\"", "        val concat\
    \ = lst.foldLeft(\"\")((a,b) => a + b)\n        if (concat.count(_ == '(') ==\
    \ concat.count(_ == ')')) \"Yes\" else \"No\"", "        def countParens(str :\
    \ String) : (Int, Int) = str.foldLeft((0, 0)) { case ((numOpen, numClose), c)\
    \ => \n            if (c == '(') (numOpen + 1, numClose)\n            else (numOpen,\
    \ numClose + 1)\n        }\n        val (numOpen1, numClose1) = countParens(lst(0))\n\
    \        val (numOpen2, numClose2) = countParens(lst(1))\n        if (numOpen1\
    \ > numClose2 || numOpen2 > numClose1) return \"No\"\n        if (numOpen1 ==\
    \ numClose2 && numOpen2 == numClose1) return \"Yes\"\n        \"Yes\"", "    \
    \    val starts = ArrayBuffer[Int]()\n        val stack = ArrayBuffer[Int]()\n\
    \        def match2(idx : Int, c : Char) : Boolean = {\n            if (c == '(')\
    \ {\n                stack += idx\n                return true\n            }\n\
    \            if (stack.length > 0) {\n                stack.remove(stack.length\
    \ - 1)\n                return true\n            }\n            return false\n\
    \        }\n        def match1(idx : Int, c : Char) : Boolean = {\n          \
    \  if (c == ')') {\n                starts += idx\n                return true\n\
    \            }\n            return false\n        }\n        for (i <- 0 until\
    \ lst(0).length) {\n            if (!match2(i, lst(0)(i))) return \"No\"\n   \
    \     }\n        for (i <- 0 until lst(1).length) {\n            if (!match1(i,\
    \ lst(1)(i))) return \"No\"\n        }\n        if (starts.length != stack.length)\
    \ return \"No\"\n        var i = 0\n        while (i < starts.length) {\n    \
    \        if (starts(i) < stack(i)) return \"No\"\n            i += 1\n       \
    \ }\n        return \"Yes\"", "    \tval l = lst(0)\n    \tval r = lst(1)\n  \
    \  \tvar i = 0\n    \tvar j = 0\n    \twhile (i < l.length) {\n    \t\tif (l(i)\
    \ == '(') j += 1\n    \t\telse j -= 1\n    \t\tif (j < 0) return \"No\"\n    \t\
    \ti += 1\n    \t}\n    \ti = 0\n    \twhile (i < r.length) {\n    \t\tif (r(i)\
    \ == '(') j += 1\n    \t\telse j -= 1\n    \t\tif (j < 0) return \"No\"\n    \t\
    \ti += 1\n    \t}\n    \tif (j == 0) \"Yes\" else \"No\"", "        // Since a\
    \ good string must have equal number of open and close\n        // parentheses,\
    \ the string formed by concatenating the two strings is\n        // good if and\
    \ only if the number of close parentheses in the string\n        // exceeds the\
    \ number of open parentheses in the string.\n        val result = lst.head.count(_\
    \ == ')') - lst.head.count(_ == '(')\n        val result2 = lst.tail.head.count(_\
    \ == ')') - lst.tail.head.count(_ == '(')\n        if (result > 0 && result2 >\
    \ 0) \"Yes\" else \"No\"", "        if (lst.head.length % 2 == 0) {\n        \
    \    val firstHalf = lst.head.substring(0, lst.head.length / 2)\n            val\
    \ secondHalf = lst.head.substring(lst.head.length / 2)\n            if (checkParens(firstHalf\
    \ + lst.last) || checkParens(secondHalf + lst.last)) \"Yes\" else \"No\"\n   \
    \     } else \"No\"", "        // if (lst.length != 2) return \"No\"\n       \
    \ val open = lst(0).count(_ == '(')\n        val close = lst(1).count(_ == ')')\n\
    \        if (open == close) \"Yes\" else \"No\"", "        val s = lst.map(s =>\
    \ (s.filter(c => c == '(') + s.filter(c => c == ')')).mkString).mkString\n   \
    \     var p = 0\n        for (i <- 0 until s.length) {\n            if (s(i) ==\
    \ '(') p += 1\n            else p -= 1\n            if (p < 0) return \"No\"\n\
    \        }\n        if (p == 0) \"Yes\" else \"No\"", "        val s = lst.reduce(_\
    \ + _)\n        val n = s.length\n        def f(i : Int, c : Int) : Boolean =\
    \ {\n            if (i == n) c == 0\n            else if (s(i) == '(') f(i + 1,\
    \ c + 1)\n            else if (c > 0) f(i + 1, c - 1)\n            else false\n\
    \        }\n        if (f(0, 0)) \"Yes\" else \"No\"", "        var flag = false\n\
    \        var a = lst(0).toList\n        var b = lst(1).toList\n        while (!flag\
    \ && !a.isEmpty && !b.isEmpty) {\n            if (a.last == '(' && b.head == ')')\
    \ {\n                a = a.dropRight(1)\n                b = b.drop(1)\n     \
    \       } else if (a.last == ')' && b.head == '(') {\n                a = a.dropRight(1)\n\
    \                b = b.drop(1)\n            } else if (a.last == ')' && b.head\
    \ == ')') {\n                flag = true\n            } else if (a.last == '('\
    \ && b.head == '(') {\n                flag = true\n            } else {\n   \
    \             println(\"Error\")\n            }\n        }\n        if (flag)\
    \ {\n            return \"No\"\n        } else {\n            return \"Yes\"\n\
    \        }", "        val (left, right) = (lst(0), lst(1))\n        def recur(t\
    \ : (String, String)) : Boolean = {\n            if (t._1.length == 0 && t._2.length\
    \ == 0) true\n            else if (t._1.length == 0 && t._2.length == 1) false\n\
    \            else if (t._1.head == '(' && t._2.head == ')') recur((t._1.tail,\
    \ t._2.tail))\n            else if (t._1.head == '(' && t._2.head == '(') recur((t._1.tail,\
    \ t._2))\n            else if (t._1.head == ')' && t._2.head == ')') recur((t._1,\
    \ t._2.tail))\n            else if (t._1.head == ')' && t._2.head == '(') recur((t._1,\
    \ t._2.tail))\n            else false\n        }\n        if (recur((left, right)))\
    \ \"Yes\" else \"No\"", "        val lefts = lst(0).filter(_ == '(').length\n\
    \        val rights = lst(1).filter(_ == ')').length\n        if (lefts == rights)\
    \ \"Yes\" else \"No\"", "        if (isGood(lst(0)) && isGood(lst(1))) {\n   \
    \         return \"Yes\"\n        }\n        else if (isGood(lst(0) + lst(1)))\
    \ {\n            return \"Yes\"\n        }\n        else if (isGood(lst(1) + lst(0)))\
    \ {\n            return \"Yes\"\n        }\n        else {\n            return\
    \ \"No\"\n        }", "        def check(str : String) : Boolean = {\n       \
    \     var bal = 0\n            for (c <- str) {\n                if (c == '(')\
    \ bal += 1\n                else if (c == ')') bal -= 1\n                if (bal\
    \ < 0) return false\n            }\n            bal == 0\n        }\n        if\
    \ (check(lst(0)) && check(lst(1))) \"Yes\"\n        else if (check(lst(0) + lst(1)))\
    \ \"Yes\"\n        else if (check(lst(1) + lst(0))) \"Yes\"\n        else \"No\"",
  "        if (lst.head == \"()\")\n            return \"Yes\"\n        if (lst.head\
    \ == \")\")\n            return \"No\"\n        if (lst.tail.head == \"()\")\n\
    \            return \"Yes\"\n        if (lst.tail.head == \"(\")\n           \
    \ return \"Yes\"\n        \"No\"", "        val (x, y) = (lst(0), lst(1))\n  \
    \      if (x == \"\") return if (y == \"\") \"Yes\" else \"No\"\n        if (y\
    \ == \"\") return if (x == \"\") \"Yes\" else \"No\"\n        if (x.length ==\
    \ 1 && y.length == 1) return if (x == \"(\" && y == \")\") \"Yes\" else \"No\"\
    \n        if (x.length == 1) return if (x == \"(\" && y.last == ')') \"Yes\" else\
    \ \"No\"\n        if (y.length == 1) return if (y == \")\" && x.head == '(') \"\
    Yes\" else \"No\"\n        val dp = Array.ofDim[Boolean](x.length + 1, y.length\
    \ + 1)\n        for (i <- 0 to x.length) dp(i)(0) = true\n        for (j <- 0\
    \ to y.length) dp(0)(j) = true\n        for (i <- 1 to x.length) {\n         \
    \   for (j <- 1 to y.length) {\n                if (dp(i - 1)(j) && x(i - 1) ==\
    \ '(') dp(i)(j) = true\n                if (dp(i)(j - 1) && y(j - 1) == ')') dp(i)(j)\
    \ = true\n                if (dp(i - 1)(j - 1) && (x(i - 1) == '(' && y(j - 1)\
    \ == ')')) dp(i)(j) = true\n            }\n        }\n        return if (dp(x.length)(y.length))\
    \ \"Yes\" else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n  \
    \      var count = 0\n        for (i <- 0 until s1.length()) {\n            if\
    \ (s1(i) == '(') count += 1\n            else count -= 1\n        }\n        for\
    \ (i <- 0 until s2.length()) {\n            if (s2(i) == '(') count += 1\n   \
    \         else count -= 1\n        }\n        if (count != 0) return \"No\"\n\
    \        count = 0\n        for (i <- 0 until s1.length()) {\n            if (s1(i)\
    \ == '(') count += 1\n            else count -= 1\n            if (count < 0)\
    \ return \"No\"\n        }\n        for (i <- 0 until s2.length()) {\n       \
    \     if (s2(i) == '(') count += 1\n            else count -= 1\n            if\
    \ (count < 0) return \"No\"\n        }\n        \"Yes\"", "        def extract(str\
    \ : String) : (String, String) = {\n            val first = str.indexOf('(')\n\
    \            val last = str.lastIndexOf(')')\n            (str.slice(0, first),\
    \ str.slice(last + 1, str.length))\n        }\n        val (lhs, rhs) = (extract(lst(0)),\
    \ extract(lst(1)))\n        if (lhs._1.length != rhs._2.length) \"No\"\n     \
    \   else if (lhs._2.length != rhs._1.length) \"No\"\n        else {\n        \
    \    def loop(s : String) : Boolean = {\n                if (s.length == 0) true\n\
    \                else if (s.head == '(' && s.last == ')') loop(s.slice(1, s.length\
    \ - 1))\n                else false\n            }\n            if (loop(lhs._2\
    \ + rhs._1)) \"Yes\"\n            else \"No\"\n        }", "        val x = lst(0)\n\
    \        val y = lst(1)\n        if (x.length == 0 && y.length == 0) return \"\
    Yes\"\n        if (x.length == 0 && y.length > 0) return \"No\"\n        if (x.length\
    \ > 0 && y.length == 0) return \"No\"\n        val xe = x.head\n        val ye\
    \ = y.head\n        if (xe == ')' && ye == ')') return \"No\"\n        if (xe\
    \ == '(' && ye == '(') {\n            val restx = x.drop(1)\n            val resty\
    \ = y.drop(1)\n            return matchParens(List(restx, resty))\n        }\n\
    \        if (xe == ')' && ye == '(') {\n            val restx = x.drop(1)\n  \
    \          val resty = y.drop(1)\n            return matchParens(List(restx, resty))\n\
    \        }\n        if (xe == '(' && ye == ')') {\n            val restx = x.drop(1)\n\
    \            val resty = y.drop(1)\n            return matchParens(List(restx,\
    \ resty))\n        }\n        return \"\"", "        def helper(lst : List[String],\
    \ count : Int) : Boolean = lst match {\n            case Nil => count == 0\n \
    \           case h :: t => {\n                if (h == \"(\") helper(t, count\
    \ + 1)\n                else if (h == \")\") {\n                    if (count\
    \ > 0) helper(t, count - 1)\n                    else false\n                }\n\
    \                else false\n            }\n        }\n        val str = lst.mkString\n\
    \        if (helper(str.toList, 0)) \"Yes\" else \"No\"", "        if (lst.isEmpty)\
    \ return \"Yes\"\n        val s = lst.head\n        val res = ListBuffer[Int]()\n\
    \        for (i <- 0 until s.length) {\n            s(i) match {\n           \
    \     case '(' => res += i\n                case ')' => if (res.isEmpty) return\
    \ \"No\" else res.remove(res.length - 1)\n            }\n        }\n        if\
    \ (res.isEmpty) \"Yes\" else \"No\"", "      var arr : Array[Char] = lst.flatten.toArray\n\
    \      var count = 0\n      for (i <- 0 until arr.length) {\n        if (arr(i)\
    \ == '(') count += 1\n        else count -= 1\n        if (count < 0) return \"\
    No\"\n      }\n      if (count == 0) \"Yes\" else \"No\"", "        val s1 = lst(0)\n\
    \        val s2 = lst(1)\n        val t1 = s1.split(\"\").filter(_ != \"\")\n\
    \        val t2 = s2.split(\"\").filter(_ != \"\")\n        val num = s1.size\n\
    \        def loop(t1 : List[String], t2 : List[String], l : Int, r : Int) : Boolean\
    \ = {\n            if (l == num && r == num) true\n            else if (l > num\
    \ || r > num) false\n            else if (t1.size == 0 && t2.size == 0) false\n\
    \            else if (t1.size == 0) loop(t1, t2.tail, l, r + 1)\n            else\
    \ if (t2.size == 0) loop(t1.tail, t2, l + 1, r)\n            else {\n        \
    \        if (t1.head == \"(\" && t2.head == \")\") loop(t1.tail, t2.tail, l +\
    \ 1, r + 1)\n                else if (t1.head == \"(\" && t2.head == \"(\") loop(t1.tail,\
    \ t2, l + 1, r)\n                else if (t1.head == \")\" && t2.head == \")\"\
    ) loop(t1, t2.tail, l, r + 1)\n                else if (t1.head == \")\" && t2.head\
    \ == \"(\") loop(t1, t2.tail, l, r)\n                else false\n            }\n\
    \        }\n        if (loop(t1.toList, t2.toList, 0, 0)) \"Yes\" else \"No\"",
  "        val lst1 = lst(0).split(\"\")\n        val lst2 = lst(1).split(\"\")\n\
    \        if (checkParens(lst1 ++ lst2)) \"Yes\" else \"No\"", "    \tval s = new\
    \ Stack[String]\n    \tfor (i <- 0 until lst.length) {\n    \t\tval str = lst(i)\n\
    \    \t\tfor (j <- 0 until str.length) {\n    \t\t\tval c = str(j)\n    \t\t\t\
    if (c == '(') s.push(c.toString)\n    \t\t\telse {\n    \t\t\t\tif (s.isEmpty)\
    \ return \"No\"\n    \t\t\t\ts.pop\n    \t\t\t}\n    \t\t}\n    \t}\n    \tif\
    \ (s.isEmpty) \"Yes\" else \"No\"", "        def solve(str : String) : Boolean\
    \ = {\n            val n = str.length;\n            var cnt = 0;\n           \
    \ for (i <- 0 until n) {\n                if (str(i) == '(') cnt += 1\n      \
    \          else cnt -= 1\n                if (cnt < 0) return false\n        \
    \    }\n            return cnt == 0\n        }\n        if (solve(lst(0) + lst(1)))\
    \ \"Yes\" else \"No\"", "        val s = lst.mkString(\"\")\n        val o = s.count(c\
    \ => c == '(')\n        val c = s.count(c => c == ')')\n        if (o == c) {\n\
    \            \"Yes\"\n        } else {\n            \"No\"\n        }", "    \
    \    val str1 = lst(0)\n        val str2 = lst(1)\n        var res = \"Yes\"\n\
    \        if (str1(0) == ')') res = \"No\"\n        else if (str2(0) == '(') res\
    \ = \"No\"\n        return res", "        var fst = lst(0)\n        var snd =\
    \ lst(1)\n        for (i <- 0 until fst.length) {\n            for (j <- 0 until\
    \ snd.length) {\n                if (isGood(fst.substring(0, i) + snd.substring(0,\
    \ j))) {\n                    return \"Yes\"\n                }\n            }\n\
    \        }\n        return \"No\"", "        val s = lst.reduce(_ + _)\n     \
    \   var st = new Stack[Char]\n        for (i <- 0 until s.length) {\n        \
    \    val c = s(i)\n            if (c == '(') {\n                st.push(c)\n \
    \           } else {\n                if (st.isEmpty) return \"No\"\n        \
    \        st.pop\n            }\n        }\n        if (st.isEmpty) \"Yes\" else\
    \ \"No\"", "        val open = '('\n        val close = ')'\n        def sub(x\
    \ : List[Char]) : Int = {\n            if (x.isEmpty) 0\n            else if (x.head\
    \ == open) 1 + sub(x.tail)\n            else if (x.head == close) -1 + sub(x.tail)\n\
    \            else throw new IllegalArgumentException\n        }\n        def fix(x\
    \ : List[Char]) : List[Char] = {\n            if (x.isEmpty) Nil\n           \
    \ else if (x.head == open) x.head :: fix(x.tail)\n            else if (x.head\
    \ == close) x.head :: fix(x.tail)\n            else throw new IllegalArgumentException\n\
    \        }\n        sub(fix(lst.head.toList)) + sub(fix(lst.last.toList)) match\
    \ {\n            case 0 => \"Yes\"\n            case _ => \"No\"\n        }",
  "        val st1 = new Stack[Char]\n        val st2 = new Stack[Char]\n        lst(0).foreach\
    \ { x => if (x == '(') st1.push(x) else st2.push(x) }\n        lst(1).foreach\
    \ { x => if (x == '(') st1.push(x) else st2.push(x) }\n        if (st1.size ==\
    \ st2.size) \"Yes\" else \"No\"", "      var map : HashMap[String, Int] = HashMap[String,\
    \ Int]()\n      for (s <- lst) {\n        for (i <- 0 until s.length) {\n    \
    \      if (s(i) == '(') {\n            if (map.contains(\"open\")) map(\"open\"\
    ) += 1\n            else map(\"open\") = 1\n          } else {\n            if\
    \ (map.contains(\"close\")) map(\"close\") += 1\n            else map(\"close\"\
    ) = 1\n          }\n        }\n      }\n      val result = if (map(\"open\") ==\
    \ map(\"close\")) \"Yes\" else \"No\"\n      result", "        if (lst.length\
    \ != 2) return \"No\"\n        val a = lst(0)\n        val b = lst(1)\n      \
    \  if (a.length == 0) return if (b.length == 0) \"Yes\" else \"No\"\n        if\
    \ (b.length == 0) return if (a.length == 0) \"Yes\" else \"No\"\n        // ')'\
    \ in a, '(', in b\n        if (a.filter(c => c == ')').length > 0 && b.filter(c\
    \ => c == '(').length > 0) {\n            val a1 = a.filter(c => c == ')')\n \
    \           val b1 = b.filter(c => c == '(')\n            val c1 = if (a1.length\
    \ == b1.length) \"Yes\" else \"No\"\n            return c1\n        }\n      \
    \  val c2 = if (a.length == b.length) \"Yes\" else \"No\"\n        return c2",
  "        val x = lst(0)\n        val y = lst(1)\n        if (isGood(x + y)) return\
    \ \"Yes\"\n        if (isGood(y + x)) return \"Yes\"\n        return \"No\"",
  "        val s1 = lst(0).toCharArray.toList\n        val s2 = lst(1).toCharArray.toList\n\
    \        val left = s1.filter(c => c == '(').length\n        val right = s1.filter(c\
    \ => c == ')').length\n        if (left != right) {\n            return \"No\"\
    \n        }\n        val left2 = s2.filter(c => c == '(').length\n        val\
    \ right2 = s2.filter(c => c == ')').length\n        if (left2 != right2) {\n \
    \           return \"No\"\n        }\n        if (left + left2 == right + right2)\
    \ {\n            return \"Yes\"\n        }\n        return \"No\"", "        def\
    \ isGood(str : String) : Boolean = {\n            var stack = new Stack[Char]\n\
    \            for (c <- str) {\n                if (c == '(') stack.push(c)\n \
    \               else {\n                    if (stack.isEmpty) return false\n\
    \                    else stack.pop\n                }\n            }\n      \
    \      return stack.isEmpty\n        }\n        if (isGood(lst(0)) && isGood(lst(1)))\
    \ \"Yes\"\n        else \"No\"", "        val s = lst.reduceLeft((a, b) => a +\
    \ b)\n        var stack = Stack[Char]()\n        for (c <- s) {\n            if\
    \ (c == '(') stack.push(c)\n            else if (stack.isEmpty) return \"No\"\n\
    \            else stack.pop\n        }\n        if (stack.isEmpty) \"Yes\" else\
    \ \"No\"", "        var s = lst(0) + lst(1)\n        var d = 0\n        for (c\
    \ <- s) {\n            if (c == '(') d += 1\n            else if (c == ')') d\
    \ -= 1\n            if (d < 0) return \"No\"\n        }\n        if (d == 0) \"\
    Yes\" else \"No\"", "        val (a, b) = (lst(0), lst(1))\n        val s = new\
    \ Stack[Char]\n        for (c <- a) {\n            if (c == '(') s.push(c)\n \
    \           else if (s.isEmpty) return \"No\"\n            else s.pop\n      \
    \  }\n        for (c <- b) {\n            if (c == '(') s.push(c)\n          \
    \  else if (s.isEmpty) return \"No\"\n            else s.pop\n        }\n    \
    \    if (s.isEmpty) \"Yes\" else \"No\"", "        // Count the number of parentheses\
    \ in each string.\n        // If the number of parentheses in the two strings\
    \ is not equal,\n        // return 'No'.\n        // Else, add the parentheses\
    \ in the first string to a queue and\n        // check the second string.\n  \
    \      // If the number of open parentheses is greater than the number of\n  \
    \      // close parentheses, return 'No'.\n        val s1 = lst(0)\n        val\
    \ s2 = lst(1)\n        val l1 = s1.length\n        val l2 = s2.length\n      \
    \  val a1 = s1.toCharArray\n        val a2 = s2.toCharArray\n        val num1\
    \ = a1.filter(c => c == '(').length\n        val num2 = a1.filter(c => c == ')').length\n\
    \        val num3 = a2.filter(c => c == '(').length\n        val num4 = a2.filter(c\
    \ => c == ')').length\n        if (num1 != num2 || num3 != num4) return \"No\"\
    \n        var q = new Queue[Char]\n        var count = 0\n        for (i <- 0\
    \ until l1) {\n            if (a1(i) == '(') q += a1(i)\n            else {\n\
    \                q += a1(i)\n                count += 1\n            }\n     \
    \   }\n        for (i <- 0 until l2) {\n            if (a2(i) == '(') q += a2(i)\n\
    \            else {\n                if (q.length == 0) return \"No\"\n      \
    \          q.dequeue\n                count -= 1\n            }\n        }\n \
    \       if (count < 0) return \"No\"\n        \"Yes\"", "        var r1 = new\
    \ Stack[Char]\n        var r2 = new Stack[Char]\n        val s1 = lst(0)\n   \
    \     val s2 = lst(1)\n        val s3 = s1 + s2\n        val s4 = s2 + s1\n  \
    \      if (s3.length % 2 == 1) {\n            return \"No\"\n        }\n     \
    \   def checkGood(s : String) : Boolean = {\n            r1.clear\n          \
    \  r2.clear\n            var i = 0\n            while (i < s.length) {\n     \
    \           if (s(i) == '(') {\n                    r1.push(s(i))\n          \
    \      } else {\n                    if (r1.isEmpty) {\n                     \
    \   return false\n                    } else {\n                        r1.pop\n\
    \                    }\n                }\n                i += 1\n          \
    \  }\n            if (r1.isEmpty) {\n                return true\n           \
    \ } else {\n                return false\n            }\n        }\n        if\
    \ (checkGood(s3)) {\n            return \"Yes\"\n        } else if (checkGood(s4))\
    \ {\n            return \"Yes\"\n        } else {\n            return \"No\"\n\
    \        }", "        // The trick here is that we will use the invariant that\
    \ the number of\n        // closing parenthesis must be equal to the number of\
    \ opening\n        // parenthesis. For example, if we have the string '((()))',\
    \ there must\n        // be two opening parentheses for every closing parentheses.\
    \ Note that\n        // in the string '))((', we cannot have a correct ordering\
    \ that obeys\n        // this invariant.\n        def f(s : String) : Boolean\
    \ = {\n            var open = 0\n            var close = 0\n            for (i\
    \ <- 0 until s.length) {\n                if (s(i) == '(') open += 1\n       \
    \         else close += 1\n                if (close > open) return false\n  \
    \          }\n            return true\n        }\n        val n1 = lst(0).filter(x\
    \ => x == '(' || x == ')').length\n        val n2 = lst(1).filter(x => x == '('\
    \ || x == ')').length\n        if (n1 != n2) return \"No\"\n        val slst =\
    \ for (i <- 0 until lst(0).length; j <- 0 until lst(1).length) yield lst(0).substring(0,\
    \ i) + lst(1).substring(0, j)\n        for (s <- slst) if (f(s)) return \"Yes\"\
    \n        return \"No\"", "        val (c1, c2) = (lst(0).toList, lst(1).toList)\n\
    \        if (c1.contains(')') && c2.contains('(')) return \"No\"\n        val\
    \ cnt1 = c1.count(_ == '(')\n        val cnt2 = c2.count(_ == '(')\n        if\
    \ (cnt1 == cnt2) return \"Yes\"\n        if (cnt1 > cnt2) return \"No\"\n    \
    \    if (cnt1 < cnt2) {\n            val cnt = cnt2 - cnt1\n            if (cnt\
    \ % 2 == 0) return \"Yes\"\n            else return \"No\"\n        }\n      \
    \  \"No\"", "        val a = lst(0).count(_ == '(')\n        val b = lst(1).count(_\
    \ == '(')\n        val c = lst(0).count(_ == ')')\n        val d = lst(1).count(_\
    \ == ')')\n        if (a > b) {\n            if (c >= a - b) \"Yes\" else \"No\"\
    \n        } else {\n            if (d >= b - a) \"Yes\" else \"No\"\n        }",
  "        var arr = new Array[Int](lst.length)\n        for (i <- 0 until lst.length)\
    \ {\n            var num = 0\n            for (j <- 0 until lst(i).length) {\n\
    \                if (lst(i)(j) == '(') num += 1\n                else num -= 1\n\
    \                if (num < 0) return \"No\"\n            }\n            arr(i)\
    \ = num\n        }\n        var j = arr.length - 1\n        var total = 0\n  \
    \      while (j >= 0) {\n            total += arr(j)\n            if (total %\
    \ 2 == 1) return \"No\"\n            j -= 1\n        }\n        \"Yes\"", "  \
    \    val (s1, s2) = (lst(0), lst(1))\n      def isGood(s : String) : Boolean =\
    \ {\n        val d = new Stack[Char]\n        for (i <- 0 until s.length()) {\n\
    \          if (s(i) == '(') d.push('(')\n          else if (d.isEmpty || d.pop()\
    \ != '(') return false\n        }\n        d.isEmpty\n      }\n      val ans =\
    \ if (isGood(s1 + s2)) \"Yes\" else if (isGood(s2 + s1)) \"Yes\" else \"No\"\n\
    \      ans", "        def balance(str : String) : Boolean = {\n            var\
    \ left = 0\n            var right = 0\n            for (c <- str) {\n        \
    \        if (c == '(') left += 1\n                else right += 1\n          \
    \      if (right > left) return false\n            }\n            return right\
    \ == left\n        }\n        if (balance(lst(0) + lst(1))) \"Yes\" else \"No\"",
  "        val s = (lst(0) + lst(1)).toList\n        val q = Queue[Char]()\n     \
    \   for (c <- s) {\n            c match {\n                case '(' => q.enqueue(c)\n\
    \                case ')' => q.dequeue\n            }\n        }\n        if (q.isEmpty)\
    \ \"Yes\" else \"No\"", "        var canMatch = true\n        var nonBalanced\
    \ = 0\n        for (str <- lst) {\n            var balance = 0\n            for\
    \ (ch <- str) {\n                if (ch == '(') balance += 1\n               \
    \ else if (ch == ')') balance -= 1\n                if (balance < 0) {\n     \
    \               canMatch = false\n                    break\n                }\n\
    \            }\n            nonBalanced += balance\n        }\n        if (nonBalanced\
    \ == 0) return \"Yes\"\n        else if (canMatch) return \"Yes\"\n        else\
    \ return \"No\"", "        def f(s : String) : Boolean = {\n            var count\
    \ = 0\n            for (i <- 0 until s.length) {\n                if (s(i) ==\
    \ '(') count += 1\n                else count -= 1\n                if (count\
    \ < 0) return false\n            }\n            return true\n        }\n     \
    \   if (f(lst(0)) && f(lst(1))) return \"Yes\"\n        else return \"No\"", " \
    \       val s1 = lst(0)\n        val s2 = lst(1)\n        if (s1.length == 0)\
    \ {\n            if (s2.length == 0) \"Yes\"\n            else {\n           \
    \     if (s2.take(1) == \"(\") \"No\"\n                else matchParens(List(s1,\
    \ s2.drop(1)))\n            }\n        }\n        else {\n            if (s2.length\
    \ == 0) {\n                if (s1.take(1) == \")\") \"No\"\n                else\
    \ matchParens(List(s1.drop(1), s2))\n            }\n            else {\n     \
    \           if (s1.take(1) == \")\" && s2.take(1) == \"(\") \"No\"\n         \
    \       else if (s1.take(1) == \")\" && s2.take(1) == \")\") matchParens(List(s1.drop(1),\
    \ s2))\n                else if (s1.take(1) == \"(\" && s2.take(1) == \")\") matchParens(List(s1,\
    \ s2.drop(1)))\n                else matchParens(List(s1.drop(1), s2))\n     \
    \       }\n        }", "        val stack = Stack[Char]()\n        for (paren\
    \ <- lst.head) {\n            if (paren == '(') stack.push(paren)\n          \
    \  else if (stack.isEmpty) return \"No\"\n            else stack.pop\n       \
    \ }\n        if (stack.isEmpty) return \"Yes\"\n        return \"No\"", "    \
    \    var x = new ArrayBuffer[Char]\n        var y = new ArrayBuffer[Char]\n  \
    \      for (i <- 0 until lst(0).length) x += lst(0)(i)\n        for (i <- 0 until\
    \ lst(1).length) y += lst(1)(i)\n        val xs = x.toString.replace(\"ArrayBuffer\"\
    , \"\").replace(\",\", \"\").replace(\" \", \"\")\n        val ys = y.toString.replace(\"\
    ArrayBuffer\", \"\").replace(\",\", \"\").replace(\" \", \"\")\n        def f(s\
    \ : String) : Boolean = {\n            val stack = new Stack[Char]\n         \
    \   for (c <- s) {\n                if (c == '(') stack.push(c)\n            \
    \    else if (stack.isEmpty) return false\n                else stack.pop\n  \
    \          }\n            return stack.isEmpty\n        }\n        if (f(xs) &&\
    \ f(ys)) return \"Yes\"\n        else if (f(xs + ys)) return \"Yes\"\n       \
    \ else if (f(ys + xs)) return \"Yes\"\n        else return \"No\"", "        lst(0)\
    \ + lst(1) match {\n            case s if (s.filter(_ == '(').length == s.filter(_\
    \ == ')').length) => \"Yes\"\n            case _ => \"No\"\n        }", "    \
    \    val first = lst(0)\n        val second = lst(1)\n        val a = isGood(first\
    \ + second)\n        val b = isGood(second + first)\n        if (a || b) \"Yes\"\
    \ else \"No\"", "      val s1 = lst(0)\n      val s2 = lst(1)\n      def check(s\
    \ : String) : Boolean = {\n        var cnt = 0\n        for (ch <- s) {\n    \
    \      if (ch == '(') cnt += 1\n          else cnt -= 1\n          if (cnt < 0)\
    \ return false\n        }\n        return cnt == 0\n      }\n      if (check(s1\
    \ + s2)) return \"Yes\"\n      if (check(s2 + s1)) return \"Yes\"\n      return\
    \ \"No\"", "        if ((lst(0) + lst(1)).count(_ == '(') == (lst(0) + lst(1)).count(_\
    \ == ')')) \"Yes\" else \"No\"", "        lst(0) + lst(1) match {\n          \
    \  case s if s.count(_ == '(') == s.count(_ == ')') => \"Yes\"\n            case\
    \ _ => \"No\"\n        }", "        lst.reduceLeft(_ + _).foldLeft(0){ (c, ch)\
    \ =>\n            ch match {\n                case '(' => c + 1\n            \
    \    case ')' => c - 1\n            }\n        } match {\n            case 0 =>\
    \ \"Yes\"\n            case _ => \"No\"\n        }", "        val a = lst(0)\n\
    \        val b = lst(1)\n        if (a.filter(_ == '(').length > a.filter(_ ==\
    \ ')').length) {\n            if (b.filter(_ == '(').length > b.filter(_ == ')').length)\
    \ {\n                \"Yes\"\n            } else {\n                \"No\"\n \
    \           }\n        } else {\n            if (b.filter(_ == '(').length < b.filter(_\
    \ == ')').length) {\n                \"Yes\"\n            } else {\n         \
    \       \"No\"\n            }\n        }", "        val s = lst.reduceLeft(_ +\
    \ _)\n        def go(s : String, c : Int) : Boolean = {\n            if (c < 0)\
    \ false\n            else {\n                if (s.isEmpty) c == 0\n         \
    \       else if (s.charAt(0) == '(') go(s.substring(1), c + 1)\n             \
    \   else go(s.substring(1), c - 1)\n            }\n        }\n        if (go(s,\
    \ 0)) \"Yes\" else \"No\"", "        val ls1 = lst(0)\n        val ls2 = lst(1)\n\
    \        val maxL = max(ls1.length, ls2.length)\n        val leftParen = List[String](\"\
    (\", \"((\", \"(((\", \"((((\", \"(((((\", \"((((((\", \"(((((((\", \"((((((((\"\
    , \"(((((((((\", \"((((((((((\", \"(((((((((((\", \"((((((((((((\", \"(((((((((((((\"\
    , \"((((((((((((((\", \"(((((((((((((((\", \"((((((((((((((((\", \"(((((((((((((((((\"\
    , \"((((((((((((((((((\", \"(((((((((((((((((((\", \"((((((((((((((((((((\", \"\
    (((((((((((((((((((((\", \"((((((((((((((((((((((\", \"(((((((((((((((((((((((\"\
    , \"((((((((((((((((((((((((\", \"(((((((((((((((((((((((((\", \"((((((((((((((((((((((((((\"\
    , \"(((((((((((((((((((((((((((\", \"((((((((((((((((((((((((((((\", \"(((((((((((((((((((((((((((((\"\
    , \"((((((((((((((((((((((((((((((\", \"(((((((((((((((((((((((((((((((\", \"\
    ((((((((((((((((((((((((((((((((\", \"(((((((((((((((((((((((((((((((((\", \"\
    ((((((((((((((((((((((((((((((((((\", \"(((((((((((((((((((((((((((((((((((\"\
    , \"((((((((((((((((((((((((((((((((((((\", \"(((((((((((((((((((((((((((((((((((((\"\
    , \"((((((((((((((((((((((((((((((((((((((\", \"((((((((", "        val openBrackets\
    \ = lst(0).count(_ == '(')\n        val closedBrackets = lst(1).count(_ == ')')\n\
    \        if (openBrackets > closedBrackets) \"No\"\n        else if (openBrackets\
    \ == closedBrackets) \"Yes\"\n        else if (openBrackets < closedBrackets)\
    \ {\n            var count = 0\n            for (i <- 0 until lst(0).length) {\n\
    \                if (lst(0)(i) == '(') count += 1\n                else count\
    \ -= 1\n                if (count < 0) return \"No\"\n            }\n        \
    \    for (i <- 0 until lst(1).length) {\n                if (lst(1)(i) == ')')\
    \ count += 1\n                else count -= 1\n                if (count < 0)\
    \ return \"No\"\n            }\n            \"Yes\"\n        }\n        else \"\
    No\"", "        def countParens(s : String) : Int = {\n            var count =\
    \ 0\n            for (c <- s) {\n                if (c == '(') count += 1\n  \
    \              else if (c == ')') count -= 1\n            }\n            count\n\
    \        }\n        val c1 = countParens(lst(0))\n        val c2 = countParens(lst(1))\n\
    \        if (c1 + c2 == 0) \"Yes\"\n        else if (c1 * c2 < 0) \"Yes\"\n  \
    \      else \"No\"", "      val s1 = lst(0)\n      val s2 = lst(1)\n      val\
    \ s3 = s1 + s2\n      val left = 0\n      val right = 0\n      val d1 = (for (i\
    \ <- 0 until s1.length) yield s1(i) == '(').filter(x => x).length\n      val d2\
    \ = (for (i <- 0 until s2.length) yield s2(i) == '(').filter(x => x).length\n\
    \      val d3 = (for (i <- 0 until s3.length) yield s3(i) == '(').filter(x =>\
    \ x).length\n      val d4 = (for (i <- 0 until s3.length) yield s3(i) == ')').filter(x\
    \ => x).length\n      if (d1 == d2 && d3 == d4) \"Yes\" else \"No\"", "      \
    \  val s = lst.reduce(_ + _)\n        if (s.count(_ == '(') != s.count(_ == ')'))\
    \ \"No\"\n        else {\n            val c = s.count(_ == '(')\n            if\
    \ (c % 2 == 0) \"Yes\"\n            else {\n                val b = c / 2\n  \
    \              val (a, b) = s.splitAt(b)\n                if (a.count(_ == '(')\
    \ == a.count(_ == ')')) \"Yes\"\n                else if (b.count(_ == '(') ==\
    \ b.count(_ == ')')) \"Yes\"\n                else \"No\"\n            }\n   \
    \     }", "        var result = \"Yes\"\n        var stack = new Stack[String]\n\
    \        for (s <- lst) {\n            for (c <- s) {\n                if (c ==\
    \ '(') {\n                    stack.push(\"(\")\n                } else {\n  \
    \                  if (stack.isEmpty) {\n                        result = \"No\"\
    \n                    } else {\n                        stack.pop\n          \
    \          }\n                }\n            }\n        }\n        if (!stack.isEmpty)\
    \ result = \"No\"\n        result", "        if (lst.size != 2) return \"Error\"\
    \n        if (lst(0).size == 0) {\n            return \"Yes\"\n        }\n   \
    \     if (lst(1).size == 0) {\n            var c = 0\n            for (c <- lst(0))\
    \ {\n                if (c == ')') return \"No\"\n            }\n            return\
    \ \"Yes\"\n        }\n        val lst1 = lst(0).toList\n        val lst2 = lst(1).toList\n\
    \        val lst1r = lst1.reverse\n        val lst2r = lst2.reverse\n        val\
    \ (x, y) = lst1r.span(_ == '(')\n        val (u, v) = lst2r.span(_ == ')')\n \
    \       val s = '(' :: v ::: u ::: x ::: y ::: ')' :: Nil\n        val t = ')'\
    \ :: v ::: u ::: x ::: y ::: '(' :: Nil\n        val str = s.mkString(\"\")\n\
    \        val str2 = t.mkString(\"\")\n        if (valid(str)) return \"Yes\"\n\
    \        if (valid(str2)) return \"Yes\"\n        \"No\"", "        if (lst.exists(s\
    \ => s.count(_ == '(') != s.count(_ == ')'))) {\n            \"No\"\n        }\
    \ else {\n            \"Yes\"\n        }", "        def isBalanced(str : String)\
    \ : Boolean = {\n            val stack = new Stack[Char]\n            for (ch\
    \ <- str) {\n                if (ch == '(') {\n                    stack.push(ch)\n\
    \                } else {\n                    if (stack.isEmpty) return false\n\
    \                    stack.pop\n                }\n            }\n           \
    \ stack.isEmpty\n        }\n        if (isBalanced(lst(0) + lst(1))) \"Yes\" else\
    \ \"No\"", "      val S = lst(0)\n      val T = lst(1)\n      val opened = new\
    \ HashMap[Int, Int]\n      val closed = new HashMap[Int, Int]\n      S.indices.foreach(i\
    \ => if (S(i) == '(') opened += (i -> i) else closed += (i -> i))\n      T.indices.foreach(i\
    \ => if (T(i) == '(') opened += (i + S.length -> i + S.length) else closed +=\
    \ (i + S.length -> i + S.length))\n      def search(i : Int, j : Int) : Boolean\
    \ = {\n        if (i > j) return true\n        else if (i == j) return !opened.contains(i)\n\
    \        else {\n          if (opened.contains(i)) {\n            if (closed.contains(j))\
    \ return search(i + 1, j - 1)\n            else return search(i + 1, j)\n    \
    \      }\n          else {\n            if (closed.contains(j)) return search(i,\
    \ j - 1)\n            else return false\n          }\n        }\n      }\n   \
    \   if (search(0, S.length + T.length - 1)) \"Yes\" else \"No\"", "    \tval str1\
    \ = lst(0)\n    \tval str2 = lst(1)\n    \tif (str1(0) == '(' && str2(0) == '(')\
    \ return \"Yes\"\n    \telse if (str1(0) == ')' && str2(0) == ')') return \"Yes\"\
    \n    \telse if (str1(0) == '(' && str2(0) == ')') return \"Yes\"\n    \telse\
    \ return \"No\"", "        val s = lst.map(_.foldLeft(0)((s, c) => s + (if (c\
    \ == '(') 1 else -1)))\n        val isGood = s.forall(_ == 0)\n        if (isGood)\
    \ {\n            if (s.last == 0) \"Yes\" else \"No\"\n        } else \"No\"",
  "        val ls = lst(0).toList\n        val rs = lst(1).toList\n        val c =\
    \ ls.size\n        val d = rs.size\n        if (c < d) return \"No\"\n       \
    \ val cnt = (ls.map((c) => if (c == '(') 1 else -1).toList ::: rs.map((c) => if\
    \ (c == ')') -1 else 1).toList).groupBy((x) => x).mapValues((x) => x.size)\n \
    \       if (!cnt.contains(-1)) return \"Yes\"\n        return \"No\"", "     \
    \   val str = lst.foldLeft(\"\")((s, str) => s + str)\n        if (str.length\
    \ % 2 == 1) return \"No\"\n        var cnt = 0\n        str.foreach(ch => if (ch\
    \ == '(') cnt += 1 else cnt -= 1)\n        if (cnt != 0) return \"No\"\n     \
    \   var s = new Stack[Char]\n        str.foreach(ch => if (ch == '(') s.push(ch)\
    \ else if (s.isEmpty || s.pop != '(') return \"No\")\n        if (s.isEmpty) return\
    \ \"Yes\" else return \"No\"", "        val open = lst(0).count(_ == '(')\n  \
    \      val close = lst(1).count(_ == ')')\n        val range = open + close\n\
    \        var s = \"\"\n        for (i <- 0 until range) {\n            if (i %\
    \ 2 == 0) s += \"(\"\n            else s += \")\"\n        }\n        if (s.matches(\"\
    \\\\(+\\\\)\\\\(+\\\\)\")) \"Yes\"\n        else \"No\"", "        val str = lst.reduceLeft((x,\
    \ y) => x + y)\n        var stack = List[Char]()\n        for (c <- str) {\n \
    \           if (c == '(') {\n                stack = stack :+ c\n            }\
    \ else {\n                if (stack.size == 0) return \"No\"\n               \
    \ stack = stack.tail\n            }\n        }\n        return if (stack.size\
    \ == 0) \"Yes\" else \"No\"", "        val str1 = lst(0)\n        val str2 = lst(1)\n\
    \        val dp = Array.ofDim[Boolean](str1.length + 1, str2.length + 1)\n   \
    \     dp(0)(0) = true\n        for (i <- 1 to str1.length) {\n            dp(i)(0)\
    \ = dp(i - 1)(0) && (str1(i - 1) == '(')\n        }\n        for (j <- 1 to str2.length)\
    \ {\n            dp(0)(j) = dp(0)(j - 1) && (str2(j - 1) == '(')\n        }\n\
    \        for (i <- 1 to str1.length; j <- 1 to str2.length) {\n            if\
    \ (str1(i - 1) == '(') dp(i)(j) = dp(i - 1)(j)\n            else if (str2(j -\
    \ 1) == '(') dp(i)(j) = dp(i)(j - 1)\n            else dp(i)(j) = dp(i - 1)(j\
    \ - 1)\n        }\n        if (dp(str1.length)(str2.length)) \"Yes\" else \"No\"",
  "      // return \"Yes\" if the string is good and \"No\" otherwise\n      def isGood(s\
    \ : String) : String = {\n        def isGoodHelper(cnt : Int, lst : List[Char])\
    \ : Boolean = {\n          if (cnt < 0) return false\n          lst match {\n\
    \            case Nil => if (cnt == 0) true else false\n            case h ::\
    \ t => if (h == '(') isGoodHelper(cnt + 1, t) else isGoodHelper(cnt - 1, t)\n\
    \          }\n        }\n        if (isGoodHelper(0, s.toList)) \"Yes\" else \"\
    No\"\n      }\n      // (1) check if the string is good\n      if (isGood(lst(0))\
    \ == \"Yes\" && isGood(lst(1)) == \"Yes\") \"Yes\"\n      // (2) reverse the string,\
    \ check if the string is good\n      else if (isGood(lst(0).reverse) == \"Yes\"\
    \ && isGood(lst(1)) == \"Yes\") \"Yes\"\n      else if (isGood(lst(0)) == \"Yes\"\
    \ && isGood(lst(1).reverse) == \"Yes\") \"Yes\"\n      else if (isGood(lst(0).reverse)\
    \ == \"Yes\" && isGood(lst(1).reverse) == \"Yes\") \"Yes\"\n      else \"No\"",
  "        def concat(s1 : String, s2 : String) : Boolean = {\n            val lst\
    \ = List(s1, s2)\n            val k = lst.mkString\n            k.count(_ == '(')\
    \ == k.count(_ == ')')\n        }\n        if (concat(lst(0), lst(1))) \"Yes\"\
    \ else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n        if\
    \ (s1.length + s2.length == 0) \"Yes\"\n        else if (s1.length + s2.length\
    \ % 2 == 1) \"No\"\n        else {\n            val remainingOpen = new mutable.ArrayBuffer[Int]()\n\
    \            for (i <- 0 until s1.length) if (s1(i) == '(') remainingOpen += 1\n\
    \            for (i <- 0 until s2.length) if (s2(i) == ')') remainingOpen -= 1\n\
    \            if (remainingOpen.forall(_ >= 0)) \"Yes\"\n            else \"No\"\
    \n        }", "        val s = lst.head + lst.tail.head\n        val opens = ArrayBuffer[Char]()\n\
    \        for (ch <- s) {\n            if (ch == '(') {\n                opens\
    \ += ch\n            } else {\n                if (opens.size == 0) return \"\
    No\"\n                else opens.remove(opens.size - 1)\n            }\n     \
    \   }\n        if (opens.size == 0) \"Yes\" else \"No\"", "        var opens =\
    \ 0\n        var closes = 0\n        lst.foreach { x =>\n            x.foreach\
    \ { c =>\n                if (c == '(') opens += 1\n                else closes\
    \ += 1\n            }\n        }\n        if (opens >= closes) \"Yes\" else \"\
    No\"", "        def isGood(s : String) : Boolean = {\n            var stack =\
    \ new Stack[Char]\n            var good = true\n            for (i <- 0 until\
    \ s.length) {\n                if (s(i) == '(') stack.push('(')\n            \
    \    else if (stack.isEmpty) good = false\n                else stack.pop\n  \
    \          }\n            good && stack.isEmpty\n        }\n        val s = lst(0)\
    \ + lst(1)\n        for (i <- 0 until s.length) if (isGood(s.substring(0, i) +\
    \ s.substring(i + 1))) return \"Yes\"\n        \"No\"", "        def helper(lst\
    \ : List[String], ns : Int) : String = {\n            if (ns < 0) \"No\"\n   \
    \         else lst match {\n                case Nil => if (ns == 0) \"Yes\" else\
    \ \"No\"\n                case h :: t => helper(t, ns + h.filter(_ == '(').length\
    \ - h.filter(_ == ')').length)\n            }\n        }\n        helper(lst,\
    \ 0)", "    \tval s = lst.mkString\n    \tdef cond1(str : String) : Boolean =\
    \ {\n    \t\tval s = str.replaceAll(\"[()]\", \"\")\n    \t\ts.isEmpty\n    \t\
    }\n    \tif (cond1(s)) {\n    \t\t\"Yes\"\n    \t} else {\n    \t\tval s1 = s.replaceAll(\"\
    [()]\", \" \")\n    \t\tval tokens = s1.split(\" \")\n    \t\tval lst = tokens.map(_.length)\n\
    \    \t\tval n = lst.length\n    \t\tif (n % 2 == 0) {\n    \t\t\t\"No\"\n   \
    \ \t\t} else {\n    \t\t\tval k = n / 2\n    \t\t\tval ms = lst.combinations(k).toList\n\
    \    \t\t\tval res = ms.map(m => m.sum).toSet\n    \t\t\tif (res.contains(0))\
    \ {\n    \t\t\t\t\"Yes\"\n    \t\t\t} else {\n    \t\t\t\t\"No\"\n    \t\t\t}\n\
    \    \t\t}\n    \t}", "        var stack = new Stack[Char]\n        var i = 0\n\
    \        while (i < lst(0).length) {\n            if (lst(0)(i) == '(') stack.push('(')\n\
    \            else if (stack.isEmpty) return \"No\"\n            else stack.pop\n\
    \            i += 1\n        }\n        i = 0\n        while (i < lst(1).length)\
    \ {\n            if (lst(1)(i) == '(') stack.push('(')\n            else if (stack.isEmpty)\
    \ return \"No\"\n            else stack.pop\n            i += 1\n        }\n \
    \       if (stack.isEmpty) \"Yes\" else \"No\"", "    \tval a = lst(0)\n    \t\
    val b = lst(1)\n    \tval s = a + b\n    \tif (s.length % 2 == 1) return \"No\"\
    \n    \tval r = new scala.util.matching.Regex(\"\\\\(\\\\)\")\n    \tvar t = s\n\
    \    \tdo {\n    \t\tt = r.replaceAllIn(t, \"\")\n    \t} while (r.findFirstIn(t)\
    \ != None)\n    \tif (t.length == 0) \"Yes\" else \"No\"", "        def leftSide(s\
    \ : String) : Int = {\n            var c : Int = 0\n            for (c2 <- s)\
    \ {\n                if (c2 == '(') c += 1\n                else c -= 1\n    \
    \        }\n            return c\n        }\n        val left : Int = leftSide(lst(0))\n\
    \        val right : Int = leftSide(lst(1))\n        if (left == 0 && right ==\
    \ 0) \"Yes\"\n        else if (left < 0 || right > 0) \"No\"\n        else if\
    \ (left > right) \"Yes\"\n        else \"No\"", "      def helper(s : String)\
    \ : Int = {\n        var index = 0\n        var count = 0\n        while (index\
    \ < s.length) {\n          s(index) match {\n            case '(' => count +=\
    \ 1\n            case ')' => if (count == 0) return -1\n                     \
    \   else count -= 1\n          }\n          index += 1\n        }\n        count\n\
    \      }\n      var a = helper(lst(0))\n      var b = helper(lst(1))\n      if\
    \ (a < 0 || b < 0) return \"No\"\n      if (a == 0 && b == 0) return \"Yes\"\n\
    \      if (a == 0) return \"Yes\"\n      if (b == 0) return \"Yes\"\n      if\
    \ (a == b) return \"Yes\"\n      \"No\"", "        val brcnt : Array[Int] = new\
    \ Array[Int](lst.size)\n        for (i <- 0 until lst.size) {\n            for\
    \ (c <- lst(i))\n                if (c == '(') brcnt(i) += 1\n               \
    \ else brcnt(i) -= 1\n        }\n        if (brcnt.foldLeft(0)(_ + _) != 0) \"\
    No\"\n        else if (brcnt.foldLeft(0)(_ + _) == 0) \"Yes\"\n        else if\
    \ (brcnt.contains(0)) \"Yes\"\n        else \"No\"", "        // find the number\
    \ of '(' and ')' in each string.\n        val a = lst(0).count(_ == '(')\n   \
    \     val b = lst(0).count(_ == ')')\n        val c = lst(1).count(_ == '(')\n\
    \        val d = lst(1).count(_ == ')')\n        if ((a + c == b + d) && (a +\
    \ d == b + c)) {\n            // we can make a good string\n            return\
    \ \"Yes\"\n        }\n        else {\n            return \"No\"\n        }", " \
    \       val s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n  \
    \      var depth = 0\n        for (i <- 0 until s.length) {\n            if (s(i)\
    \ == '(') depth += 1\n            else depth -= 1\n            if (depth < 0)\
    \ return \"No\"\n        }\n        if (depth == 0) \"Yes\" else \"No\"", "  \
    \      def go(s : String) : Int = {\n            var res = 0\n            var\
    \ idx = 0\n            while (idx < s.length) {\n                if (s(idx) ==\
    \ '(') res += 1\n                else res -= 1\n                if (res < 0) return\
    \ -1\n                idx += 1\n            }\n            res\n        }\n  \
    \      val one = go(lst(0))\n        val two = go(lst(1))\n        if (one < 0\
    \ || two < 0) return \"No\"\n        if (one == 0) return \"Yes\"\n        else\
    \ if (two == 0) return \"Yes\"\n        else if (one == two) return \"Yes\"\n\
    \        else return \"No\"", "        if (lst.head == \")\" || lst.last == \"\
    (\") return \"No\"\n        val good = lst.head.length - lst.head.count(_ == ')')\
    \ + lst.last.length - lst.last.count(_ == '(')\n        if (good % 2 == 0) \"\
    Yes\" else \"No\"", "        if ((lst(0) + lst(1)).split(\"\").filter(x => x ==\
    \ \"(\").length !=\n            (lst(0) + lst(1)).split(\"\").filter(x => x ==\
    \ \")\").length) return \"No\"\n        var g = 0\n        for (c <- (lst(0) +\
    \ lst(1)).split(\"\")) {\n            if (c == \"(\") g += 1\n            else\
    \ g -= 1\n            if (g < 0) return \"No\"\n        }\n        return \"Yes\"",
  "        val unbalanced = lst.map(paren => {\n            var result = 0\n     \
    \       for (c <- paren) {\n                if (c == '(') result += 1\n      \
    \          else result -= 1\n                if (result < 0) return false\n  \
    \          }\n            result == 0\n        })\n        if (unbalanced.contains(false))\
    \ \"No\"\n        else \"Yes\"", "        val s = lst.map(i => i.filter(c => c\
    \ == '(' || c == ')')).map(i =>\n            i.count(c => c == '(') - i.count(c\
    \ => c == ')')).sum\n        if (s == 0) \"Yes\" else \"No\"", "        val s1\
    \ = lst(0)\n        val s2 = lst(1)\n        def balanced(s : String) : Boolean\
    \ = {\n            val stack = new Stack[Char]\n            var i = 0\n      \
    \      while (i < s.length) {\n                if (s(i) == '(') stack.push('(')\n\
    \                else if (stack.isEmpty) return false\n                else stack.pop\n\
    \                i += 1\n            }\n            stack.isEmpty\n        }\n\
    \        if (balanced(s1 + s2)) \"Yes\"\n        else if (balanced(s2 + s1)) \"\
    Yes\"\n        else \"No\"", "      val sb = new StringBuilder\n      sb.append(lst(0))\n\
    \      sb.append(lst(1))\n      val s = sb.toString\n      var counter = 0\n \
    \     for (c <- s) {\n        if (c == '(') counter += 1\n        else counter\
    \ -= 1\n        if (counter < 0) return \"No\"\n      }\n      if (counter ==\
    \ 0) \"Yes\" else \"No\"", "        val s = lst.mkString\n        val st = new\
    \ Stack[Char]\n        val close = new Stack[Char]\n        for (c <- s) {\n \
    \           if (c == '(') st.push(c)\n            else if (st.size > 0) st.pop\n\
    \            else close.push(c)\n        }\n        if (st.size == 0 && close.size\
    \ == 0) \"Yes\"\n        else if (st.size == 1 && close.size == 1) \"Yes\"\n \
    \       else \"No\"", "        val a = lst(0)\n        val b = lst(1)\n      \
    \  def isGood(s : String) : Boolean = {\n            val sb = new StringBuilder\n\
    \            var cnt = 0\n            for (i <- 0 until s.length) {\n        \
    \        sb.append(s(i))\n                if (s(i) == '(') cnt += 1\n        \
    \        else if (s(i) == ')') cnt -= 1\n                if (cnt < 0) return false\n\
    \            }\n            cnt == 0\n        }\n        if (isGood(a + b)) \"\
    Yes\"\n        else if (isGood(b + a)) \"Yes\"\n        else \"No\"", "      \
    \  // Check if a string is good.\n        def isGood(s : String) : Boolean = {\n\
    \            var parenDepth = 0\n            for (c <- s) {\n                c\
    \ match {\n                    case '(' => parenDepth += 1\n                 \
    \   case ')' => {\n                        if (parenDepth == 0) return false\n\
    \                        parenDepth -= 1\n                    }\n            \
    \    }\n            }\n            return (parenDepth == 0)\n        }\n     \
    \   val paren1 = lst(0)\n        val paren2 = lst(1)\n        val paren1Length\
    \ = paren1.length\n        val paren2Length = paren2.length\n        // Check\
    \ if it is possible to make good strings when concatenating.\n        if (paren1(0)\
    \ == ')' && paren2(0) == ')') return \"No\"\n        if (paren1(paren1Length -\
    \ 1) == '(' && paren2(paren2Length - 1) == '(') return \"No\"\n        // Check\
    \ if it is possible to make good strings when swapping.\n        for (i <- 1 until\
    \ paren1Length - 1) {\n            for (j <- 1 until paren2Length - 1) {\n   \
    \             if (paren1(i) == '(' && paren2(j) == ')') {\n                  \
    \  return \"Yes\"\n                }\n            }\n        }\n        // If\
    \ we got here, it's not possible to make good strings by concatenating or swapping,\
    \ so we return \"No\".\n        return \"No\"", "        def isGood(str : String)\
    \ : Boolean = {\n            var depth = 0\n            for (c <- str) {\n   \
    \             if (c == '(') depth += 1\n                else if (c == ')') depth\
    \ -= 1\n                if (depth < 0) return false\n            }\n         \
    \   return depth == 0\n        }\n        if (isGood(lst(0) + lst(1))) return\
    \ \"Yes\"\n        if (isGood(lst(1) + lst(0))) return \"Yes\"\n        return\
    \ \"No\"", "        // if there is a ')' without a preceeding '('\n        if\
    \ (lst.exists(s => s.startsWith(\")\"))) return \"No\"\n        // if there is\
    \ a '(' without a succeeding ')'\n        if (lst.exists(s => s.endsWith(\"(\"\
    ))) return \"No\"\n        // if there is a '(' in the middle of either string\n\
    \        if (lst.exists(s => s.length > 1 && s.substring(1, s.length - 1).contains(\"\
    (\"))) return \"No\"\n        // otherwise\n        return \"Yes\"", "       \
    \ val sb = new StringBuilder\n        lst.foreach { s => sb.append(s) }\n    \
    \    val s = sb.toString\n        // negative result means more \"(\" than \"\
    )\"\n        var cnt = 0\n        for (c <- s) {\n            if (c == '(') cnt\
    \ += 1\n            else cnt -= 1\n            if (cnt < 0) return \"No\"\n  \
    \      }\n        if (cnt == 0) \"Yes\" else \"No\"", "        var stack : Stack[Char]\
    \ = new Stack[Char]\n        for (s <- lst) {\n            for (i <- 0 until s.length)\
    \ {\n                val ch = s(i)\n                if (ch == '(') stack.push(ch)\n\
    \                else if (ch == ')') {\n                    if (stack.isEmpty)\
    \ return \"No\"\n                    stack.pop\n                }\n          \
    \  }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", "        val\
    \ str = lst.mkString\n        var balance = 0\n        for (c <- str) {\n    \
    \        c match {\n                case '(' => balance += 1\n               \
    \ case ')' => balance -= 1\n            }\n            if (balance < 0) return\
    \ \"No\"\n        }\n        if (balance == 0) \"Yes\" else \"No\"", "      var\
    \ yes = true\n      var stack = new Stack[Char]\n      var i = 0\n      for (i\
    \ <- 0 until lst.length) {\n        for (j <- 0 until lst(i).length) {\n     \
    \     if (lst(i)(j) == '(') {\n            stack.push(lst(i)(j))\n          }\
    \ else {\n            if (stack.isEmpty) {\n              yes = false\n      \
    \      } else {\n              stack.pop\n            }\n          }\n       \
    \ }\n      }\n      if (yes) {\n        if (stack.isEmpty) {\n          \"Yes\"\
    \n        } else {\n          \"No\"\n        }\n      } else {\n        \"No\"\
    \n      }", "        val rst = lst.foldLeft(0)((acc, x) => acc + x.count(_ ==\
    \ '(') - x.count(_ == ')'))\n        if (rst == 0) \"Yes\" else \"No\"", "   \
    \     val openCount = lst.filter(x => x == \"(\").length\n        val closeCount\
    \ = lst.filter(x => x == \")\").length\n        if (openCount == closeCount) \"\
    Yes\" else \"No\"", "        if (lst.forall(s => (s.count(c => c == '(') == s.count(c\
    \ => c == ')'))))\n            \"Yes\"\n        else\n            \"No\"", " \
    \       val s = lst.tail.head + lst.head\n        val o = new scala.collection.mutable.Stack[Char]\n\
    \        var bad = false\n        for (i <- 0 until s.length) {\n            if\
    \ (s(i) == '(') {\n                o.push(s(i))\n            } else {\n      \
    \          if (o.isEmpty) {\n                    bad = true\n                }\
    \ else {\n                    o.pop\n                }\n            }\n      \
    \  }\n        if (bad || !o.isEmpty) {\n            \"No\"\n        } else {\n\
    \            \"Yes\"\n        }", "        val (s1, s2) = (lst(0), lst(1))\n \
    \       def isGood(s : String) : Boolean = {\n            val count = s.count(_\
    \ == '(') - s.count(_ == ')')\n            if (count < 0) return false\n     \
    \       if (count == 0) return true\n            isGood(s.drop(count) + s.take(count))\n\
    \        }\n        if (isGood(s1 + s2)) \"Yes\" else \"No\"", "        val first\
    \ = lst(0)\n        val second = lst(1)\n        var goodCount = 0\n        for\
    \ (c <- first) {\n            if (c == '(') goodCount += 1\n            else goodCount\
    \ -= 1\n        }\n        for (c <- second) {\n            if (c == '(') goodCount\
    \ += 1\n            else goodCount -= 1\n        }\n        if (goodCount == 0)\
    \ \"Yes\"\n        else \"No\"", "        if (lst.reduceLeft((a, b) => a + b).filter(c\
    \ => c == '(').length ==\n            lst.reduceLeft((a, b) => a + b).filter(c\
    \ => c == ')').length) \"Yes\" else \"No\"", "        val c1 = lst(0).count(_\
    \ == '(')\n        val c2 = lst(1).count(_ == '(')\n        if (c1 == lst(0).length\
    \ && c2 == lst(1).length) return \"Yes\"\n        if (c1 != lst(0).length && c2\
    \ != lst(1).length) return \"No\"\n        if (c1 != lst(0).length) {\n      \
    \      if (c1 > c2) return \"Yes\"\n            else return \"No\"\n        }\n\
    \        if (c2 != lst(1).length) {\n            if (c2 > c1) return \"Yes\"\n\
    \            else return \"No\"\n        }\n        \"\"", "        val str1 =\
    \ lst(0)\n        val str2 = lst(1)\n        val s = str1 + str2\n        var\
    \ stack = Stack[Char]()\n        for (i <- 0 until s.length) {\n            if\
    \ (s(i) == '(') stack.push('(')\n            else if (s(i) == ')') {\n       \
    \         if (stack.isEmpty) return \"No\"\n                stack.pop\n      \
    \      }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", "      \
    \  val s1 = lst(0)\n        val s2 = lst(1)\n        val s1Match = s1.count(_\
    \ == '(') - s1.count(_ == ')')\n        val s2Match = s2.count(_ == '(') - s2.count(_\
    \ == ')')\n        val totalMatch = s1Match + s2Match\n        if (totalMatch\
    \ == 0) return \"Yes\"\n        val s1left = s1.count(_ == '(')\n        val s2left\
    \ = s2.count(_ == '(')\n        val totalLeft = s1left + s2left\n        if (totalLeft\
    \ < abs(totalMatch)) return \"No\"\n        if (totalLeft == abs(totalMatch))\
    \ {\n            if (totalMatch > 0) return \"Yes\"\n            return \"No\"\
    \n        }\n        // There are more lefts than needed.\n        if (totalMatch\
    \ == 0) return \"Yes\"\n        if (totalMatch > 0) {\n            if (totalLeft\
    \ == totalMatch) return \"No\"\n            return \"Yes\"\n        }\n      \
    \  return \"Yes\"", "        val balanced = new BalancedParens\n        for (s\
    \ <- lst) {\n            for (ch <- s) {\n                if (ch == '(') balanced.push\n\
    \                else balanced.pop\n            }\n        }\n        if (balanced.isEmpty)\
    \ \"Yes\" else \"No\"", "        val (s1, s2) = (lst(0), lst(1))\n        def\
    \ isGood(s : String) : Boolean = {\n            var cnt = 0\n            for (c\
    \ <- s) {\n                if (c == '(') cnt += 1\n                else if (c\
    \ == ')') cnt -= 1\n                if (cnt < 0) return false\n            }\n\
    \            return cnt == 0\n        }\n        return if (isGood(s1 + s2) ||\
    \ isGood(s2 + s1)) \"Yes\" else \"No\"", "        val (s1, s2) = (lst(0), lst(1))\n\
    \        def isBad(s : String) : Boolean = {\n            var depth = 0\n    \
    \        for (i <- 0 until s.length) {\n                if (s(i) == '(') depth\
    \ += 1\n                else depth -= 1\n                if (depth < 0) return\
    \ true\n            }\n            depth != 0\n        }\n        val options\
    \ = List(s1 + s2, s2 + s1, \"(\" + s1 + s2 + \")\", \"(\" + s2 + s1 + \")\")\n\
    \        if (options.exists(s => !isBad(s))) \"Yes\" else \"No\"", "        val\
    \ x = lst(0)\n        val y = lst(1)\n        if(x.length == 0) return y\n   \
    \     if(y.length == 0) return x\n        if(x(0) == ')' && y(0) == ')') return\
    \ \"No\"\n        if(x(0) == ')' && y(0) == '(') return y\n        if(x(0) ==\
    \ '(' && y(0) == ')') return x\n        if(x(0) == '(' && y(0) == '(') return\
    \ matchParens(List(x.substring(1), y.substring(1)))\n        \"No\"", "      \
    \  val ints = lst.map(x => x.map(y => if (y == '(') 1 else -1).sum)\n        val\
    \ str = ints.mkString(\"+\")\n        if (str.charAt(0) == '-') {\n          \
    \  if (str.startsWith(\"-+\") || str.startsWith(\"--\")) \"Yes\" else \"No\"\n\
    \        } else {\n            if (str.startsWith(\"+-\") || str.startsWith(\"\
    ++\")) \"Yes\" else \"No\"\n        }", "        val str = lst.mkString\n    \
    \    val (left, right) = str.foldLeft((0, 0)) {\n            case ((open, close),\
    \ '(') => (open + 1, close)\n            case ((open, close), ')') => (open, close\
    \ + 1)\n        }\n        if (right > left) \"No\" else \"Yes\"", "        val\
    \ s1 = lst(0)\n        val s2 = lst(1)\n        def merge(s1 : String, s2 : String)\
    \ : String = {\n            val s = s1 + s2\n            if (s(0) == ')') {\n\
    \                val firstClose = s.indexOf(')')\n                val sub = s.substring(firstClose)\n\
    \                if (isBalanced(sub)) s.substring(firstClose) else \"No\"\n  \
    \          } else if (s(s.length - 1) == '(') {\n                val lastOpen\
    \ = s.lastIndexOf('(')\n                val sub = s.substring(0, lastOpen + 1)\n\
    \                if (isBalanced(sub)) s.substring(0, lastOpen + 1) else \"No\"\
    \n            } else \"No\"\n        }\n        val split1 = s1.split('(')\n \
    \       val split2 = s2.split('(')\n        if (split1.length == 1 && split2.length\
    \ == 1) merge(s1, s2)\n        else if (split1.length == 1) {\n            val\
    \ subs = split2.filter(_ != \"\")\n            val s = merge(s1, subs(0))\n  \
    \          if (s == \"No\") \"No\"\n            else if (isBalanced(s)) s\n  \
    \          else \"No\"\n        } else if (split2.length == 1) {\n           \
    \ val subs = split1.filter(_ != \"\")\n            val s = merge(subs(0), s2)\n\
    \            if (s == \"No\") \"No\"\n            else if (isBalanced(s)) s\n\
    \            else \"No\"\n        } else \"No\"", "      var s = lst(0) + lst(1)\n\
    \      var currCount = 0\n      for (i <- 0 until s.length) {\n        if (s(i)\
    \ == '(') currCount += 1\n        else currCount -= 1\n        if (currCount <\
    \ 0) return \"No\"\n      }\n      return if (currCount == 0) \"Yes\" else \"\
    No\"", "        val a = lst(0).toCharArray\n        val b = lst(1).toCharArray\n\
    \        val openA = a.filter(x => x == '(').length\n        val closeA = a.filter(x\
    \ => x == ')').length\n        val openB = b.filter(x => x == '(').length\n  \
    \      val closeB = b.filter(x => x == ')').length\n        if (openA + openB\
    \ == closeA + closeB) \"Yes\" else \"No\"", "        // balanced parentheses expression\n\
    \        def bpe(s : String) : Boolean = {\n            var s = s\n          \
    \  var c = 0\n            while (s.length > 0) {\n                if (s.head ==\
    \ '(') c += 1\n                else if (s.head == ')') c -= 1\n              \
    \  else throw new Exception(\"unknown expression\")\n                if (c < 0)\
    \ return false\n                s = s.tail\n            }\n            return\
    \ c == 0\n        }\n        return (if (bpe(lst(0) + lst(1))) \"Yes\" else \"\
    No\")", "        val s = lst.mkString\n        val openCount = s.filter(_ == '(').length\n\
    \        val closeCount = s.filter(_ == ')').length\n        if (openCount ==\
    \ closeCount) \"Yes\" else \"No\"", "        val sb = new StringBuilder\n    \
    \    sb.append(lst(0)); sb.append(lst(1))\n        var stack = new Stack[Char]\n\
    \        for (c <- sb.toString) c match {\n            case '(' => stack.push(c)\n\
    \            case ')' =>\n                if (stack.isEmpty) return \"No\"\n \
    \               else stack.pop\n        }\n        if (stack.isEmpty) \"Yes\"\
    \ else \"No\"", "        def matchParens0(lst : List[String], count : Int) : String\
    \ = {\n            if (count < 0) \"No\"\n            else if (lst.isEmpty) if\
    \ (count == 0) \"Yes\" else \"No\"\n            else matchParens0(lst.tail, count\
    \ + (if (lst.head == \"(\") 1 else -1))\n        }\n        matchParens0(lst,\
    \ 0)", "        val str = lst.mkString(\"\")\n        if (str.count(_ == '(')\
    \ == str.count(_ == ')')) {\n            val stack = new Stack[Char]\n       \
    \     str.foreach(c => {\n                if (c == '(') {\n                  \
    \  stack.push(c)\n                } else {\n                    if (stack.isEmpty)\
    \ {\n                        return \"No\"\n                    } else {\n   \
    \                     stack.pop\n                    }\n                }\n  \
    \          })\n            \"Yes\"\n        } else {\n            \"No\"\n   \
    \     }", "        val a = lst(0)\n        val b = lst(1)\n        var cnt = 0\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == '(') cnt += 1\n\
    \            else cnt -= 1\n        }\n        if (cnt < 0) return \"No\"\n  \
    \      for (i <- 0 until b.length) {\n            if (b(i) == '(') cnt += 1\n\
    \            else cnt -= 1\n        }\n        if (cnt != 0) return \"No\"\n \
    \       var balance = 0\n        for (i <- 0 until a.length) {\n            if\
    \ (a(i) == '(') balance += 1\n            else balance -= 1\n            if (balance\
    \ < 0) return \"No\"\n        }\n        balance = 0\n        for (i <- 0 until\
    \ b.length) {\n            if (b(i) == '(') balance += 1\n            else balance\
    \ -= 1\n            if (balance < 0) return \"No\"\n        }\n        \"Yes\"",
  '        return "Yes"', "        val a = lst(0).toCharArray\n        val b = lst(1).toCharArray\n\
    \        val pair = Map('(' -> ')')\n        val sta = Stack[Char]()\n       \
    \ a.foreach {ch =>\n            if (pair.contains(ch)) sta.push(ch)\n        \
    \    else {\n                if (sta.isEmpty || pair(sta.pop) != ch) return \"\
    No\"\n            }\n        }\n        if (sta.isEmpty) {\n            val l\
    \ = b.length\n            var index = 0\n            while (index < l) {\n   \
    \             if (pair.contains(b(index))) {\n                    if (index +\
    \ 1 == l) return \"No\"\n                    if (pair(b(index)) != b(index + 1))\
    \ return \"No\"\n                    index += 2\n                }\n         \
    \       else index += 1\n            }\n            \"Yes\"\n        }\n     \
    \   else {\n            val l = b.length\n            var index = 0\n        \
    \    while (index < l) {\n                if (pair.contains(b(index))) {\n   \
    \                 if (index + 1 == l) return \"No\"\n                    if (pair(b(index))\
    \ != b(index + 1)) return \"No\"\n                    if (sta.isEmpty) return\
    \ \"No\"\n                    sta.pop\n                    index += 2\n      \
    \          }\n                else index += 1\n            }\n            if (sta.isEmpty)\
    \ \"Yes\"\n            else \"No\"\n        }", "      val p1 = lst(0)\n     \
    \ val p2 = lst(1)\n      def isGood(p : String) : Boolean = {\n        var s =\
    \ Stack[Char]()\n        for (c <- p) {\n          if (c == '(') s.push(c)\n \
    \         else {\n            if (s.isEmpty) return false\n            else s.pop\n\
    \          }\n        }\n        s.isEmpty\n      }\n      if (isGood(p1 + p2))\
    \ \"Yes\"\n      else if (isGood(p2 + p1)) \"Yes\"\n      else \"No\"", "    \t\
    def isGood(str : String) : Boolean = {\n    \t\tvar count = 0\n    \t\tfor (c\
    \ <- str) {\n    \t\t\tif (c == '(') count += 1\n    \t\t\telse if (c == ')')\
    \ count -= 1\n    \t\t\tif (count < 0) return false\n    \t\t}\n    \t\treturn\
    \ count == 0\n    \t}\n    \tval first = lst(0)\n    \tval second = lst(1)\n \
    \   \tval concats = List(first + second, second + first)\n    \tfor (str <- concats)\
    \ {\n    \t\tif (isGood(str)) return \"Yes\"\n    \t}\n    \treturn \"No\"", " \
    \       if (lst.length != 2) return \"No\"\n        val parens1 = lst(0).toList\n\
    \        val parens2 = lst(1).toList\n        val check1 = recurse(parens1, 0)\n\
    \        val check2 = recurse(parens2, 0)\n        if (check1 && check2) return\
    \ \"Yes\"\n        if (check1 && recurse(parens2, 0)) return \"Yes\"\n       \
    \ if (check2 && recurse(parens1, 0)) return \"Yes\"\n        return \"No\"", " \
    \       val (a, b) = (lst(0), lst(1))\n        (a + b).count(c => c == '(') ==\
    \ (a + b).count(c => c == ')') match {\n            case true => \"Yes\"\n   \
    \         case false => \"No\"\n        }", "        // we have to add up the\
    \ number of open parentheses and close\n        // parentheses and make sure the\
    \ total is zero. We need to\n        // traverse the strings from left to right\
    \ and make sure there\n        // are never more close parentheses than open parentheses.\n\
    \        var sum = 0\n        for (str <- lst) {\n            for (ch <- str)\
    \ {\n                if (ch == '(') sum += 1\n                else sum -= 1\n\
    \                if (sum < 0) return \"No\"\n            }\n        }\n      \
    \  if (sum == 0) \"Yes\" else \"No\"", "        val x = lst(0)\n        val y\
    \ = lst(1)\n        if (x.length + y.length == 0) \"Yes\"\n        else if (x.length\
    \ == 0) {\n            if (y.head == '(') \"No\"\n            else matchParens(List(x,\
    \ y.drop(1)))\n        }\n        else if (y.length == 0) {\n            if (x.last\
    \ == ')') \"No\"\n            else matchParens(List(x.dropRight(1), y))\n    \
    \    }\n        else if (x.last == '(' && y.head == ')') matchParens(List(x.dropRight(1),\
    \ y.drop(1)))\n        else if (x.last == '(') matchParens(List(x, y.drop(1)))\n\
    \        else if (y.head == ')') matchParens(List(x.dropRight(1), y))\n      \
    \  else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n        if\
    \ (s1.filter(_ == '(').length == s1.filter(_ == ')').length) {\n            if\
    \ (s2.filter(_ == '(').length == s2.filter(_ == ')').length) \"Yes\"\n       \
    \     else \"No\"\n        } else \"No\"", "        val used = new HashSet[String]\n\
    \        var found = false\n        def search(a : String, b : String) {\n   \
    \         if (!found) {\n                if (a.isEmpty) {\n                  \
    \  if (b.isEmpty) {\n                        found = true\n                  \
    \  } else {\n                        val s = b.filter(_ == '(')\n            \
    \            if (s.size == b.size / 2) {\n                            found =\
    \ true\n                        }\n                    }\n                } else\
    \ {\n                    if (b.isEmpty) {\n                        val s = a.filter(_\
    \ == ')')\n                        if (s.size == a.size / 2) {\n             \
    \               found = true\n                        }\n                    }\
    \ else {\n                        val s = a + b\n                        if (!used.contains(s))\
    \ {\n                            used += s\n                            search(a.tail,\
    \ b)\n                            search(a, b.tail)\n                        }\n\
    \                    }\n                }\n            }\n        }\n        search(lst(0),\
    \ lst(1))\n        if (found) \"Yes\" else \"No\"", "      if (lst(0).length %\
    \ 2 == 1) return \"No\"\n      else {\n        def go(s1 : String, s2 : String)\
    \ : String = {\n          if (s1.length == 0) return \"Yes\"\n          else if\
    \ (s1.head == '(') go(s1.tail, s2 + '(')\n          else if (s2.length > 0 &&\
    \ s2.last == '(') go(s1.tail, s2.init)\n          else return \"No\"\n       \
    \ }\n        return go(lst(0) + lst(1), \"\")\n      }", "        if (lst.size\
    \ < 2) {\n            throw new Error(\"List size must be >= 2\")\n        }\n\
    \        val str1 = lst(0)\n        val str2 = lst(1)\n        var i = 0\n   \
    \     var score = 0\n        while (i < str1.length) {\n            if (str1(i)\
    \ == '(') {\n                score += 1\n            } else {\n              \
    \  score -= 1\n            }\n            if (score < 0) {\n                return\
    \ \"No\"\n            }\n            i += 1\n        }\n        i = 0\n      \
    \  while (i < str2.length) {\n            if (str2(i) == '(') {\n            \
    \    score += 1\n            } else {\n                score -= 1\n          \
    \  }\n            if (score < 0) {\n                return \"No\"\n          \
    \  }\n            i += 1\n        }\n        if (score != 0) {\n            return\
    \ \"No\"\n        }\n        return \"Yes\"", '        "Yes"', "        val s1\
    \ = lst(0)\n        val s2 = lst(1)\n        var openCount = 0\n        var closeCount\
    \ = 0\n        for (s <- s1) {\n            if (s == '(') openCount += 1\n   \
    \         else closeCount += 1\n        }\n        var canMatch = false\n    \
    \    for (s <- s2) {\n            if (s == '(') openCount += 1\n            else\
    \ {\n                closeCount += 1\n                if (closeCount > openCount)\
    \ canMatch = true\n            }\n        }\n        if (canMatch) \"Yes\" else\
    \ \"No\"", "        val s = lst.mkString(\"\")\n        if (s.map(ch => if (ch\
    \ == '(') 1 else -1).scanLeft(0)(_ + _).min < 0) \"No\" else \"Yes\"", "     \
    \   val (a, b) = (lst(0), lst(1))\n        val aopen = a.count(_ == '(')\n   \
    \     val aclose = a.count(_ == ')')\n        val bopen = b.count(_ == '(')\n\
    \        val bclose = b.count(_ == ')')\n        if (aopen != aclose || bopen\
    \ != bclose) \"No\"\n        else if (abs(aopen - bopen) % 2 == 0) \"Yes\"\n \
    \       else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n    \
    \    var stack = Stack[Char]()\n        var result = \"Yes\"\n        if (s1.contains(')')\
    \ || s2.contains('(')) result = \"No\"\n        for (i <- 0 until s1.length) {\n\
    \            if (s1(i) == '(') stack.push(s1(i))\n            else {\n       \
    \         if (stack.isEmpty) result = \"No\"\n                else stack.pop\n\
    \            }\n        }\n        for (i <- 0 until s2.length) {\n          \
    \  if (s2(i) == '(') stack.push(s2(i))\n            else {\n                if\
    \ (stack.isEmpty) result = \"No\"\n                else stack.pop\n          \
    \  }\n        }\n        if (!stack.isEmpty) result = \"No\"\n        result",
  "        var s = lst(0) + lst(1)\n        var depth = 0\n        for (i <- 0 until\
    \ s.length) {\n            if (s(i) == '(') depth += 1\n            else depth\
    \ -= 1\n            if (depth < 0) return \"No\"\n        }\n        if (depth\
    \ == 0) \"Yes\" else \"No\"", "        def concat(lst : List[String]) : String\
    \ = lst match {\n            case x :: y :: Nil => x + y\n            case _ =>\
    \ {\n                val n = lst.size / 2\n                concat(lst.take(n)\
    \ ++ List(concat(lst.takeRight(2))))\n            }\n        }\n        def check(x\
    \ : String) : Boolean = {\n            var sc = 0\n            x.foreach(i =>\
    \ if (i == '(') sc += 1 else sc -= 1)\n            sc == 0\n        }\n      \
    \  if (check(concat(lst)) && check(concat(lst.reverse))) \"Yes\" else \"No\"",
  "    \tvar hasOpens = false\n    \tvar hasCloses = false\n    \tlst.foreach { s\
    \ =>\n    \t\tif (s.indexOf('(') >= 0) hasOpens = true\n    \t\tif (s.indexOf(')')\
    \ >= 0) hasCloses = true\n    \t}\n    \tif (hasOpens && hasCloses) return \"\
    Yes\"\n    \telse if (hasOpens) return \"Yes\"\n    \telse if (hasCloses) return\
    \ \"No\"\n    \telse return \"Yes\"", "        val lst2 = lst(0) + lst(1)\n  \
    \      var count = 0\n        for (c <- lst2) {\n            if (c == '(') count\
    \ += 1\n            else count -= 1\n            if (count < 0) return \"No\"\n\
    \        }\n        if (count == 0) \"Yes\" else \"No\"", "        // ')' -> '('\n\
    \        // 1 -> -1\n        def isValid(s : String) : Boolean = {\n         \
    \   var sum = 0\n            for (i <- 0 until s.length) {\n                if\
    \ (s(i) == '(') sum += 1\n                else sum -= 1\n                if (sum\
    \ < 0) return false\n            }\n            if (sum == 0) true else false\n\
    \        }\n        // '(' -> ')'\n        // 1 -> -1\n        def getClosingPos(s\
    \ : String) : Int = {\n            var sum = 0\n            for (i <- 0 until\
    \ s.length) {\n                if (s(i) == '(') sum += 1\n                else\
    \ sum -= 1\n                if (sum == 0) return i\n            }\n          \
    \  -1\n        }\n        // ')' -> '('\n        // 1 -> -1\n        def getOpeningPos(s\
    \ : String) : Int = {\n            var sum = 0\n            for (i <- s.length\
    \ - 1 to 0 by -1) {\n                if (s(i) == ')') sum += 1\n             \
    \   else sum -= 1\n                if (sum == 0) return i\n            }\n   \
    \         -1\n        }\n        var lst2 = lst.map(x => {\n            if (isValid(x))\
    \ \".\" + x\n            else {\n                val pos = getClosingPos(x)\n\
    \                x.substring(0, pos + 1) + \".\" + x.substring(pos + 1)\n    \
    \        }\n        })\n        var lst3 = lst2.map(x => {\n            if (x.startsWith(\"\
    .\")) x\n            else {\n                val pos = getOpeningPos(x)\n    \
    \            \".\" + x.substring(0, pos) + \".\" + x.substring(pos)\n        \
    \    }\n        })\n        var lst4 = lst3.map(x => x.replaceAll(\"\\\\.\", \"\
    \"))\n        var current = lst4(0)\n        var valid = true\n        for (str\
    \ <- lst4) {\n            current = current + str\n            if (!isValid(current))\
    \ {\n                valid = false\n                break\n           "]
stop_tokens:
- "\n    }\n"
