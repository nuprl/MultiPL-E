language: scala
name: HumanEval_9_rolling_max
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) {\n            return numbers\n        }\n    \
    \    //val maximum = numbers.max\n        var result = ListBuffer[Long]()\n  \
    \      result += numbers(0)\n        for (i <- 1 until numbers.length) {\n   \
    \         result += result(i - 1).max(numbers(i))\n        }\n        return result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxValue = 0l\n        var output = List[Long]()\n        for (number\
    \ <- numbers) {\n            maxValue = max(maxValue, number)\n            output\
    \ = output :+ maxValue\n        }\n        return output\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def helper(currentMax : Long, list : List[Long], result : List[Long]) :\
    \ List[Long] = {\n            if (list.isEmpty) result\n            else {\n \
    \               val next = max(currentMax, list.head)\n                helper(next,\
    \ list.tail, result ++ List(next))\n            }\n        }\n        val result\
    \ = helper(numbers.head, numbers.tail, List(numbers.head))\n        println(result)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmp1rw08y19.scala:16)\n\
    \tat Problem$.main(tmp1rw08y19.scala:21)\n\tat Problem.main(tmp1rw08y19.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxElements = new ListBuffer[Long]()\n        var largestElement : Long\
    \ = 0l\n        for (i <- 0 until numbers.length) {\n            if (largestElement\
    \ < numbers(i)) largestElement = numbers(i)\n            maxElements += largestElement\n\
    \        }\n        maxElements.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(ListBuffer[Long]())((acc, x) => {\n            if (acc.isEmpty)\
    \ acc += x\n            else {\n                val maxSoFar = acc.last\n    \
    \            acc += (if (x > maxSoFar) x else maxSoFar)\n            }\n     \
    \   }).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return List()\n        var result = ListBuffer[Long]()\n\
    \        var maximum = numbers(0)\n        for (number <- numbers) {\n       \
    \     if (number > maximum) maximum = number\n            result += maximum\n\
    \        }\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanLeft(0l.toLong)(max(_, _)).tail\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxs = new ListBuffer[Long]\n        var max = 0l\n        for (number\
    \ <- numbers) {\n            max = max(number, max)\n            maxs += max\n\
    \        }\n        maxs.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp_f9zjkhn.scala:12:18 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            max = max(number, max)\n\e[31m\e[31m   |\e\
    [0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maximum = Long.MinValue\n        numbers.map { x =>\n            maximum\
    \ = max(maximum, x)\n            maximum\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val cache = new Array[Long](numbers.length)\n        cache(0) = numbers(0)\n\
    \        for (i <- 1 until numbers.length) {\n            if (numbers(i) >= cache(i\
    \ - 1)) {\n                cache(i) = numbers(i)\n            } else {\n     \
    \           cache(i) = cache(i - 1)\n            }\n        }\n        cache.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpiaacts34.scala:10)\n\tat Problem$.main(tmpiaacts34.scala:21)\n\
    \tat Problem.main(tmpiaacts34.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0l.toLong\n        numbers.map(n => {\n            if (n > max)\
    \ max = n\n            max\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max : Long = 0l\n        numbers.map(x => {if (x > max) max = x; max})\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanLeft(Long.MinValue)((r, x) => max(r, x)).tail\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var seq = List[Long]()\n        var max : Long = 0\n        numbers.foreach(number\
    \ => {\n            if (number > max) {\n                max = number\n      \
    \      }\n            seq = seq :+ max\n        })\n        seq\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   // numbers.foldLeft(List[Long]())((acc, num) => acc :+ math.max(num, acc.last))\n\
    \      numbers.scanLeft(Long.MinValue)((acc, num) => math.max(num, acc))\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9urk0dny.scala:13)\n\tat Problem.main(tmp9urk0dny.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) return List[Long]()\n        if (numbers.length ==\
    \ 1) return List[Long](numbers(0))\n        var maximums = List[Long](numbers(0))\n\
    \        for (i <- 1 until numbers.length) {\n            maximums = maximums\
    \ :+ max(maximums(i - 1), numbers(i))\n        }\n        return maximums\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maximum = 0l.toLong\n        var result = List[Long]()\n        numbers.foreach(\
    \ (x : Long) => {\n            maximum = max(maximum, x)\n            result =\
    \ result :+ maximum\n        })\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var currentMax = 0l\n        var index = 0\n        var result = List[Long]()\n\
    \        while (index < numbers.length) {\n            if (numbers(index) > currentMax)\
    \ currentMax = numbers(index)\n            result = result :+ currentMax\n   \
    \         index += 1\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     //val it = numbers.iterator\n        numbers.scanLeft(numbers.head)((a,\
    \ b) => max(a, b))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmpbtd0yl2l.scala:10)\n\
    \tat Problem$.main(tmpbtd0yl2l.scala:13)\n\tat Problem.main(tmpbtd0yl2l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) {\n            return List.empty[Long]\n      \
    \  }\n        var result = List(numbers(0))\n        for (i <- 1 until numbers.length)\
    \ {\n            result = result :+ max(result(i - 1), numbers(i))\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = numbers(0)\n        val answer = new ListBuffer[Long]\n      \
    \  for (x <- numbers) {\n            max = if (x > max) x else max\n         \
    \   answer += max\n        }\n        answer.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpeocauere.scala:9)\n\tat Problem$.main(tmpeocauere.scala:18)\n\
    \tat Problem.main(tmpeocauere.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long]()\n        var max = numbers(0)\n        for (number\
    \ <- numbers) {\n            max = max(number, max)\n            result = result\
    \ ++ List(max)\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpccix1dnm.scala:12:18 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            max = max(number, max)\n\e[31m\e[31m   |\e\
    [0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   // Init list\n      var out = new ListBuffer[Long]()\n      out += numbers(0)\n\
    \      // current max at given moment\n      var max = numbers(0)\n      // calculate\
    \ rolling max\n      for (i <- 1 until numbers.length) {\n        if (numbers(i)\
    \ > max) {\n          max = numbers(i)\n        }\n        out += max\n      }\n\
    \      out.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp59szihnc.scala:11)\n\tat Problem$.main(tmp59szihnc.scala:24)\n\
    \tat Problem.main(tmp59szihnc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def rollingMaxHelper(numbers : List[Long], currentMax : Long, result : List[Long])\
    \ : List[Long] = {\n            if (numbers.isEmpty) result.reverse\n        \
    \    else {\n                val newMax = max(currentMax, numbers.head)\n    \
    \            rollingMaxHelper(numbers.tail, newMax, newMax :: result)\n      \
    \      }\n        }\n        rollingMaxHelper(numbers, 0, List())\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var currentMax = numbers(0)\n        var result = List[Long]()\n       \
    \ result = result :+ currentMax\n        for (i <- 1 until numbers.length) {\n\
    \            if (numbers(i) > currentMax) currentMax = numbers(i)\n          \
    \  result = result :+ currentMax\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp4fx_42dm.scala:9)\n\tat Problem$.main(tmp4fx_42dm.scala:19)\n\
    \tat Problem.main(tmp4fx_42dm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val indexMap = new HashMap[Long, Int]\n        numbers.zipWithIndex.foreach\
    \ { case (x, idx) =>\n            indexMap.get(x) match {\n                case\
    \ Some(oldIdx) => {\n                    if (oldIdx < idx) indexMap += (x -> idx)\n\
    \                }\n                case None => indexMap += (x -> idx)\n    \
    \        }\n        }\n        val rollingMaxList = numbers.map { x =>\n     \
    \       indexMap.filterKeys(key => key >= x).keys.max\n        }\n        rollingMaxList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcuzpxb4o.scala:25)\n\tat Problem.main(tmpcuzpxb4o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanLeft(numbers.head)((max, x) => max max x)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmpb5_bgwa0.scala:9)\n\
    \tat Problem$.main(tmpb5_bgwa0.scala:12)\n\tat Problem.main(tmpb5_bgwa0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n        // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n        val _max :\
    \ Buffer[Long] = new ListBuffer[Long]\n        _max += numbers(0)\n        var\
    \ i = 1\n        while (i < numbers.length) {\n            if (numbers(i) > _max(i\
    \ - 1)) {\n                _max += numbers(i)\n            } else {\n        \
    \        _max += _max(i - 1)\n            }\n            i += 1\n        }\n \
    \       _max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmppx6q6fz3.scala:12)\n\tat Problem$.main(tmppx6q6fz3.scala:25)\n\
    \tat Problem.main(tmppx6q6fz3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var stack = ListBuffer[Long]()\n        var result = ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            while (!stack.isEmpty && stack.last\
    \ < number) {\n                stack.remove(stack.length - 1)\n            }\n\
    \            stack += number\n            result += stack.head\n        }\n  \
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var rollingMax = new LinkedList[Long]\n        var max = 0l\n        numbers.foreach(number\
    \ => {\n            if (number > max) {\n                max = number\n      \
    \      }\n            rollingMax.add(max)\n        })\n        rollingMax.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmbd2apge.scala:9:29 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mrollingMax\e[0m = \e[33mnew\e\
    [0m \e[35mLinkedList\e[0m[\e[35mLong\e[0m]\n\e[31m\e[31m  |\e[0m             \
    \                ^^^^^^^^^^\e[0m\n\e[31m  |\e[0m                             Not\
    \ found: type LinkedList\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty)\n            List[Long]()\n        else\n         \
    \   List[Long](numbers.head) ++ rollingMax(numbers.tail.scanLeft(numbers.head)(max(_,\
    \ _)))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.ArrayOps$ArrayIterator.<init>(ArrayOps.scala:125)\n\
    \tat scala.collection.ArrayOps$ArrayIterator$mcJ$sp.<init>(ArrayOps.scala:123)\n\
    \tat scala.collection.immutable.ArraySeq$ofLong.iterator(ArraySeq.scala:541)\n\
    \tat scala.collection.immutable.List.prependedAll(List.scala:151)\n\tat scala.collection.immutable.List$.from(List.scala:684)\n\
    \tat scala.collection.immutable.List$.from(List.scala:681)\n\tat scala.collection.IterableFactory.apply(Factory.scala:103)\n\
    \tat scala.collection.IterableFactory.apply$(Factory.scala:103)\n\tat scala.collection.immutable.List$.apply(List.scala:681)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\tat Problem$.rollingMax(tmpq3uv2siv.scala:12)\n\
    \tat Problem$.rollingMa"
  stdout: ''
  timestamp: 1659979952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max : Long = 0\n        var numbersWithMax : List[Long] = Nil\n    \
    \    for (number <- numbers) {\n            max = max(max, number)\n         \
    \   numbersWithMax = max :: numbersWithMax\n        }\n        numbersWithMax.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpa0_gfw0_.scala:12:18 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            max = max(max, number)\n\e[31m\e[31m   |\e\
    [0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val zeros = numbers.map(x => 0l.toLong)\n        def fn(l1 : List[Long],\
    \ l2 : List[Long]) : List[Long] = {\n            val maxs = (l1, l2).zipped.map(max)\n\
    \            zeros.zip(maxs).map(x => x._1 + x._2)\n        }\n        numbers.foldLeft(zeros)(fn)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppe2r3w86.scala:14:32\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        numbers.foldLeft(zeros)(fn)\n\
    \e[31m\e[31m   |\e[0m                                ^^\e[0m\n\e[31m   |\e[0m\
    \                        Found:    (List[Long], \e[1m\e[31mList\e[0m\e[1m\e[31m[\e\
    [0mLong\e[1m\e[31m]\e[0m) => List[Long]\n\e[31m   |\e[0m                     \
    \   Required: (List[Long], Long) => List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) {\n            return List()\n        }\n     \
    \   var result = ListBuffer[Long]()\n        var max = Long.MinValue\n       \
    \ for (number <- numbers) {\n            if (number > max) {\n               \
    \ max = number\n            }\n            result += max\n        }\n        return\
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) List[Long]()\n        else if (numbers.length ==\
    \ 1) List[Long](numbers(0))\n        else numbers(0) :: rollingMax(numbers.slice(1,\
    \ numbers.length))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcd_1_kk1.scala:16)\n\tat Problem.main(tmpcd_1_kk1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def helper(numbers : List[Long], maxSoFar : Long, result : List[Long]) :\
    \ List[Long] = {\n            if (numbers.length == 0) result.reverse\n      \
    \      else helper(numbers.tail, max(maxSoFar, numbers.head), max(maxSoFar, numbers.head)\
    \ :: result)\n        }\n        helper(numbers, 0, List[Long]())\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long]()\n        var max = 0l\n        for (number <-\
    \ numbers) {\n            max = Math.max(max, number)\n            result = result\
    \ :+ max\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   def rollingMaxHelper(numbers : List[Long], result : List[Long]) : List[Long]\
    \ = {\n        if (numbers.length == 0) result.reverse\n        else {\n     \
    \     val max = numbers.max\n          rollingMaxHelper(numbers.slice(1, numbers.length),\
    \ max :: result)\n        }\n      }\n      rollingMaxHelper(numbers, List[Long]())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzypjqr2l.scala:20)\n\tat Problem.main(tmpzypjqr2l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return numbers\n        // Keep track of maximum\
    \ found so far, as well as the maximum in the left sublist.\n        var max =\
    \ numbers(0)\n        var leftMax = 0l\n        val result = new ListBuffer[Long]\n\
    \        result += numbers(0)\n        for (i <- 1 until numbers.length) {\n \
    \           // Maximum found so far is not the maximum in the left sublist.\n\
    \            if (numbers(i) >= max) {\n                max = numbers(i)\n    \
    \            result += max\n            }\n            // Maximum found so far\
    \ is the maximum in the left sublist.\n            else {\n                if\
    \ (leftMax < numbers(i)) leftMax = numbers(i)\n                result += leftMax\n\
    \            }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph7khzymp.scala:32)\n\tat Problem.main(tmph7khzymp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxValues = new ListBuffer[Long]\n        for (i <- 0 until numbers.length)\
    \ {\n            val temp = numbers.slice(0, i + 1)\n            maxValues +=\
    \ temp.max\n        }\n        maxValues.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanLeft(Long.MinValue)((acc, n) => if (n > acc) n else acc)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd4ms3t2c.scala:12)\n\tat Problem.main(tmpd4ms3t2c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var seq = numbers.toBuffer\n        var result = List[Long]()\n        for\
    \ (i <- 0 until seq.length) {\n            result = result :+ seq.take(i + 1).max\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   var max = Long.MinValue\n      var result = new ListBuffer[Long]\n      for\
    \ (i <- 0 until numbers.length) {\n        if (numbers(i) > max) max = numbers(i)\n\
    \        result += max\n      }\n      result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new ListBuffer[Long]\n        var max = 0l\n        for (i\
    \ <- 0 until numbers.length) {\n            if (numbers(i) > max) {\n        \
    \        max = numbers(i)\n            }\n            result += max\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(ArrayBuffer[Long]())((acc, cur) => {\n            acc +=\
    \ acc.lastOption.getOrElse(0l.toLong) max cur\n            acc\n        }).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val stack = Stack[Long]()\n        numbers.map { x =>\n            while\
    \ (!stack.isEmpty && stack.top < x) stack.pop\n            stack.push(x)\n   \
    \         stack.top\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdzck65od.scala:19)\n\tat Problem.main(tmpdzck65od.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = new ListBuffer[Long]()\n        var max = 0l\n        for (number\
    \ <- numbers) {\n            max = max.max(number)\n            result += max\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979958
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) return List[Long]()\n        var result = new ListBuffer[Long]()\n\
    \        result += numbers(0)\n        for (i <- 1 until numbers.length) {\n \
    \           result += max(result(i - 1), numbers(i))\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979960
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   var rollingMaximums = List[Long]()\n      var maximum = Long.MinValue\n  \
    \    for (number <- numbers) {\n        if (number > maximum) maximum = number\n\
    \        rollingMaximums = rollingMaximums :+ maximum\n      }\n      rollingMaximums\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979960
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def rollingMaxRecurse(input : List[Long], output : List[Long]) : List[Long]\
    \ = {\n            if (input.length == 0) output\n            else {\n       \
    \         val maxValue = output.max\n                val next = input.head\n \
    \               if (next > maxValue) rollingMaxRecurse(input.tail, output :+ next)\n\
    \                else rollingMaxRecurse(input.tail, output :+ maxValue)\n    \
    \        }\n        }\n        rollingMaxRecurse(numbers.tail, List(numbers.head))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\
    \tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.rollingMax(tmpywrystyi.scala:18)\n\
    \tat Problem$.main(tmpywrystyi.scala:21)\n\tat Problem.main(tmpywrystyi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = numbers(0)\n        var s = List[Long]()\n        for (n <- numbers)\
    \ {\n            max = max.max(n)\n            s = s :+ max\n        }\n     \
    \   s\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpea5fwmzv.scala:9)\n\tat Problem$.main(tmpea5fwmzv.scala:18)\n\
    \tat Problem.main(tmpea5fwmzv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val dp = Array.fill(numbers.length + 1)(Long.MinValue)\n        for (i <-\
    \ 1 to numbers.length) {\n            dp(i) = max(dp(i - 1), numbers(i - 1))\n\
    \        }\n        dp.drop(1).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Calculate rolling maximum.\n        var max = 0l\n        var result\
    \ = List[Long]()\n        for (i <- 0 until numbers.length) {\n            max\
    \ = max max numbers(i)\n            result = result :+ max\n        }\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxs = new ListBuffer[Long]()\n        var currentMax = numbers(0)\n\
    \        maxs += currentMax\n        for (i <- 1 until numbers.length) {\n   \
    \         if (numbers(i) > currentMax) {\n                currentMax = numbers(i)\n\
    \            }\n            maxs += currentMax\n        }\n        maxs.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpydorced0.scala:10)\n\tat Problem$.main(tmpydorced0.scala:21)\n\
    \tat Problem.main(tmpydorced0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return List()\n        val result = ArrayBuffer[Long]()\n\
    \        var currMax = numbers(0)\n        result += currMax\n        for (i <-\
    \ 1 until numbers.length) {\n            currMax = max(currMax, numbers(i))\n\
    \            result += currMax\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = new ListBuffer[Long]()\n        var currentMaximum = 0l.toLong\n\
    \        for (number <- numbers) {\n            currentMaximum = Math.max(currentMaximum,\
    \ number)\n            result += currentMaximum\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   var result = List[Long]()\n      var max = 0l\n      for (index <- numbers.indices)\
    \ {\n        if (index == 0) {\n          max = numbers(index)\n          result\
    \ ::= max\n        } else {\n          if (numbers(index) > max) {\n         \
    \   max = numbers(index)\n          }\n          result ::= max\n        }\n \
    \     }\n      result.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxs = ArrayBuffer[Long]()\n        var currentMax = Long.MinValue\n\
    \        for (i <- 0 until numbers.length) {\n            if (numbers(i) > currentMax)\
    \ currentMax = numbers(i)\n            maxs += currentMax\n        }\n       \
    \ maxs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = ListBuffer[Long]()\n        var maxSoFar = Long.MinValue\n\
    \        for (number <- numbers) {\n            if (number > maxSoFar) maxSoFar\
    \ = number\n            result += maxSoFar\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def maxFrom(max: Long, last: List[Long], result: List[Long]) : List[Long]\
    \ = {\n            last match {\n                case Nil => result\n        \
    \        case x :: xs => maxFrom(max max x, xs, result :+ (max max x))\n     \
    \       }\n        }\n        maxFrom(numbers.head, numbers.tail, List(numbers.head))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmp4odwzje5.scala:15)\n\
    \tat Problem$.main(tmp4odwzje5.scala:18)\n\tat Problem.main(tmp4odwzje5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) List[Long]()\n        else {\n            val buffer\
    \ = new ListBuffer[Long]()\n            var currentMax = numbers(0)\n        \
    \    buffer += currentMax\n            for (i <- 1 until numbers.length) {\n \
    \               if (numbers(i) > currentMax) {\n                    currentMax\
    \ = numbers(i)\n                }\n                buffer += currentMax\n    \
    \        }\n            buffer.toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return numbers\n        var result = new ListBuffer[Long]()\n\
    \        var max = numbers(0)\n        for (i <- 0 until numbers.length) {\n \
    \           max = max(numbers(i), max)\n            result += max\n        }\n\
    \        return result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpt_zr1slo.scala:13:18 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            max = max(numbers(i), max)\n\e[31m\e[31m\
    \   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   var max = numbers(0)\n      (numbers.map(x => if (x > max) max = x; max))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkbiyt8r3.scala:10:44 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m      (numbers.map(\e[36mx\e[0m => \e[33mif\e[0m (x >\
    \ max) max = x; max))\n\e[31m\e[31m   |\e[0m                                 \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \  ')' expected, but ';' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkbiyt8r3.scala:10:49\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m      (numbers.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x > max) max = x; max))\n\e[31m\e[31m   |\e[0m  \
    \                                               ^\e[0m\n\e[31m   |\e[0m      \
    \                                       '}' expected, but ')' found\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val (m, l) = numbers.foldLeft((List[Long](), List[Long]()))((acc, n) =>\
    \ {\n            val (maxElements, elements) = acc\n            val (currentMax,\
    \ newElements) = elements.foldLeft((Long.MinValue, List[Long]()))((innerAcc, m)\
    \ => {\n                val (currentMax, newElements) = innerAcc\n           \
    \     if (m >= n) (currentMax, m :: newElements)\n                else (currentMax,\
    \ n :: newElements)\n            })\n            (List(max(currentMax, n)) :::\
    \ maxElements, List(n) ::: newElements)\n        })\n        l.reverse ::: m\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpehucc7me.scala:22)\n\tat Problem.main(tmpehucc7me.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxElements = new ListBuffer[Long]()\n        var currentMax = 0l\n\
    \        for (i <- 0 until numbers.length) {\n            if (numbers(i) > currentMax)\
    \ {\n                currentMax = numbers(i)\n            }\n            maxElements\
    \ += currentMax\n        }\n        maxElements.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val res = new ArrayBuffer[Long]()\n        res += numbers(0)\n        for\
    \ (i <- 1 until numbers.length) {\n            res += max(res(i - 1), numbers(i))\n\
    \        }\n        res.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp1bxq1asj.scala:10)\n\tat Problem$.main(tmp1bxq1asj.scala:17)\n\
    \tat Problem.main(tmp1bxq1asj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxes = ListBuffer[Long]()\n        var max = 0l\n        for (number\
    \ <- numbers) {\n            max = max(number, max)\n            maxes += max\n\
    \        }\n        maxes.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmptle4y6ku.scala:12:18 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            max = max(number, max)\n\e[31m\e[31m   |\e\
    [0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxs = List[Long]()\n        var max = 0l\n        for (number <- numbers)\
    \ {\n            max = max(number, max)\n            maxs = maxs ++ List(max)\n\
    \        }\n        return maxs\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp3nu2vrrf.scala:12:18 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            max = max(number, max)\n\e[31m\e[31m   |\e\
    [0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979962
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxs = new ListBuffer[Long]\n        maxs += numbers(0)\n        for\
    \ (i <- 1 until numbers.length) {\n            maxs += max(maxs(i - 1), numbers(i))\n\
    \        }\n        maxs.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpk66g83d3.scala:10)\n\tat Problem$.main(tmpk66g83d3.scala:17)\n\
    \tat Problem.main(tmpk66g83d3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Helper function that takes the most maximum element found so far and\
    \ the latest element in the list\n        // and finds the maximum of two\n  \
    \      def max(maxSoFar : Long, currentElement : Long) : Long =\n            if\
    \ (maxSoFar > currentElement) maxSoFar else currentElement\n        numbers.scanLeft(0l.toLong)(max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0nwvemw8.scala:16)\n\tat Problem.main(tmp0nwvemw8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979969
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) List[Long]()\n        else if (numbers.size == 1) List[Long](numbers(0))\n\
    \        else {\n            numbers(0) :: rollingMax(numbers.tail).scanLeft(numbers(0))(_\
    \ max _).toList\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxedo65ei.scala:17)\n\tat Problem.main(tmpxedo65ei.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979970
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val res = new ListBuffer[Long]\n        var max = Long.MinValue\n      \
    \  for (i <- 0 until numbers.length) {\n            if (numbers(i) > max) max\
    \ = numbers(i)\n            res += max\n        }\n        res.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979971
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) return List[Long]()\n        if (numbers.length ==\
    \ 1) return List[Long](numbers(0))\n        var result = List[Long](numbers(0))\n\
    \        for (i <- Range(1, numbers.length)) {\n            result = result :+\
    \ max(result(i - 1), numbers(i))\n        }\n        return result\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979970
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   val result = ListBuffer[Long]()\n      var max = 0l\n      for (number <-\
    \ numbers) {\n        max = max max number\n        result += max\n      }\n \
    \     result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979971
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val r = numbers.scanRight(0l.toLong)(_ max _)\n        // We remove last\
    \ element of r because r(i) = max(numbers(i) ... numbers(n))\n        // and we\
    \ don't need the last element of r which is not in numbers.\n        r.dropRight(1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpik00330k.scala:16)\n\tat Problem.main(tmpik00330k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979970
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return List()\n        var max = numbers(0)\n \
    \       return numbers.map(n => {\n            max = math.max(max, n)\n      \
    \      max\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979971
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val length = numbers.length\n        val maxValues = new Array[Long](length)\n\
    \        var maxValue = numbers(0)\n        maxValues(0) = maxValue\n        for\
    \ (i <- 1 until length) {\n            maxValue = max(maxValue, numbers(i))\n\
    \            maxValues(i) = maxValue\n        }\n        maxValues.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpi0k35cbz.scala:11)\n\tat Problem$.main(tmpi0k35cbz.scala:20)\n\
    \tat Problem.main(tmpi0k35cbz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]())((rollingMaxList, number) => rollingMaxList\
    \ match {\n            case Nil => List(number)\n            case head :: tail\
    \ => List(math.max(head, number)) ::: rollingMaxList\n        }).reverse\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   numbers.foldLeft(List[Long]())((r, c) => if (r.isEmpty) List(c) else (c ::\
    \ r).max :: r).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanLeft(List[Long]())((a, b) => a :+ (max(b, a.headOption.getOrElse(0l.toLong))))\n\
    \            .tail\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplgi9dww6.scala:10:13\
    \ --------------------\e[0m\e[0m\n\e[31m 9 |\e[0m        numbers.scanLeft(List[\e\
    [35mLong\e[0m]())((\e[36ma\e[0m, \e[36mb\e[0m) => a :+ (max(b, a.headOption.getOrElse(\e\
    [31m0l\e[0m.toLong))))\n\e[31m10 |\e[0m            .tail\n\e[31m\e[31m   |\e[0m\
    \        ^\e[0m\n\e[31m   |\e[0m        Found:    List[List[Long] @uncheckedVariance]\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxSoFar = new ArrayBuffer[Long]()\n        var currentMax = 0l\n  \
    \      for (x <- numbers) {\n            if (x > currentMax) currentMax = x\n\
    \            maxSoFar += currentMax\n        }\n        maxSoFar.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Passing closure from maxima\n        var index : Int = 0\n        var\
    \ max : Long = numbers(0)\n        var maxima : List[Long] = List()\n        def\
    \ getMax() : Long = {\n            return max\n        }\n        def setMax(value\
    \ : Long) : Unit = {\n            max = value\n        }\n        for (value <-\
    \ numbers) {\n            index += 1\n            if (index == 1) {\n        \
    \        maxima = List(value)\n            } else {\n                if (value\
    \ > max) {\n                    maxima = maxima :+ value\n                   \
    \ setMax(value)\n                } else {\n                    maxima = maxima\
    \ :+ getMax()\n                }\n            }\n        }\n        return maxima\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpr4xk4j3h.scala:11)\n\tat Problem$.main(tmpr4xk4j3h.scala:35)\n\
    \tat Problem.main(tmpr4xk4j3h.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   (numbers.scanLeft(numbers.head)((x, y) => max(x, y))).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmpx6pmzik_.scala:9)\n\
    \tat Problem$.main(tmpx6pmzik_.scala:12)\n\tat Problem.main(tmpx6pmzik_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long]()\n        if (numbers.size > 0) {\n           \
    \ result = result :+ numbers(0)\n            for (i <- 1 until numbers.size) {\n\
    \                result = result :+ max(result(i - 1), numbers(i))\n         \
    \   }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maximums = new ListBuffer[Long]\n        for (i <- 0 until numbers.length)\
    \ {\n            val maximum = if (i == 0) numbers(i) else maximums(i - 1)\n \
    \           maximums += max(maximum, numbers(i))\n        }\n        maximums.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0l\n        var result = List[Long]()\n        for (number <-\
    \ numbers) {\n            if (number > max) max = number\n            result =\
    \ result :+ max\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) List[Long]()\n        else {\n            val maximum\
    \ = numbers.head\n            numbers.scanLeft(maximum)((prev, current) => max(prev,\
    \ current)).tail\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Generate the initial empty list.\n        val iniList = ListBuffer[Long]()\n\
    \        // Generate the result.\n        numbers.foldLeft(iniList)(\n       \
    \     (acc, item) => acc.append(max(item, if (acc.length > 0) acc.last else item))\n\
    \        ).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val queue = new Queue[Long]\n        val ret = new ListBuffer[Long]\n  \
    \      for (number <- numbers) {\n            while (queue.nonEmpty && queue.head\
    \ < number) {\n                queue.dequeue\n            }\n            queue.enqueue(number)\n\
    \            ret.append(queue.head)\n        }\n        ret.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]())((b,a) => {\n            if (b.isEmpty)\n\
    \                List(a)\n            else\n                b :+ max(b.last, a)\n\
    \        })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]())((res, number) => res :+ (if (res.isEmpty)\
    \ number else max(res.last, number)))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long]()\n        var max = 0l\n        for (n <- numbers)\
    \ {\n            if (n > max) {\n                max = n\n            }\n    \
    \        result = result :+ max\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var ans = List[Long]()\n        var maximum = 0l\n        for (i <- 0 until\
    \ numbers.length) {\n            maximum = max(maximum, numbers(i))\n        \
    \    ans = ans :+ maximum\n        }\n        ans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new ListBuffer[Long]()\n        var max = Long.MinValue\n \
    \       for (i <- 0 until numbers.length) {\n            if (numbers(i) > max)\
    \ {\n                max = numbers(i)\n            }\n            result += max\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // We add infinite number at the start of the list to ensure we have a maximum\
    \ to compare with.\n        val tempList = (numbers.max + 1) :: numbers\n    \
    \    val rollingMax = ListBuffer[Long]()\n        for (i <- 1 to tempList.length\
    \ - 1) {\n            rollingMax += (List(tempList(i), tempList(i - 1))).max\n\
    \        }\n        rollingMax.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.rollingMax(tmppmbhffxx.scala:10)\n\tat Problem$.main(tmppmbhffxx.scala:18)\n\
    \tat Problem.main(tmppmbhffxx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxs = numbers.foldLeft(List[Long]())((l : List[Long], n : Long) =>\
    \ l :+ (if (l.isEmpty) n else max(l.last, n)))\n        maxs\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   if (numbers.length == 0) return numbers\n      var result = ListBuffer[Long]()\n\
    \      var max = numbers(0)\n      result += max\n      for (i <- 1 until numbers.length)\
    \ {\n        max = max(numbers(i), max)\n        result += max\n      }\n    \
    \  result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpe50rceqr.scala:14:14 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        max = max(numbers(i), max)\n\e[31m\e[31m   |\e\
    [0m              ^^^\e[0m\n\e[31m   |\e[0m              \e[33mvariable\e[0m \e\
    [35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val buffer = Buffer[Long]()\n        var maximum = Long.MinValue\n     \
    \   for (number <- numbers) {\n            if (number > maximum) maximum = number\n\
    \            buffer += maximum\n        }\n        buffer.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = Long.MinValue\n        numbers.map(n => { max = math.max(max,\
    \ n); max })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var rmax : List[Long] = List[Long]()\n        var current_max : Long = 0\n\
    \        for (number <- numbers) {\n            current_max = max(current_max,\
    \ number)\n            rmax = rmax :+ current_max\n        }\n        return rmax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var m = numbers(0)\n        var result = new ListBuffer[Long]()\n      \
    \  result += m\n        for (i <- 1 until numbers.length) {\n            m = max(m,\
    \ numbers(i))\n            result += m\n        }\n        result.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpespj4dgm.scala:9)\n\tat Problem$.main(tmpespj4dgm.scala:19)\n\
    \tat Problem.main(tmpespj4dgm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = new ListBuffer[Long]\n        var maximum = numbers(0)\n  \
    \      result += maximum\n        for (i <- 1 until numbers.length) {\n      \
    \      maximum = max(maximum, numbers(i))\n            result += maximum\n   \
    \     }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmphrvppaq4.scala:10)\n\tat Problem$.main(tmphrvppaq4.scala:19)\n\
    \tat Problem.main(tmphrvppaq4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanLeft(Long.MinValue)((max, i) => max.max(i))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4rn97f2y.scala:12)\n\tat Problem.main(tmp4rn97f2y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long]()\n        var maxCurrent = Long.MinValue\n    \
    \    for (n <- numbers) {\n            maxCurrent = max(maxCurrent, n)\n     \
    \       result = result :+ maxCurrent\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   var runningMaximum = Long.MinValue\n      numbers.map(current => {runningMaximum\
    \ = max(runningMaximum, current); runningMaximum})\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = numbers(0)\n        numbers.map(num => {\n            max = max.max(num)\n\
    \            max\n        })\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpak_ysu79.scala:9)\n\tat Problem$.main(tmpak_ysu79.scala:16)\n\
    \tat Problem.main(tmpak_ysu79.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   def maxSoFar(numbers : List[Long], numbersSoFar : List[Long]) : List[Long]\
    \ = {\n        if (numbers.isEmpty) numbersSoFar\n        else {\n          val\
    \ m = numbersSoFar.max\n          maxSoFar(numbers.tail, numbersSoFar :+ max(m,\
    \ numbers.head))\n        }\n      }\n      maxSoFar(numbers.tail, List(numbers.head))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\
    \tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.rollingMax(tmp3t15pdqg.scala:16)\n\
    \tat Problem$.main(tmp3t15pdqg.scala:19)\n\tat Problem.main(tmp3t15pdqg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = Long.MinValue\n        val result = ListBuffer[Long]()\n     \
    \   for (i <- 0 until numbers.length) {\n            max = max(numbers(i), max)\n\
    \            result += max\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp6fy1gnkz.scala:12:18 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            max = max(numbers(i), max)\n\e[31m\e[31m\
    \   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.sliding(2).map(p => math.max(p(0), p(1))).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq4uxu74n.scala:13)\n\tat Problem.main(tmpq4uxu74n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var dp = new ListBuffer[Long]\n        numbers.foldLeft(Long.MinValue)((x,\
    \ y) => {\n            dp += max(x, y)\n            y\n        })\n        dp.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzzy7xatb.scala:19)\n\tat Problem.main(tmpzzy7xatb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val l = ListBuffer[Long]()\n        var m = 0l\n        for (n <- numbers)\
    \ {\n            if (n > m) {\n                m = n\n            }\n        \
    \    l += m\n        }\n        l.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) List()\n        else {\n            var res = ListBuffer[Long]()\n\
    \            var maxVal = numbers.head\n            res += maxVal\n          \
    \  for (i <- 1 until numbers.length) {\n                maxVal = max(maxVal, numbers(i))\n\
    \                res += maxVal\n            }\n            res.toList\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979985
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanRight(0l.toLong)((x, acc) => max(x, acc)).tail\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcwgzkot.scala:13)\n\tat Problem.main(tmpdcwgzkot.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maximums = numbers.foldLeft(List[Long]())((acc, n) => \n           \
    \ if (acc.isEmpty) List(n)\n            else List(max(acc.head, n)) ++ acc\n \
    \       )\n        maximums.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979985
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Recursive function generating the list of maximum elements.\n       \
    \ def rMax(numbers : List[Long], max : Long, result : List[Long]) : List[Long]\
    \ = {\n            numbers match {\n                case Nil => result\n     \
    \           case head :: tail => {\n                    val newMax = max max head\n\
    \                    rMax(tail, newMax, newMax :: result)\n                }\n\
    \            }\n        }\n        rMax(numbers, numbers.head, List[Long]()).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmpz1x2j_g9.scala:19)\n\
    \tat Problem$.main(tmpz1x2j_g9.scala:22)\n\tat Problem.main(tmpz1x2j_g9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979986
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   var maxSoFar = numbers(0)\n      var results = List[Long]()\n      for (number\
    \ <- numbers) {\n        maxSoFar = max(maxSoFar, number)\n        results = results\
    \ :+ maxSoFar\n      }\n      results\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp0swi4cxx.scala:9)\n\tat Problem$.main(tmp0swi4cxx.scala:18)\n\
    \tat Problem.main(tmp0swi4cxx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return numbers\n        val maximums = ListBuffer.empty[Long]\n\
    \        maximums += numbers(0)\n        for (i <- 1 until numbers.length) {\n\
    \            maximums += max(maximums(i - 1), numbers(i))\n        }\n       \
    \ maximums.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979992
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   if (numbers.isEmpty) List[Long]()\n      else if (numbers.length == 1) List[Long](numbers(0))\n\
    \      else numbers(0) :: rollingMax(numbers.tail.map(x => max(x, numbers(0))))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]())((acc, x) => {\n            if (acc.isEmpty)\
    \ x :: acc\n            else acc.head max x :: acc\n        }).reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4y7ogq37.scala:11:30\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            \e[33melse\e[0m acc.head\
    \ max x :: acc\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    \e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                   \
    \           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var rolling : List[Long] = List[Long]()\n        var max : Long = Long.MinValue\n\
    \        for (number <- numbers) {\n            max = max.max(number)\n      \
    \      rolling = rolling :+ max\n        }\n        return rolling\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979992
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) List()\n        else {\n            val max = numbers.max\n\
    \            if (max < numbers.head) max :: rollingMax(numbers.tail)\n       \
    \     else max :: rollingMax(numbers.tail)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc47yap5l.scala:18)\n\tat Problem.main(tmpc47yap5l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val len = numbers.length\n        val rolled = new Array[Long](len)\n  \
    \      numbers.foldLeft((Long.MinValue, rolled))((curr, num) => {\n          \
    \  val (max, rolled) = curr\n            rolled(numbers.indexOf(num)) = max max\
    \ num\n            (max max num, rolled)\n        })._2.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8xb_q3mj.scala:21)\n\tat Problem.main(tmp8xb_q3mj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979992
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maximum = numbers(0)\n        var maxima = List[Long]()\n        for\
    \ (number <- numbers) {\n            if (number > maximum) maximum = number\n\
    \            maxima = maxima :+ maximum\n        }\n        maxima\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpz351ud8u.scala:9)\n\tat Problem$.main(tmpz351ud8u.scala:18)\n\
    \tat Problem.main(tmpz351ud8u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   numbers.scan(0l.toLong)((maximum, element) => max(maximum, element)).tail\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = new ListBuffer[Long]\n        for (i <- 0 until numbers.length)\
    \ {\n            val subset = numbers.slice(0, i)\n            val max = if (subset.isEmpty)\
    \ 0 else subset.max\n            maxes += max\n        }\n        maxes.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprvmblhop.scala:19)\n\tat Problem.main(tmprvmblhop.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long]()\n        var max = numbers(0)\n        for (number\
    \ <- numbers) {\n            if (number > max) {\n                max = number\n\
    \            }\n            result = result :+ max\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpk8bolieh.scala:10)\n\tat Problem$.main(tmpk8bolieh.scala:20)\n\
    \tat Problem.main(tmpk8bolieh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def helper(numbers : List[Long], acc : List[Long]) : List[Long] = {\n  \
    \          if (numbers.length == 0) acc\n            else helper(numbers.tail,\
    \ numbers.head :: acc)\n        }\n        helper(numbers, List[Long]()).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvhla4alp.scala:18)\n\tat Problem.main(tmpvhla4alp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxes = ListBuffer[Long]()\n        var max : Long = numbers(0)\n  \
    \      for (i <- 0 until numbers.length) {\n            if (numbers(i) > max)\
    \ max = numbers(i)\n            maxes += max\n        }\n        maxes.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp1ab49ao1.scala:10)\n\tat Problem$.main(tmp1ab49ao1.scala:18)\n\
    \tat Problem.main(tmp1ab49ao1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return numbers\n        var numbers2 = ListBuffer[Long]()\n\
    \        numbers2 += numbers(0)\n        for (i <- 1 until numbers.length) {\n\
    \            numbers2 += max(numbers2(i - 1), numbers(i))\n        }\n       \
    \ numbers2.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979995
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     return numbers.scanLeft(0l.toLong)((a, b) => max(a, b))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppsegcfqh.scala:12)\n\tat Problem.main(tmppsegcfqh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]())((accum, current) => if (accum.length == 0)\
    \ {\n            List(current)\n        } else {\n            val max = math.max(accum.last,\
    \ current)\n            accum ++ List(max)\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979995
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max : Long = 0l\n        for (n <- numbers) {\n            if (n > max)\
    \ max = n\n        }\n        (numbers.map((n : Long) => max))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4lfshnqv.scala:17)\n\tat Problem.main(tmp4lfshnqv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979995
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val m = numbers.map(x => x).toArray\n        val n = numbers.size\n    \
    \    for (i <- 1 until n) {\n            val last = m(i - 1)\n            if (last\
    \ > m(i)) m(i) = last\n        }\n        m.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979995
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max : Long = 0\n        var result : List[Long] = List()\n        for\
    \ (i <- 0 until numbers.length) {\n            if (numbers(i) > max) {\n     \
    \           max = numbers(i)\n            }\n            result = result :+ max\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979995
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = new ArrayBuffer[Long]()\n        var max = 0l\n        for (number\
    \ <- numbers) {\n            max = max(max, number)\n            maxes += max\n\
    \        }\n        maxes.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpru5l_n4u.scala:12:18 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            max = max(max, number)\n\e[31m\e[31m   |\e\
    [0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979992
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var acc = Long.MinValue\n        var maximums = List[Long]()\n        for\
    \ (number <- numbers) {\n            if (number > acc) {\n                acc\
    \ = number\n            }\n            maximums = maximums :+ acc\n        }\n\
    \        maximums\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979995
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new ListBuffer[Long]()\n        if (!numbers.isEmpty) {\n \
    \           var max = numbers.head\n            result += max\n            for\
    \ (number <- numbers.tail) {\n                if (number > max) {\n          \
    \          max = number\n                }\n                result += max\n  \
    \          }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979996
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def loop(numbers : List[Long], result : List[Long]) : List[Long] = {\n \
    \           if (numbers.length == 0) result.reverse\n            else {\n    \
    \            val maxSoFar = result.head\n                val max = if (numbers.head\
    \ > maxSoFar) numbers.head else maxSoFar\n                loop(numbers.tail, max\
    \ :: result)\n            }\n        }\n        loop(numbers, List[Long](Long.MinValue))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp10sq_qzg.scala:20)\n\tat Problem.main(tmp10sq_qzg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979996
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxNumber = Long.MinValue\n        var maxList = List[Long]()\n    \
    \    numbers.foreach { n =>\n            maxNumber = max(maxNumber, n)\n     \
    \       maxList = maxList :+ maxNumber\n        }\n        maxList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979999
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = numbers.tail.foldLeft(List(numbers.head))((a, b) => a :+ max(a.last,\
    \ b))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\
    \tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.rollingMax(tmpvpor48v7.scala:9)\n\
    \tat Problem$.main(tmpvpor48v7.scala:13)\n\tat Problem.main(tmpvpor48v7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return numbers\n        // Create a list of rolling\
    \ maximums.\n        def findMaximums(numbers : List[Long], maximums : List[Long])\
    \ : List[Long] = {\n            if (numbers.length == 0) return maximums\n   \
    \         val head = numbers.head\n            val previousMaximum = maximums.head\n\
    \            val maximum = if (head > previousMaximum) head else previousMaximum\n\
    \            findMaximums(numbers.tail, maximum :: maximums)\n        }\n    \
    \    findMaximums(numbers.tail, List(numbers.head)).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980002
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \ \tval maxSeq = new ListBuffer[Long]()\n    \tfor (i <- 0 until numbers.length)\
    \ {\n    \t\tmaxSeq += numbers.slice(0, i + 1).max\n    \t}\n    \tmaxSeq.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980002
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanLeft(Long.MinValue)((x, y) => max(x, y)).tail\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980002
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val (numbers1, numbers2) = numbers.splitAt(1)\n        val results = numbers1.toList\n\
    \        val next = numbers2.foldLeft(List[Long]())((acc, number) => if (number\
    \ > acc.head) number :: acc else acc.head :: acc).reverse\n        results :::\
    \ next\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.$anonfun$1(tmpmfp3j5l5.scala:11)\n\
    \tat Problem$.$anonfun$adapted$1(tmpmfp3j5l5.scala:11)\n\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\
    \tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpmfp3j5l5.scala:11)\n\tat Problem$.main(tmpmfp3j5l5.scala:16)\n\
    \tat Problem.main(tmpmfp3j5l5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maximum = new ListBuffer[Long]\n        maximum += numbers(0)\n    \
    \    for (i <- 1 until numbers.length) {\n            maximum += max(maximum(i\
    \ - 1), numbers(i))\n        }\n        maximum.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpa_k6ilx5.scala:10)\n\tat Problem$.main(tmpa_k6ilx5.scala:17)\n\
    \tat Problem.main(tmpa_k6ilx5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val size = numbers.size\n        val maxima = new Array[Long](size)\n  \
    \      var max = numbers(0)\n        maxima(0) = max\n        for (i <- 1 until\
    \ size) {\n            max = max(numbers(i), max)\n            maxima(i) = max\n\
    \        }\n        return maxima.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmph237vk7q.scala:14:18 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            max = max(numbers(i), max)\n\e[31m\e[31m\
    \   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   if (numbers.isEmpty) List()\n      else {\n        numbers.head :: rollingMax(numbers.tail.zip(numbers).map(x\
    \ => max(x._1, x._2)))\n      }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanLeft(0l.toLong)(max).drop(1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var currentMax = 0L\n        var result = new ListBuffer[Long]()\n     \
    \   numbers.foreach(i => {\n            if (i > currentMax) currentMax = i\n \
    \           result += currentMax\n        })\n        result.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = new ListBuffer[Long]()\n        var maxValue = 0l\n       \
    \ for (number <- numbers) {\n            maxValue = max(maxValue, number)\n  \
    \          result += maxValue\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980005
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var stack = Stack[Long]()\n        var maxs = List[Long]()\n        for\
    \ (number <- numbers) {\n            while (stack.size > 0 && stack.top < number)\
    \ stack.pop\n            stack.push(number)\n            maxs = maxs :+ stack.top\n\
    \        }\n        return maxs\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphdx909vq.scala:21)\n\tat Problem.main(tmphdx909vq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980006
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanLeft(numbers.head)((a, b) => max(a, b)).tail\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmpakz2wj6j.scala:9)\n\
    \tat Problem$.main(tmpakz2wj6j.scala:12)\n\tat Problem.main(tmpakz2wj6j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) List()\n        else {\n            val max = numbers.head\n\
    \            List(max) ::: rollingMax(numbers.tail.map(e => max(e, max)))\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpijcfl3dq.scala:12:59 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            List(max) ::: rollingMax(numbers.tail.map(\e\
    [36me\e[0m => max(e, max)))\n\e[31m\e[31m   |\e[0m                           \
    \                                ^^^\e[0m\n\e[31m   |\e[0m                   \
    \                   \e[33mvalue\e[0m \e[35mmax\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var queue = mutable.Queue.empty[Long]\n        var max = numbers.head\n\
    \        numbers.foreach(x => {\n            if (x >= max) {\n               \
    \ max = x\n                queue.enqueue(max)\n            }\n            else\
    \ {\n                queue.enqueue(max)\n            }\n        })\n        queue.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq4ksg_di.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mqueue\e[0m = mutable.Queue.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxList = List[Long]()\n        var curMax = Long.MinValue\n       \
    \ for (i <- 0 until numbers.length) {\n            curMax = max(curMax, numbers(i))\n\
    \            maxList = maxList :+ curMax\n        }\n        return maxList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980006
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var currMax = numbers(0)\n        var result = List[Long]()\n        result\
    \ :+= currMax\n        for (index <- 1 until numbers.length) {\n            currMax\
    \ = max(currMax, numbers(index))\n            result :+= currMax\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp41mcp_9u.scala:9)\n\tat Problem$.main(tmp41mcp_9u.scala:19)\n\
    \tat Problem.main(tmp41mcp_9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980005
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return List()\n        var maxSoFar = numbers(0)\n\
    \        var result = List(maxSoFar)\n        for (i <- 1 until numbers.length)\
    \ {\n            maxSoFar = max(maxSoFar, numbers(i))\n            result = result\
    \ :+ maxSoFar\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980006
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val num = numbers.toArray\n        val max = numbers.length\n        val\
    \ result = new Array[Long](max)\n        result(0) = num(0)\n        for (i <-\
    \ 1 until max) result(i) = max(result(i - 1), num(i))\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpkmiishv6.scala:13:43 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m (i <- \e[31m1\e[0m until max)\
    \ result(i) = max(result(i - \e[31m1\e[0m), num(i))\n\e[31m\e[31m   |\e[0m   \
    \                                        ^^^\e[0m\n\e[31m   |\e[0m           \
    \                           \e[33mvalue\e[0m \e[35mmax\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980002
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     return numbers.scanLeft(0l.toLong)((max, number) => Math.max(max, number))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6tf9cy6t.scala:12)\n\tat Problem.main(tmp6tf9cy6t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980006
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.scanRight(Long.MinValue)((v, acc) => max(v, acc)).dropRight(1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwbog_qex.scala:13)\n\tat Problem.main(tmpwbog_qex.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980006
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.tail.foldLeft(List[Long](numbers.head)) { (acc, x) =>\n        \
    \    acc.head :: acc\n        }.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\
    \tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.rollingMax(tmpkwmzi5ax.scala:9)\n\
    \tat Problem$.main(tmpkwmzi5ax.scala:14)\n\tat Problem.main(tmpkwmzi5ax.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980007
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) {\n            List()\n        } else {\n         \
    \   numbers.zipWithIndex.map(x => (x._1, x._2, numbers.slice(0, x._2 + 1).max)).map(x\
    \ => x._3)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxSoFar = 0l\n        numbers.map(n => {\n            if (n > maxSoFar)\
    \ maxSoFar = n\n            maxSoFar\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   if (numbers.length == 0) List[Long]()\n      else if (numbers.length == 1)\
    \ List[Long](numbers(0))\n      else {\n        var result = new ListBuffer[Long]()\n\
    \        var max = Long.MinValue\n        for (n <- numbers) {\n          max\
    \ = max max n\n          result += max\n        }\n        result.toList\n   \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxSoFar = numbers(0)\n        numbers.map(number => {\n           \
    \ maxSoFar = max(maxSoFar, number)\n            maxSoFar\n        })\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpj9y5l4bo.scala:9)\n\tat Problem$.main(tmpj9y5l4bo.scala:16)\n\
    \tat Problem.main(tmpj9y5l4bo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]())((list, item) =>\n            if (list.isEmpty)\
    \ List(item)\n            else if (item > list.last) list :+ item\n          \
    \  else list :+ list.last\n        )\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980013
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = ListBuffer[Long]()\n        var currentMax = numbers(0)\n \
    \       result += currentMax\n        for (i <- 1 until numbers.length) {\n  \
    \          currentMax = max(currentMax, numbers(i))\n            result += currentMax\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp66i1mzyr.scala:10)\n\tat Problem$.main(tmp66i1mzyr.scala:19)\n\
    \tat Problem.main(tmp66i1mzyr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980013
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def inner(numbers : List[Long], maximum : Long, result : List[Long]) : List[Long]\
    \ = {\n            if (numbers.isEmpty) result.reverse\n            else inner(numbers.tail,\
    \ max(maximum, numbers.head), max(maximum, numbers.head) :: result)\n        }\n\
    \        inner(numbers, numbers.head, List[Long]())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmph1kaiiss.scala:13)\n\
    \tat Problem$.main(tmph1kaiiss.scala:16)\n\tat Problem.main(tmph1kaiiss.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980013
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val accumulator = (0l.toLong, List[Long]())\n        numbers.foldLeft(accumulator)\
    \ ((accumulator, number) => {\n            val (lastMax, maxList) = accumulator\n\
    \            (max(lastMax, number), maxList :+ max(lastMax, number))\n       \
    \ })._2\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980013
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = new ListBuffer[Long]()\n        var max = 0l\n        for (i\
    \ <- 0 until numbers.length) {\n            if (numbers(i) > max) {\n        \
    \        max = numbers(i)\n            }\n            result += max\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980013
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = ListBuffer[Long]()\n        var i = 0\n        while (i < numbers.length)\
    \ {\n            maxes += numbers.slice(0, i + 1).max\n            i += 1\n  \
    \      }\n        maxes.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980013
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var rolling = ListBuffer[Long]()\n        var max = 0l\n        for (number\
    \ <- numbers) {\n            if (number > max) max = number\n            rolling\
    \ += max\n        }\n        rolling.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980014
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   def rollingMaxHelper(numbers : List[Long], maxs : List[Long]) : List[Long]\
    \ = {\n        if (numbers.isEmpty) maxs.reverse\n        else rollingMaxHelper(numbers.tail,\
    \ max(numbers.head, maxs.head) :: maxs)\n      }\n      rollingMaxHelper(numbers,\
    \ List[Long](0))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk7akjt_x.scala:16)\n\tat Problem.main(tmpk7akjt_x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980014
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   def loop(inputs : List[Long], outputs : List[Long]) : List[Long] = {\n   \
    \     if (inputs.isEmpty) {\n          outputs\n        } else {\n          val\
    \ output = if (outputs.isEmpty) inputs.head else max(outputs.head, inputs.head)\n\
    \          loop(inputs.tail, output :: outputs)\n        }\n      }\n      loop(numbers,\
    \ List[Long]()).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980014
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new ListBuffer[Long]()\n        var maximum = 0l\n        numbers.foreach(value\
    \ => {\n            maximum = max(maximum, value)\n            result += maximum\n\
    \        })\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980014
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   if (numbers.length == 0) return numbers\n      if (numbers.length == 1) return\
    \ numbers\n      def rec(numbers : List[Long], result : List[Long]) : List[Long]\
    \ = {\n        if (numbers.length == 0) return result\n        if (numbers.length\
    \ == 1) return numbers.head :: result\n        val subResult = numbers.head ::\
    \ result\n        val max = if (subResult.head > subResult.tail.head) subResult.head\
    \ else subResult.tail.head\n        rec(numbers.tail, max :: subResult)\n    \
    \  }\n      rec(numbers, List[Long]()).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rec$1(tmponaiallg.scala:15)\n\
    \tat Problem$.rollingMax(tmponaiallg.scala:18)\n\tat Problem$.main(tmponaiallg.scala:22)\n\
    \tat Problem.main(tmponaiallg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980015
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = numbers(0)\n        var ans = List[Long]()\n        ans = ans\
    \ :+ max\n        for (i <- 1 until numbers.length) {\n            max = max.max(numbers(i))\n\
    \            ans = ans :+ max\n        }\n        ans\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmppnzqlhfx.scala:9)\n\tat Problem$.main(tmppnzqlhfx.scala:19)\n\
    \tat Problem.main(tmppnzqlhfx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980015
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = new ListBuffer[Long]\n        var currentMax = numbers(0)\n\
    \        result += currentMax\n        for (i <- 1 until numbers.length) {\n \
    \           val element = numbers(i)\n            currentMax = max(currentMax,\
    \ element)\n            result += currentMax\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpvap2s2m9.scala:10)\n\tat Problem$.main(tmpvap2s2m9.scala:20)\n\
    \tat Problem.main(tmpvap2s2m9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \ \tif (numbers.isEmpty) return numbers\n    \tvar result = List[Long]()\n   \
    \ \tvar currentMax = numbers.head\n    \tfor (number <- numbers) {\n    \t\tcurrentMax\
    \ = max(currentMax, number)\n    \t\tresult = result :+ currentMax\n    \t}\n\
    \    \tresult\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val q = new mutable.Queue[Long]\n        return numbers.map { i =>\n   \
    \         while (!q.isEmpty && q.last < i) q.dequeue\n            q.enqueue(i)\n\
    \            q.head\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprnf23n_9.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = \e[33mnew\e[0m mutable.Queue[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0l\n        var maxes = List[Long]()\n        for (n <- numbers)\
    \ {\n            max = max(n, max)\n            maxes = maxes :+ max\n       \
    \ }\n        return maxes\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp58oc35m1.scala:12:18 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            max = max(n, max)\n\e[31m\e[31m   |\e[0m\
    \                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980013
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxes = new ListBuffer[Long]()\n        var currentMax = numbers(0)\n\
    \        maxes += currentMax\n        for (i <- 1 until numbers.length) {\n  \
    \          if (numbers(i) > currentMax) {\n                currentMax = numbers(i)\n\
    \            }\n            maxes += currentMax\n        }\n        maxes.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpa55d8e10.scala:10)\n\tat Problem$.main(tmpa55d8e10.scala:21)\n\
    \tat Problem.main(tmpa55d8e10.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   if (numbers.isEmpty)\n        Nil\n      else {\n        val maxs = new ArrayBuffer[Long]\n\
    \        maxs += numbers.head\n        for (num <- numbers.tail) {\n         \
    \ if (num >= maxs.last)\n            maxs += num\n          else\n           \
    \ maxs += maxs.last\n        }\n        maxs.toList\n      }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980017
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val dp = Array.fill(numbers.length)(0l)\n        dp(0) = numbers(0)\n  \
    \      for (i <- 1 until numbers.length) {\n            dp(i) = max(dp(i - 1),\
    \ numbers(i))\n        }\n        dp.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpuaomw6hl.scala:10)\n\tat Problem$.main(tmpuaomw6hl.scala:17)\n\
    \tat Problem.main(tmpuaomw6hl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980017
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Return a queue containing the list of numbers.\n        // The queue\
    \ will be used to pop out maximum values.\n        def toQ(numbers : List[Long])\
    \ : Queue[Long] = {\n            var q = Queue[Long]()\n            numbers.foreach(x\
    \ => q += x)\n            q\n        }\n        // Return the maximum of x and\
    \ q.\n        def maxQ(x : Long, q : Queue[Long]) : Long = {\n            if (q.isEmpty)\
    \ x\n            else if (x >= q.front) x\n            else q.front\n        }\n\
    \        var q = toQ(numbers)\n        var currentMax = q.front\n        var result\
    \ = List[Long]()\n        while (!q.isEmpty) {\n            currentMax = maxQ(q.front,\
    \ q)\n            result = result :+ currentMax\n            q.dequeue\n     \
    \   }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0 is out of bounds (min 0, max -1)\n\
    \tat scala.collection.mutable.ArrayDeque.apply(ArrayDeque.scala:580)\n\tat scala.collection.IndexedSeqOps.head(IndexedSeq.scala:84)\n\
    \tat scala.collection.IndexedSeqOps.head$(IndexedSeq.scala:84)\n\tat scala.collection.mutable.ArrayDeque.head(ArrayDeque.scala:39)\n\
    \tat scala.collection.mutable.Queue.front(Queue.scala:111)\n\tat Problem$.rollingMax(tmpevvtlf6w.scala:23)\n\
    \tat Problem$.main(tmpevvtlf6w.scala:33)\n\tat Problem.main(tmpevvtlf6w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.map(x => x).scanLeft(0l.toLong)((b, a) => if (a > b) a else b)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzf0xcfkv.scala:12)\n\tat Problem.main(tmpzf0xcfkv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val m = ListBuffer[Long]()\n        for (i <- 0 until numbers.length) {\n\
    \            val s = numbers.slice(0, i + 1)\n            m += s.max\n       \
    \ }\n        m.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980021
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxList = List[Long]()\n        var currentMax = 0l\n        for (n\
    \ <- numbers) {\n            currentMax = max(currentMax, n)\n            maxList\
    \ = maxList :+ currentMax\n        }\n        return maxList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980021
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val n = numbers.length\n        var result = List[Long]()\n        var maximum\
    \ : Long = 0\n        for (i <- 0 until n) {\n            maximum = max(maximum,\
    \ numbers(i))\n            result = result :+ maximum\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980021
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maximum = numbers(0)\n        var maximums = List[Long]()\n        maximums\
    \ = maximums :+ maximum\n        for (i <- 1 until numbers.length) {\n       \
    \     if (numbers(i) > maximum) {\n                maximum = numbers(i)\n    \
    \        }\n            maximums = maximums :+ maximum\n        }\n        maximums\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpx_yd_ug9.scala:9)\n\tat Problem$.main(tmpx_yd_ug9.scala:21)\n\
    \tat Problem.main(tmpx_yd_ug9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980021
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new ListBuffer[Long]\n        val stack = new Stack[Long]\n\
    \        for (n <- numbers) {\n            while (stack.size > 0 && stack.top\
    \ < n) {\n                stack.pop\n            }\n            stack.push(n)\n\
    \            result += stack.top\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplwg8i1kt.scala:23)\n\tat Problem.main(tmplwg8i1kt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980021
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = Buffer[Long]()\n        var max = Long.MinValue\n        for\
    \ (number <- numbers) {\n            if (number > max) {\n                max\
    \ = number\n            }\n            result += max\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980021
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.tail.foldLeft(List[Long](numbers.head)) {\n            case (List(a),\
    \ b) => List(max(a, b))\n            case (list, num) => max(list.head, num) ::\
    \ list\n        }.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\
    \tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.rollingMax(tmp0lny2dfp.scala:9)\n\
    \tat Problem$.main(tmp0lny2dfp.scala:15)\n\tat Problem.main(tmp0lny2dfp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maximum = List[Long]()\n        var currentMax = numbers(0)\n      \
    \  maximum = maximum :+ currentMax\n        for (i <- 1 until numbers.length)\
    \ {\n            currentMax = max(currentMax, numbers(i))\n            maximum\
    \ = maximum :+ currentMax\n        }\n        maximum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpvq6huzl3.scala:10)\n\tat Problem$.main(tmpvq6huzl3.scala:19)\n\
    \tat Problem.main(tmpvq6huzl3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) return numbers\n        val results = new ListBuffer[Long]()\n\
    \        results += numbers(0)\n        for (i <- 1 until numbers.length) {\n\
    \            results += max(results(i - 1), numbers(i))\n        }\n        results.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980022
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val initial = numbers.head\n        val res = ListBuffer(initial)\n    \
    \    for (i <- 1 until numbers.length) {\n            val maxFrom = numbers.slice(0,\
    \ i + 1).max\n            res += maxFrom\n        }\n        res.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmp1ohcvi9n.scala:9)\n\
    \tat Problem$.main(tmp1ohcvi9n.scala:18)\n\tat Problem.main(tmp1ohcvi9n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0l\n        return numbers.map(n => {\n            if (n > max)\
    \ {\n                max = n\n            }\n            max\n        })\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980022
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxSeen = 0l\n        var result = List[Long]()\n        for (number\
    \ <- numbers) {\n            maxSeen = max(maxSeen, number)\n            result\
    \ = result :+ maxSeen\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980022
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var list = List[Long]()\n        var lmax = numbers(0)\n        for (n <-\
    \ numbers) {\n            if (n > lmax) {\n                lmax = n\n        \
    \    }\n            list = list :+ lmax\n        }\n        list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpi6awafmg.scala:10)\n\tat Problem$.main(tmpi6awafmg.scala:20)\n\
    \tat Problem.main(tmpi6awafmg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maximums = new ListBuffer[Long]\n        maximums += numbers(0)\n  \
    \      for (i <- 1 until numbers.length) {\n            maximums += max(maximums(i\
    \ - 1), numbers(i))\n        }\n        maximums.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmprn7rmlzm.scala:10)\n\tat Problem$.main(tmprn7rmlzm.scala:17)\n\
    \tat Problem.main(tmprn7rmlzm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980022
